{"version":3,"sources":["../../../node_modules/jose/dist/webapi/jwks/remote.js","../../../node_modules/zod/index.js","../../../node_modules/%40better-auth/utils/dist/binary.mjs","../../../node_modules/%40better-auth/utils/dist/hmac.mjs","../../../node_modules/better-auth/node_modules/ms/dist/index.js","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../node_modules/%40better-auth/core/dist/api/index.mjs","../../../node_modules/%40better-fetch/fetch/dist/index.js","../../../node_modules/better-auth/dist/get-request-ip-D6st-mto.mjs","../../../node_modules/better-auth/dist/schema-Bb7wzeK_.mjs","../../../node_modules/jose/dist/webapi/jwks/local.js","../../../node_modules/jose/dist/webapi/util/decode_jwt.js","../../../node_modules/defu/dist/defu.mjs","../../../node_modules/drizzle-orm/sql/functions/aggregate.js","../../../node_modules/better-auth/dist/parser-pHp5yoAv.mjs","../../../node_modules/better-auth/dist/index.mjs","../../../node_modules/better-auth/dist/permission-JwliMugl.mjs","../../../node_modules/better-auth/dist/client-CMPEe5-e.mjs","../../../node_modules/%40better-auth/utils/dist/base32.mjs","../../../node_modules/jose/dist/webapi/key/generate_key_pair.js","../../../node_modules/%40better-auth/core/dist/social-providers/index.mjs","../../../node_modules/better-auth/dist/password-BFQK0cLg.mjs","../../../node_modules/%40better-auth/core/dist/db/index.mjs","../../../node_modules/better-auth/dist/access-Dx8TLKnw.mjs","../../../node_modules/better-auth/dist/plugin-helper-zFdFWLgL.mjs","../../../node_modules/better-auth/dist/access-h-uttVNZ.mjs","../../../node_modules/better-auth/dist/has-permission-qCjQqGds.mjs","../../../node_modules/better-auth/dist/access-vPNO48H4.mjs","../../../node_modules/better-auth/dist/get-migration-Bf0TuCzm.mjs","../../../src/lib/auth/index.ts","../../../node_modules/%40better-auth/telemetry/dist/index.mjs","../../../node_modules/better-auth/dist/url-CB8xCwz-.mjs","../../../node_modules/jose/dist/webapi/util/decode_protected_header.js","../../../src/app/api/auth/%5B...all%5D/route.ts","../../../node_modules/%40better-auth/core/dist/oauth2-B2XPHgx5.mjs","../../../node_modules/better-auth/dist/captcha-Dbvurc2Z.mjs","../../../node_modules/better-auth/dist/bearer-C6RSCXv_.mjs","../../../node_modules/better-auth/dist/custom-session-CaUbM_of.mjs","../../../node_modules/better-auth/dist/open-api-DZG02vyi.mjs","../../../node_modules/better-auth/dist/siwe-D81Y4fkp.mjs","../../../node_modules/better-auth/dist/adapters/drizzle-adapter/index.mjs","../../../node_modules/better-auth/dist/auth-DfR8_5w3.mjs","../../../node_modules/better-auth/dist/haveibeenpwned-BSsFUFTi.mjs","../../../node_modules/better-auth/dist/one-tap-Bz8Q39Od.mjs","../../../node_modules/%40better-auth/utils/dist/otp.mjs","../../../node_modules/better-auth/dist/multi-session-CbEYz_wJ.mjs","../../../node_modules/better-auth/dist/one-time-token-C8YQxf38.mjs","../../../node_modules/better-auth/dist/jwt-Ar1sciI2.mjs","../../../node_modules/better-auth/dist/cookies-D72PbWdz.mjs","../../../node_modules/better-auth/dist/integrations/next-js.mjs","../../../node_modules/better-auth/dist/magic-link-QdHvtdfs.mjs","../../../node_modules/better-auth/dist/device-authorization-9_f1Up5D.mjs","../../../node_modules/better-auth/dist/anonymous-DxoIOUPc.mjs","../../../node_modules/better-auth/dist/oauth-proxy-Dz1E1SVN.mjs","../../../node_modules/better-auth/dist/username-C_wmkXwt.mjs","../../../node_modules/better-auth/dist/phone-number-wU9XYnr8.mjs","../../../node_modules/better-auth/dist/admin-D-OMdNIc.mjs","../../../node_modules/better-auth/dist/session-AaRl3_x-.mjs","../../../node_modules/better-auth/dist/email-otp-CiznqFUN.mjs","../../../node_modules/better-auth/dist/generic-oauth-BGbWWUh9.mjs","../../../node_modules/better-auth/dist/api-CkmycQ2x.mjs","../../../node_modules/better-auth/dist/oidc-provider-B9SsN23J.mjs","../../../node_modules/better-auth/dist/base-CiRMFqet.mjs","../../../node_modules/better-auth/dist/organization-BdJSRNgM.mjs","../../../node_modules/better-auth/dist/two-factor-BDQvVILL.mjs","../../../node_modules/%40noble/hashes/src/sha3.ts","../../../node_modules/better-auth/dist/plugins-DgSTpOzm.mjs","../../../node_modules/%40better-fetch/fetch/src/utils.ts"],"sourcesContent":["import { JOSEError, JWKSNoMatchingKey, JWKSTimeout } from '../util/errors.js';\nimport { createLocalJWKSet } from './local.js';\nimport { isObject } from '../lib/is_object.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'jose';\n    const VERSION = 'v6.1.3';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nexport const customFetch = Symbol();\nasync function fetchJwks(url, headers, signal, fetchImpl = fetch) {\n    const response = await fetchImpl(url, {\n        method: 'GET',\n        signal,\n        redirect: 'manual',\n        headers,\n    }).catch((err) => {\n        if (err.name === 'TimeoutError') {\n            throw new JWKSTimeout();\n        }\n        throw err;\n    });\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n}\nexport const jwksCache = Symbol();\nfunction isFreshJwksCache(input, cacheMaxAge) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || Date.now() - input.uat >= cacheMaxAge) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isObject)) {\n        return false;\n    }\n    return true;\n}\nclass RemoteJWKSet {\n    #url;\n    #timeoutDuration;\n    #cooldownDuration;\n    #cacheMaxAge;\n    #jwksTimestamp;\n    #pendingFetch;\n    #headers;\n    #customFetch;\n    #local;\n    #cache;\n    constructor(url, options) {\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this.#url = new URL(url.href);\n        this.#timeoutDuration =\n            typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;\n        this.#cooldownDuration =\n            typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;\n        this.#cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;\n        this.#headers = new Headers(options?.headers);\n        if (USER_AGENT && !this.#headers.has('User-Agent')) {\n            this.#headers.set('User-Agent', USER_AGENT);\n        }\n        if (!this.#headers.has('accept')) {\n            this.#headers.set('accept', 'application/json');\n            this.#headers.append('accept', 'application/jwk-set+json');\n        }\n        this.#customFetch = options?.[customFetch];\n        if (options?.[jwksCache] !== undefined) {\n            this.#cache = options?.[jwksCache];\n            if (isFreshJwksCache(options?.[jwksCache], this.#cacheMaxAge)) {\n                this.#jwksTimestamp = this.#cache.uat;\n                this.#local = createLocalJWKSet(this.#cache.jwks);\n            }\n        }\n    }\n    pendingFetch() {\n        return !!this.#pendingFetch;\n    }\n    coolingDown() {\n        return typeof this.#jwksTimestamp === 'number'\n            ? Date.now() < this.#jwksTimestamp + this.#cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this.#jwksTimestamp === 'number'\n            ? Date.now() < this.#jwksTimestamp + this.#cacheMaxAge\n            : false;\n    }\n    jwks() {\n        return this.#local?.jwks();\n    }\n    async getKey(protectedHeader, token) {\n        if (!this.#local || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await this.#local(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return this.#local(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this.#pendingFetch && isCloudflareWorkers()) {\n            this.#pendingFetch = undefined;\n        }\n        this.#pendingFetch ||= fetchJwks(this.#url.href, this.#headers, AbortSignal.timeout(this.#timeoutDuration), this.#customFetch)\n            .then((json) => {\n            this.#local = createLocalJWKSet(json);\n            if (this.#cache) {\n                this.#cache.uat = Date.now();\n                this.#cache.jwks = json;\n            }\n            this.#jwksTimestamp = Date.now();\n            this.#pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this.#pendingFetch = undefined;\n            throw err;\n        });\n        await this.#pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(remoteJWKSet, {\n        coolingDown: {\n            get: () => set.coolingDown(),\n            enumerable: true,\n            configurable: false,\n        },\n        fresh: {\n            get: () => set.fresh(),\n            enumerable: true,\n            configurable: false,\n        },\n        reload: {\n            value: () => set.reload(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n        reloading: {\n            get: () => set.pendingFetch(),\n            enumerable: true,\n            configurable: false,\n        },\n        jwks: {\n            value: () => set.jwks(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return remoteJWKSet;\n}\n","import * as z from \"./v4/classic/external.js\";\nexport * from \"./v4/classic/external.js\";\nexport { z };\nexport default z;\n","const decoders = /* @__PURE__ */ new Map();\nconst encoder = new TextEncoder();\nconst binary = {\n  decode: (data, encoding = \"utf-8\") => {\n    if (!decoders.has(encoding)) {\n      decoders.set(encoding, new TextDecoder(encoding));\n    }\n    const decoder = decoders.get(encoding);\n    return decoder.decode(data);\n  },\n  encode: encoder.encode\n};\n\nexport { binary };\n","import { hex } from './hex.mjs';\nimport { base64Url, base64 } from './base64.mjs';\nimport { getWebcryptoSubtle } from './index.mjs';\n\nconst createHMAC = (algorithm = \"SHA-256\", encoding = \"none\") => {\n  const hmac = {\n    importKey: async (key, keyUsage) => {\n      return getWebcryptoSubtle().importKey(\n        \"raw\",\n        typeof key === \"string\" ? new TextEncoder().encode(key) : key,\n        { name: \"HMAC\", hash: { name: algorithm } },\n        false,\n        [keyUsage]\n      );\n    },\n    sign: async (hmacKey, data) => {\n      if (typeof hmacKey === \"string\") {\n        hmacKey = await hmac.importKey(hmacKey, \"sign\");\n      }\n      const signature = await getWebcryptoSubtle().sign(\n        \"HMAC\",\n        hmacKey,\n        typeof data === \"string\" ? new TextEncoder().encode(data) : data\n      );\n      if (encoding === \"hex\") {\n        return hex.encode(signature);\n      }\n      if (encoding === \"base64\" || encoding === \"base64url\" || encoding === \"base64urlnopad\") {\n        return base64Url.encode(signature, {\n          padding: encoding !== \"base64urlnopad\"\n        });\n      }\n      return signature;\n    },\n    verify: async (hmacKey, data, signature) => {\n      if (typeof hmacKey === \"string\") {\n        hmacKey = await hmac.importKey(hmacKey, \"verify\");\n      }\n      if (encoding === \"hex\") {\n        signature = hex.decode(signature);\n      }\n      if (encoding === \"base64\" || encoding === \"base64url\" || encoding === \"base64urlnopad\") {\n        signature = await base64.decode(signature);\n      }\n      return getWebcryptoSubtle().verify(\n        \"HMAC\",\n        hmacKey,\n        typeof signature === \"string\" ? new TextEncoder().encode(signature) : signature,\n        typeof data === \"string\" ? new TextEncoder().encode(data) : data\n      );\n    }\n  };\n  return hmac;\n};\n\nexport { createHMAC };\n","//#region src/index.ts\nconst s = 1e3;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nconst w = d * 7;\nconst y = d * 365.25;\nconst mo = y / 12;\nfunction ms(value, options) {\n\tif (typeof value === \"string\") return parse(value);\n\telse if (typeof value === \"number\") return format(value, options);\n\tthrow new Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(value)}`);\n}\n/**\n* Parse the given string and return milliseconds.\n*\n* @param str - A string to parse to milliseconds\n* @returns The parsed value in milliseconds, or `NaN` if the string can't be\n* parsed\n*/\nfunction parse(str) {\n\tif (typeof str !== \"string\" || str.length === 0 || str.length > 100) throw new Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(str)}`);\n\tconst match = /^(?<value>-?\\d*\\.?\\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(str);\n\tif (!match?.groups) return NaN;\n\tconst { value, unit = \"ms\" } = match.groups;\n\tconst n = parseFloat(value);\n\tconst matchUnit = unit.toLowerCase();\n\t/* istanbul ignore next - istanbul doesn't understand, but thankfully the TypeScript the exhaustiveness check in the default case keeps us type safe here */\n\tswitch (matchUnit) {\n\t\tcase \"years\":\n\t\tcase \"year\":\n\t\tcase \"yrs\":\n\t\tcase \"yr\":\n\t\tcase \"y\": return n * y;\n\t\tcase \"months\":\n\t\tcase \"month\":\n\t\tcase \"mo\": return n * mo;\n\t\tcase \"weeks\":\n\t\tcase \"week\":\n\t\tcase \"w\": return n * w;\n\t\tcase \"days\":\n\t\tcase \"day\":\n\t\tcase \"d\": return n * d;\n\t\tcase \"hours\":\n\t\tcase \"hour\":\n\t\tcase \"hrs\":\n\t\tcase \"hr\":\n\t\tcase \"h\": return n * h;\n\t\tcase \"minutes\":\n\t\tcase \"minute\":\n\t\tcase \"mins\":\n\t\tcase \"min\":\n\t\tcase \"m\": return n * m;\n\t\tcase \"seconds\":\n\t\tcase \"second\":\n\t\tcase \"secs\":\n\t\tcase \"sec\":\n\t\tcase \"s\": return n * s;\n\t\tcase \"milliseconds\":\n\t\tcase \"millisecond\":\n\t\tcase \"msecs\":\n\t\tcase \"msec\":\n\t\tcase \"ms\": return n;\n\t\tdefault: throw new Error(`Unknown unit \"${matchUnit}\" provided to ms.parse(). value=${JSON.stringify(str)}`);\n\t}\n}\n/**\n* Parse the given StringValue and return milliseconds.\n*\n* @param value - A typesafe StringValue to parse to milliseconds\n* @returns The parsed value in milliseconds, or `NaN` if the string can't be\n* parsed\n*/\nfunction parseStrict(value) {\n\treturn parse(value);\n}\n/**\n* Short format for `ms`.\n*/\nfunction fmtShort(ms$1) {\n\tconst msAbs = Math.abs(ms$1);\n\tif (msAbs >= y) return `${Math.round(ms$1 / y)}y`;\n\tif (msAbs >= mo) return `${Math.round(ms$1 / mo)}mo`;\n\tif (msAbs >= w) return `${Math.round(ms$1 / w)}w`;\n\tif (msAbs >= d) return `${Math.round(ms$1 / d)}d`;\n\tif (msAbs >= h) return `${Math.round(ms$1 / h)}h`;\n\tif (msAbs >= m) return `${Math.round(ms$1 / m)}m`;\n\tif (msAbs >= s) return `${Math.round(ms$1 / s)}s`;\n\treturn `${ms$1}ms`;\n}\n/**\n* Long format for `ms`.\n*/\nfunction fmtLong(ms$1) {\n\tconst msAbs = Math.abs(ms$1);\n\tif (msAbs >= y) return plural(ms$1, msAbs, y, \"year\");\n\tif (msAbs >= mo) return plural(ms$1, msAbs, mo, \"month\");\n\tif (msAbs >= w) return plural(ms$1, msAbs, w, \"week\");\n\tif (msAbs >= d) return plural(ms$1, msAbs, d, \"day\");\n\tif (msAbs >= h) return plural(ms$1, msAbs, h, \"hour\");\n\tif (msAbs >= m) return plural(ms$1, msAbs, m, \"minute\");\n\tif (msAbs >= s) return plural(ms$1, msAbs, s, \"second\");\n\treturn `${ms$1} ms`;\n}\n/**\n* Format the given integer as a string.\n*\n* @param ms - milliseconds\n* @param options - Options for the conversion\n* @returns The formatted string\n*/\nfunction format(ms$1, options) {\n\tif (typeof ms$1 !== \"number\" || !Number.isFinite(ms$1)) throw new Error(\"Value provided to ms.format() must be of type number.\");\n\treturn options?.long ? fmtLong(ms$1) : fmtShort(ms$1);\n}\n/**\n* Pluralization helper.\n*/\nfunction plural(ms$1, msAbs, n, name) {\n\tconst isPlural = msAbs >= n * 1.5;\n\treturn `${Math.round(ms$1 / n)} ${name}${isPlural ? \"s\" : \"\"}`;\n}\n\n//#endregion\nexport { format, ms, parse, parseStrict };","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/auth/[...all]/route\",\n        pathname: \"/api/auth/[...all]\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/auth/[...all]/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/auth/[...all]/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import \"../async_hooks-BfRfbd1J.mjs\";\nimport { f as runWithEndpointContext } from \"../context-DgQ9XGBl.mjs\";\nimport { createEndpoint, createMiddleware } from \"better-call\";\n\n//#region src/api/index.ts\nconst optionsMiddleware = createMiddleware(async () => {\n\t/**\n\t* This will be passed on the instance of\n\t* the context. Used to infer the type\n\t* here.\n\t*/\n\treturn {};\n});\nconst createAuthMiddleware = createMiddleware.create({ use: [optionsMiddleware, createMiddleware(async () => {\n\treturn {};\n})] });\nconst use = [optionsMiddleware];\nconst createAuthEndpoint = (path, options, handler) => {\n\treturn createEndpoint(path, {\n\t\t...options,\n\t\tuse: [...options?.use || [], ...use]\n\t}, async (ctx) => runWithEndpointContext(ctx, () => handler(ctx)));\n};\n\n//#endregion\nexport { createAuthEndpoint, createAuthMiddleware, optionsMiddleware };","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/error.ts\nvar BetterFetchError = class extends Error {\n  constructor(status, statusText, error) {\n    super(statusText || status.toString(), {\n      cause: error\n    });\n    this.status = status;\n    this.statusText = statusText;\n    this.error = error;\n  }\n};\n\n// src/plugins.ts\nvar initializePlugins = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f;\n  let opts = options || {};\n  const hooks = {\n    onRequest: [options == null ? void 0 : options.onRequest],\n    onResponse: [options == null ? void 0 : options.onResponse],\n    onSuccess: [options == null ? void 0 : options.onSuccess],\n    onError: [options == null ? void 0 : options.onError],\n    onRetry: [options == null ? void 0 : options.onRetry]\n  };\n  if (!options || !(options == null ? void 0 : options.plugins)) {\n    return {\n      url,\n      options: opts,\n      hooks\n    };\n  }\n  for (const plugin of (options == null ? void 0 : options.plugins) || []) {\n    if (plugin.init) {\n      const pluginRes = await ((_a = plugin.init) == null ? void 0 : _a.call(plugin, url.toString(), options));\n      opts = pluginRes.options || opts;\n      url = pluginRes.url;\n    }\n    hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);\n    hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);\n    hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);\n    hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);\n    hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);\n  }\n  return {\n    url,\n    options: opts,\n    hooks\n  };\n};\n\n// src/retry.ts\nvar LinearRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay() {\n    return this.options.delay;\n  }\n};\nvar ExponentialRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay(attempt) {\n    const delay = Math.min(\n      this.options.maxDelay,\n      this.options.baseDelay * 2 ** attempt\n    );\n    return delay;\n  }\n};\nfunction createRetryStrategy(options) {\n  if (typeof options === \"number\") {\n    return new LinearRetryStrategy({\n      type: \"linear\",\n      attempts: options,\n      delay: 1e3\n    });\n  }\n  switch (options.type) {\n    case \"linear\":\n      return new LinearRetryStrategy(options);\n    case \"exponential\":\n      return new ExponentialRetryStrategy(options);\n    default:\n      throw new Error(\"Invalid retry strategy\");\n  }\n}\n\n// src/auth.ts\nvar getAuthHeader = async (options) => {\n  const headers = {};\n  const getValue = async (value) => typeof value === \"function\" ? await value() : value;\n  if (options == null ? void 0 : options.auth) {\n    if (options.auth.type === \"Bearer\") {\n      const token = await getValue(options.auth.token);\n      if (!token) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Bearer ${token}`;\n    } else if (options.auth.type === \"Basic\") {\n      const username = getValue(options.auth.username);\n      const password = getValue(options.auth.password);\n      if (!username || !password) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Basic ${btoa(`${username}:${password}`)}`;\n    } else if (options.auth.type === \"Custom\") {\n      const value = getValue(options.auth.value);\n      if (!value) {\n        return headers;\n      }\n      headers[\"authorization\"] = `${getValue(options.auth.prefix)} ${value}`;\n    }\n  }\n  return headers;\n};\n\n// src/utils.ts\nvar JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(request) {\n  const _contentType = request.headers.get(\"content-type\");\n  const textTypes = /* @__PURE__ */ new Set([\n    \"image/svg\",\n    \"application/xml\",\n    \"application/xhtml\",\n    \"application/html\"\n  ]);\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction isJSONParsable(value) {\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction jsonParse(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return text;\n  }\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction getFetch(options) {\n  if (options == null ? void 0 : options.customFetchImpl) {\n    return options.customFetchImpl;\n  }\n  if (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n    return globalThis.fetch;\n  }\n  if (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n    return window.fetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction isPayloadMethod(method) {\n  if (!method) {\n    return false;\n  }\n  const payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  return payloadMethod.includes(method.toUpperCase());\n}\nfunction isRouteMethod(method) {\n  const routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  if (!method) {\n    return false;\n  }\n  return routeMethod.includes(method.toUpperCase());\n}\nasync function getHeaders(opts) {\n  const headers = new Headers(opts == null ? void 0 : opts.headers);\n  const authHeader = await getAuthHeader(opts);\n  for (const [key, value] of Object.entries(authHeader || {})) {\n    headers.set(key, value);\n  }\n  if (!headers.has(\"content-type\")) {\n    const t = detectContentType(opts == null ? void 0 : opts.body);\n    if (t) {\n      headers.set(\"content-type\", t);\n    }\n  }\n  return headers;\n}\nfunction getURL(url, options) {\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  let _url;\n  try {\n    if (url.startsWith(\"http\")) {\n      _url = url;\n    } else {\n      let baseURL = options == null ? void 0 : options.baseURL;\n      if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith(\"/\"))) {\n        baseURL = baseURL + \"/\";\n      }\n      if (url.startsWith(\"/\")) {\n        _url = new URL(url.substring(1), baseURL);\n      } else {\n        _url = new URL(url, options == null ? void 0 : options.baseURL);\n      }\n    }\n  } catch (e) {\n    if (e instanceof TypeError) {\n      if (!(options == null ? void 0 : options.baseURL)) {\n        throw TypeError(\n          `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`\n        );\n      }\n      throw TypeError(\n        `Invalid URL ${url}. Please validate that you are passing the correct input.`\n      );\n    }\n    throw e;\n  }\n  if (options == null ? void 0 : options.params) {\n    if (Array.isArray(options == null ? void 0 : options.params)) {\n      const params = (options == null ? void 0 : options.params) ? Array.isArray(options.params) ? `/${options.params.join(\"/\")}` : `/${Object.values(options.params).join(\"/\")}` : \"\";\n      _url = _url.toString().split(\"/:\")[0];\n      _url = `${_url.toString()}${params}`;\n    } else {\n      for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {\n        _url = _url.toString().replace(`:${key}`, String(value));\n      }\n    }\n  }\n  const __url = new URL(_url);\n  const queryParams = options == null ? void 0 : options.query;\n  if (queryParams) {\n    for (const [key, value] of Object.entries(queryParams)) {\n      __url.searchParams.append(key, String(value));\n    }\n  }\n  return __url;\n}\nfunction detectContentType(body) {\n  if (isJSONSerializable(body)) {\n    return \"application/json\";\n  }\n  return null;\n}\nfunction getBody(options) {\n  if (!(options == null ? void 0 : options.body)) {\n    return null;\n  }\n  const headers = new Headers(options == null ? void 0 : options.headers);\n  if (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n    for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {\n      if (value instanceof Date) {\n        options.body[key] = value.toISOString();\n      }\n    }\n    return JSON.stringify(options.body);\n  }\n  return options.body;\n}\nfunction getMethod(url, options) {\n  var _a;\n  if (options == null ? void 0 : options.method) {\n    return options.method.toUpperCase();\n  }\n  if (url.startsWith(\"@\")) {\n    const pMethod = (_a = url.split(\"@\")[1]) == null ? void 0 : _a.split(\"/\")[0];\n    if (!methods.includes(pMethod)) {\n      return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n    }\n    return pMethod.toUpperCase();\n  }\n  return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n}\nfunction getTimeout(options, controller) {\n  let abortTimeout;\n  if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) {\n    abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);\n  }\n  return {\n    abortTimeout,\n    clearTimeout: () => {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n  };\n}\nfunction bodyParser(data, responseType) {\n  if (responseType === \"json\") {\n    return JSON.parse(data);\n  }\n  return data;\n}\nvar ValidationError = class _ValidationError extends Error {\n  constructor(issues, message) {\n    super(message || JSON.stringify(issues, null, 2));\n    this.issues = issues;\n    Object.setPrototypeOf(this, _ValidationError.prototype);\n  }\n};\nasync function parseStandardSchema(schema, input) {\n  let result = await schema[\"~standard\"].validate(input);\n  if (result.issues) {\n    throw new ValidationError(result.issues);\n  }\n  return result.value;\n}\n\n// src/create-fetch/schema.ts\nvar methods = [\"get\", \"post\", \"put\", \"patch\", \"delete\"];\nvar createSchema = (schema, config) => {\n  return {\n    schema,\n    config\n  };\n};\n\n// src/create-fetch/index.ts\nvar applySchemaPlugin = (config) => ({\n  id: \"apply-schema\",\n  name: \"Apply Schema\",\n  version: \"1.0.0\",\n  async init(url, options) {\n    var _a, _b, _c, _d;\n    const schema = ((_b = (_a = config.plugins) == null ? void 0 : _a.find(\n      (plugin) => {\n        var _a2;\n        return ((_a2 = plugin.schema) == null ? void 0 : _a2.config) ? url.startsWith(plugin.schema.config.baseURL || \"\") || url.startsWith(plugin.schema.config.prefix || \"\") : false;\n      }\n    )) == null ? void 0 : _b.schema) || config.schema;\n    if (schema) {\n      let urlKey = url;\n      if ((_c = schema.config) == null ? void 0 : _c.prefix) {\n        if (urlKey.startsWith(schema.config.prefix)) {\n          urlKey = urlKey.replace(schema.config.prefix, \"\");\n          if (schema.config.baseURL) {\n            url = url.replace(schema.config.prefix, schema.config.baseURL);\n          }\n        }\n      }\n      if ((_d = schema.config) == null ? void 0 : _d.baseURL) {\n        if (urlKey.startsWith(schema.config.baseURL)) {\n          urlKey = urlKey.replace(schema.config.baseURL, \"\");\n        }\n      }\n      const keySchema = schema.schema[urlKey];\n      if (keySchema) {\n        let opts = __spreadProps(__spreadValues({}, options), {\n          method: keySchema.method,\n          output: keySchema.output\n        });\n        if (!(options == null ? void 0 : options.disableValidation)) {\n          opts = __spreadProps(__spreadValues({}, opts), {\n            body: keySchema.input ? await parseStandardSchema(keySchema.input, options == null ? void 0 : options.body) : options == null ? void 0 : options.body,\n            params: keySchema.params ? await parseStandardSchema(keySchema.params, options == null ? void 0 : options.params) : options == null ? void 0 : options.params,\n            query: keySchema.query ? await parseStandardSchema(keySchema.query, options == null ? void 0 : options.query) : options == null ? void 0 : options.query\n          });\n        }\n        return {\n          url,\n          options: opts\n        };\n      }\n    }\n    return {\n      url,\n      options\n    };\n  }\n});\nvar createFetch = (config) => {\n  async function $fetch(url, options) {\n    const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {\n      plugins: [...(config == null ? void 0 : config.plugins) || [], applySchemaPlugin(config || {})]\n    });\n    if (config == null ? void 0 : config.catchAllError) {\n      try {\n        return await betterFetch(url, opts);\n      } catch (error) {\n        return {\n          data: null,\n          error: {\n            status: 500,\n            statusText: \"Fetch Error\",\n            message: \"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n            error\n          }\n        };\n      }\n    }\n    return await betterFetch(url, opts);\n  }\n  return $fetch;\n};\n\n// src/url.ts\nfunction getURL2(url, option) {\n  let { baseURL, params, query } = option || {\n    query: {},\n    params: {},\n    baseURL: \"\"\n  };\n  let basePath = url.startsWith(\"http\") ? url.split(\"/\").slice(0, 3).join(\"/\") : baseURL || \"\";\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  if (!basePath.endsWith(\"/\")) basePath += \"/\";\n  let [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n  const queryParams = new URLSearchParams(urlQuery);\n  for (const [key, value] of Object.entries(query || {})) {\n    if (value == null) continue;\n    queryParams.set(key, String(value));\n  }\n  if (params) {\n    if (Array.isArray(params)) {\n      const paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n      for (const [index, key] of paramPaths.entries()) {\n        const value = params[index];\n        path = path.replace(key, value);\n      }\n    } else {\n      for (const [key, value] of Object.entries(params)) {\n        path = path.replace(`:${key}`, String(value));\n      }\n    }\n  }\n  path = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n  if (path.startsWith(\"/\")) path = path.slice(1);\n  let queryParamString = queryParams.toString();\n  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\\+/g, \"%20\") : \"\";\n  if (!basePath.startsWith(\"http\")) {\n    return `${basePath}${path}${queryParamString}`;\n  }\n  const _url = new URL(`${path}${queryParamString}`, basePath);\n  return _url;\n}\n\n// src/fetch.ts\nvar betterFetch = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const {\n    hooks,\n    url: __url,\n    options: opts\n  } = await initializePlugins(url, options);\n  const fetch = getFetch(opts);\n  const controller = new AbortController();\n  const signal = (_a = opts.signal) != null ? _a : controller.signal;\n  const _url = getURL2(__url, opts);\n  const body = getBody(opts);\n  const headers = await getHeaders(opts);\n  const method = getMethod(__url, opts);\n  let context = __spreadProps(__spreadValues({}, opts), {\n    url: _url,\n    headers,\n    body,\n    method,\n    signal\n  });\n  for (const onRequest of hooks.onRequest) {\n    if (onRequest) {\n      const res = await onRequest(context);\n      if (res instanceof Object) {\n        context = res;\n      }\n    }\n  }\n  if (\"pipeTo\" in context && typeof context.pipeTo === \"function\" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === \"function\") {\n    if (!(\"duplex\" in context)) {\n      context.duplex = \"half\";\n    }\n  }\n  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);\n  let response = await fetch(context.url, context);\n  clearTimeout2();\n  const responseContext = {\n    response,\n    request: context\n  };\n  for (const onResponse of hooks.onResponse) {\n    if (onResponse) {\n      const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), {\n        response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response\n      }));\n      if (r instanceof Response) {\n        response = r;\n      } else if (r instanceof Object) {\n        response = r.response;\n      }\n    }\n  }\n  if (response.ok) {\n    const hasBody = context.method !== \"HEAD\";\n    if (!hasBody) {\n      return {\n        data: \"\",\n        error: null\n      };\n    }\n    const responseType = detectResponseType(response);\n    const successContext = {\n      data: \"\",\n      response,\n      request: context\n    };\n    if (responseType === \"json\" || responseType === \"text\") {\n      const text = await response.text();\n      const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;\n      const data = await parser2(text);\n      successContext.data = data;\n    } else {\n      successContext.data = await response[responseType]();\n    }\n    if (context == null ? void 0 : context.output) {\n      if (context.output && !context.disableValidation) {\n        successContext.data = await parseStandardSchema(\n          context.output,\n          successContext.data\n        );\n      }\n    }\n    for (const onSuccess of hooks.onSuccess) {\n      if (onSuccess) {\n        await onSuccess(__spreadProps(__spreadValues({}, successContext), {\n          response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response\n        }));\n      }\n    }\n    if (options == null ? void 0 : options.throw) {\n      return successContext.data;\n    }\n    return {\n      data: successContext.data,\n      error: null\n    };\n  }\n  const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;\n  const responseText = await response.text();\n  const isJSONResponse = isJSONParsable(responseText);\n  const errorObject = isJSONResponse ? await parser(responseText) : null;\n  const errorContext = {\n    response,\n    responseText,\n    request: context,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n  for (const onError of hooks.onError) {\n    if (onError) {\n      await onError(__spreadProps(__spreadValues({}, errorContext), {\n        response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.retry) {\n    const retryStrategy = createRetryStrategy(options.retry);\n    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;\n    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {\n      for (const onRetry of hooks.onRetry) {\n        if (onRetry) {\n          await onRetry(responseContext);\n        }\n      }\n      const delay = retryStrategy.getDelay(_retryAttempt);\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return await betterFetch(url, __spreadProps(__spreadValues({}, options), {\n        retryAttempt: _retryAttempt + 1\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.throw) {\n    throw new BetterFetchError(\n      response.status,\n      response.statusText,\n      isJSONResponse ? errorObject : responseText\n    );\n  }\n  return {\n    data: null,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n};\nexport {\n  BetterFetchError,\n  ValidationError,\n  applySchemaPlugin,\n  betterFetch,\n  bodyParser,\n  createFetch,\n  createRetryStrategy,\n  createSchema,\n  detectContentType,\n  detectResponseType,\n  getBody,\n  getFetch,\n  getHeaders,\n  getMethod,\n  getTimeout,\n  getURL,\n  initializePlugins,\n  isFunction,\n  isJSONParsable,\n  isJSONSerializable,\n  isPayloadMethod,\n  isRouteMethod,\n  jsonParse,\n  methods,\n  parseStandardSchema\n};\n//# sourceMappingURL=index.js.map","import { isDevelopment, isTest } from \"@better-auth/core/env\";\nimport * as z from \"zod\";\n\n//#region src/utils/get-request-ip.ts\nconst LOCALHOST_IP = \"127.0.0.1\";\nfunction getIp(req, options) {\n\tif (options.advanced?.ipAddress?.disableIpTracking) return null;\n\tif (isTest() || isDevelopment()) return LOCALHOST_IP;\n\tconst headers = \"headers\" in req ? req.headers : req;\n\tconst ipHeaders = options.advanced?.ipAddress?.ipAddressHeaders || [\"x-forwarded-for\"];\n\tfor (const key of ipHeaders) {\n\t\tconst value = \"get\" in headers ? headers.get(key) : headers[key];\n\t\tif (typeof value === \"string\") {\n\t\t\tconst ip = value.split(\",\")[0].trim();\n\t\t\tif (isValidIP(ip)) return ip;\n\t\t}\n\t}\n\treturn null;\n}\nfunction isValidIP(ip) {\n\tif (z.ipv4().safeParse(ip).success) return true;\n\tif (z.ipv6().safeParse(ip).success) return true;\n\treturn false;\n}\n\n//#endregion\nexport { getIp as t };","import { APIError } from \"better-call\";\n\n//#region src/utils/date.ts\nconst getDate = (span, unit = \"ms\") => {\n\treturn new Date(Date.now() + (unit === \"sec\" ? span * 1e3 : span));\n};\n\n//#endregion\n//#region src/db/schema.ts\nconst cache = /* @__PURE__ */ new WeakMap();\nfunction parseOutputData(data, schema) {\n\tconst fields = schema.fields;\n\tconst parsedData = {};\n\tfor (const key in data) {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (field.returned === false) continue;\n\t\tparsedData[key] = data[key];\n\t}\n\treturn parsedData;\n}\nfunction getAllFields(options, table) {\n\tif (!cache.has(options)) cache.set(options, /* @__PURE__ */ new Map());\n\tconst tableCache = cache.get(options);\n\tif (tableCache.has(table)) return tableCache.get(table);\n\tlet schema = {\n\t\t...table === \"user\" ? options.user?.additionalFields : {},\n\t\t...table === \"session\" ? options.session?.additionalFields : {}\n\t};\n\tfor (const plugin of options.plugins || []) if (plugin.schema && plugin.schema[table]) schema = {\n\t\t...schema,\n\t\t...plugin.schema[table].fields\n\t};\n\tcache.get(options).set(table, schema);\n\treturn schema;\n}\nfunction parseUserOutput(options, user) {\n\treturn {\n\t\t...parseOutputData(user, { fields: getAllFields(options, \"user\") }),\n\t\tid: user.id\n\t};\n}\nfunction parseAccountOutput(options, account) {\n\treturn parseOutputData(account, { fields: getAllFields(options, \"account\") });\n}\nfunction parseSessionOutput(options, session) {\n\treturn parseOutputData(session, { fields: getAllFields(options, \"session\") });\n}\nfunction parseInputData(data, schema) {\n\tconst action = schema.action || \"create\";\n\tconst fields = schema.fields;\n\tconst parsedData = Object.assign(Object.create(null), null);\n\tfor (const key in fields) {\n\t\tif (key in data) {\n\t\t\tif (fields[key].input === false) {\n\t\t\t\tif (fields[key].defaultValue !== void 0) {\n\t\t\t\t\tif (action !== \"update\") {\n\t\t\t\t\t\tparsedData[key] = fields[key].defaultValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data[key]) throw new APIError(\"BAD_REQUEST\", { message: `${key} is not allowed to be set` });\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key].validator?.input && data[key] !== void 0) {\n\t\t\t\tparsedData[key] = fields[key].validator.input[\"~standard\"].validate(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key].transform?.input && data[key] !== void 0) {\n\t\t\t\tparsedData[key] = fields[key].transform?.input(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (fields[key].defaultValue !== void 0 && action === \"create\") {\n\t\t\tif (typeof fields[key].defaultValue === \"function\") {\n\t\t\t\tparsedData[key] = fields[key].defaultValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = fields[key].defaultValue;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fields[key].required && action === \"create\") throw new APIError(\"BAD_REQUEST\", { message: `${key} is required` });\n\t}\n\treturn parsedData;\n}\nfunction parseUserInput(options, user = {}, action) {\n\treturn parseInputData(user, {\n\t\tfields: getAllFields(options, \"user\"),\n\t\taction\n\t});\n}\nfunction parseAdditionalUserInput(options, user) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn parseInputData(user || {}, { fields: schema });\n}\nfunction parseAccountInput(options, account) {\n\treturn parseInputData(account, { fields: getAllFields(options, \"account\") });\n}\nfunction parseSessionInput(options, session) {\n\treturn parseInputData(session, { fields: getAllFields(options, \"session\") });\n}\nfunction mergeSchema(schema, newSchema) {\n\tif (!newSchema) return schema;\n\tfor (const table in newSchema) {\n\t\tconst newModelName = newSchema[table]?.modelName;\n\t\tif (newModelName) schema[table].modelName = newModelName;\n\t\tfor (const field in schema[table].fields) {\n\t\t\tconst newField = newSchema[table]?.fields?.[field];\n\t\t\tif (!newField) continue;\n\t\t\tschema[table].fields[field].fieldName = newField;\n\t\t}\n\t}\n\treturn schema;\n}\n\n//#endregion\nexport { parseInputData as a, parseUserInput as c, parseAdditionalUserInput as i, parseUserOutput as l, parseAccountInput as n, parseSessionInput as o, parseAccountOutput as r, parseSessionOutput as s, mergeSchema as t, getDate as u };","import { importJWK } from '../key/import.js';\nimport { JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';\nimport { isObject } from '../lib/is_object.js';\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        case 'ML':\n            return 'AKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nclass LocalJWKSet {\n    #jwks;\n    #cached = new WeakMap();\n    constructor(jwks) {\n        if (!isJWKSLike(jwks)) {\n            throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this.#jwks = structuredClone(jwks);\n    }\n    jwks() {\n        return this.#jwks;\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token?.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this.#jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && (typeof jwk.alg === 'string' || kty === 'AKP')) {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                    case 'Ed25519':\n                    case 'EdDSA':\n                        candidate = jwk.crv === 'Ed25519';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new JWKSNoMatchingKey();\n        }\n        if (length !== 1) {\n            const error = new JWKSMultipleMatchingKeys();\n            const _cached = this.#cached;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch { }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this.#cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await importJWK({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nexport function createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(localJWKSet, {\n        jwks: {\n            value: () => structuredClone(set.jwks()),\n            enumerable: false,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return localJWKSet;\n}\n","import { decode as b64u } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { isObject } from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = b64u(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n","function isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","import { Column } from \"../../column.js\";\nimport { is } from \"../../entity.js\";\nimport { sql } from \"../sql.js\";\nfunction count(expression) {\n  return sql`count(${expression || sql.raw(\"*\")})`.mapWith(Number);\n}\nfunction countDistinct(expression) {\n  return sql`count(distinct ${expression})`.mapWith(Number);\n}\nfunction avg(expression) {\n  return sql`avg(${expression})`.mapWith(String);\n}\nfunction avgDistinct(expression) {\n  return sql`avg(distinct ${expression})`.mapWith(String);\n}\nfunction sum(expression) {\n  return sql`sum(${expression})`.mapWith(String);\n}\nfunction sumDistinct(expression) {\n  return sql`sum(distinct ${expression})`.mapWith(String);\n}\nfunction max(expression) {\n  return sql`max(${expression})`.mapWith(is(expression, Column) ? expression : String);\n}\nfunction min(expression) {\n  return sql`min(${expression})`.mapWith(is(expression, Column) ? expression : String);\n}\nexport {\n  avg,\n  avgDistinct,\n  count,\n  countDistinct,\n  max,\n  min,\n  sum,\n  sumDistinct\n};\n//# sourceMappingURL=aggregate.js.map","//#region src/client/parser.ts\nconst PROTO_POLLUTION_PATTERNS = {\n\tproto: /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/,\n\tconstructor: /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/,\n\tprotoShort: /\"__proto__\"\\s*:/,\n\tconstructorShort: /\"constructor\"\\s*:/\n};\nconst JSON_SIGNATURE = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nconst SPECIAL_VALUES = {\n\ttrue: true,\n\tfalse: false,\n\tnull: null,\n\tundefined: void 0,\n\tnan: NaN,\n\tinfinity: Number.POSITIVE_INFINITY,\n\t\"-infinity\": Number.NEGATIVE_INFINITY\n};\nconst ISO_DATE_REGEX = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,7}))?(?:Z|([+-])(\\d{2}):(\\d{2}))$/;\nfunction isValidDate(date) {\n\treturn date instanceof Date && !isNaN(date.getTime());\n}\nfunction parseISODate(value) {\n\tconst match = ISO_DATE_REGEX.exec(value);\n\tif (!match) return null;\n\tconst [, year, month, day, hour, minute, second, ms, offsetSign, offsetHour, offsetMinute] = match;\n\tlet date = new Date(Date.UTC(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10), parseInt(hour, 10), parseInt(minute, 10), parseInt(second, 10), ms ? parseInt(ms.padEnd(3, \"0\"), 10) : 0));\n\tif (offsetSign) {\n\t\tconst offset = (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) * (offsetSign === \"+\" ? -1 : 1);\n\t\tdate.setUTCMinutes(date.getUTCMinutes() + offset);\n\t}\n\treturn isValidDate(date) ? date : null;\n}\nfunction betterJSONParse(value, options = {}) {\n\tconst { strict = false, warnings = false, reviver, parseDates = true } = options;\n\tif (typeof value !== \"string\") return value;\n\tconst trimmed = value.trim();\n\tif (trimmed.length > 0 && trimmed[0] === \"\\\"\" && trimmed.endsWith(\"\\\"\") && !trimmed.slice(1, -1).includes(\"\\\"\")) return trimmed.slice(1, -1);\n\tconst lowerValue = trimmed.toLowerCase();\n\tif (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) return SPECIAL_VALUES[lowerValue];\n\tif (!JSON_SIGNATURE.test(trimmed)) {\n\t\tif (strict) throw new SyntaxError(\"[better-json] Invalid JSON\");\n\t\treturn value;\n\t}\n\tif (Object.entries(PROTO_POLLUTION_PATTERNS).some(([key, pattern]) => {\n\t\tconst matches = pattern.test(trimmed);\n\t\tif (matches && warnings) console.warn(`[better-json] Detected potential prototype pollution attempt using ${key} pattern`);\n\t\treturn matches;\n\t}) && strict) throw new Error(\"[better-json] Potential prototype pollution attempt detected\");\n\ttry {\n\t\tconst secureReviver = (key, value$1) => {\n\t\t\tif (key === \"__proto__\" || key === \"constructor\" && value$1 && typeof value$1 === \"object\" && \"prototype\" in value$1) {\n\t\t\t\tif (warnings) console.warn(`[better-json] Dropping \"${key}\" key to prevent prototype pollution`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (parseDates && typeof value$1 === \"string\") {\n\t\t\t\tconst date = parseISODate(value$1);\n\t\t\t\tif (date) return date;\n\t\t\t}\n\t\t\treturn reviver ? reviver(key, value$1) : value$1;\n\t\t};\n\t\treturn JSON.parse(trimmed, secureReviver);\n\t} catch (error) {\n\t\tif (strict) throw error;\n\t\treturn value;\n\t}\n}\nfunction parseJSON(value, options = { strict: true }) {\n\treturn betterJSONParse(value, options);\n}\nvar parser_default = parseJSON;\n\n//#endregion\nexport { parser_default as n, parseJSON as t };","import \"./dialect-D9ZUZA4J.mjs\";\nimport \"./get-model-name-D4DUV7S2.mjs\";\nimport \"./get-migration-Bf0TuCzm.mjs\";\nimport { i as parseState, n as HIDE_METADATA, r as generateState, t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport \"./crypto-CFUhAR9W.mjs\";\nimport { t as capitalizeFirstLetter } from \"./misc-BwNc0MKr.mjs\";\nimport \"./schema-Bb7wzeK_.mjs\";\nimport \"./get-request-ip-D6st-mto.mjs\";\nimport \"./json-CnHxKYpj.mjs\";\nimport \"./url-CB8xCwz-.mjs\";\nimport { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport \"./cookies-D72PbWdz.mjs\";\nimport \"./session-AaRl3_x-.mjs\";\nimport \"./base-CiRMFqet.mjs\";\nimport \"./password-BFQK0cLg.mjs\";\nimport { t as betterAuth } from \"./auth-DfR8_5w3.mjs\";\nimport \"./types-BOTDmeLz.mjs\";\nimport { getCurrentAdapter } from \"@better-auth/core/context\";\nimport { createTelemetry, getTelemetryAuthConfig } from \"@better-auth/telemetry\";\n\nexport * from \"@better-auth/core\"\n\nexport * from \"@better-auth/core/db\"\n\nexport * from \"@better-auth/core/env\"\n\nexport * from \"@better-auth/core/error\"\n\nexport * from \"@better-auth/core/oauth2\"\n\nexport * from \"@better-auth/core/utils\"\n\nexport { APIError, HIDE_METADATA, betterAuth, capitalizeFirstLetter, createTelemetry, generateId, generateState, getCurrentAdapter, getTelemetryAuthConfig, parseState };","//#region src/plugins/organization/permission.ts\nconst hasPermissionFn = (input, acRoles) => {\n\tif (!input.permissions && !input.permission) return false;\n\tconst roles = input.role.split(\",\");\n\tconst creatorRole = input.options.creatorRole || \"owner\";\n\tconst isCreator = roles.includes(creatorRole);\n\tconst allowCreatorsAllPermissions = input.allowCreatorAllPermissions || false;\n\tif (isCreator && allowCreatorsAllPermissions) return true;\n\tfor (const role of roles) if ((acRoles[role]?.authorize(input.permissions ?? input.permission))?.success) return true;\n\treturn false;\n};\nlet cacheAllRoles = /* @__PURE__ */ new Map();\n\n//#endregion\nexport { hasPermissionFn as n, cacheAllRoles as t };","//#region src/plugins/two-factor/client.ts\nconst twoFactorClient = (options) => {\n\treturn {\n\t\tid: \"two-factor\",\n\t\t$InferServerPlugin: {},\n\t\tatomListeners: [{\n\t\t\tmatcher: (path) => path.startsWith(\"/two-factor/\"),\n\t\t\tsignal: \"$sessionSignal\"\n\t\t}],\n\t\tpathMethods: {\n\t\t\t\"/two-factor/disable\": \"POST\",\n\t\t\t\"/two-factor/enable\": \"POST\",\n\t\t\t\"/two-factor/send-otp\": \"POST\",\n\t\t\t\"/two-factor/generate-backup-codes\": \"POST\"\n\t\t},\n\t\tfetchPlugins: [{\n\t\t\tid: \"two-factor\",\n\t\t\tname: \"two-factor\",\n\t\t\thooks: { async onSuccess(context) {\n\t\t\t\tif (context.data?.twoFactorRedirect) {\n\t\t\t\t\tif (options?.onTwoFactorRedirect) await options.onTwoFactorRedirect();\n\t\t\t\t}\n\t\t\t} }\n\t\t}]\n\t};\n};\n\n//#endregion\nexport { twoFactorClient as t };","function getAlphabet(hex) {\n  return hex ? \"0123456789ABCDEFGHIJKLMNOPQRSTUV\" : \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n}\nfunction createDecodeMap(alphabet) {\n  const decodeMap = /* @__PURE__ */ new Map();\n  for (let i = 0; i < alphabet.length; i++) {\n    decodeMap.set(alphabet[i], i);\n  }\n  return decodeMap;\n}\nfunction base32Encode(data, alphabet, padding) {\n  let result = \"\";\n  let buffer = 0;\n  let shift = 0;\n  for (const byte of data) {\n    buffer = buffer << 8 | byte;\n    shift += 8;\n    while (shift >= 5) {\n      shift -= 5;\n      result += alphabet[buffer >> shift & 31];\n    }\n  }\n  if (shift > 0) {\n    result += alphabet[buffer << 5 - shift & 31];\n  }\n  if (padding) {\n    const padCount = (8 - result.length % 8) % 8;\n    result += \"=\".repeat(padCount);\n  }\n  return result;\n}\nfunction base32Decode(data, alphabet) {\n  const decodeMap = createDecodeMap(alphabet);\n  const result = [];\n  let buffer = 0;\n  let bitsCollected = 0;\n  for (const char of data) {\n    if (char === \"=\")\n      break;\n    const value = decodeMap.get(char);\n    if (value === void 0) {\n      throw new Error(`Invalid Base32 character: ${char}`);\n    }\n    buffer = buffer << 5 | value;\n    bitsCollected += 5;\n    while (bitsCollected >= 8) {\n      bitsCollected -= 8;\n      result.push(buffer >> bitsCollected & 255);\n    }\n  }\n  return Uint8Array.from(result);\n}\nconst base32 = {\n  /**\n   * Encodes data into a Base32 string.\n   * @param data - The data to encode (ArrayBuffer, TypedArray, or string).\n   * @param options - Encoding options.\n   * @returns The Base32 encoded string.\n   */\n  encode(data, options = {}) {\n    const alphabet = getAlphabet(false);\n    const buffer = typeof data === \"string\" ? new TextEncoder().encode(data) : new Uint8Array(data);\n    return base32Encode(buffer, alphabet, options.padding ?? true);\n  },\n  /**\n   * Decodes a Base32 string into a Uint8Array.\n   * @param data - The Base32 encoded string or ArrayBuffer/TypedArray.\n   * @returns The decoded Uint8Array.\n   */\n  decode(data) {\n    if (typeof data !== \"string\") {\n      data = new TextDecoder().decode(data);\n    }\n    const alphabet = getAlphabet(false);\n    return base32Decode(data, alphabet);\n  }\n};\nconst base32hex = {\n  /**\n   * Encodes data into a Base32hex string.\n   * @param data - The data to encode (ArrayBuffer, TypedArray, or string).\n   * @param options - Encoding options.\n   * @returns The Base32hex encoded string.\n   */\n  encode(data, options = {}) {\n    const alphabet = getAlphabet(true);\n    const buffer = typeof data === \"string\" ? new TextEncoder().encode(data) : new Uint8Array(data);\n    return base32Encode(buffer, alphabet, options.padding ?? true);\n  },\n  /**\n   * Decodes a Base32hex string into a Uint8Array.\n   * @param data - The Base32hex encoded string.\n   * @returns The decoded Uint8Array.\n   */\n  decode(data) {\n    const alphabet = getAlphabet(true);\n    return base32Decode(data, alphabet);\n  }\n};\n\nexport { base32, base32hex };\n","import { JOSENotSupported } from '../util/errors.js';\nfunction getModulusLengthOption(options) {\n    const modulusLength = options?.modulusLength ?? 2048;\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n    }\n    return modulusLength;\n}\nexport async function generateKeyPair(alg, options) {\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = {\n                name: 'RSA-PSS',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: Uint8Array.of(0x01, 0x00, 0x01),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: Uint8Array.of(0x01, 0x00, 0x01),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n                publicExponent: Uint8Array.of(0x01, 0x00, 0x01),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'Ed25519':\n        case 'EdDSA': {\n            keyUsages = ['sign', 'verify'];\n            algorithm = { name: 'Ed25519' };\n            break;\n        }\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87': {\n            keyUsages = ['sign', 'verify'];\n            algorithm = { name: alg };\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            keyUsages = ['deriveBits'];\n            const crv = options?.crv ?? 'P-256';\n            switch (crv) {\n                case 'P-256':\n                case 'P-384':\n                case 'P-521': {\n                    algorithm = { name: 'ECDH', namedCurve: crv };\n                    break;\n                }\n                case 'X25519':\n                    algorithm = { name: 'X25519' };\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, and X25519');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages);\n}\n","import { i as logger } from \"../env-8yWFh7b8.mjs\";\nimport { a as refreshAccessToken, c as getOAuth2Tokens, n as validateAuthorizationCode, o as createAuthorizationURL, s as generateCodeChallenge } from \"../oauth2-B2XPHgx5.mjs\";\nimport \"../utils-C5EN75oV.mjs\";\nimport { t as BetterAuthError } from \"../error-BhAKg8LX.mjs\";\nimport * as z from \"zod\";\nimport { base64 } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { createRemoteJWKSet, decodeJwt, decodeProtectedHeader, importJWK, jwtVerify } from \"jose\";\nimport { APIError } from \"better-call\";\n\n//#region src/social-providers/apple.ts\nconst apple = (options) => {\n\tconst tokenEndpoint = \"https://appleid.apple.com/auth/token\";\n\treturn {\n\t\tid: \"apple\",\n\t\tname: \"Apple\",\n\t\tasync createAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scope = options.disableDefaultScope ? [] : [\"email\", \"name\"];\n\t\t\tif (options.scope) _scope.push(...options.scope);\n\t\t\tif (scopes) _scope.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"apple\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://appleid.apple.com/auth/authorize\",\n\t\t\t\tscopes: _scope,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tresponseMode: \"form_post\",\n\t\t\t\tresponseType: \"code id_token\"\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) return false;\n\t\t\tif (options.verifyIdToken) return options.verifyIdToken(token, nonce);\n\t\t\tconst { kid, alg: jwtAlg } = decodeProtectedHeader(token);\n\t\t\tif (!kid || !jwtAlg) return false;\n\t\t\tconst { payload: jwtClaims } = await jwtVerify(token, await getApplePublicKey(kid), {\n\t\t\t\talgorithms: [jwtAlg],\n\t\t\t\tissuer: \"https://appleid.apple.com\",\n\t\t\t\taudience: options.audience && options.audience.length ? options.audience : options.appBundleIdentifier ? options.appBundleIdentifier : options.clientId,\n\t\t\t\tmaxTokenAge: \"1h\"\n\t\t\t});\n\t\t\t[\"email_verified\", \"is_private_email\"].forEach((field) => {\n\t\t\t\tif (jwtClaims[field] !== void 0) jwtClaims[field] = Boolean(jwtClaims[field]);\n\t\t\t});\n\t\t\tif (nonce && jwtClaims.nonce !== nonce) return false;\n\t\t\treturn !!jwtClaims;\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://appleid.apple.com/auth/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (!token.idToken) return null;\n\t\t\tconst profile = decodeJwt(token.idToken);\n\t\t\tif (!profile) return null;\n\t\t\tconst name = token.user ? `${token.user.name?.firstName} ${token.user.name?.lastName}` : profile.name || profile.email;\n\t\t\tconst emailVerified = typeof profile.email_verified === \"boolean\" ? profile.email_verified : profile.email_verified === \"true\";\n\t\t\tconst enrichedProfile = {\n\t\t\t\t...profile,\n\t\t\t\tname\n\t\t\t};\n\t\t\tconst userMap = await options.mapProfileToUser?.(enrichedProfile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: enrichedProfile.name,\n\t\t\t\t\temailVerified,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: enrichedProfile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\nconst getApplePublicKey = async (kid) => {\n\tconst { data } = await betterFetch(`https://appleid.apple.com/auth/keys`);\n\tif (!data?.keys) throw new APIError(\"BAD_REQUEST\", { message: \"Keys not found\" });\n\tconst jwk = data.keys.find((key) => key.kid === kid);\n\tif (!jwk) throw new Error(`JWK with kid ${kid} not found`);\n\treturn await importJWK(jwk, jwk.alg);\n};\n\n//#endregion\n//#region src/social-providers/atlassian.ts\nconst atlassian = (options) => {\n\treturn {\n\t\tid: \"atlassian\",\n\t\tname: \"Atlassian\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Secret are required for Atlassian\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) throw new BetterAuthError(\"codeVerifier is required for Atlassian\");\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"read:jira-user\", \"offline_access\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"atlassian\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://auth.atlassian.com/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tadditionalParams: { audience: \"api.atlassian.com\" },\n\t\t\t\tprompt: options.prompt\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://auth.atlassian.com/oauth/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://auth.atlassian.com/oauth/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (!token.accessToken) return null;\n\t\t\ttry {\n\t\t\t\tconst { data: profile } = await betterFetch(\"https://api.atlassian.com/me\", { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\t\tif (!profile) return null;\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: profile.account_id,\n\t\t\t\t\t\tname: profile.name,\n\t\t\t\t\t\temail: profile.email,\n\t\t\t\t\t\timage: profile.picture,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t...userMap\n\t\t\t\t\t},\n\t\t\t\t\tdata: profile\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Figma:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/cognito.ts\nconst cognito = (options) => {\n\tif (!options.domain || !options.region || !options.userPoolId) {\n\t\tlogger.error(\"Domain, region and userPoolId are required for Amazon Cognito. Make sure to provide them in the options.\");\n\t\tthrow new BetterAuthError(\"DOMAIN_AND_REGION_REQUIRED\");\n\t}\n\tconst cleanDomain = options.domain.replace(/^https?:\\/\\//, \"\");\n\tconst authorizationEndpoint = `https://${cleanDomain}/oauth2/authorize`;\n\tconst tokenEndpoint = `https://${cleanDomain}/oauth2/token`;\n\tconst userInfoEndpoint = `https://${cleanDomain}/oauth2/userinfo`;\n\treturn {\n\t\tid: \"cognito\",\n\t\tname: \"Cognito\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId) {\n\t\t\t\tlogger.error(\"ClientId is required for Amazon Cognito. Make sure to provide them in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (options.requireClientSecret && !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Secret is required when requireClientSecret is true. Make sure to provide it in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"cognito\",\n\t\t\t\toptions: { ...options },\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) return false;\n\t\t\tif (options.verifyIdToken) return options.verifyIdToken(token, nonce);\n\t\t\ttry {\n\t\t\t\tconst { kid, alg: jwtAlg } = decodeProtectedHeader(token);\n\t\t\t\tif (!kid || !jwtAlg) return false;\n\t\t\t\tconst publicKey = await getCognitoPublicKey(kid, options.region, options.userPoolId);\n\t\t\t\tconst expectedIssuer = `https://cognito-idp.${options.region}.amazonaws.com/${options.userPoolId}`;\n\t\t\t\tconst { payload: jwtClaims } = await jwtVerify(token, publicKey, {\n\t\t\t\t\talgorithms: [jwtAlg],\n\t\t\t\t\tissuer: expectedIssuer,\n\t\t\t\t\taudience: options.clientId,\n\t\t\t\t\tmaxTokenAge: \"1h\"\n\t\t\t\t});\n\t\t\t\tif (nonce && jwtClaims.nonce !== nonce) return false;\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to verify ID token:\", error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (token.idToken) try {\n\t\t\t\tconst profile = decodeJwt(token.idToken);\n\t\t\t\tif (!profile) return null;\n\t\t\t\tconst name = profile.name || profile.given_name || profile.username || profile.email;\n\t\t\t\tconst enrichedProfile = {\n\t\t\t\t\t...profile,\n\t\t\t\t\tname\n\t\t\t\t};\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(enrichedProfile);\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: profile.sub,\n\t\t\t\t\t\tname: enrichedProfile.name,\n\t\t\t\t\t\temail: profile.email,\n\t\t\t\t\t\timage: profile.picture,\n\t\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\t\t...userMap\n\t\t\t\t\t},\n\t\t\t\t\tdata: enrichedProfile\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to decode ID token:\", error);\n\t\t\t}\n\t\t\tif (token.accessToken) try {\n\t\t\t\tconst { data: userInfo } = await betterFetch(userInfoEndpoint, { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\t\tif (userInfo) {\n\t\t\t\t\tconst userMap = await options.mapProfileToUser?.(userInfo);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: userInfo.sub,\n\t\t\t\t\t\t\tname: userInfo.name || userInfo.given_name || userInfo.username,\n\t\t\t\t\t\t\temail: userInfo.email,\n\t\t\t\t\t\t\timage: userInfo.picture,\n\t\t\t\t\t\t\temailVerified: userInfo.email_verified,\n\t\t\t\t\t\t\t...userMap\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: userInfo\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Cognito:\", error);\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\toptions\n\t};\n};\nconst getCognitoPublicKey = async (kid, region, userPoolId) => {\n\tconst COGNITO_JWKS_URI = `https://cognito-idp.${region}.amazonaws.com/${userPoolId}/.well-known/jwks.json`;\n\ttry {\n\t\tconst { data } = await betterFetch(COGNITO_JWKS_URI);\n\t\tif (!data?.keys) throw new APIError(\"BAD_REQUEST\", { message: \"Keys not found\" });\n\t\tconst jwk = data.keys.find((key) => key.kid === kid);\n\t\tif (!jwk) throw new Error(`JWK with kid ${kid} not found`);\n\t\treturn await importJWK(jwk, jwk.alg);\n\t} catch (error) {\n\t\tlogger.error(\"Failed to fetch Cognito public key:\", error);\n\t\tthrow error;\n\t}\n};\n\n//#endregion\n//#region src/social-providers/discord.ts\nconst discord = (options) => {\n\treturn {\n\t\tid: \"discord\",\n\t\tname: \"Discord\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"identify\", \"email\"];\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tconst permissionsParam = _scopes.includes(\"bot\") && options.permissions !== void 0 ? `&permissions=${options.permissions}` : \"\";\n\t\t\treturn new URL(`https://discord.com/api/oauth2/authorize?scope=${_scopes.join(\"+\")}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}&prompt=${options.prompt || \"none\"}${permissionsParam}`);\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://discord.com/api/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://discord.com/api/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://discord.com/api/users/@me\", { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error) return null;\n\t\t\tif (profile.avatar === null) profile.image_url = `https://cdn.discordapp.com/embed/avatars/${profile.discriminator === \"0\" ? Number(BigInt(profile.id) >> BigInt(22)) % 6 : parseInt(profile.discriminator) % 5}.png`;\n\t\t\telse {\n\t\t\t\tconst format = profile.avatar.startsWith(\"a_\") ? \"gif\" : \"png\";\n\t\t\t\tprofile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format}`;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.global_name || profile.username || \"\",\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.verified,\n\t\t\t\t\timage: profile.image_url,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/dropbox.ts\nconst dropbox = (options) => {\n\tconst tokenEndpoint = \"https://api.dropboxapi.com/oauth2/token\";\n\treturn {\n\t\tid: \"dropbox\",\n\t\tname: \"Dropbox\",\n\t\tcreateAuthorizationURL: async ({ state, scopes, codeVerifier, redirectURI }) => {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"account_info.read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tconst additionalParams = {};\n\t\t\tif (options.accessType) additionalParams.token_access_type = options.accessType;\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"dropbox\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.dropbox.com/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t\tadditionalParams\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn await validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://api.dropbox.com/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.dropboxapi.com/2/users/get_current_account\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.account_id,\n\t\t\t\t\tname: profile.name?.display_name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.email_verified || false,\n\t\t\t\t\timage: profile.profile_photo_url,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/facebook.ts\nconst facebook = (options) => {\n\treturn {\n\t\tid: \"facebook\",\n\t\tname: \"Facebook\",\n\t\tasync createAuthorizationURL({ state, scopes, redirectURI, loginHint }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"email\", \"public_profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"facebook\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.facebook.com/v21.0/dialog/oauth\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t\tadditionalParams: options.configId ? { config_id: options.configId } : {}\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://graph.facebook.com/oauth/access_token\"\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) return false;\n\t\t\tif (options.verifyIdToken) return options.verifyIdToken(token, nonce);\n\t\t\tif (token.split(\".\").length === 3) try {\n\t\t\t\tconst { payload: jwtClaims } = await jwtVerify(token, createRemoteJWKSet(new URL(\"https://limited.facebook.com/.well-known/oauth/openid/jwks/\")), {\n\t\t\t\t\talgorithms: [\"RS256\"],\n\t\t\t\t\taudience: options.clientId,\n\t\t\t\t\tissuer: \"https://www.facebook.com\"\n\t\t\t\t});\n\t\t\t\tif (nonce && jwtClaims.nonce !== nonce) return false;\n\t\t\t\treturn !!jwtClaims;\n\t\t\t} catch (error) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://graph.facebook.com/v18.0/oauth/access_token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (token.idToken && token.idToken.split(\".\").length === 3) {\n\t\t\t\tconst profile$1 = decodeJwt(token.idToken);\n\t\t\t\tconst user = {\n\t\t\t\t\tid: profile$1.sub,\n\t\t\t\t\tname: profile$1.name,\n\t\t\t\t\temail: profile$1.email,\n\t\t\t\t\tpicture: { data: {\n\t\t\t\t\t\turl: profile$1.picture,\n\t\t\t\t\t\theight: 100,\n\t\t\t\t\t\twidth: 100,\n\t\t\t\t\t\tis_silhouette: false\n\t\t\t\t\t} }\n\t\t\t\t};\n\t\t\t\tconst userMap$1 = await options.mapProfileToUser?.({\n\t\t\t\t\t...user,\n\t\t\t\t\temail_verified: false\n\t\t\t\t});\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t...userMap$1\n\t\t\t\t\t},\n\t\t\t\t\tdata: profile$1\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://graph.facebook.com/me?fields=\" + [\n\t\t\t\t\"id\",\n\t\t\t\t\"name\",\n\t\t\t\t\"email\",\n\t\t\t\t\"picture\",\n\t\t\t\t...options?.fields || []\n\t\t\t].join(\",\"), { auth: {\n\t\t\t\ttype: \"Bearer\",\n\t\t\t\ttoken: token.accessToken\n\t\t\t} });\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture.data.url,\n\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/figma.ts\nconst figma = (options) => {\n\treturn {\n\t\tid: \"figma\",\n\t\tname: \"Figma\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Client Secret are required for Figma. Make sure to provide them in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) throw new BetterAuthError(\"codeVerifier is required for Figma\");\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"file_read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"figma\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.figma.com/oauth\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://www.figma.com/api/oauth/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://www.figma.com/api/oauth/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\ttry {\n\t\t\t\tconst { data: profile } = await betterFetch(\"https://api.figma.com/v1/me\", { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\t\tif (!profile) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user from Figma\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: profile.id,\n\t\t\t\t\t\tname: profile.handle,\n\t\t\t\t\t\temail: profile.email,\n\t\t\t\t\t\timage: profile.img_url,\n\t\t\t\t\t\temailVerified: !!profile.email,\n\t\t\t\t\t\t...userMap\n\t\t\t\t\t},\n\t\t\t\t\tdata: profile\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Figma:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/github.ts\nconst github = (options) => {\n\tconst tokenEndpoint = \"https://github.com/login/oauth/access_token\";\n\treturn {\n\t\tid: \"github\",\n\t\tname: \"GitHub\",\n\t\tcreateAuthorizationURL({ state, scopes, loginHint, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"read:user\", \"user:email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"github\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://github.com/login/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t\tprompt: options.prompt\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://github.com/login/oauth/access_token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.github.com/user\", { headers: {\n\t\t\t\t\"User-Agent\": \"better-auth\",\n\t\t\t\tauthorization: `Bearer ${token.accessToken}`\n\t\t\t} });\n\t\t\tif (error) return null;\n\t\t\tconst { data: emails } = await betterFetch(\"https://api.github.com/user/emails\", { headers: {\n\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\"User-Agent\": \"better-auth\"\n\t\t\t} });\n\t\t\tif (!profile.email && emails) profile.email = (emails.find((e) => e.primary) ?? emails[0])?.email;\n\t\t\tconst emailVerified = emails?.find((e) => e.email === profile.email)?.verified ?? false;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name || profile.login,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.avatar_url,\n\t\t\t\t\temailVerified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/gitlab.ts\nconst cleanDoubleSlashes = (input = \"\") => {\n\treturn input.split(\"://\").map((str) => str.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n};\nconst issuerToEndpoints = (issuer) => {\n\tlet baseUrl = issuer || \"https://gitlab.com\";\n\treturn {\n\t\tauthorizationEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/authorize`),\n\t\ttokenEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/token`),\n\t\tuserinfoEndpoint: cleanDoubleSlashes(`${baseUrl}/api/v4/user`)\n\t};\n};\nconst gitlab = (options) => {\n\tconst { authorizationEndpoint, tokenEndpoint, userinfoEndpoint } = issuerToEndpoints(options.issuer);\n\tconst issuerId = \"gitlab\";\n\treturn {\n\t\tid: issuerId,\n\t\tname: \"Gitlab\",\n\t\tcreateAuthorizationURL: async ({ state, scopes, codeVerifier, loginHint, redirectURI }) => {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"read_user\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: issuerId,\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t\tloginHint\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\tcodeVerifier,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(userinfoEndpoint, { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error || profile.state !== \"active\" || profile.locked) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name ?? profile.username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.avatar_url,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/google.ts\nconst google = (options) => {\n\treturn {\n\t\tid: \"google\",\n\t\tname: \"Google\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI, loginHint, display }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Client Secret is required for Google. Make sure to provide them in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) throw new BetterAuthError(\"codeVerifier is required for Google\");\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"email\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"openid\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"google\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://accounts.google.com/o/oauth2/auth\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t\taccessType: options.accessType,\n\t\t\t\tdisplay: display || options.display,\n\t\t\t\tloginHint,\n\t\t\t\thd: options.hd,\n\t\t\t\tadditionalParams: { include_granted_scopes: \"true\" }\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://oauth2.googleapis.com/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://www.googleapis.com/oauth2/v4/token\"\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) return false;\n\t\t\tif (options.verifyIdToken) return options.verifyIdToken(token, nonce);\n\t\t\tconst { data: tokenInfo } = await betterFetch(`https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${token}`);\n\t\t\tif (!tokenInfo) return false;\n\t\t\treturn tokenInfo.aud === options.clientId && (tokenInfo.iss === \"https://accounts.google.com\" || tokenInfo.iss === \"accounts.google.com\");\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (!token.idToken) return null;\n\t\t\tconst user = decodeJwt(token.idToken);\n\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.sub,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.picture,\n\t\t\t\t\temailVerified: user.email_verified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: user\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/huggingface.ts\nconst huggingface = (options) => {\n\treturn {\n\t\tid: \"huggingface\",\n\t\tname: \"Hugging Face\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"huggingface\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://huggingface.co/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://huggingface.co/oauth/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://huggingface.co/oauth/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://huggingface.co/oauth/userinfo\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name || profile.preferred_username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/kakao.ts\nconst kakao = (options) => {\n\treturn {\n\t\tid: \"kakao\",\n\t\tname: \"Kakao\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"account_email\",\n\t\t\t\t\"profile_image\",\n\t\t\t\t\"profile_nickname\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"kakao\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://kauth.kakao.com/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://kauth.kakao.com/oauth/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://kauth.kakao.com/oauth/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://kapi.kakao.com/v2/user/me\", { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error || !profile) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tconst account = profile.kakao_account || {};\n\t\t\tconst kakaoProfile = account.profile || {};\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: String(profile.id),\n\t\t\t\t\tname: kakaoProfile.nickname || account.name || void 0,\n\t\t\t\t\temail: account.email,\n\t\t\t\t\timage: kakaoProfile.profile_image_url || kakaoProfile.thumbnail_image_url,\n\t\t\t\t\temailVerified: !!account.is_email_valid && !!account.is_email_verified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/kick.ts\nconst kick = (options) => {\n\treturn {\n\t\tid: \"kick\",\n\t\tname: \"Kick\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI, codeVerifier }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user:read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"kick\",\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://id.kick.com/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tcodeVerifier,\n\t\t\t\tstate\n\t\t\t});\n\t\t},\n\t\tasync validateAuthorizationCode({ code, redirectURI, codeVerifier }) {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://id.kick.com/oauth/token\",\n\t\t\t\tcodeVerifier\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data, error } = await betterFetch(\"https://api.kick.com/public/v1/users\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tif (error) return null;\n\t\t\tconst profile = data.data[0];\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.user_id,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.profile_picture,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/line.ts\n/**\n* LINE Login v2.1\n* - Authorization endpoint: https://access.line.me/oauth2/v2.1/authorize\n* - Token endpoint: https://api.line.me/oauth2/v2.1/token\n* - UserInfo endpoint: https://api.line.me/oauth2/v2.1/userinfo\n* - Verify ID token: https://api.line.me/oauth2/v2.1/verify\n*\n* Docs: https://developers.line.biz/en/reference/line-login/#issue-access-token\n*/\nconst line = (options) => {\n\tconst authorizationEndpoint = \"https://access.line.me/oauth2/v2.1/authorize\";\n\tconst tokenEndpoint = \"https://api.line.me/oauth2/v2.1/token\";\n\tconst userInfoEndpoint = \"https://api.line.me/oauth2/v2.1/userinfo\";\n\tconst verifyIdTokenEndpoint = \"https://api.line.me/oauth2/v2.1/verify\";\n\treturn {\n\t\tid: \"line\",\n\t\tname: \"LINE\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI, loginHint }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"line\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) return false;\n\t\t\tif (options.verifyIdToken) return options.verifyIdToken(token, nonce);\n\t\t\tconst body = new URLSearchParams();\n\t\t\tbody.set(\"id_token\", token);\n\t\t\tbody.set(\"client_id\", options.clientId);\n\t\t\tif (nonce) body.set(\"nonce\", nonce);\n\t\t\tconst { data, error } = await betterFetch(verifyIdTokenEndpoint, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: { \"content-type\": \"application/x-www-form-urlencoded\" },\n\t\t\t\tbody\n\t\t\t});\n\t\t\tif (error || !data) return false;\n\t\t\tif (data.aud !== options.clientId) return false;\n\t\t\tif (nonce && data.nonce && data.nonce !== nonce) return false;\n\t\t\treturn true;\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tlet profile = null;\n\t\t\tif (token.idToken) try {\n\t\t\t\tprofile = decodeJwt(token.idToken);\n\t\t\t} catch {}\n\t\t\tif (!profile) {\n\t\t\t\tconst { data } = await betterFetch(userInfoEndpoint, { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\t\tprofile = data || null;\n\t\t\t}\n\t\t\tif (!profile) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tconst id = profile.sub || profile.userId;\n\t\t\tconst name = profile.name || profile.displayName;\n\t\t\tconst image = profile.picture || profile.pictureUrl || void 0;\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid,\n\t\t\t\t\tname,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/linear.ts\nconst linear = (options) => {\n\tconst tokenEndpoint = \"https://api.linear.app/oauth/token\";\n\treturn {\n\t\tid: \"linear\",\n\t\tname: \"Linear\",\n\t\tcreateAuthorizationURL({ state, scopes, loginHint, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"linear\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://linear.app/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.linear.app/graphql\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({ query: `\n\t\t\t\t\t\t\tquery {\n\t\t\t\t\t\t\t\tviewer {\n\t\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\t\tavatarUrl\n\t\t\t\t\t\t\t\t\tactive\n\t\t\t\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t` })\n\t\t\t});\n\t\t\tif (error || !profile?.data?.viewer) return null;\n\t\t\tconst userData = profile.data.viewer;\n\t\t\tconst userMap = await options.mapProfileToUser?.(userData);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.data.viewer.id,\n\t\t\t\t\tname: profile.data.viewer.name,\n\t\t\t\t\temail: profile.data.viewer.email,\n\t\t\t\t\timage: profile.data.viewer.avatarUrl,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: userData\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/linkedin.ts\nconst linkedin = (options) => {\n\tconst authorizationEndpoint = \"https://www.linkedin.com/oauth/v2/authorization\";\n\tconst tokenEndpoint = \"https://www.linkedin.com/oauth/v2/accessToken\";\n\treturn {\n\t\tid: \"linkedin\",\n\t\tname: \"Linkedin\",\n\t\tcreateAuthorizationURL: async ({ state, scopes, redirectURI, loginHint }) => {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\",\n\t\t\t\t\"openid\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"linkedin\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tloginHint,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn await validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.linkedin.com/v2/userinfo\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.email_verified || false,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/microsoft-entra-id.ts\nconst microsoft = (options) => {\n\tconst tenant = options.tenantId || \"common\";\n\tconst authority = options.authority || \"https://login.microsoftonline.com\";\n\tconst authorizationEndpoint = `${authority}/${tenant}/oauth2/v2.0/authorize`;\n\tconst tokenEndpoint = `${authority}/${tenant}/oauth2/v2.0/token`;\n\treturn {\n\t\tid: \"microsoft\",\n\t\tname: \"Microsoft EntraID\",\n\t\tcreateAuthorizationURL(data) {\n\t\t\tconst scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\",\n\t\t\t\t\"User.Read\",\n\t\t\t\t\"offline_access\"\n\t\t\t];\n\t\t\tif (options.scope) scopes.push(...options.scope);\n\t\t\tif (data.scopes) scopes.push(...data.scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"microsoft\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tstate: data.state,\n\t\t\t\tcodeVerifier: data.codeVerifier,\n\t\t\t\tscopes,\n\t\t\t\tredirectURI: data.redirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t\tloginHint: data.loginHint\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode({ code, codeVerifier, redirectURI }) {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (!token.idToken) return null;\n\t\t\tconst user = decodeJwt(token.idToken);\n\t\t\tconst profilePhotoSize = options.profilePhotoSize || 48;\n\t\t\tawait betterFetch(`https://graph.microsoft.com/v1.0/me/photos/${profilePhotoSize}x${profilePhotoSize}/$value`, {\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` },\n\t\t\t\tasync onResponse(context) {\n\t\t\t\t\tif (options.disableProfilePhoto || !context.response.ok) return;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst pictureBuffer = await context.response.clone().arrayBuffer();\n\t\t\t\t\t\tuser.picture = `data:image/jpeg;base64, ${base64.encode(pictureBuffer)}`;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlogger.error(e && typeof e === \"object\" && \"name\" in e ? e.name : \"\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\tconst emailVerified = user.email_verified !== void 0 ? user.email_verified : user.email && (user.verified_primary_email?.includes(user.email) || user.verified_secondary_email?.includes(user.email)) ? true : false;\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.sub,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.picture,\n\t\t\t\t\temailVerified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: user\n\t\t\t};\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\tconst scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\",\n\t\t\t\t\"User.Read\",\n\t\t\t\t\"offline_access\"\n\t\t\t];\n\t\t\tif (options.scope) scopes.push(...options.scope);\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\textraParams: { scope: scopes.join(\" \") },\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/naver.ts\nconst naver = (options) => {\n\treturn {\n\t\tid: \"naver\",\n\t\tname: \"Naver\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"profile\", \"email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"naver\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://nid.naver.com/oauth2.0/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://nid.naver.com/oauth2.0/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://nid.naver.com/oauth2.0/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://openapi.naver.com/v1/nid/me\", { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error || !profile || profile.resultcode !== \"00\") return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tconst res = profile.response || {};\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: res.id,\n\t\t\t\t\tname: res.name || res.nickname,\n\t\t\t\t\temail: res.email,\n\t\t\t\t\timage: res.profile_image,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/notion.ts\nconst notion = (options) => {\n\tconst tokenEndpoint = \"https://api.notion.com/v1/oauth/token\";\n\treturn {\n\t\tid: \"notion\",\n\t\tname: \"Notion\",\n\t\tcreateAuthorizationURL({ state, scopes, loginHint, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"notion\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://api.notion.com/v1/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t\tadditionalParams: { owner: \"user\" }\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t\tauthentication: \"basic\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.notion.com/v1/users/me\", { headers: {\n\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\"Notion-Version\": \"2022-06-28\"\n\t\t\t} });\n\t\t\tif (error || !profile) return null;\n\t\t\tconst userProfile = profile.bot?.owner?.user;\n\t\t\tif (!userProfile) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(userProfile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: userProfile.id,\n\t\t\t\t\tname: userProfile.name || \"Notion User\",\n\t\t\t\t\temail: userProfile.person?.email || null,\n\t\t\t\t\timage: userProfile.avatar_url,\n\t\t\t\t\temailVerified: !!userProfile.person?.email,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: userProfile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/paybin.ts\nconst paybin = (options) => {\n\tconst issuer = options.issuer || \"https://idp.paybin.io\";\n\tconst authorizationEndpoint = `${issuer}/oauth2/authorize`;\n\tconst tokenEndpoint = `${issuer}/oauth2/token`;\n\treturn {\n\t\tid: \"paybin\",\n\t\tname: \"Paybin\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI, loginHint }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Client Secret is required for Paybin. Make sure to provide them in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) throw new BetterAuthError(\"codeVerifier is required for Paybin\");\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"email\",\n\t\t\t\t\"profile\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"paybin\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t\tloginHint\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (!token.idToken) return null;\n\t\t\tconst user = decodeJwt(token.idToken);\n\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.sub,\n\t\t\t\t\tname: user.name || user.preferred_username || (user.email ? user.email.split(\"@\")[0] : \"User\") || \"User\",\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.picture,\n\t\t\t\t\temailVerified: user.email_verified || false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: user\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/paypal.ts\nconst paypal = (options) => {\n\tconst isSandbox = (options.environment || \"sandbox\") === \"sandbox\";\n\tconst authorizationEndpoint = isSandbox ? \"https://www.sandbox.paypal.com/signin/authorize\" : \"https://www.paypal.com/signin/authorize\";\n\tconst tokenEndpoint = isSandbox ? \"https://api-m.sandbox.paypal.com/v1/oauth2/token\" : \"https://api-m.paypal.com/v1/oauth2/token\";\n\tconst userInfoEndpoint = isSandbox ? \"https://api-m.sandbox.paypal.com/v1/identity/oauth2/userinfo\" : \"https://api-m.paypal.com/v1/identity/oauth2/userinfo\";\n\treturn {\n\t\tid: \"paypal\",\n\t\tname: \"PayPal\",\n\t\tasync createAuthorizationURL({ state, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Client Secret is required for PayPal. Make sure to provide them in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"paypal\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: [],\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\t/**\n\t\t\t* PayPal requires Basic Auth for token exchange\n\t\t\t**/\n\t\t\tconst credentials = base64.encode(`${options.clientId}:${options.clientSecret}`);\n\t\t\ttry {\n\t\t\t\tconst response = await betterFetch(tokenEndpoint, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Basic ${credentials}`,\n\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\t\"Accept-Language\": \"en_US\",\n\t\t\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: new URLSearchParams({\n\t\t\t\t\t\tgrant_type: \"authorization_code\",\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tredirect_uri: redirectURI\n\t\t\t\t\t}).toString()\n\t\t\t\t});\n\t\t\t\tif (!response.data) throw new BetterAuthError(\"FAILED_TO_GET_ACCESS_TOKEN\");\n\t\t\t\tconst data = response.data;\n\t\t\t\treturn {\n\t\t\t\t\taccessToken: data.access_token,\n\t\t\t\t\trefreshToken: data.refresh_token,\n\t\t\t\t\taccessTokenExpiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1e3) : void 0,\n\t\t\t\t\tidToken: data.id_token\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"PayPal token exchange failed:\", error);\n\t\t\t\tthrow new BetterAuthError(\"FAILED_TO_GET_ACCESS_TOKEN\");\n\t\t\t}\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\tconst credentials = base64.encode(`${options.clientId}:${options.clientSecret}`);\n\t\t\ttry {\n\t\t\t\tconst response = await betterFetch(tokenEndpoint, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Basic ${credentials}`,\n\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\t\"Accept-Language\": \"en_US\",\n\t\t\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: new URLSearchParams({\n\t\t\t\t\t\tgrant_type: \"refresh_token\",\n\t\t\t\t\t\trefresh_token: refreshToken\n\t\t\t\t\t}).toString()\n\t\t\t\t});\n\t\t\t\tif (!response.data) throw new BetterAuthError(\"FAILED_TO_REFRESH_ACCESS_TOKEN\");\n\t\t\t\tconst data = response.data;\n\t\t\t\treturn {\n\t\t\t\t\taccessToken: data.access_token,\n\t\t\t\t\trefreshToken: data.refresh_token,\n\t\t\t\t\taccessTokenExpiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1e3) : void 0\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"PayPal token refresh failed:\", error);\n\t\t\t\tthrow new BetterAuthError(\"FAILED_TO_REFRESH_ACCESS_TOKEN\");\n\t\t\t}\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) return false;\n\t\t\tif (options.verifyIdToken) return options.verifyIdToken(token, nonce);\n\t\t\ttry {\n\t\t\t\treturn !!decodeJwt(token).sub;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to verify PayPal ID token:\", error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tif (!token.accessToken) {\n\t\t\t\tlogger.error(\"Access token is required to fetch PayPal user info\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst response = await betterFetch(`${userInfoEndpoint}?schema=paypalv1.1`, { headers: {\n\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\tAccept: \"application/json\"\n\t\t\t\t} });\n\t\t\t\tif (!response.data) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user info from PayPal\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst userInfo = response.data;\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(userInfo);\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: userInfo.user_id,\n\t\t\t\t\t\tname: userInfo.name,\n\t\t\t\t\t\temail: userInfo.email,\n\t\t\t\t\t\timage: userInfo.picture,\n\t\t\t\t\t\temailVerified: userInfo.email_verified,\n\t\t\t\t\t\t...userMap\n\t\t\t\t\t},\n\t\t\t\t\tdata: userInfo\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from PayPal:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/polar.ts\nconst polar = (options) => {\n\treturn {\n\t\tid: \"polar\",\n\t\tname: \"Polar\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"polar\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://polar.sh/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.polar.sh/v1/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://api.polar.sh/v1/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.polar.sh/v1/oauth2/userinfo\", { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.public_name || profile.username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.avatar_url,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/reddit.ts\nconst reddit = (options) => {\n\treturn {\n\t\tid: \"reddit\",\n\t\tname: \"Reddit\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"identity\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"reddit\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.reddit.com/api/v1/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tduration: options.duration\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\tconst body = new URLSearchParams({\n\t\t\t\tgrant_type: \"authorization_code\",\n\t\t\t\tcode,\n\t\t\t\tredirect_uri: options.redirectURI || redirectURI\n\t\t\t});\n\t\t\tconst { data, error } = await betterFetch(\"https://www.reddit.com/api/v1/access_token\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\t\t\t\taccept: \"text/plain\",\n\t\t\t\t\t\"user-agent\": \"better-auth\",\n\t\t\t\t\tAuthorization: `Basic ${base64.encode(`${options.clientId}:${options.clientSecret}`)}`\n\t\t\t\t},\n\t\t\t\tbody: body.toString()\n\t\t\t});\n\t\t\tif (error) throw error;\n\t\t\treturn getOAuth2Tokens(data);\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\tauthentication: \"basic\",\n\t\t\t\ttokenEndpoint: \"https://www.reddit.com/api/v1/access_token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://oauth.reddit.com/api/v1/me\", { headers: {\n\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\"User-Agent\": \"better-auth\"\n\t\t\t} });\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.oauth_client_id,\n\t\t\t\t\temailVerified: profile.has_verified_email,\n\t\t\t\t\timage: profile.icon_img?.split(\"?\")[0],\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/roblox.ts\nconst roblox = (options) => {\n\treturn {\n\t\tid: \"roblox\",\n\t\tname: \"Roblox\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"openid\", \"profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn new URL(`https://apis.roblox.com/oauth/v1/authorize?scope=${_scopes.join(\"+\")}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}&prompt=${options.prompt || \"select_account consent\"}`);\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://apis.roblox.com/oauth/v1/token\",\n\t\t\t\tauthentication: \"post\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://apis.roblox.com/oauth/v1/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://apis.roblox.com/oauth/v1/userinfo\", { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.nickname || profile.preferred_username || \"\",\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temail: profile.preferred_username || null,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: { ...profile }\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/salesforce.ts\nconst salesforce = (options) => {\n\tconst isSandbox = (options.environment ?? \"production\") === \"sandbox\";\n\tconst authorizationEndpoint = options.loginUrl ? `https://${options.loginUrl}/services/oauth2/authorize` : isSandbox ? \"https://test.salesforce.com/services/oauth2/authorize\" : \"https://login.salesforce.com/services/oauth2/authorize\";\n\tconst tokenEndpoint = options.loginUrl ? `https://${options.loginUrl}/services/oauth2/token` : isSandbox ? \"https://test.salesforce.com/services/oauth2/token\" : \"https://login.salesforce.com/services/oauth2/token\";\n\tconst userInfoEndpoint = options.loginUrl ? `https://${options.loginUrl}/services/oauth2/userinfo` : isSandbox ? \"https://test.salesforce.com/services/oauth2/userinfo\" : \"https://login.salesforce.com/services/oauth2/userinfo\";\n\treturn {\n\t\tid: \"salesforce\",\n\t\tname: \"Salesforce\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Client Secret are required for Salesforce. Make sure to provide them in the options.\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) throw new BetterAuthError(\"codeVerifier is required for Salesforce\");\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"email\",\n\t\t\t\t\"profile\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"salesforce\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\ttry {\n\t\t\t\tconst { data: user } = await betterFetch(userInfoEndpoint, { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\t\tif (!user) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user info from Salesforce\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.user_id,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\timage: user.photos?.picture || user.photos?.thumbnail,\n\t\t\t\t\t\temailVerified: user.email_verified ?? false,\n\t\t\t\t\t\t...userMap\n\t\t\t\t\t},\n\t\t\t\t\tdata: user\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Salesforce:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/slack.ts\nconst slack = (options) => {\n\treturn {\n\t\tid: \"slack\",\n\t\tname: \"Slack\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"openid\",\n\t\t\t\t\"profile\",\n\t\t\t\t\"email\"\n\t\t\t];\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tconst url = new URL(\"https://slack.com/openid/connect/authorize\");\n\t\t\turl.searchParams.set(\"scope\", _scopes.join(\" \"));\n\t\t\turl.searchParams.set(\"response_type\", \"code\");\n\t\t\turl.searchParams.set(\"client_id\", options.clientId);\n\t\t\turl.searchParams.set(\"redirect_uri\", options.redirectURI || redirectURI);\n\t\t\turl.searchParams.set(\"state\", state);\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://slack.com/api/openid.connect.token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://slack.com/api/openid.connect.token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://slack.com/api/openid.connect.userInfo\", { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile[\"https://slack.com/user_id\"],\n\t\t\t\t\tname: profile.name || \"\",\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\timage: profile.picture || profile[\"https://slack.com/user_image_512\"],\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/spotify.ts\nconst spotify = (options) => {\n\treturn {\n\t\tid: \"spotify\",\n\t\tname: \"Spotify\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user-read-email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"spotify\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://accounts.spotify.com/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://accounts.spotify.com/api/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://accounts.spotify.com/api/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.spotify.com/v1/me\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.display_name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.images[0]?.url,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/tiktok.ts\nconst tiktok = (options) => {\n\treturn {\n\t\tid: \"tiktok\",\n\t\tname: \"TikTok\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user.info.profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn new URL(`https://www.tiktok.com/v2/auth/authorize?scope=${_scopes.join(\",\")}&response_type=code&client_key=${options.clientKey}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}`);\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions: {\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://open.tiktokapis.com/v2/oauth/token/\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: { clientSecret: options.clientSecret },\n\t\t\t\ttokenEndpoint: \"https://open.tiktokapis.com/v2/oauth/token/\",\n\t\t\t\tauthentication: \"post\",\n\t\t\t\textraParams: { client_key: options.clientKey }\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(`https://open.tiktokapis.com/v2/user/info/?fields=${[\n\t\t\t\t\"open_id\",\n\t\t\t\t\"avatar_large_url\",\n\t\t\t\t\"display_name\",\n\t\t\t\t\"username\"\n\t\t\t].join(\",\")}`, { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error) return null;\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\temail: profile.data.user.email || profile.data.user.username,\n\t\t\t\t\tid: profile.data.user.open_id,\n\t\t\t\t\tname: profile.data.user.display_name || profile.data.user.username,\n\t\t\t\t\timage: profile.data.user.avatar_large_url,\n\t\t\t\t\temailVerified: profile.data.user.email ? true : false\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/twitch.ts\nconst twitch = (options) => {\n\treturn {\n\t\tid: \"twitch\",\n\t\tname: \"Twitch\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user:read:email\", \"openid\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"twitch\",\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://id.twitch.tv/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tclaims: options.claims || [\n\t\t\t\t\t\"email\",\n\t\t\t\t\t\"email_verified\",\n\t\t\t\t\t\"preferred_username\",\n\t\t\t\t\t\"picture\"\n\t\t\t\t]\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://id.twitch.tv/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://id.twitch.tv/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst idToken = token.idToken;\n\t\t\tif (!idToken) {\n\t\t\t\tlogger.error(\"No idToken found in token\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst profile = decodeJwt(idToken);\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.preferred_username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/twitter.ts\nconst twitter = (options) => {\n\treturn {\n\t\tid: \"twitter\",\n\t\tname: \"Twitter\",\n\t\tcreateAuthorizationURL(data) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\n\t\t\t\t\"users.read\",\n\t\t\t\t\"tweet.read\",\n\t\t\t\t\"offline.access\",\n\t\t\t\t\"users.email\"\n\t\t\t];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (data.scopes) _scopes.push(...data.scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"twitter\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://x.com/i/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate: data.state,\n\t\t\t\tcodeVerifier: data.codeVerifier,\n\t\t\t\tredirectURI: data.redirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tauthentication: \"basic\",\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.x.com/2/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\tauthentication: \"basic\",\n\t\t\t\ttokenEndpoint: \"https://api.x.com/2/oauth2/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error: profileError } = await betterFetch(\"https://api.x.com/2/users/me?user.fields=profile_image_url\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tif (profileError) return null;\n\t\t\tconst { data: emailData, error: emailError } = await betterFetch(\"https://api.x.com/2/users/me?user.fields=confirmed_email\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` }\n\t\t\t});\n\t\t\tlet emailVerified = false;\n\t\t\tif (!emailError && emailData?.data?.confirmed_email) {\n\t\t\t\tprofile.data.email = emailData.data.confirmed_email;\n\t\t\t\temailVerified = true;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.data.id,\n\t\t\t\t\tname: profile.data.name,\n\t\t\t\t\temail: profile.data.email || profile.data.username || null,\n\t\t\t\t\timage: profile.data.profile_image_url,\n\t\t\t\t\temailVerified,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/vercel.ts\nconst vercel = (options) => {\n\treturn {\n\t\tid: \"vercel\",\n\t\tname: \"Vercel\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!codeVerifier) throw new BetterAuthError(\"codeVerifier is required for Vercel\");\n\t\t\tlet _scopes = void 0;\n\t\t\tif (options.scope !== void 0 || scopes !== void 0) {\n\t\t\t\t_scopes = [];\n\t\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\t}\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"vercel\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://vercel.com/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.vercel.com/login/oauth/token\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.vercel.com/login/oauth/userinfo\", { headers: { Authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error || !profile) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name ?? profile.preferred_username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/vk.ts\nconst vk = (options) => {\n\treturn {\n\t\tid: \"vk\",\n\t\tname: \"VK\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"email\", \"phone\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"vk\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://id.vk.com/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tcodeVerifier\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI, deviceId }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions,\n\t\t\t\tdeviceId,\n\t\t\t\ttokenEndpoint: \"https://id.vk.com/oauth2/auth\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {\n\t\t\treturn refreshAccessToken({\n\t\t\t\trefreshToken,\n\t\t\t\toptions: {\n\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://id.vk.com/oauth2/auth\"\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(data) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(data);\n\t\t\tif (!data.accessToken) return null;\n\t\t\tconst formBody = new URLSearchParams({\n\t\t\t\taccess_token: data.accessToken,\n\t\t\t\tclient_id: options.clientId\n\t\t\t}).toString();\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://id.vk.com/oauth2/user_info\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\t\t\tbody: formBody\n\t\t\t});\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tif (!profile.user.email && !userMap?.email) return null;\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.user.user_id,\n\t\t\t\t\tfirst_name: profile.user.first_name,\n\t\t\t\t\tlast_name: profile.user.last_name,\n\t\t\t\t\temail: profile.user.email,\n\t\t\t\t\timage: profile.user.avatar,\n\t\t\t\t\temailVerified: !!profile.user.email,\n\t\t\t\t\tbirthday: profile.user.birthday,\n\t\t\t\t\tsex: profile.user.sex,\n\t\t\t\t\tname: `${profile.user.first_name} ${profile.user.last_name}`,\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: profile\n\t\t\t};\n\t\t},\n\t\toptions\n\t};\n};\n\n//#endregion\n//#region src/social-providers/zoom.ts\nconst zoom = (userOptions) => {\n\tconst options = {\n\t\tpkce: true,\n\t\t...userOptions\n\t};\n\treturn {\n\t\tid: \"zoom\",\n\t\tname: \"Zoom\",\n\t\tcreateAuthorizationURL: async ({ state, redirectURI, codeVerifier }) => {\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tresponse_type: \"code\",\n\t\t\t\tredirect_uri: options.redirectURI ? options.redirectURI : redirectURI,\n\t\t\t\tclient_id: options.clientId,\n\t\t\t\tstate\n\t\t\t});\n\t\t\tif (options.pkce) {\n\t\t\t\tconst codeChallenge = await generateCodeChallenge(codeVerifier);\n\t\t\t\tparams.set(\"code_challenge_method\", \"S256\");\n\t\t\t\tparams.set(\"code_challenge\", codeChallenge);\n\t\t\t}\n\t\t\tconst url = new URL(\"https://zoom.us/oauth/authorize\");\n\t\t\turl.search = params.toString();\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://zoom.us/oauth/token\",\n\t\t\t\tauthentication: \"post\"\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => refreshAccessToken({\n\t\t\trefreshToken,\n\t\t\toptions: {\n\t\t\t\tclientId: options.clientId,\n\t\t\t\tclientKey: options.clientKey,\n\t\t\t\tclientSecret: options.clientSecret\n\t\t\t},\n\t\t\ttokenEndpoint: \"https://zoom.us/oauth/token\"\n\t\t}),\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) return options.getUserInfo(token);\n\t\t\tconst { data: profile, error } = await betterFetch(\"https://api.zoom.us/v2/users/me\", { headers: { authorization: `Bearer ${token.accessToken}` } });\n\t\t\tif (error) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.display_name,\n\t\t\t\t\timage: profile.pic_url,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: Boolean(profile.verified),\n\t\t\t\t\t...userMap\n\t\t\t\t},\n\t\t\t\tdata: { ...profile }\n\t\t\t};\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/social-providers/index.ts\nconst socialProviders = {\n\tapple,\n\tatlassian,\n\tcognito,\n\tdiscord,\n\tfacebook,\n\tfigma,\n\tgithub,\n\tmicrosoft,\n\tgoogle,\n\thuggingface,\n\tslack,\n\tspotify,\n\ttwitch,\n\ttwitter,\n\tdropbox,\n\tkick,\n\tlinear,\n\tlinkedin,\n\tgitlab,\n\ttiktok,\n\treddit,\n\troblox,\n\tsalesforce,\n\tvk,\n\tzoom,\n\tnotion,\n\tkakao,\n\tnaver,\n\tline,\n\tpaybin,\n\tpaypal,\n\tpolar,\n\tvercel\n};\nconst socialProviderList = Object.keys(socialProviders);\nconst SocialProviderListEnum = z.enum(socialProviderList).or(z.string());\n\n//#endregion\nexport { SocialProviderListEnum, apple, atlassian, cognito, discord, dropbox, facebook, figma, getApplePublicKey, getCognitoPublicKey, github, gitlab, google, huggingface, kakao, kick, line, linear, linkedin, microsoft, naver, notion, paybin, paypal, polar, reddit, roblox, salesforce, slack, socialProviderList, socialProviders, spotify, tiktok, twitch, twitter, vercel, vk, zoom };","import { APIError } from \"better-call\";\n\n//#region src/utils/password.ts\nasync function validatePassword(ctx, data) {\n\tconst credentialAccount = (await ctx.context.internalAdapter.findAccounts(data.userId))?.find((account) => account.providerId === \"credential\");\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword) return false;\n\treturn await ctx.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: data.password\n\t});\n}\nasync function checkPassword(userId, c) {\n\tconst credentialAccount = (await c.context.internalAdapter.findAccounts(userId))?.find((account) => account.providerId === \"credential\");\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword || !c.body.password) throw new APIError(\"BAD_REQUEST\", { message: \"No password credential found\" });\n\tif (!await c.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: c.body.password\n\t})) throw new APIError(\"BAD_REQUEST\", { message: \"Invalid password\" });\n\treturn true;\n}\n\n//#endregion\nexport { validatePassword as n, checkPassword as t };","import * as z from \"zod\";\n\n//#region src/db/schema/shared.ts\nconst coreSchema = z.object({\n\tid: z.string(),\n\tcreatedAt: z.date().default(() => /* @__PURE__ */ new Date()),\n\tupdatedAt: z.date().default(() => /* @__PURE__ */ new Date())\n});\n\n//#endregion\n//#region src/db/schema/account.ts\nconst accountSchema = coreSchema.extend({\n\tproviderId: z.string(),\n\taccountId: z.string(),\n\tuserId: z.coerce.string(),\n\taccessToken: z.string().nullish(),\n\trefreshToken: z.string().nullish(),\n\tidToken: z.string().nullish(),\n\taccessTokenExpiresAt: z.date().nullish(),\n\trefreshTokenExpiresAt: z.date().nullish(),\n\tscope: z.string().nullish(),\n\tpassword: z.string().nullish()\n});\n\n//#endregion\n//#region src/db/schema/rate-limit.ts\nconst rateLimitSchema = z.object({\n\tkey: z.string(),\n\tcount: z.number(),\n\tlastRequest: z.number()\n});\n\n//#endregion\n//#region src/db/schema/session.ts\nconst sessionSchema = coreSchema.extend({\n\tuserId: z.coerce.string(),\n\texpiresAt: z.date(),\n\ttoken: z.string(),\n\tipAddress: z.string().nullish(),\n\tuserAgent: z.string().nullish()\n});\n\n//#endregion\n//#region src/db/schema/user.ts\nconst userSchema = coreSchema.extend({\n\temail: z.string().transform((val) => val.toLowerCase()),\n\temailVerified: z.boolean().default(false),\n\tname: z.string(),\n\timage: z.string().nullish()\n});\n\n//#endregion\n//#region src/db/schema/verification.ts\nconst verificationSchema = coreSchema.extend({\n\tvalue: z.string(),\n\texpiresAt: z.date(),\n\tidentifier: z.string()\n});\n\n//#endregion\nexport { accountSchema, coreSchema, rateLimitSchema, sessionSchema, userSchema, verificationSchema };","import { BetterAuthError } from \"@better-auth/core/error\";\n\n//#region src/plugins/access/access.ts\nfunction role(statements) {\n\treturn {\n\t\tauthorize(request, connector = \"AND\") {\n\t\t\tlet success = false;\n\t\t\tfor (const [requestedResource, requestedActions] of Object.entries(request)) {\n\t\t\t\tconst allowedActions = statements[requestedResource];\n\t\t\t\tif (!allowedActions) return {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `You are not allowed to access resource: ${requestedResource}`\n\t\t\t\t};\n\t\t\t\tif (Array.isArray(requestedActions)) success = requestedActions.every((requestedAction) => allowedActions.includes(requestedAction));\n\t\t\t\telse if (typeof requestedActions === \"object\") {\n\t\t\t\t\tconst actions = requestedActions;\n\t\t\t\t\tif (actions.connector === \"OR\") success = actions.actions.some((requestedAction) => allowedActions.includes(requestedAction));\n\t\t\t\t\telse success = actions.actions.every((requestedAction) => allowedActions.includes(requestedAction));\n\t\t\t\t} else throw new BetterAuthError(\"Invalid access control request\");\n\t\t\t\tif (success && connector === \"OR\") return { success };\n\t\t\t\tif (!success && connector === \"AND\") return {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `unauthorized to access resource \"${requestedResource}\"`\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (success) return { success };\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Not authorized\"\n\t\t\t};\n\t\t},\n\t\tstatements\n\t};\n}\nfunction createAccessControl(s) {\n\treturn {\n\t\tnewRole(statements) {\n\t\t\treturn role(statements);\n\t\t},\n\t\tstatements: s\n\t};\n}\n\n//#endregion\nexport { role as n, createAccessControl as t };","import { APIError } from \"better-call\";\n\n//#region src/utils/plugin-helper.ts\nconst getEndpointResponse = async (ctx) => {\n\tconst returned = ctx.context.returned;\n\tif (!returned) return null;\n\tif (returned instanceof Response) {\n\t\tif (returned.status !== 200) return null;\n\t\treturn await returned.clone().json();\n\t}\n\tif (returned instanceof APIError) return null;\n\treturn returned;\n};\n\n//#endregion\nexport { getEndpointResponse as t };","import { t as createAccessControl } from \"./access-Dx8TLKnw.mjs\";\n\n//#region src/plugins/admin/access/statement.ts\nconst defaultStatements = {\n\tuser: [\n\t\t\"create\",\n\t\t\"list\",\n\t\t\"set-role\",\n\t\t\"ban\",\n\t\t\"impersonate\",\n\t\t\"delete\",\n\t\t\"set-password\",\n\t\t\"get\",\n\t\t\"update\"\n\t],\n\tsession: [\n\t\t\"list\",\n\t\t\"revoke\",\n\t\t\"delete\"\n\t]\n};\nconst defaultAc = createAccessControl(defaultStatements);\nconst adminAc = defaultAc.newRole({\n\tuser: [\n\t\t\"create\",\n\t\t\"list\",\n\t\t\"set-role\",\n\t\t\"ban\",\n\t\t\"impersonate\",\n\t\t\"delete\",\n\t\t\"set-password\",\n\t\t\"get\",\n\t\t\"update\"\n\t],\n\tsession: [\n\t\t\"list\",\n\t\t\"revoke\",\n\t\t\"delete\"\n\t]\n});\nconst userAc = defaultAc.newRole({\n\tuser: [],\n\tsession: []\n});\nconst defaultRoles = {\n\tadmin: adminAc,\n\tuser: userAc\n};\n\n//#endregion\nexport { userAc as a, defaultStatements as i, defaultAc as n, defaultRoles as r, adminAc as t };","import { r as defaultRoles } from \"./access-h-uttVNZ.mjs\";\n\n//#region src/plugins/admin/has-permission.ts\nconst hasPermission = (input) => {\n\tif (input.userId && input.options?.adminUserIds?.includes(input.userId)) return true;\n\tif (!input.permissions && !input.permission) return false;\n\tconst roles = (input.role || input.options?.defaultRole || \"user\").split(\",\");\n\tconst acRoles = input.options?.roles || defaultRoles;\n\tfor (const role of roles) if ((acRoles[role]?.authorize(input.permission ?? input.permissions))?.success) return true;\n\treturn false;\n};\n\n//#endregion\nexport { hasPermission as t };","import { t as createAccessControl } from \"./access-Dx8TLKnw.mjs\";\n\n//#region src/plugins/organization/access/statement.ts\nconst defaultStatements = {\n\torganization: [\"update\", \"delete\"],\n\tmember: [\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t],\n\tinvitation: [\"create\", \"cancel\"],\n\tteam: [\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t],\n\tac: [\n\t\t\"create\",\n\t\t\"read\",\n\t\t\"update\",\n\t\t\"delete\"\n\t]\n};\nconst defaultAc = createAccessControl(defaultStatements);\nconst adminAc = defaultAc.newRole({\n\torganization: [\"update\"],\n\tinvitation: [\"create\", \"cancel\"],\n\tmember: [\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t],\n\tteam: [\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t],\n\tac: [\n\t\t\"create\",\n\t\t\"read\",\n\t\t\"update\",\n\t\t\"delete\"\n\t]\n});\nconst ownerAc = defaultAc.newRole({\n\torganization: [\"update\", \"delete\"],\n\tmember: [\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t],\n\tinvitation: [\"create\", \"cancel\"],\n\tteam: [\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t],\n\tac: [\n\t\t\"create\",\n\t\t\"read\",\n\t\t\"update\",\n\t\t\"delete\"\n\t]\n});\nconst memberAc = defaultAc.newRole({\n\torganization: [],\n\tmember: [],\n\tinvitation: [],\n\tteam: [],\n\tac: [\"read\"]\n});\nconst defaultRoles = {\n\tadmin: adminAc,\n\towner: ownerAc,\n\tmember: memberAc\n};\n\n//#endregion\nexport { memberAc as a, defaultStatements as i, defaultAc as n, ownerAc as o, defaultRoles as r, adminAc as t };","import { t as createKyselyAdapter } from \"./dialect-D9ZUZA4J.mjs\";\nimport { a as getAuthTables, n as initGetFieldName, t as initGetModelName } from \"./get-model-name-D4DUV7S2.mjs\";\nimport { t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport { l as parseUserOutput, o as parseSessionInput, s as parseSessionOutput, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as getIp } from \"./get-request-ip-D6st-mto.mjs\";\nimport { t as safeJSONParse } from \"./json-CnHxKYpj.mjs\";\nimport { getCurrentAdapter, getCurrentAuthContext, runWithTransaction } from \"@better-auth/core/context\";\nimport { createLogger, logger } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { sql } from \"kysely\";\nimport * as z from \"zod\";\n\n//#region src/db/adapter-base.ts\nasync function getBaseAdapter(options, handleDirectDatabase) {\n\tlet adapter;\n\tif (!options.database) {\n\t\tconst tables = getAuthTables(options);\n\t\tconst memoryDB = Object.keys(tables).reduce((acc, key) => {\n\t\t\tacc[key] = [];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tconst { memoryAdapter } = await import(\"./adapters/memory-adapter/index.mjs\");\n\t\tadapter = memoryAdapter(memoryDB)(options);\n\t} else if (typeof options.database === \"function\") adapter = options.database(options);\n\telse adapter = await handleDirectDatabase(options);\n\tif (!adapter.transaction) {\n\t\tlogger.warn(\"Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.\");\n\t\tadapter.transaction = async (cb) => {\n\t\t\treturn cb(adapter);\n\t\t};\n\t}\n\treturn adapter;\n}\n\n//#endregion\n//#region src/db/adapter-kysely.ts\nasync function getAdapter(options) {\n\treturn getBaseAdapter(options, async (opts) => {\n\t\tconst { createKyselyAdapter: createKyselyAdapter$1 } = await import(\"./adapters/kysely-adapter/index.mjs\");\n\t\tconst { kysely, databaseType, transaction } = await createKyselyAdapter$1(opts);\n\t\tif (!kysely) throw new BetterAuthError(\"Failed to initialize database adapter\");\n\t\tconst { kyselyAdapter } = await import(\"./adapters/kysely-adapter/index.mjs\");\n\t\treturn kyselyAdapter(kysely, {\n\t\t\ttype: databaseType || \"sqlite\",\n\t\t\tdebugLogs: opts.database && \"debugLogs\" in opts.database ? opts.database.debugLogs : false,\n\t\t\ttransaction\n\t\t})(opts);\n\t});\n}\n\n//#endregion\n//#region src/db/field.ts\nconst createFieldAttribute = (type, config) => {\n\treturn {\n\t\ttype,\n\t\t...config\n\t};\n};\n\n//#endregion\n//#region src/db/field-converter.ts\nfunction convertToDB(fields, values) {\n\tlet result = values.id ? { id: values.id } : {};\n\tfor (const key in fields) {\n\t\tconst field = fields[key];\n\t\tconst value = values[key];\n\t\tif (value === void 0) continue;\n\t\tresult[field.fieldName || key] = value;\n\t}\n\treturn result;\n}\nfunction convertFromDB(fields, values) {\n\tif (!values) return null;\n\tlet result = { id: values.id };\n\tfor (const [key, value] of Object.entries(fields)) result[key] = values[value.fieldName || key];\n\treturn result;\n}\n\n//#endregion\n//#region src/db/with-hooks.ts\nfunction getWithHooks(adapter, ctx) {\n\tconst hooks = ctx.hooks;\n\tasync function createWithHooks(data, model, customCreateFn) {\n\t\tconst context = await getCurrentAuthContext();\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.before;\n\t\t\tif (toRun) {\n\t\t\t\tconst result = await toRun(actualData, context);\n\t\t\t\tif (result === false) return null;\n\t\t\t\tif (typeof result === \"object\" && \"data\" in result) actualData = {\n\t\t\t\t\t...actualData,\n\t\t\t\t\t...result.data\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tconst customCreated = customCreateFn ? await customCreateFn.fn(actualData) : null;\n\t\tconst created = !customCreateFn || customCreateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).create({\n\t\t\tmodel,\n\t\t\tdata: actualData,\n\t\t\tforceAllowId: true\n\t\t}) : customCreated;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.after;\n\t\t\tif (toRun) await toRun(created, context);\n\t\t}\n\t\treturn created;\n\t}\n\tasync function updateWithHooks(data, where, model, customUpdateFn) {\n\t\tconst context = await getCurrentAuthContext();\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\tconst result = await toRun(data, context);\n\t\t\t\tif (result === false) return null;\n\t\t\t\tif (typeof result === \"object\" && \"data\" in result) actualData = {\n\t\t\t\t\t...actualData,\n\t\t\t\t\t...result.data\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tconst customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;\n\t\tconst updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).update({\n\t\t\tmodel,\n\t\t\tupdate: actualData,\n\t\t\twhere\n\t\t}) : customUpdated;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) await toRun(updated, context);\n\t\t}\n\t\treturn updated;\n\t}\n\tasync function updateManyWithHooks(data, where, model, customUpdateFn) {\n\t\tconst context = await getCurrentAuthContext();\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\tconst result = await toRun(data, context);\n\t\t\t\tif (result === false) return null;\n\t\t\t\tif (typeof result === \"object\" && \"data\" in result) actualData = {\n\t\t\t\t\t...actualData,\n\t\t\t\t\t...result.data\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tconst customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;\n\t\tconst updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).updateMany({\n\t\t\tmodel,\n\t\t\tupdate: actualData,\n\t\t\twhere\n\t\t}) : customUpdated;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) await toRun(updated, context);\n\t\t}\n\t\treturn updated;\n\t}\n\tasync function deleteWithHooks(where, model, customDeleteFn) {\n\t\tconst context = await getCurrentAuthContext();\n\t\tlet entityToDelete = null;\n\t\ttry {\n\t\t\tentityToDelete = (await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t\tlimit: 1\n\t\t\t}))[0] || null;\n\t\t} catch (error) {}\n\t\tif (entityToDelete) for (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\tif (toRun) {\n\t\t\t\tif (await toRun(entityToDelete, context) === false) return null;\n\t\t\t}\n\t\t}\n\t\tconst customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;\n\t\tconst deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).delete({\n\t\t\tmodel,\n\t\t\twhere\n\t\t}) : customDeleted;\n\t\tif (entityToDelete) for (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\tif (toRun) await toRun(entityToDelete, context);\n\t\t}\n\t\treturn deleted;\n\t}\n\tasync function deleteManyWithHooks(where, model, customDeleteFn) {\n\t\tconst context = await getCurrentAuthContext();\n\t\tlet entitiesToDelete = [];\n\t\ttry {\n\t\t\tentitiesToDelete = await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel,\n\t\t\t\twhere\n\t\t\t});\n\t\t} catch (error) {}\n\t\tfor (const entity of entitiesToDelete) for (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\tif (toRun) {\n\t\t\t\tif (await toRun(entity, context) === false) return null;\n\t\t\t}\n\t\t}\n\t\tconst customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;\n\t\tconst deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).deleteMany({\n\t\t\tmodel,\n\t\t\twhere\n\t\t}) : customDeleted;\n\t\tfor (const entity of entitiesToDelete) for (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\tif (toRun) await toRun(entity, context);\n\t\t}\n\t\treturn deleted;\n\t}\n\treturn {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks\n\t};\n}\n\n//#endregion\n//#region src/db/internal-adapter.ts\nconst createInternalAdapter = (adapter, ctx) => {\n\tconst logger$1 = ctx.logger;\n\tconst options = ctx.options;\n\tconst secondaryStorage = options.secondaryStorage;\n\tconst sessionExpiration = options.session?.expiresIn || 3600 * 24 * 7;\n\tconst { createWithHooks, updateWithHooks, updateManyWithHooks, deleteWithHooks, deleteManyWithHooks } = getWithHooks(adapter, ctx);\n\tasync function refreshUserSessions(user) {\n\t\tif (!secondaryStorage) return;\n\t\tconst listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);\n\t\tif (!listRaw) return;\n\t\tconst now = Date.now();\n\t\tconst validSessions = (safeJSONParse(listRaw) || []).filter((s) => s.expiresAt > now);\n\t\tawait Promise.all(validSessions.map(async ({ token }) => {\n\t\t\tconst cached = await secondaryStorage.get(token);\n\t\t\tif (!cached) return;\n\t\t\tconst parsed = safeJSONParse(cached);\n\t\t\tif (!parsed) return;\n\t\t\tconst sessionTTL = Math.max(Math.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1e3, 0);\n\t\t\tawait secondaryStorage.set(token, JSON.stringify({\n\t\t\t\tsession: parsed.session,\n\t\t\t\tuser\n\t\t\t}), Math.floor(sessionTTL));\n\t\t}));\n\t}\n\treturn {\n\t\tcreateOAuthUser: async (user, account) => {\n\t\t\treturn runWithTransaction(adapter, async () => {\n\t\t\t\tconst createdUser = await createWithHooks({\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t...user\n\t\t\t\t}, \"user\", void 0);\n\t\t\t\treturn {\n\t\t\t\t\tuser: createdUser,\n\t\t\t\t\taccount: await createWithHooks({\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\tuserId: createdUser.id,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t}, \"account\", void 0)\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tcreateUser: async (user) => {\n\t\t\treturn await createWithHooks({\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t...user,\n\t\t\t\temail: user.email?.toLowerCase()\n\t\t\t}, \"user\", void 0);\n\t\t},\n\t\tcreateAccount: async (account) => {\n\t\t\treturn await createWithHooks({\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t...account\n\t\t\t}, \"account\", void 0);\n\t\t},\n\t\tlistSessions: async (userId) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst currentList = await secondaryStorage.get(`active-sessions-${userId}`);\n\t\t\t\tif (!currentList) return [];\n\t\t\t\tconst list = safeJSONParse(currentList) || [];\n\t\t\t\tconst now = Date.now();\n\t\t\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\t\t\t\tconst sessions = [];\n\t\t\t\tfor (const session of validSessions) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(session.token);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\tconst s = safeJSONParse(sessionStringified);\n\t\t\t\t\t\tif (!s) return [];\n\t\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt)\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsessions.push(parsedSession);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\t\t\treturn await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tlistUsers: async (limit, offset, sortBy, where) => {\n\t\t\treturn await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\tsortBy,\n\t\t\t\twhere\n\t\t\t});\n\t\t},\n\t\tcountTotalUsers: async (where) => {\n\t\t\tconst total = await (await getCurrentAdapter(adapter)).count({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere\n\t\t\t});\n\t\t\tif (typeof total === \"string\") return parseInt(total);\n\t\t\treturn total;\n\t\t},\n\t\tdeleteUser: async (userId) => {\n\t\t\tif (secondaryStorage) await secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\tif (!secondaryStorage || options.session?.storeSessionInDatabase) await deleteManyWithHooks([{\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: userId\n\t\t\t}], \"session\", void 0);\n\t\t\tawait deleteManyWithHooks([{\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: userId\n\t\t\t}], \"account\", void 0);\n\t\t\tawait deleteWithHooks([{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: userId\n\t\t\t}], \"user\", void 0);\n\t\t},\n\t\tcreateSession: async (userId, dontRememberMe, override, overrideAll) => {\n\t\t\tconst ctx$1 = await getCurrentAuthContext().catch(() => null);\n\t\t\tconst headers = ctx$1?.headers || ctx$1?.request?.headers;\n\t\t\tconst { id: _, ...rest } = override || {};\n\t\t\tconst defaultAdditionalFields = parseSessionInput(ctx$1?.context.options ?? options, {});\n\t\t\tconst data = {\n\t\t\t\tipAddress: ctx$1?.request || ctx$1?.headers ? getIp(ctx$1?.request || ctx$1?.headers, ctx$1?.context.options) || \"\" : \"\",\n\t\t\t\tuserAgent: headers?.get(\"user-agent\") || \"\",\n\t\t\t\t...rest,\n\t\t\t\texpiresAt: dontRememberMe ? getDate(3600 * 24, \"sec\") : getDate(sessionExpiration, \"sec\"),\n\t\t\t\tuserId,\n\t\t\t\ttoken: generateId(32),\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t...defaultAdditionalFields,\n\t\t\t\t...overrideAll ? rest : {}\n\t\t\t};\n\t\t\treturn await createWithHooks(data, \"session\", secondaryStorage ? {\n\t\t\t\tfn: async (sessionData) => {\n\t\t\t\t\t/**\n\t\t\t\t\t* store the session token for the user\n\t\t\t\t\t* so we can retrieve it later for listing sessions\n\t\t\t\t\t*/\n\t\t\t\t\tconst currentList = await secondaryStorage.get(`active-sessions-${userId}`);\n\t\t\t\t\tlet list = [];\n\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tlist = safeJSONParse(currentList) || [];\n\t\t\t\t\t\tlist = list.filter((session) => session.expiresAt > now);\n\t\t\t\t\t}\n\t\t\t\t\tconst sorted = list.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\tlet furthestSessionExp = sorted.at(-1)?.expiresAt;\n\t\t\t\t\tsorted.push({\n\t\t\t\t\t\ttoken: data.token,\n\t\t\t\t\t\texpiresAt: data.expiresAt.getTime()\n\t\t\t\t\t});\n\t\t\t\t\tif (!furthestSessionExp || furthestSessionExp < data.expiresAt.getTime()) furthestSessionExp = data.expiresAt.getTime();\n\t\t\t\t\tconst furthestSessionTTL = Math.max(Math.floor((furthestSessionExp - now) / 1e3), 0);\n\t\t\t\t\tif (furthestSessionTTL > 0) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(sorted), furthestSessionTTL);\n\t\t\t\t\tconst user = await adapter.findOne({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\tvalue: userId\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tconst sessionTTL = Math.max(Math.floor((data.expiresAt.getTime() - now) / 1e3), 0);\n\t\t\t\t\tif (sessionTTL > 0) await secondaryStorage.set(data.token, JSON.stringify({\n\t\t\t\t\t\tsession: sessionData,\n\t\t\t\t\t\tuser\n\t\t\t\t\t}), sessionTTL);\n\t\t\t\t\treturn sessionData;\n\t\t\t\t},\n\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase\n\t\t\t} : void 0);\n\t\t},\n\t\tfindSession: async (token) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessionStringified = await secondaryStorage.get(token);\n\t\t\t\tif (!sessionStringified && !options.session?.storeSessionInDatabase) return null;\n\t\t\t\tif (sessionStringified) {\n\t\t\t\t\tconst s = safeJSONParse(sessionStringified);\n\t\t\t\t\tif (!s) return null;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsession: parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t\tcreatedAt: new Date(s.session.createdAt),\n\t\t\t\t\t\t\tupdatedAt: new Date(s.session.updatedAt)\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tuser: parseUserOutput(ctx.options, {\n\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt)\n\t\t\t\t\t\t})\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [{\n\t\t\t\t\tvalue: token,\n\t\t\t\t\tfield: \"token\"\n\t\t\t\t}],\n\t\t\t\tjoin: { user: true }\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { user, ...session } = result;\n\t\t\tif (!user) return null;\n\t\t\treturn {\n\t\t\t\tsession: parseSessionOutput(ctx.options, session),\n\t\t\t\tuser: parseUserOutput(ctx.options, user)\n\t\t\t};\n\t\t},\n\t\tfindSessions: async (sessionTokens) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessions$1 = [];\n\t\t\t\tfor (const sessionToken of sessionTokens) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\tconst s = safeJSONParse(sessionStringified);\n\t\t\t\t\t\tif (!s) return [];\n\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsessions$1.push(session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions$1;\n\t\t\t}\n\t\t\tconst sessions = await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"token\",\n\t\t\t\t\tvalue: sessionTokens,\n\t\t\t\t\toperator: \"in\"\n\t\t\t\t}],\n\t\t\t\tjoin: { user: true }\n\t\t\t});\n\t\t\tif (!sessions.length) return [];\n\t\t\tif (sessions.some((session) => !session.user)) return [];\n\t\t\treturn sessions.map((_session) => {\n\t\t\t\tconst { user, ...session } = _session;\n\t\t\t\treturn {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tupdateSession: async (sessionToken, session) => {\n\t\t\treturn await updateWithHooks(session, [{\n\t\t\t\tfield: \"token\",\n\t\t\t\tvalue: sessionToken\n\t\t\t}], \"session\", secondaryStorage ? {\n\t\t\t\tasync fn(data) {\n\t\t\t\t\tconst currentSession = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tlet updatedSession = null;\n\t\t\t\t\tif (currentSession) {\n\t\t\t\t\t\tconst parsedSession = safeJSONParse(currentSession);\n\t\t\t\t\t\tif (!parsedSession) return null;\n\t\t\t\t\t\tupdatedSession = {\n\t\t\t\t\t\t\t...parsedSession.session,\n\t\t\t\t\t\t\t...data\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn updatedSession;\n\t\t\t\t\t} else return null;\n\t\t\t\t},\n\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase\n\t\t\t} : void 0);\n\t\t},\n\t\tdeleteSession: async (token) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst { session } = safeJSONParse(data) ?? {};\n\t\t\t\t\tif (!session) {\n\t\t\t\t\t\tlogger$1.error(\"Session not found in secondary storage\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst userId = session.userId;\n\t\t\t\t\tconst currentList = await secondaryStorage.get(`active-sessions-${userId}`);\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tlet list = safeJSONParse(currentList) || [];\n\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\tconst filtered = list.filter((session$1) => session$1.expiresAt > now && session$1.token !== token);\n\t\t\t\t\t\tconst furthestSessionExp = filtered.sort((a, b) => a.expiresAt - b.expiresAt).at(-1)?.expiresAt;\n\t\t\t\t\t\tif (filtered.length > 0 && furthestSessionExp && furthestSessionExp > Date.now()) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(filtered), Math.floor((furthestSessionExp - now) / 1e3));\n\t\t\t\t\t\telse await secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\t\t\t} else logger$1.error(\"Active sessions list not found in secondary storage\");\n\t\t\t\t}\n\t\t\t\tawait secondaryStorage.delete(token);\n\t\t\t\tif (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;\n\t\t\t}\n\t\t\tawait (await getCurrentAdapter(adapter)).delete({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"token\",\n\t\t\t\t\tvalue: token\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tdeleteAccounts: async (userId) => {\n\t\t\tawait deleteManyWithHooks([{\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: userId\n\t\t\t}], \"account\", void 0);\n\t\t},\n\t\tdeleteAccount: async (accountId) => {\n\t\t\tawait deleteWithHooks([{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: accountId\n\t\t\t}], \"account\", void 0);\n\t\t},\n\t\tdeleteSessions: async (userIdOrSessionTokens) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tif (typeof userIdOrSessionTokens === \"string\") {\n\t\t\t\t\tconst activeSession = await secondaryStorage.get(`active-sessions-${userIdOrSessionTokens}`);\n\t\t\t\t\tconst sessions = activeSession ? safeJSONParse(activeSession) : [];\n\t\t\t\t\tif (!sessions) return;\n\t\t\t\t\tfor (const session of sessions) await secondaryStorage.delete(session.token);\n\t\t\t\t} else for (const sessionToken of userIdOrSessionTokens) if (await secondaryStorage.get(sessionToken)) await secondaryStorage.delete(sessionToken);\n\t\t\t\tif (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;\n\t\t\t}\n\t\t\tawait deleteManyWithHooks([{\n\t\t\t\tfield: Array.isArray(userIdOrSessionTokens) ? \"token\" : \"userId\",\n\t\t\t\tvalue: userIdOrSessionTokens,\n\t\t\t\toperator: Array.isArray(userIdOrSessionTokens) ? \"in\" : void 0\n\t\t\t}], \"session\", void 0);\n\t\t},\n\t\tfindOAuthUser: async (email, accountId, providerId) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [{\n\t\t\t\t\tvalue: accountId,\n\t\t\t\t\tfield: \"accountId\"\n\t\t\t\t}],\n\t\t\t\tjoin: { user: true }\n\t\t\t}).then((accounts) => {\n\t\t\t\treturn accounts.find((a) => a.providerId === providerId);\n\t\t\t});\n\t\t\tif (account) if (account.user) return {\n\t\t\t\tuser: account.user,\n\t\t\t\taccounts: [account]\n\t\t\t};\n\t\t\telse {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\"\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (user) return {\n\t\t\t\t\tuser,\n\t\t\t\t\taccounts: [account]\n\t\t\t\t};\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\"\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (user) return {\n\t\t\t\t\tuser,\n\t\t\t\t\taccounts: await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tvalue: user.id,\n\t\t\t\t\t\t\tfield: \"userId\"\n\t\t\t\t\t\t}]\n\t\t\t\t\t}) || []\n\t\t\t\t};\n\t\t\t\telse return null;\n\t\t\t}\n\t\t},\n\t\tfindUserByEmail: async (email, options$1) => {\n\t\t\tconst result = await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [{\n\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\tfield: \"email\"\n\t\t\t\t}],\n\t\t\t\tjoin: { ...options$1?.includeAccounts ? { account: true } : {} }\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { account: accounts, ...user } = result;\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\taccounts: accounts ?? []\n\t\t\t};\n\t\t},\n\t\tfindUserById: async (userId) => {\n\t\t\tif (!userId) return null;\n\t\t\treturn await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: userId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tlinkAccount: async (account) => {\n\t\t\treturn await createWithHooks({\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t...account\n\t\t\t}, \"account\", void 0);\n\t\t},\n\t\tupdateUser: async (userId, data) => {\n\t\t\tconst user = await updateWithHooks(data, [{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: userId\n\t\t\t}], \"user\", void 0);\n\t\t\tawait refreshUserSessions(user);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdateUserByEmail: async (email, data) => {\n\t\t\tconst user = await updateWithHooks(data, [{\n\t\t\t\tfield: \"email\",\n\t\t\t\tvalue: email.toLowerCase()\n\t\t\t}], \"user\", void 0);\n\t\t\tawait refreshUserSessions(user);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdatePassword: async (userId, password) => {\n\t\t\tawait updateManyWithHooks({ password }, [{\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: userId\n\t\t\t}, {\n\t\t\t\tfield: \"providerId\",\n\t\t\t\tvalue: \"credential\"\n\t\t\t}], \"account\", void 0);\n\t\t},\n\t\tfindAccounts: async (userId) => {\n\t\t\treturn await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindAccount: async (accountId) => {\n\t\t\treturn await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\tvalue: accountId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindAccountByProviderId: async (accountId, providerId) => {\n\t\t\treturn await (await getCurrentAdapter(adapter)).findOne({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\tvalue: accountId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\tvalue: providerId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindAccountByUserId: async (userId) => {\n\t\t\treturn await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tupdateAccount: async (id, data) => {\n\t\t\treturn await updateWithHooks(data, [{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: id\n\t\t\t}], \"account\", void 0);\n\t\t},\n\t\tcreateVerificationValue: async (data) => {\n\t\t\treturn await createWithHooks({\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t...data\n\t\t\t}, \"verification\", void 0);\n\t\t},\n\t\tfindVerificationValue: async (identifier) => {\n\t\t\tconst verification = await (await getCurrentAdapter(adapter)).findMany({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\tvalue: identifier\n\t\t\t\t}],\n\t\t\t\tsortBy: {\n\t\t\t\t\tfield: \"createdAt\",\n\t\t\t\t\tdirection: \"desc\"\n\t\t\t\t},\n\t\t\t\tlimit: 1\n\t\t\t});\n\t\t\tif (!options.verification?.disableCleanup) await (await getCurrentAdapter(adapter)).deleteMany({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\tvalue: /* @__PURE__ */ new Date(),\n\t\t\t\t\toperator: \"lt\"\n\t\t\t\t}]\n\t\t\t});\n\t\t\treturn verification[0];\n\t\t},\n\t\tdeleteVerificationValue: async (id) => {\n\t\t\tawait (await getCurrentAdapter(adapter)).delete({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: id\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tdeleteVerificationByIdentifier: async (identifier) => {\n\t\t\tawait (await getCurrentAdapter(adapter)).delete({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\tvalue: identifier\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tupdateVerificationValue: async (id, data) => {\n\t\t\treturn await updateWithHooks(data, [{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: id\n\t\t\t}], \"verification\", void 0);\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/db/to-zod.ts\nfunction toZodSchema({ fields, isClientSide }) {\n\tconst zodFields = Object.keys(fields).reduce((acc, key) => {\n\t\tconst field = fields[key];\n\t\tif (!field) return acc;\n\t\tif (isClientSide && field.input === false) return acc;\n\t\tlet schema;\n\t\tif (field.type === \"json\") schema = z.json ? z.json() : z.any();\n\t\telse if (field.type === \"string[]\" || field.type === \"number[]\") schema = z.array(field.type === \"string[]\" ? z.string() : z.number());\n\t\telse if (Array.isArray(field.type)) schema = z.any();\n\t\telse schema = z[field.type]();\n\t\tif (field?.required === false) schema = schema.optional();\n\t\tif (field?.returned === false) return acc;\n\t\treturn {\n\t\t\t...acc,\n\t\t\t[key]: schema\n\t\t};\n\t}, {});\n\treturn z.object(zodFields);\n}\n\n//#endregion\n//#region src/db/get-schema.ts\nfunction getSchema(config) {\n\tconst tables = getAuthTables(config);\n\tlet schema = {};\n\tfor (const key in tables) {\n\t\tconst table = tables[key];\n\t\tconst fields = table.fields;\n\t\tlet actualFields = {};\n\t\tObject.entries(fields).forEach(([key$1, field]) => {\n\t\t\tactualFields[field.fieldName || key$1] = field;\n\t\t\tif (field.references) {\n\t\t\t\tconst refTable = tables[field.references.model];\n\t\t\t\tif (refTable) actualFields[field.fieldName || key$1].references = {\n\t\t\t\t\t...field.references,\n\t\t\t\t\tmodel: refTable.modelName,\n\t\t\t\t\tfield: field.references.field\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tif (schema[table.modelName]) {\n\t\t\tschema[table.modelName].fields = {\n\t\t\t\t...schema[table.modelName].fields,\n\t\t\t\t...actualFields\n\t\t\t};\n\t\t\tcontinue;\n\t\t}\n\t\tschema[table.modelName] = {\n\t\t\tfields: actualFields,\n\t\t\torder: table.order || Infinity\n\t\t};\n\t}\n\treturn schema;\n}\n\n//#endregion\n//#region src/db/get-migration.ts\nconst map = {\n\tpostgres: {\n\t\tstring: [\n\t\t\t\"character varying\",\n\t\t\t\"varchar\",\n\t\t\t\"text\",\n\t\t\t\"uuid\"\n\t\t],\n\t\tnumber: [\n\t\t\t\"int4\",\n\t\t\t\"integer\",\n\t\t\t\"bigint\",\n\t\t\t\"smallint\",\n\t\t\t\"numeric\",\n\t\t\t\"real\",\n\t\t\t\"double precision\"\n\t\t],\n\t\tboolean: [\"bool\", \"boolean\"],\n\t\tdate: [\n\t\t\t\"timestamptz\",\n\t\t\t\"timestamp\",\n\t\t\t\"date\"\n\t\t],\n\t\tjson: [\"json\", \"jsonb\"]\n\t},\n\tmysql: {\n\t\tstring: [\n\t\t\t\"varchar\",\n\t\t\t\"text\",\n\t\t\t\"uuid\"\n\t\t],\n\t\tnumber: [\n\t\t\t\"integer\",\n\t\t\t\"int\",\n\t\t\t\"bigint\",\n\t\t\t\"smallint\",\n\t\t\t\"decimal\",\n\t\t\t\"float\",\n\t\t\t\"double\"\n\t\t],\n\t\tboolean: [\"boolean\", \"tinyint\"],\n\t\tdate: [\n\t\t\t\"timestamp\",\n\t\t\t\"datetime\",\n\t\t\t\"date\"\n\t\t],\n\t\tjson: [\"json\"]\n\t},\n\tsqlite: {\n\t\tstring: [\"TEXT\"],\n\t\tnumber: [\"INTEGER\", \"REAL\"],\n\t\tboolean: [\"INTEGER\", \"BOOLEAN\"],\n\t\tdate: [\"DATE\", \"INTEGER\"],\n\t\tjson: [\"TEXT\"]\n\t},\n\tmssql: {\n\t\tstring: [\n\t\t\t\"varchar\",\n\t\t\t\"nvarchar\",\n\t\t\t\"uniqueidentifier\"\n\t\t],\n\t\tnumber: [\n\t\t\t\"int\",\n\t\t\t\"bigint\",\n\t\t\t\"smallint\",\n\t\t\t\"decimal\",\n\t\t\t\"float\",\n\t\t\t\"double\"\n\t\t],\n\t\tboolean: [\"bit\", \"smallint\"],\n\t\tdate: [\n\t\t\t\"datetime2\",\n\t\t\t\"date\",\n\t\t\t\"datetime\"\n\t\t],\n\t\tjson: [\"varchar\", \"nvarchar\"]\n\t}\n};\nfunction matchType(columnDataType, fieldType, dbType) {\n\tfunction normalize(type) {\n\t\treturn type.toLowerCase().split(\"(\")[0].trim();\n\t}\n\tif (fieldType === \"string[]\" || fieldType === \"number[]\") return columnDataType.toLowerCase().includes(\"json\");\n\tconst types = map[dbType];\n\treturn (Array.isArray(fieldType) ? types[\"string\"].map((t) => t.toLowerCase()) : types[fieldType].map((t) => t.toLowerCase())).includes(normalize(columnDataType));\n}\n/**\n* Get the current PostgreSQL schema (search_path) for the database connection\n* Returns the first schema in the search_path, defaulting to 'public' if not found\n*/\nasync function getPostgresSchema(db) {\n\ttry {\n\t\tconst result = await sql`SHOW search_path`.execute(db);\n\t\tif (result.rows[0]?.search_path) return result.rows[0].search_path.split(\",\").map((s) => s.trim()).map((s) => s.replace(/^[\"']|[\"']$/g, \"\")).filter((s) => !s.startsWith(\"$\"))[0] || \"public\";\n\t} catch (error) {}\n\treturn \"public\";\n}\nasync function getMigrations(config) {\n\tconst betterAuthSchema = getSchema(config);\n\tconst logger$1 = createLogger(config.logger);\n\tlet { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);\n\tif (!dbType) {\n\t\tlogger$1.warn(\"Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.\");\n\t\tdbType = \"sqlite\";\n\t}\n\tif (!db) {\n\t\tlogger$1.error(\"Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.\");\n\t\tprocess.exit(1);\n\t}\n\tlet currentSchema = \"public\";\n\tif (dbType === \"postgres\") {\n\t\tcurrentSchema = await getPostgresSchema(db);\n\t\tlogger$1.debug(`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`);\n\t\ttry {\n\t\t\tif (!(await sql`\n\t\t\t\tSELECT schema_name \n\t\t\t\tFROM information_schema.schemata \n\t\t\t\tWHERE schema_name = ${currentSchema}\n\t\t\t`.execute(db)).rows[0]) logger$1.warn(`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`);\n\t\t} catch (error) {\n\t\t\tlogger$1.debug(`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`);\n\t\t}\n\t}\n\tconst allTableMetadata = await db.introspection.getTables();\n\tlet tableMetadata = allTableMetadata;\n\tif (dbType === \"postgres\") try {\n\t\tconst tablesInSchema = await sql`\n\t\t\t\tSELECT table_name \n\t\t\t\tFROM information_schema.tables \n\t\t\t\tWHERE table_schema = ${currentSchema}\n\t\t\t\tAND table_type = 'BASE TABLE'\n\t\t\t`.execute(db);\n\t\tconst tableNamesInSchema = new Set(tablesInSchema.rows.map((row) => row.table_name));\n\t\ttableMetadata = allTableMetadata.filter((table) => table.schema === currentSchema && tableNamesInSchema.has(table.name));\n\t\tlogger$1.debug(`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(\", \") || \"(none)\"}`);\n\t} catch (error) {\n\t\tlogger$1.warn(`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n\tconst toBeCreated = [];\n\tconst toBeAdded = [];\n\tfor (const [key, value] of Object.entries(betterAuthSchema)) {\n\t\tconst table = tableMetadata.find((t) => t.name === key);\n\t\tif (!table) {\n\t\t\tconst tIndex = toBeCreated.findIndex((t) => t.table === key);\n\t\t\tconst tableData = {\n\t\t\t\ttable: key,\n\t\t\t\tfields: value.fields,\n\t\t\t\torder: value.order || Infinity\n\t\t\t};\n\t\t\tconst insertIndex = toBeCreated.findIndex((t) => (t.order || Infinity) > tableData.order);\n\t\t\tif (insertIndex === -1) if (tIndex === -1) toBeCreated.push(tableData);\n\t\t\telse toBeCreated[tIndex].fields = {\n\t\t\t\t...toBeCreated[tIndex].fields,\n\t\t\t\t...value.fields\n\t\t\t};\n\t\t\telse toBeCreated.splice(insertIndex, 0, tableData);\n\t\t\tcontinue;\n\t\t}\n\t\tlet toBeAddedFields = {};\n\t\tfor (const [fieldName, field] of Object.entries(value.fields)) {\n\t\t\tconst column = table.columns.find((c) => c.name === fieldName);\n\t\t\tif (!column) {\n\t\t\t\ttoBeAddedFields[fieldName] = field;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (matchType(column.dataType, field.type, dbType)) continue;\n\t\t\telse logger$1.warn(`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`);\n\t\t}\n\t\tif (Object.keys(toBeAddedFields).length > 0) toBeAdded.push({\n\t\t\ttable: key,\n\t\t\tfields: toBeAddedFields,\n\t\t\torder: value.order || Infinity\n\t\t});\n\t}\n\tconst migrations = [];\n\tconst useUUIDs = config.advanced?.database?.generateId === \"uuid\";\n\tconst useNumberId = config.advanced?.database?.useNumberId || config.advanced?.database?.generateId === \"serial\";\n\tfunction getType(field, fieldName) {\n\t\tconst type = field.type;\n\t\tconst typeMap = {\n\t\t\tstring: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"text\",\n\t\t\t\tmysql: field.unique ? \"varchar(255)\" : field.references ? \"varchar(36)\" : field.sortable ? \"varchar(255)\" : field.index ? \"varchar(255)\" : \"text\",\n\t\t\t\tmssql: field.unique || field.sortable ? \"varchar(255)\" : field.references ? \"varchar(36)\" : \"varchar(8000)\"\n\t\t\t},\n\t\t\tboolean: {\n\t\t\t\tsqlite: \"integer\",\n\t\t\t\tpostgres: \"boolean\",\n\t\t\t\tmysql: \"boolean\",\n\t\t\t\tmssql: \"smallint\"\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tsqlite: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tpostgres: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmysql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmssql: field.bigint ? \"bigint\" : \"integer\"\n\t\t\t},\n\t\t\tdate: {\n\t\t\t\tsqlite: \"date\",\n\t\t\t\tpostgres: \"timestamptz\",\n\t\t\t\tmysql: \"timestamp(3)\",\n\t\t\t\tmssql: sql`datetime2(3)`\n\t\t\t},\n\t\t\tjson: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\"\n\t\t\t},\n\t\t\tid: {\n\t\t\t\tpostgres: useNumberId ? sql`integer GENERATED BY DEFAULT AS IDENTITY` : useUUIDs ? \"uuid\" : \"text\",\n\t\t\t\tmysql: useNumberId ? \"integer\" : useUUIDs ? \"varchar(36)\" : \"varchar(36)\",\n\t\t\t\tmssql: useNumberId ? \"integer\" : useUUIDs ? \"varchar(36)\" : \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\"\n\t\t\t},\n\t\t\tforeignKeyId: {\n\t\t\t\tpostgres: useNumberId ? \"integer\" : useUUIDs ? \"uuid\" : \"text\",\n\t\t\t\tmysql: useNumberId ? \"integer\" : useUUIDs ? \"varchar(36)\" : \"varchar(36)\",\n\t\t\t\tmssql: useNumberId ? \"integer\" : useUUIDs ? \"varchar(36)\" : \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\"\n\t\t\t}\n\t\t};\n\t\tif (fieldName === \"id\" || field.references?.field === \"id\") {\n\t\t\tif (fieldName === \"id\") return typeMap.id[dbType];\n\t\t\treturn typeMap.foreignKeyId[dbType];\n\t\t}\n\t\tif (dbType === \"sqlite\" && (type === \"string[]\" || type === \"number[]\")) return \"text\";\n\t\tif (type === \"string[]\" || type === \"number[]\") return \"jsonb\";\n\t\tif (Array.isArray(type)) return \"text\";\n\t\tif (!(type in typeMap)) throw new Error(`Unsupported field type '${String(type)}' for field '${fieldName}'. Allowed types are: string, number, boolean, date, string[], number[]. If you need to store structured data, store it as a JSON string (type: \"string\") or split it into primitive fields. See https://better-auth.com/docs/advanced/schema#additional-fields`);\n\t\treturn typeMap[type][dbType || \"sqlite\"];\n\t}\n\tconst getModelName = initGetModelName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false\n\t});\n\tconst getFieldName = initGetFieldName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false\n\t});\n\tfunction getReferencePath(model, field) {\n\t\ttry {\n\t\t\treturn `${getModelName(model)}.${getFieldName({\n\t\t\t\tmodel,\n\t\t\t\tfield\n\t\t\t})}`;\n\t\t} catch {\n\t\t\treturn `${model}.${field}`;\n\t\t}\n\t}\n\tif (toBeAdded.length) for (const table of toBeAdded) for (const [fieldName, field] of Object.entries(table.fields)) {\n\t\tconst type = getType(field, fieldName);\n\t\tlet builder = db.schema.alterTable(table.table);\n\t\tif (field.index) {\n\t\t\tconst index = db.schema.alterTable(table.table).addIndex(`${table.table}_${fieldName}_idx`);\n\t\t\tmigrations.push(index);\n\t\t}\n\t\tlet built = builder.addColumn(fieldName, type, (col) => {\n\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\tif (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || \"cascade\");\n\t\t\tif (field.unique) col = col.unique();\n\t\t\tif (field.type === \"date\" && typeof field.defaultValue === \"function\" && (dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")) if (dbType === \"mysql\") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\telse col = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\treturn col;\n\t\t});\n\t\tmigrations.push(built);\n\t}\n\tlet toBeIndexed = [];\n\tif (config.advanced?.database?.useNumberId) logger$1.warn(\"`useNumberId` is deprecated. Please use `generateId` with `serial` instead.\");\n\tif (toBeCreated.length) for (const table of toBeCreated) {\n\t\tconst idType = getType({ type: useNumberId ? \"number\" : \"string\" }, \"id\");\n\t\tlet dbT = db.schema.createTable(table.table).addColumn(\"id\", idType, (col) => {\n\t\t\tif (useNumberId) {\n\t\t\t\tif (dbType === \"postgres\") return col.primaryKey().notNull();\n\t\t\t\telse if (dbType === \"sqlite\") return col.primaryKey().notNull();\n\t\t\t\telse if (dbType === \"mssql\") return col.identity().primaryKey().notNull();\n\t\t\t\treturn col.autoIncrement().primaryKey().notNull();\n\t\t\t}\n\t\t\tif (useUUIDs) {\n\t\t\t\tif (dbType === \"postgres\") return col.primaryKey().defaultTo(sql`pg_catalog.gen_random_uuid()`).notNull();\n\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t}\n\t\t\treturn col.primaryKey().notNull();\n\t\t});\n\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\tconst type = getType(field, fieldName);\n\t\t\tdbT = dbT.addColumn(fieldName, type, (col) => {\n\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\tif (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\tif (field.unique) col = col.unique();\n\t\t\t\tif (field.type === \"date\" && typeof field.defaultValue === \"function\" && (dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")) if (dbType === \"mysql\") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\telse col = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\treturn col;\n\t\t\t});\n\t\t\tif (field.index) {\n\t\t\t\tlet builder = db.schema.createIndex(`${table.table}_${fieldName}_${field.unique ? \"uidx\" : \"idx\"}`).on(table.table).columns([fieldName]);\n\t\t\t\ttoBeIndexed.push(field.unique ? builder.unique() : builder);\n\t\t\t}\n\t\t}\n\t\tmigrations.push(dbT);\n\t}\n\tif (toBeIndexed.length) for (const index of toBeIndexed) migrations.push(index);\n\tasync function runMigrations() {\n\t\tfor (const migration of migrations) await migration.execute();\n\t}\n\tasync function compileMigrations() {\n\t\treturn migrations.map((m) => m.compile().sql).join(\";\\n\\n\") + \";\";\n\t}\n\treturn {\n\t\ttoBeCreated,\n\t\ttoBeAdded,\n\t\trunMigrations,\n\t\tcompileMigrations\n\t};\n}\n\n//#endregion\nexport { createInternalAdapter as a, convertToDB as c, getBaseAdapter as d, toZodSchema as i, createFieldAttribute as l, matchType as n, getWithHooks as o, getSchema as r, convertFromDB as s, getMigrations as t, getAdapter as u };","import { betterAuth } from 'better-auth';\nimport { drizzleAdapter } from 'better-auth/adapters/drizzle';\nimport { username } from 'better-auth/plugins';\nimport { db } from '@/lib/db';\nimport * as schema from '@/lib/db/schema';\n\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, {\n    provider: 'pg',\n    usePlural: true,\n    schema: {\n      ...schema,\n      user: schema.users,\n      session: schema.sessions,\n      account: schema.accounts,\n      verification: schema.verifications,\n    },\n  }),\n\n  emailAndPassword: {\n    enabled: true,\n    requireEmailVerification: false,\n  },\n\n  plugins: [\n    username({\n      minUsernameLength: 3,\n      maxUsernameLength: 30,\n    }),\n  ],\n\n  session: {\n    cookieCache: {\n      enabled: true,\n      maxAge: 60 * 5, // 5 minutes\n    },\n    expiresIn: 60 * 60 * 24 * 7, // 7 days\n    updateAge: 60 * 60 * 24, // 1 day\n  },\n\n  user: {\n    additionalFields: {\n      schoolId: {\n        type: 'string',\n        required: false,\n      },\n      role: {\n        type: 'string',\n        required: true,\n        defaultValue: 'student',\n      },\n      firstName: {\n        type: 'string',\n        required: true,\n      },\n      lastName: {\n        type: 'string',\n        required: true,\n      },\n      isActive: {\n        type: 'boolean',\n        required: false,\n        defaultValue: true,\n      },\n      lastLoginAt: {\n        type: 'date',\n        required: false,\n      },\n    },\n  },\n\n  trustedOrigins: [\n    process.env.BETTER_AUTH_URL || 'http://localhost:3000',\n  ],\n});\n\nexport type Session = typeof auth.$Infer.Session;\nexport type User = typeof auth.$Infer.Session.user;\n","import { ENV, env, getBooleanEnvVar, getEnvVar, isTest, logger } from \"@better-auth/core/env\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { base64 } from \"@better-auth/utils/base64\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { createRandomStringGenerator } from \"@better-auth/utils/random\";\n\n//#region src/detectors/detect-auth-config.ts\nfunction getTelemetryAuthConfig(options, context) {\n\treturn {\n\t\tdatabase: context?.database,\n\t\tadapter: context?.adapter,\n\t\temailVerification: {\n\t\t\tsendVerificationEmail: !!options.emailVerification?.sendVerificationEmail,\n\t\t\tsendOnSignUp: !!options.emailVerification?.sendOnSignUp,\n\t\t\tsendOnSignIn: !!options.emailVerification?.sendOnSignIn,\n\t\t\tautoSignInAfterVerification: !!options.emailVerification?.autoSignInAfterVerification,\n\t\t\texpiresIn: options.emailVerification?.expiresIn,\n\t\t\tonEmailVerification: !!options.emailVerification?.onEmailVerification,\n\t\t\tafterEmailVerification: !!options.emailVerification?.afterEmailVerification\n\t\t},\n\t\temailAndPassword: {\n\t\t\tenabled: !!options.emailAndPassword?.enabled,\n\t\t\tdisableSignUp: !!options.emailAndPassword?.disableSignUp,\n\t\t\trequireEmailVerification: !!options.emailAndPassword?.requireEmailVerification,\n\t\t\tmaxPasswordLength: options.emailAndPassword?.maxPasswordLength,\n\t\t\tminPasswordLength: options.emailAndPassword?.minPasswordLength,\n\t\t\tsendResetPassword: !!options.emailAndPassword?.sendResetPassword,\n\t\t\tresetPasswordTokenExpiresIn: options.emailAndPassword?.resetPasswordTokenExpiresIn,\n\t\t\tonPasswordReset: !!options.emailAndPassword?.onPasswordReset,\n\t\t\tpassword: {\n\t\t\t\thash: !!options.emailAndPassword?.password?.hash,\n\t\t\t\tverify: !!options.emailAndPassword?.password?.verify\n\t\t\t},\n\t\t\tautoSignIn: !!options.emailAndPassword?.autoSignIn,\n\t\t\trevokeSessionsOnPasswordReset: !!options.emailAndPassword?.revokeSessionsOnPasswordReset\n\t\t},\n\t\tsocialProviders: Object.keys(options.socialProviders || {}).map((p) => {\n\t\t\tconst provider = options.socialProviders?.[p];\n\t\t\tif (!provider) return {};\n\t\t\treturn {\n\t\t\t\tid: p,\n\t\t\t\tmapProfileToUser: !!provider.mapProfileToUser,\n\t\t\t\tdisableDefaultScope: !!provider.disableDefaultScope,\n\t\t\t\tdisableIdTokenSignIn: !!provider.disableIdTokenSignIn,\n\t\t\t\tdisableImplicitSignUp: provider.disableImplicitSignUp,\n\t\t\t\tdisableSignUp: provider.disableSignUp,\n\t\t\t\tgetUserInfo: !!provider.getUserInfo,\n\t\t\t\toverrideUserInfoOnSignIn: !!provider.overrideUserInfoOnSignIn,\n\t\t\t\tprompt: provider.prompt,\n\t\t\t\tverifyIdToken: !!provider.verifyIdToken,\n\t\t\t\tscope: provider.scope,\n\t\t\t\trefreshAccessToken: !!provider.refreshAccessToken\n\t\t\t};\n\t\t}),\n\t\tplugins: options.plugins?.map((p) => p.id.toString()),\n\t\tuser: {\n\t\t\tmodelName: options.user?.modelName,\n\t\t\tfields: options.user?.fields,\n\t\t\tadditionalFields: options.user?.additionalFields,\n\t\t\tchangeEmail: {\n\t\t\t\tenabled: options.user?.changeEmail?.enabled,\n\t\t\t\tsendChangeEmailVerification: !!options.user?.changeEmail?.sendChangeEmailVerification\n\t\t\t}\n\t\t},\n\t\tverification: {\n\t\t\tmodelName: options.verification?.modelName,\n\t\t\tdisableCleanup: options.verification?.disableCleanup,\n\t\t\tfields: options.verification?.fields\n\t\t},\n\t\tsession: {\n\t\t\tmodelName: options.session?.modelName,\n\t\t\tadditionalFields: options.session?.additionalFields,\n\t\t\tcookieCache: {\n\t\t\t\tenabled: options.session?.cookieCache?.enabled,\n\t\t\t\tmaxAge: options.session?.cookieCache?.maxAge,\n\t\t\t\tstrategy: options.session?.cookieCache?.strategy\n\t\t\t},\n\t\t\tdisableSessionRefresh: options.session?.disableSessionRefresh,\n\t\t\texpiresIn: options.session?.expiresIn,\n\t\t\tfields: options.session?.fields,\n\t\t\tfreshAge: options.session?.freshAge,\n\t\t\tpreserveSessionInDatabase: options.session?.preserveSessionInDatabase,\n\t\t\tstoreSessionInDatabase: options.session?.storeSessionInDatabase,\n\t\t\tupdateAge: options.session?.updateAge\n\t\t},\n\t\taccount: {\n\t\t\tmodelName: options.account?.modelName,\n\t\t\tfields: options.account?.fields,\n\t\t\tencryptOAuthTokens: options.account?.encryptOAuthTokens,\n\t\t\tupdateAccountOnSignIn: options.account?.updateAccountOnSignIn,\n\t\t\taccountLinking: {\n\t\t\t\tenabled: options.account?.accountLinking?.enabled,\n\t\t\t\ttrustedProviders: options.account?.accountLinking?.trustedProviders,\n\t\t\t\tupdateUserInfoOnLink: options.account?.accountLinking?.updateUserInfoOnLink,\n\t\t\t\tallowUnlinkingAll: options.account?.accountLinking?.allowUnlinkingAll\n\t\t\t}\n\t\t},\n\t\thooks: {\n\t\t\tafter: !!options.hooks?.after,\n\t\t\tbefore: !!options.hooks?.before\n\t\t},\n\t\tsecondaryStorage: !!options.secondaryStorage,\n\t\tadvanced: {\n\t\t\tcookiePrefix: !!options.advanced?.cookiePrefix,\n\t\t\tcookies: !!options.advanced?.cookies,\n\t\t\tcrossSubDomainCookies: {\n\t\t\t\tdomain: !!options.advanced?.crossSubDomainCookies?.domain,\n\t\t\t\tenabled: options.advanced?.crossSubDomainCookies?.enabled,\n\t\t\t\tadditionalCookies: options.advanced?.crossSubDomainCookies?.additionalCookies\n\t\t\t},\n\t\t\tdatabase: {\n\t\t\t\tuseNumberId: !!options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === \"serial\",\n\t\t\t\tgenerateId: options.advanced?.database?.generateId,\n\t\t\t\tdefaultFindManyLimit: options.advanced?.database?.defaultFindManyLimit\n\t\t\t},\n\t\t\tuseSecureCookies: options.advanced?.useSecureCookies,\n\t\t\tipAddress: {\n\t\t\t\tdisableIpTracking: options.advanced?.ipAddress?.disableIpTracking,\n\t\t\t\tipAddressHeaders: options.advanced?.ipAddress?.ipAddressHeaders\n\t\t\t},\n\t\t\tdisableCSRFCheck: options.advanced?.disableCSRFCheck,\n\t\t\tcookieAttributes: {\n\t\t\t\texpires: options.advanced?.defaultCookieAttributes?.expires,\n\t\t\t\tsecure: options.advanced?.defaultCookieAttributes?.secure,\n\t\t\t\tsameSite: options.advanced?.defaultCookieAttributes?.sameSite,\n\t\t\t\tdomain: !!options.advanced?.defaultCookieAttributes?.domain,\n\t\t\t\tpath: options.advanced?.defaultCookieAttributes?.path,\n\t\t\t\thttpOnly: options.advanced?.defaultCookieAttributes?.httpOnly\n\t\t\t}\n\t\t},\n\t\ttrustedOrigins: options.trustedOrigins?.length,\n\t\trateLimit: {\n\t\t\tstorage: options.rateLimit?.storage,\n\t\t\tmodelName: options.rateLimit?.modelName,\n\t\t\twindow: options.rateLimit?.window,\n\t\t\tcustomStorage: !!options.rateLimit?.customStorage,\n\t\t\tenabled: options.rateLimit?.enabled,\n\t\t\tmax: options.rateLimit?.max\n\t\t},\n\t\tonAPIError: {\n\t\t\terrorURL: options.onAPIError?.errorURL,\n\t\t\tonError: !!options.onAPIError?.onError,\n\t\t\tthrow: options.onAPIError?.throw\n\t\t},\n\t\tlogger: {\n\t\t\tdisabled: options.logger?.disabled,\n\t\t\tlevel: options.logger?.level,\n\t\t\tlog: !!options.logger?.log\n\t\t},\n\t\tdatabaseHooks: {\n\t\t\tuser: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.user?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.user?.create?.before\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.user?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.user?.update?.before\n\t\t\t\t}\n\t\t\t},\n\t\t\tsession: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.session?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.session?.create?.before\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.session?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.session?.update?.before\n\t\t\t\t}\n\t\t\t},\n\t\t\taccount: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.account?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.account?.create?.before\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.account?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.account?.update?.before\n\t\t\t\t}\n\t\t\t},\n\t\t\tverification: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.verification?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.verification?.create?.before\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.verification?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.verification?.update?.before\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/package-json.ts\nlet packageJSONCache;\nasync function readRootPackageJson() {\n\tif (packageJSONCache) return packageJSONCache;\n\ttry {\n\t\tconst cwd = typeof process !== \"undefined\" && typeof process.cwd === \"function\" ? process.cwd() : \"\";\n\t\tif (!cwd) return void 0;\n\t\tconst importRuntime$1 = (m) => Function(\"mm\", \"return import(mm)\")(m);\n\t\tconst [{ default: fs }, { default: path }] = await Promise.all([importRuntime$1(\"fs/promises\"), importRuntime$1(\"path\")]);\n\t\tconst raw = await fs.readFile(path.join(cwd, \"package.json\"), \"utf-8\");\n\t\tpackageJSONCache = JSON.parse(raw);\n\t\treturn packageJSONCache;\n\t} catch {}\n}\nasync function getPackageVersion(pkg) {\n\tif (packageJSONCache) return packageJSONCache.dependencies?.[pkg] || packageJSONCache.devDependencies?.[pkg] || packageJSONCache.peerDependencies?.[pkg];\n\ttry {\n\t\tconst cwd = typeof process !== \"undefined\" && typeof process.cwd === \"function\" ? process.cwd() : \"\";\n\t\tif (!cwd) throw new Error(\"no-cwd\");\n\t\tconst importRuntime$1 = (m) => Function(\"mm\", \"return import(mm)\")(m);\n\t\tconst [{ default: fs }, { default: path }] = await Promise.all([importRuntime$1(\"fs/promises\"), importRuntime$1(\"path\")]);\n\t\tconst pkgJsonPath = path.join(cwd, \"node_modules\", pkg, \"package.json\");\n\t\tconst raw = await fs.readFile(pkgJsonPath, \"utf-8\");\n\t\treturn JSON.parse(raw).version || await getVersionFromLocalPackageJson(pkg) || void 0;\n\t} catch {}\n\treturn await getVersionFromLocalPackageJson(pkg);\n}\nasync function getVersionFromLocalPackageJson(pkg) {\n\tconst json = await readRootPackageJson();\n\tif (!json) return void 0;\n\treturn {\n\t\t...json.dependencies,\n\t\t...json.devDependencies,\n\t\t...json.peerDependencies\n\t}[pkg];\n}\nasync function getNameFromLocalPackageJson() {\n\treturn (await readRootPackageJson())?.name;\n}\n\n//#endregion\n//#region src/detectors/detect-database.ts\nconst DATABASES = {\n\tpg: \"postgresql\",\n\tmysql: \"mysql\",\n\tmariadb: \"mariadb\",\n\tsqlite3: \"sqlite\",\n\t\"better-sqlite3\": \"sqlite\",\n\t\"@prisma/client\": \"prisma\",\n\tmongoose: \"mongodb\",\n\tmongodb: \"mongodb\",\n\t\"drizzle-orm\": \"drizzle\"\n};\nasync function detectDatabase() {\n\tfor (const [pkg, name] of Object.entries(DATABASES)) {\n\t\tconst version = await getPackageVersion(pkg);\n\t\tif (version) return {\n\t\t\tname,\n\t\t\tversion\n\t\t};\n\t}\n}\n\n//#endregion\n//#region src/detectors/detect-framework.ts\nconst FRAMEWORKS = {\n\tnext: \"next\",\n\tnuxt: \"nuxt\",\n\t\"@remix-run/server-runtime\": \"remix\",\n\tastro: \"astro\",\n\t\"@sveltejs/kit\": \"sveltekit\",\n\t\"solid-start\": \"solid-start\",\n\t\"tanstack-start\": \"tanstack-start\",\n\thono: \"hono\",\n\texpress: \"express\",\n\telysia: \"elysia\",\n\texpo: \"expo\"\n};\nasync function detectFramework() {\n\tfor (const [pkg, name] of Object.entries(FRAMEWORKS)) {\n\t\tconst version = await getPackageVersion(pkg);\n\t\tif (version) return {\n\t\t\tname,\n\t\t\tversion\n\t\t};\n\t}\n}\n\n//#endregion\n//#region src/detectors/detect-project-info.ts\nfunction detectPackageManager() {\n\tconst userAgent = env.npm_config_user_agent;\n\tif (!userAgent) return;\n\tconst pmSpec = userAgent.split(\" \")[0];\n\tconst separatorPos = pmSpec.lastIndexOf(\"/\");\n\tconst name = pmSpec.substring(0, separatorPos);\n\treturn {\n\t\tname: name === \"npminstall\" ? \"cnpm\" : name,\n\t\tversion: pmSpec.substring(separatorPos + 1)\n\t};\n}\n\n//#endregion\n//#region src/utils/import-util.ts\nconst importRuntime = (m) => {\n\treturn Function(\"mm\", \"return import(mm)\")(m);\n};\n\n//#endregion\n//#region src/detectors/detect-system-info.ts\nfunction getVendor() {\n\tconst hasAny = (...keys) => keys.some((k) => Boolean(env[k]));\n\tif (hasAny(\"CF_PAGES\", \"CF_PAGES_URL\", \"CF_ACCOUNT_ID\") || typeof navigator !== \"undefined\" && navigator.userAgent === \"Cloudflare-Workers\") return \"cloudflare\";\n\tif (hasAny(\"VERCEL\", \"VERCEL_URL\", \"VERCEL_ENV\")) return \"vercel\";\n\tif (hasAny(\"NETLIFY\", \"NETLIFY_URL\")) return \"netlify\";\n\tif (hasAny(\"RENDER\", \"RENDER_URL\", \"RENDER_INTERNAL_HOSTNAME\", \"RENDER_SERVICE_ID\")) return \"render\";\n\tif (hasAny(\"AWS_LAMBDA_FUNCTION_NAME\", \"AWS_EXECUTION_ENV\", \"LAMBDA_TASK_ROOT\")) return \"aws\";\n\tif (hasAny(\"GOOGLE_CLOUD_FUNCTION_NAME\", \"GOOGLE_CLOUD_PROJECT\", \"GCP_PROJECT\", \"K_SERVICE\")) return \"gcp\";\n\tif (hasAny(\"AZURE_FUNCTION_NAME\", \"FUNCTIONS_WORKER_RUNTIME\", \"WEBSITE_INSTANCE_ID\", \"WEBSITE_SITE_NAME\")) return \"azure\";\n\tif (hasAny(\"DENO_DEPLOYMENT_ID\", \"DENO_REGION\")) return \"deno-deploy\";\n\tif (hasAny(\"FLY_APP_NAME\", \"FLY_REGION\", \"FLY_ALLOC_ID\")) return \"fly-io\";\n\tif (hasAny(\"RAILWAY_STATIC_URL\", \"RAILWAY_ENVIRONMENT_NAME\")) return \"railway\";\n\tif (hasAny(\"DYNO\", \"HEROKU_APP_NAME\")) return \"heroku\";\n\tif (hasAny(\"DO_DEPLOYMENT_ID\", \"DO_APP_NAME\", \"DIGITALOCEAN\")) return \"digitalocean\";\n\tif (hasAny(\"KOYEB\", \"KOYEB_DEPLOYMENT_ID\", \"KOYEB_APP_NAME\")) return \"koyeb\";\n\treturn null;\n}\nasync function detectSystemInfo() {\n\ttry {\n\t\tif (getVendor() === \"cloudflare\") return \"cloudflare\";\n\t\tconst os = await importRuntime(\"os\");\n\t\tconst cpus = os.cpus();\n\t\treturn {\n\t\t\tdeploymentVendor: getVendor(),\n\t\t\tsystemPlatform: os.platform(),\n\t\t\tsystemRelease: os.release(),\n\t\t\tsystemArchitecture: os.arch(),\n\t\t\tcpuCount: cpus.length,\n\t\t\tcpuModel: cpus.length ? cpus[0].model : null,\n\t\t\tcpuSpeed: cpus.length ? cpus[0].speed : null,\n\t\t\tmemory: os.totalmem(),\n\t\t\tisWSL: await isWsl(),\n\t\t\tisDocker: await isDocker(),\n\t\t\tisTTY: typeof process !== \"undefined\" && process.stdout ? process.stdout.isTTY : null\n\t\t};\n\t} catch (e) {\n\t\treturn {\n\t\t\tsystemPlatform: null,\n\t\t\tsystemRelease: null,\n\t\t\tsystemArchitecture: null,\n\t\t\tcpuCount: null,\n\t\t\tcpuModel: null,\n\t\t\tcpuSpeed: null,\n\t\t\tmemory: null,\n\t\t\tisWSL: null,\n\t\t\tisDocker: null,\n\t\t\tisTTY: null\n\t\t};\n\t}\n}\nlet isDockerCached;\nasync function hasDockerEnv() {\n\tif (getVendor() === \"cloudflare\") return false;\n\ttry {\n\t\t(await importRuntime(\"fs\")).statSync(\"/.dockerenv\");\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\nasync function hasDockerCGroup() {\n\tif (getVendor() === \"cloudflare\") return false;\n\ttry {\n\t\treturn (await importRuntime(\"fs\")).readFileSync(\"/proc/self/cgroup\", \"utf8\").includes(\"docker\");\n\t} catch {\n\t\treturn false;\n\t}\n}\nasync function isDocker() {\n\tif (getVendor() === \"cloudflare\") return false;\n\tif (isDockerCached === void 0) isDockerCached = await hasDockerEnv() || await hasDockerCGroup();\n\treturn isDockerCached;\n}\nasync function isWsl() {\n\ttry {\n\t\tif (getVendor() === \"cloudflare\") return false;\n\t\tif (typeof process === \"undefined\" || process?.platform !== \"linux\") return false;\n\t\tconst fs = await importRuntime(\"fs\");\n\t\tif ((await importRuntime(\"os\")).release().toLowerCase().includes(\"microsoft\")) {\n\t\t\tif (await isInsideContainer()) return false;\n\t\t\treturn true;\n\t\t}\n\t\treturn fs.readFileSync(\"/proc/version\", \"utf8\").toLowerCase().includes(\"microsoft\") ? !await isInsideContainer() : false;\n\t} catch {\n\t\treturn false;\n\t}\n}\nlet isInsideContainerCached;\nconst hasContainerEnv = async () => {\n\tif (getVendor() === \"cloudflare\") return false;\n\ttry {\n\t\t(await importRuntime(\"fs\")).statSync(\"/run/.containerenv\");\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\nasync function isInsideContainer() {\n\tif (isInsideContainerCached === void 0) isInsideContainerCached = await hasContainerEnv() || await isDocker();\n\treturn isInsideContainerCached;\n}\nfunction isCI() {\n\treturn env.CI !== \"false\" && (\"BUILD_ID\" in env || \"BUILD_NUMBER\" in env || \"CI\" in env || \"CI_APP_ID\" in env || \"CI_BUILD_ID\" in env || \"CI_BUILD_NUMBER\" in env || \"CI_NAME\" in env || \"CONTINUOUS_INTEGRATION\" in env || \"RUN_ID\" in env);\n}\n\n//#endregion\n//#region src/detectors/detect-runtime.ts\nfunction detectRuntime() {\n\tif (typeof Deno !== \"undefined\") return {\n\t\tname: \"deno\",\n\t\tversion: Deno?.version?.deno ?? null\n\t};\n\tif (typeof Bun !== \"undefined\") return {\n\t\tname: \"bun\",\n\t\tversion: Bun?.version ?? null\n\t};\n\tif (typeof process !== \"undefined\" && process?.versions?.node) return {\n\t\tname: \"node\",\n\t\tversion: process.versions.node ?? null\n\t};\n\treturn {\n\t\tname: \"edge\",\n\t\tversion: null\n\t};\n}\nfunction detectEnvironment() {\n\treturn getEnvVar(\"NODE_ENV\") === \"production\" ? \"production\" : isCI() ? \"ci\" : isTest() ? \"test\" : \"development\";\n}\n\n//#endregion\n//#region src/utils/hash.ts\nasync function hashToBase64(data) {\n\tconst buffer = await createHash(\"SHA-256\").digest(data);\n\treturn base64.encode(buffer);\n}\n\n//#endregion\n//#region src/utils/id.ts\nconst generateId = (size) => {\n\treturn createRandomStringGenerator(\"a-z\", \"A-Z\", \"0-9\")(size || 32);\n};\n\n//#endregion\n//#region src/project-id.ts\nlet projectIdCached = null;\nasync function getProjectId(baseUrl) {\n\tif (projectIdCached) return projectIdCached;\n\tconst projectName = await getNameFromLocalPackageJson();\n\tif (projectName) {\n\t\tprojectIdCached = await hashToBase64(baseUrl ? baseUrl + projectName : projectName);\n\t\treturn projectIdCached;\n\t}\n\tif (baseUrl) {\n\t\tprojectIdCached = await hashToBase64(baseUrl);\n\t\treturn projectIdCached;\n\t}\n\tprojectIdCached = generateId(32);\n\treturn projectIdCached;\n}\n\n//#endregion\n//#region src/index.ts\nasync function createTelemetry(options, context) {\n\tconst debugEnabled = options.telemetry?.debug || getBooleanEnvVar(\"BETTER_AUTH_TELEMETRY_DEBUG\", false);\n\tconst TELEMETRY_ENDPOINT = ENV.BETTER_AUTH_TELEMETRY_ENDPOINT;\n\tconst track = async (event) => {\n\t\tif (context?.customTrack) await context.customTrack(event).catch(logger.error);\n\t\telse if (debugEnabled) logger.info(\"telemetry event\", JSON.stringify(event, null, 2));\n\t\telse await betterFetch(TELEMETRY_ENDPOINT, {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: event\n\t\t}).catch(logger.error);\n\t};\n\tconst isEnabled = async () => {\n\t\tconst telemetryEnabled = options.telemetry?.enabled !== void 0 ? options.telemetry.enabled : false;\n\t\treturn (getBooleanEnvVar(\"BETTER_AUTH_TELEMETRY\", false) || telemetryEnabled) && (context?.skipTestCheck || !isTest());\n\t};\n\tconst enabled = await isEnabled();\n\tlet anonymousId;\n\tif (enabled) {\n\t\tanonymousId = await getProjectId(options.baseURL);\n\t\ttrack({\n\t\t\ttype: \"init\",\n\t\t\tpayload: {\n\t\t\t\tconfig: getTelemetryAuthConfig(options, context),\n\t\t\t\truntime: detectRuntime(),\n\t\t\t\tdatabase: await detectDatabase(),\n\t\t\t\tframework: await detectFramework(),\n\t\t\t\tenvironment: detectEnvironment(),\n\t\t\t\tsystemInfo: await detectSystemInfo(),\n\t\t\t\tpackageManager: detectPackageManager()\n\t\t\t},\n\t\t\tanonymousId\n\t\t});\n\t}\n\treturn { publish: async (event) => {\n\t\tif (!enabled) return;\n\t\tif (!anonymousId) anonymousId = await getProjectId(options.baseURL);\n\t\tawait track({\n\t\t\ttype: event.type,\n\t\t\tpayload: event.payload,\n\t\t\tanonymousId\n\t\t});\n\t} };\n}\n\n//#endregion\nexport { createTelemetry, getTelemetryAuthConfig };","import { env } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\n//#region src/utils/url.ts\nfunction checkHasPath(url) {\n\ttry {\n\t\treturn (new URL(url).pathname.replace(/\\/+$/, \"\") || \"/\") !== \"/\";\n\t} catch (error) {\n\t\tthrow new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`);\n\t}\n}\nfunction assertHasProtocol(url) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tif (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") throw new BetterAuthError(`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`);\n\t} catch (error) {\n\t\tif (error instanceof BetterAuthError) throw error;\n\t\tthrow new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`, String(error));\n\t}\n}\nfunction withPath(url, path = \"/api/auth\") {\n\tassertHasProtocol(url);\n\tif (checkHasPath(url)) return url;\n\tconst trimmedUrl = url.replace(/\\/+$/, \"\");\n\tif (!path || path === \"/\") return trimmedUrl;\n\tpath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${trimmedUrl}${path}`;\n}\nfunction getBaseURL(url, path, request, loadEnv, trustedProxyHeaders) {\n\tif (url) return withPath(url, path);\n\tif (loadEnv !== false) {\n\t\tconst fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== \"/\" ? env.BASE_URL : void 0);\n\t\tif (fromEnv) return withPath(fromEnv, path);\n\t}\n\tconst fromRequest = request?.headers.get(\"x-forwarded-host\");\n\tconst fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n\tif (fromRequest && fromRequestProto && trustedProxyHeaders) return withPath(`${fromRequestProto}://${fromRequest}`, path);\n\tif (request) {\n\t\tconst url$1 = getOrigin(request.url);\n\t\tif (!url$1) throw new BetterAuthError(\"Could not get origin from request. Please provide a valid base URL.\");\n\t\treturn withPath(url$1, path);\n\t}\n\tif (typeof window !== \"undefined\" && window.location) return withPath(window.location.origin, path);\n}\nfunction getOrigin(url) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.origin === \"null\" ? null : parsedUrl.origin;\n\t} catch (error) {\n\t\treturn null;\n\t}\n}\nfunction getProtocol(url) {\n\ttry {\n\t\treturn new URL(url).protocol;\n\t} catch (error) {\n\t\treturn null;\n\t}\n}\nfunction getHost(url) {\n\ttry {\n\t\treturn new URL(url).host;\n\t} catch (error) {\n\t\treturn null;\n\t}\n}\n\n//#endregion\nexport { getProtocol as i, getHost as n, getOrigin as r, getBaseURL as t };","import { decode as b64u } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { isObject } from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(b64u(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n","import { auth } from '@/lib/auth';\nimport { toNextJsHandler } from 'better-auth/next-js';\n\nexport const { GET, POST } = toNextJsHandler(auth);\n","import { base64, base64Url } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { jwtVerify } from \"jose\";\n\n//#region src/oauth2/client-credentials-token.ts\nfunction createClientCredentialsTokenRequest({ options, scope, authentication, resource }) {\n\tconst body = new URLSearchParams();\n\tconst headers = {\n\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\taccept: \"application/json\"\n\t};\n\tbody.set(\"grant_type\", \"client_credentials\");\n\tscope && body.set(\"scope\", scope);\n\tif (resource) if (typeof resource === \"string\") body.append(\"resource\", resource);\n\telse for (const _resource of resource) body.append(\"resource\", _resource);\n\tif (authentication === \"basic\") {\n\t\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\t\theaders[\"authorization\"] = `Basic ${base64Url.encode(`${primaryClientId}:${options.clientSecret}`)}`;\n\t} else {\n\t\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\t\tbody.set(\"client_id\", primaryClientId);\n\t\tbody.set(\"client_secret\", options.clientSecret);\n\t}\n\treturn {\n\t\tbody,\n\t\theaders\n\t};\n}\nasync function clientCredentialsToken({ options, tokenEndpoint, scope, authentication, resource }) {\n\tconst { body, headers } = createClientCredentialsTokenRequest({\n\t\toptions,\n\t\tscope,\n\t\tauthentication,\n\t\tresource\n\t});\n\tconst { data, error } = await betterFetch(tokenEndpoint, {\n\t\tmethod: \"POST\",\n\t\tbody,\n\t\theaders\n\t});\n\tif (error) throw error;\n\tconst tokens = {\n\t\taccessToken: data.access_token,\n\t\ttokenType: data.token_type,\n\t\tscopes: data.scope?.split(\" \")\n\t};\n\tif (data.expires_in) {\n\t\tconst now = /* @__PURE__ */ new Date();\n\t\ttokens.accessTokenExpiresAt = new Date(now.getTime() + data.expires_in * 1e3);\n\t}\n\treturn tokens;\n}\n\n//#endregion\n//#region src/oauth2/utils.ts\nfunction getOAuth2Tokens(data) {\n\tconst getDate = (seconds) => {\n\t\tconst now = /* @__PURE__ */ new Date();\n\t\treturn new Date(now.getTime() + seconds * 1e3);\n\t};\n\treturn {\n\t\ttokenType: data.token_type,\n\t\taccessToken: data.access_token,\n\t\trefreshToken: data.refresh_token,\n\t\taccessTokenExpiresAt: data.expires_in ? getDate(data.expires_in) : void 0,\n\t\trefreshTokenExpiresAt: data.refresh_token_expires_in ? getDate(data.refresh_token_expires_in) : void 0,\n\t\tscopes: data?.scope ? typeof data.scope === \"string\" ? data.scope.split(\" \") : data.scope : [],\n\t\tidToken: data.id_token,\n\t\traw: data\n\t};\n}\nasync function generateCodeChallenge(codeVerifier) {\n\tconst data = new TextEncoder().encode(codeVerifier);\n\tconst hash = await crypto.subtle.digest(\"SHA-256\", data);\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n}\n\n//#endregion\n//#region src/oauth2/create-authorization-url.ts\nasync function createAuthorizationURL({ id, options, authorizationEndpoint, state, codeVerifier, scopes, claims, redirectURI, duration, prompt, accessType, responseType, display, loginHint, hd, responseMode, additionalParams, scopeJoiner }) {\n\tconst url = new URL(authorizationEndpoint);\n\turl.searchParams.set(\"response_type\", responseType || \"code\");\n\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\turl.searchParams.set(\"client_id\", primaryClientId);\n\turl.searchParams.set(\"state\", state);\n\tif (scopes) url.searchParams.set(\"scope\", scopes.join(scopeJoiner || \" \"));\n\turl.searchParams.set(\"redirect_uri\", options.redirectURI || redirectURI);\n\tduration && url.searchParams.set(\"duration\", duration);\n\tdisplay && url.searchParams.set(\"display\", display);\n\tloginHint && url.searchParams.set(\"login_hint\", loginHint);\n\tprompt && url.searchParams.set(\"prompt\", prompt);\n\thd && url.searchParams.set(\"hd\", hd);\n\taccessType && url.searchParams.set(\"access_type\", accessType);\n\tresponseMode && url.searchParams.set(\"response_mode\", responseMode);\n\tif (codeVerifier) {\n\t\tconst codeChallenge = await generateCodeChallenge(codeVerifier);\n\t\turl.searchParams.set(\"code_challenge_method\", \"S256\");\n\t\turl.searchParams.set(\"code_challenge\", codeChallenge);\n\t}\n\tif (claims) {\n\t\tconst claimsObj = claims.reduce((acc, claim) => {\n\t\t\tacc[claim] = null;\n\t\t\treturn acc;\n\t\t}, {});\n\t\turl.searchParams.set(\"claims\", JSON.stringify({ id_token: {\n\t\t\temail: null,\n\t\t\temail_verified: null,\n\t\t\t...claimsObj\n\t\t} }));\n\t}\n\tif (additionalParams) Object.entries(additionalParams).forEach(([key, value]) => {\n\t\turl.searchParams.set(key, value);\n\t});\n\treturn url;\n}\n\n//#endregion\n//#region src/oauth2/refresh-access-token.ts\nfunction createRefreshAccessTokenRequest({ refreshToken, options, authentication, extraParams, resource }) {\n\tconst body = new URLSearchParams();\n\tconst headers = {\n\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\taccept: \"application/json\"\n\t};\n\tbody.set(\"grant_type\", \"refresh_token\");\n\tbody.set(\"refresh_token\", refreshToken);\n\tif (authentication === \"basic\") {\n\t\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\t\tif (primaryClientId) headers[\"authorization\"] = \"Basic \" + base64.encode(`${primaryClientId}:${options.clientSecret ?? \"\"}`);\n\t\telse headers[\"authorization\"] = \"Basic \" + base64.encode(`:${options.clientSecret ?? \"\"}`);\n\t} else {\n\t\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\t\tbody.set(\"client_id\", primaryClientId);\n\t\tif (options.clientSecret) body.set(\"client_secret\", options.clientSecret);\n\t}\n\tif (resource) if (typeof resource === \"string\") body.append(\"resource\", resource);\n\telse for (const _resource of resource) body.append(\"resource\", _resource);\n\tif (extraParams) for (const [key, value] of Object.entries(extraParams)) body.set(key, value);\n\treturn {\n\t\tbody,\n\t\theaders\n\t};\n}\nasync function refreshAccessToken({ refreshToken, options, tokenEndpoint, authentication, extraParams }) {\n\tconst { body, headers } = createRefreshAccessTokenRequest({\n\t\trefreshToken,\n\t\toptions,\n\t\tauthentication,\n\t\textraParams\n\t});\n\tconst { data, error } = await betterFetch(tokenEndpoint, {\n\t\tmethod: \"POST\",\n\t\tbody,\n\t\theaders\n\t});\n\tif (error) throw error;\n\tconst tokens = {\n\t\taccessToken: data.access_token,\n\t\trefreshToken: data.refresh_token,\n\t\ttokenType: data.token_type,\n\t\tscopes: data.scope?.split(\" \"),\n\t\tidToken: data.id_token\n\t};\n\tif (data.expires_in) {\n\t\tconst now = /* @__PURE__ */ new Date();\n\t\ttokens.accessTokenExpiresAt = new Date(now.getTime() + data.expires_in * 1e3);\n\t}\n\treturn tokens;\n}\n\n//#endregion\n//#region src/oauth2/validate-authorization-code.ts\nfunction createAuthorizationCodeRequest({ code, codeVerifier, redirectURI, options, authentication, deviceId, headers, additionalParams = {}, resource }) {\n\tconst body = new URLSearchParams();\n\tconst requestHeaders = {\n\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\taccept: \"application/json\",\n\t\t...headers\n\t};\n\tbody.set(\"grant_type\", \"authorization_code\");\n\tbody.set(\"code\", code);\n\tcodeVerifier && body.set(\"code_verifier\", codeVerifier);\n\toptions.clientKey && body.set(\"client_key\", options.clientKey);\n\tdeviceId && body.set(\"device_id\", deviceId);\n\tbody.set(\"redirect_uri\", options.redirectURI || redirectURI);\n\tif (resource) if (typeof resource === \"string\") body.append(\"resource\", resource);\n\telse for (const _resource of resource) body.append(\"resource\", _resource);\n\tif (authentication === \"basic\") {\n\t\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\t\trequestHeaders[\"authorization\"] = `Basic ${base64.encode(`${primaryClientId}:${options.clientSecret ?? \"\"}`)}`;\n\t} else {\n\t\tconst primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;\n\t\tbody.set(\"client_id\", primaryClientId);\n\t\tif (options.clientSecret) body.set(\"client_secret\", options.clientSecret);\n\t}\n\tfor (const [key, value] of Object.entries(additionalParams)) if (!body.has(key)) body.append(key, value);\n\treturn {\n\t\tbody,\n\t\theaders: requestHeaders\n\t};\n}\nasync function validateAuthorizationCode({ code, codeVerifier, redirectURI, options, tokenEndpoint, authentication, deviceId, headers, additionalParams = {}, resource }) {\n\tconst { body, headers: requestHeaders } = createAuthorizationCodeRequest({\n\t\tcode,\n\t\tcodeVerifier,\n\t\tredirectURI,\n\t\toptions,\n\t\tauthentication,\n\t\tdeviceId,\n\t\theaders,\n\t\tadditionalParams,\n\t\tresource\n\t});\n\tconst { data, error } = await betterFetch(tokenEndpoint, {\n\t\tmethod: \"POST\",\n\t\tbody,\n\t\theaders: requestHeaders\n\t});\n\tif (error) throw error;\n\treturn getOAuth2Tokens(data);\n}\nasync function validateToken(token, jwksEndpoint) {\n\tconst { data, error } = await betterFetch(jwksEndpoint, {\n\t\tmethod: \"GET\",\n\t\theaders: { accept: \"application/json\" }\n\t});\n\tif (error) throw error;\n\tconst keys = data[\"keys\"];\n\tconst header = JSON.parse(atob(token.split(\".\")[0]));\n\tconst key = keys.find((key$1) => key$1.kid === header.kid);\n\tif (!key) throw new Error(\"Key not found\");\n\treturn await jwtVerify(token, key);\n}\n\n//#endregion\nexport { refreshAccessToken as a, getOAuth2Tokens as c, createRefreshAccessTokenRequest as i, clientCredentialsToken as l, validateAuthorizationCode as n, createAuthorizationURL as o, validateToken as r, generateCodeChallenge as s, createAuthorizationCodeRequest as t, createClientCredentialsTokenRequest as u };","import { t as getIp } from \"./get-request-ip-D6st-mto.mjs\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { betterFetch } from \"@better-fetch/fetch\";\n\n//#region src/utils/middleware-response.ts\nconst middlewareResponse = ({ message, status }) => ({ response: new Response(JSON.stringify({ message }), { status }) });\n\n//#endregion\n//#region src/plugins/captcha/constants.ts\nconst defaultEndpoints = [\n\t\"/sign-up/email\",\n\t\"/sign-in/email\",\n\t\"/request-password-reset\"\n];\nconst Providers = {\n\tCLOUDFLARE_TURNSTILE: \"cloudflare-turnstile\",\n\tGOOGLE_RECAPTCHA: \"google-recaptcha\",\n\tHCAPTCHA: \"hcaptcha\",\n\tCAPTCHAFOX: \"captchafox\"\n};\nconst siteVerifyMap = {\n\t[Providers.CLOUDFLARE_TURNSTILE]: \"https://challenges.cloudflare.com/turnstile/v0/siteverify\",\n\t[Providers.GOOGLE_RECAPTCHA]: \"https://www.google.com/recaptcha/api/siteverify\",\n\t[Providers.HCAPTCHA]: \"https://api.hcaptcha.com/siteverify\",\n\t[Providers.CAPTCHAFOX]: \"https://api.captchafox.com/siteverify\"\n};\n\n//#endregion\n//#region src/plugins/captcha/error-codes.ts\nconst EXTERNAL_ERROR_CODES = defineErrorCodes({\n\tVERIFICATION_FAILED: \"Captcha verification failed\",\n\tMISSING_RESPONSE: \"Missing CAPTCHA response\",\n\tUNKNOWN_ERROR: \"Something went wrong\"\n});\nconst INTERNAL_ERROR_CODES = defineErrorCodes({\n\tMISSING_SECRET_KEY: \"Missing secret key\",\n\tSERVICE_UNAVAILABLE: \"CAPTCHA service unavailable\"\n});\n\n//#endregion\n//#region src/plugins/captcha/utils.ts\nconst encodeToURLParams = (obj) => {\n\tif (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) throw new Error(\"Input must be a non-null object.\");\n\tconst params = new URLSearchParams();\n\tfor (const [key, value] of Object.entries(obj)) if (value !== void 0 && value !== null) params.append(key, String(value));\n\treturn params.toString();\n};\n\n//#endregion\n//#region src/plugins/captcha/verify-handlers/captchafox.ts\nconst captchaFox = async ({ siteVerifyURL, captchaResponse, secretKey, siteKey, remoteIP }) => {\n\tconst response = await betterFetch(siteVerifyURL, {\n\t\tmethod: \"POST\",\n\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\tbody: encodeToURLParams({\n\t\t\tsecret: secretKey,\n\t\t\tresponse: captchaResponse,\n\t\t\t...siteKey && { sitekey: siteKey },\n\t\t\t...remoteIP && { remoteIp: remoteIP }\n\t\t})\n\t});\n\tif (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);\n\tif (!response.data.success) return middlewareResponse({\n\t\tmessage: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,\n\t\tstatus: 403\n\t});\n};\n\n//#endregion\n//#region src/plugins/captcha/verify-handlers/cloudflare-turnstile.ts\nconst cloudflareTurnstile = async ({ siteVerifyURL, captchaResponse, secretKey, remoteIP }) => {\n\tconst response = await betterFetch(siteVerifyURL, {\n\t\tmethod: \"POST\",\n\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\tbody: JSON.stringify({\n\t\t\tsecret: secretKey,\n\t\t\tresponse: captchaResponse,\n\t\t\t...remoteIP && { remoteip: remoteIP }\n\t\t})\n\t});\n\tif (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);\n\tif (!response.data.success) return middlewareResponse({\n\t\tmessage: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,\n\t\tstatus: 403\n\t});\n};\n\n//#endregion\n//#region src/plugins/captcha/verify-handlers/google-recaptcha.ts\nconst isV3 = (response) => {\n\treturn \"score\" in response && typeof response.score === \"number\";\n};\nconst googleRecaptcha = async ({ siteVerifyURL, captchaResponse, secretKey, minScore = .5, remoteIP }) => {\n\tconst response = await betterFetch(siteVerifyURL, {\n\t\tmethod: \"POST\",\n\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\tbody: encodeToURLParams({\n\t\t\tsecret: secretKey,\n\t\t\tresponse: captchaResponse,\n\t\t\t...remoteIP && { remoteip: remoteIP }\n\t\t})\n\t});\n\tif (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);\n\tif (!response.data.success || isV3(response.data) && response.data.score < minScore) return middlewareResponse({\n\t\tmessage: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,\n\t\tstatus: 403\n\t});\n};\n\n//#endregion\n//#region src/plugins/captcha/verify-handlers/h-captcha.ts\nconst hCaptcha = async ({ siteVerifyURL, captchaResponse, secretKey, siteKey, remoteIP }) => {\n\tconst response = await betterFetch(siteVerifyURL, {\n\t\tmethod: \"POST\",\n\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\tbody: encodeToURLParams({\n\t\t\tsecret: secretKey,\n\t\t\tresponse: captchaResponse,\n\t\t\t...siteKey && { sitekey: siteKey },\n\t\t\t...remoteIP && { remoteip: remoteIP }\n\t\t})\n\t});\n\tif (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);\n\tif (!response.data.success) return middlewareResponse({\n\t\tmessage: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,\n\t\tstatus: 403\n\t});\n};\n\n//#endregion\n//#region src/plugins/captcha/index.ts\nconst captcha = (options) => ({\n\tid: \"captcha\",\n\tonRequest: async (request, ctx) => {\n\t\ttry {\n\t\t\tif (!(options.endpoints?.length ? options.endpoints : defaultEndpoints).some((endpoint) => request.url.includes(endpoint))) return void 0;\n\t\t\tif (!options.secretKey) throw new Error(INTERNAL_ERROR_CODES.MISSING_SECRET_KEY);\n\t\t\tconst captchaResponse = request.headers.get(\"x-captcha-response\");\n\t\t\tconst remoteUserIP = getIp(request, ctx.options) ?? void 0;\n\t\t\tif (!captchaResponse) return middlewareResponse({\n\t\t\t\tmessage: EXTERNAL_ERROR_CODES.MISSING_RESPONSE,\n\t\t\t\tstatus: 400\n\t\t\t});\n\t\t\tconst handlerParams = {\n\t\t\t\tsiteVerifyURL: options.siteVerifyURLOverride || siteVerifyMap[options.provider],\n\t\t\t\tcaptchaResponse,\n\t\t\t\tsecretKey: options.secretKey,\n\t\t\t\tremoteIP: remoteUserIP\n\t\t\t};\n\t\t\tif (options.provider === Providers.CLOUDFLARE_TURNSTILE) return await cloudflareTurnstile(handlerParams);\n\t\t\tif (options.provider === Providers.GOOGLE_RECAPTCHA) return await googleRecaptcha({\n\t\t\t\t...handlerParams,\n\t\t\t\tminScore: options.minScore\n\t\t\t});\n\t\t\tif (options.provider === Providers.HCAPTCHA) return await hCaptcha({\n\t\t\t\t...handlerParams,\n\t\t\t\tsiteKey: options.siteKey\n\t\t\t});\n\t\t\tif (options.provider === Providers.CAPTCHAFOX) return await captchaFox({\n\t\t\t\t...handlerParams,\n\t\t\t\tsiteKey: options.siteKey\n\t\t\t});\n\t\t} catch (_error) {\n\t\t\tconst errorMessage = _error instanceof Error ? _error.message : void 0;\n\t\t\tctx.logger.error(errorMessage ?? \"Unknown error\", {\n\t\t\t\tendpoint: request.url,\n\t\t\t\tmessage: _error\n\t\t\t});\n\t\t\treturn middlewareResponse({\n\t\t\t\tmessage: EXTERNAL_ERROR_CODES.UNKNOWN_ERROR,\n\t\t\t\tstatus: 500\n\t\t\t});\n\t\t}\n\t}\n});\n\n//#endregion\nexport { captcha as t };","import { l as parseSetCookieHeader } from \"./cookies-D72PbWdz.mjs\";\nimport { serializeSignedCookie } from \"better-call\";\nimport { createAuthMiddleware } from \"@better-auth/core/api\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\n\n//#region src/plugins/bearer/index.ts\n/**\n* Converts bearer token to session cookie\n*/\nconst bearer = (options) => {\n\treturn {\n\t\tid: \"bearer\",\n\t\thooks: {\n\t\t\tbefore: [{\n\t\t\t\tmatcher(context) {\n\t\t\t\t\treturn Boolean(context.request?.headers.get(\"authorization\") || context.headers?.get(\"authorization\"));\n\t\t\t\t},\n\t\t\t\thandler: createAuthMiddleware(async (c) => {\n\t\t\t\t\tconst token = c.request?.headers.get(\"authorization\")?.replace(\"Bearer \", \"\") || c.headers?.get(\"Authorization\")?.replace(\"Bearer \", \"\");\n\t\t\t\t\tif (!token) return;\n\t\t\t\t\tlet signedToken = \"\";\n\t\t\t\t\tif (token.includes(\".\")) signedToken = token.replace(\"=\", \"\");\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (options?.requireSignature) return;\n\t\t\t\t\t\tsignedToken = (await serializeSignedCookie(\"\", token, c.context.secret)).replace(\"=\", \"\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst decodedToken = decodeURIComponent(signedToken);\n\t\t\t\t\t\tif (!await createHMAC(\"SHA-256\", \"base64urlnopad\").verify(c.context.secret, decodedToken.split(\".\")[0], decodedToken.split(\".\")[1])) return;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst existingHeaders = c.request?.headers || c.headers;\n\t\t\t\t\tconst headers = new Headers({ ...Object.fromEntries(existingHeaders?.entries()) });\n\t\t\t\t\theaders.append(\"cookie\", `${c.context.authCookies.sessionToken.name}=${signedToken}`);\n\t\t\t\t\treturn { context: { headers } };\n\t\t\t\t})\n\t\t\t}],\n\t\t\tafter: [{\n\t\t\t\tmatcher(context) {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\tconst setCookie = ctx.context.responseHeaders?.get(\"set-cookie\");\n\t\t\t\t\tif (!setCookie) return;\n\t\t\t\t\tconst parsedCookies = parseSetCookieHeader(setCookie);\n\t\t\t\t\tconst cookieName = ctx.context.authCookies.sessionToken.name;\n\t\t\t\t\tconst sessionCookie = parsedCookies.get(cookieName);\n\t\t\t\t\tif (!sessionCookie || !sessionCookie.value || sessionCookie[\"max-age\"] === 0) return;\n\t\t\t\t\tconst token = sessionCookie.value;\n\t\t\t\t\tconst exposedHeaders = ctx.context.responseHeaders?.get(\"access-control-expose-headers\") || \"\";\n\t\t\t\t\tconst headersSet = new Set(exposedHeaders.split(\",\").map((header) => header.trim()).filter(Boolean));\n\t\t\t\t\theadersSet.add(\"set-auth-token\");\n\t\t\t\t\tctx.setHeader(\"set-auth-token\", token);\n\t\t\t\t\tctx.setHeader(\"Access-Control-Expose-Headers\", Array.from(headersSet).join(\", \"));\n\t\t\t\t})\n\t\t\t}]\n\t\t}\n\t};\n};\n\n//#endregion\nexport { bearer as t };","import { n as getSession } from \"./session-AaRl3_x-.mjs\";\nimport { t as getEndpointResponse } from \"./plugin-helper-zFdFWLgL.mjs\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/custom-session/index.ts\nconst getSessionQuerySchema = z.optional(z.object({\n\tdisableCookieCache: z.boolean().meta({ description: \"Disable cookie cache and fetch session from database\" }).or(z.string().transform((v) => v === \"true\")).optional(),\n\tdisableRefresh: z.boolean().meta({ description: \"Disable session refresh. Useful for checking session status, without updating the session\" }).optional()\n}));\nconst customSession = (fn, options, pluginOptions) => {\n\treturn {\n\t\tid: \"custom-session\",\n\t\thooks: { after: [{\n\t\t\tmatcher: (ctx) => ctx.path === \"/multi-session/list-device-sessions\" && (pluginOptions?.shouldMutateListDeviceSessionsEndpoint ?? false),\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst response = await getEndpointResponse(ctx);\n\t\t\t\tif (!response) return;\n\t\t\t\tconst newResponse = await Promise.all(response.map(async (v) => await fn(v, ctx)));\n\t\t\t\treturn ctx.json(newResponse);\n\t\t\t})\n\t\t}] },\n\t\tendpoints: { getSession: createAuthEndpoint(\"/get-session\", {\n\t\t\tmethod: \"GET\",\n\t\t\tquery: getSessionQuerySchema,\n\t\t\tmetadata: {\n\t\t\t\tCUSTOM_SESSION: true,\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Get custom session data\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\titems: { $ref: \"#/components/schemas/Session\" }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t}\n\t\t\t},\n\t\t\trequireHeaders: true\n\t\t}, async (ctx) => {\n\t\t\tconst session = await getSession()({\n\t\t\t\t...ctx,\n\t\t\t\tasResponse: false,\n\t\t\t\theaders: ctx.headers,\n\t\t\t\treturnHeaders: true\n\t\t\t}).catch((e) => {\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tif (!session?.response) return ctx.json(null);\n\t\t\tconst fnResult = await fn(session.response, ctx);\n\t\t\tconst setCookie = session.headers.get(\"set-cookie\");\n\t\t\tif (setCookie) {\n\t\t\t\tctx.setHeader(\"set-cookie\", setCookie);\n\t\t\t\tsession.headers.delete(\"set-cookie\");\n\t\t\t}\n\t\t\tsession.headers.forEach((value, key) => {\n\t\t\t\tctx.setHeader(key, value);\n\t\t\t});\n\t\t\treturn ctx.json(fnResult);\n\t\t}) },\n\t\t$Infer: { Session: {} }\n\t};\n};\n\n//#endregion\nexport { customSession as t };","import { a as getAuthTables } from \"./get-model-name-D4DUV7S2.mjs\";\nimport { a as getEndpoints, t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\n\n//#region src/plugins/open-api/generator.ts\nconst allowedType = new Set([\n\t\"string\",\n\t\"number\",\n\t\"boolean\",\n\t\"array\",\n\t\"object\"\n]);\nfunction getTypeFromZodType(zodType) {\n\tconst type = zodType.type;\n\treturn allowedType.has(type) ? type : \"string\";\n}\nfunction getFieldSchema(field) {\n\tconst schema = {\n\t\ttype: field.type === \"date\" ? \"string\" : field.type,\n\t\t...field.type === \"date\" && { format: \"date-time\" }\n\t};\n\tif (field.defaultValue !== void 0) schema.default = typeof field.defaultValue === \"function\" ? \"Generated at runtime\" : field.defaultValue;\n\tif (field.input === false) schema.readOnly = true;\n\treturn schema;\n}\nfunction getParameters(options) {\n\tconst parameters = [];\n\tif (options.metadata?.openapi?.parameters) {\n\t\tparameters.push(...options.metadata.openapi.parameters);\n\t\treturn parameters;\n\t}\n\tif (options.query instanceof z.ZodObject) Object.entries(options.query.shape).forEach(([key, value]) => {\n\t\tif (value instanceof z.ZodType) parameters.push({\n\t\t\tname: key,\n\t\t\tin: \"query\",\n\t\t\tschema: {\n\t\t\t\t...processZodType(value),\n\t\t\t\t...\"minLength\" in value && value.minLength ? { minLength: value.minLength } : {}\n\t\t\t}\n\t\t});\n\t});\n\treturn parameters;\n}\nfunction getRequestBody(options) {\n\tif (options.metadata?.openapi?.requestBody) return options.metadata.openapi.requestBody;\n\tif (!options.body) return void 0;\n\tif (options.body instanceof z.ZodObject || options.body instanceof z.ZodOptional) {\n\t\tconst shape = options.body.shape;\n\t\tif (!shape) return void 0;\n\t\tconst properties = {};\n\t\tconst required = [];\n\t\tObject.entries(shape).forEach(([key, value]) => {\n\t\t\tif (value instanceof z.ZodType) {\n\t\t\t\tproperties[key] = processZodType(value);\n\t\t\t\tif (!(value instanceof z.ZodOptional)) required.push(key);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\trequired: options.body instanceof z.ZodOptional ? false : options.body ? true : false,\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties,\n\t\t\t\trequired\n\t\t\t} } }\n\t\t};\n\t}\n}\nfunction processZodType(zodType) {\n\tif (zodType instanceof z.ZodOptional) {\n\t\tconst innerType = zodType._def.innerType;\n\t\treturn {\n\t\t\t...processZodType(innerType),\n\t\t\tnullable: true\n\t\t};\n\t}\n\tif (zodType instanceof z.ZodObject) {\n\t\tconst shape = zodType.shape;\n\t\tif (shape) {\n\t\t\tconst properties = {};\n\t\t\tconst required = [];\n\t\t\tObject.entries(shape).forEach(([key, value]) => {\n\t\t\t\tif (value instanceof z.ZodType) {\n\t\t\t\t\tproperties[key] = processZodType(value);\n\t\t\t\t\tif (!(value instanceof z.ZodOptional)) required.push(key);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties,\n\t\t\t\t...required.length > 0 ? { required } : {},\n\t\t\t\tdescription: zodType.description\n\t\t\t};\n\t\t}\n\t}\n\treturn {\n\t\ttype: getTypeFromZodType(zodType),\n\t\tdescription: zodType.description\n\t};\n}\nfunction getResponse(responses) {\n\treturn {\n\t\t\"400\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } },\n\t\t\t\trequired: [\"message\"]\n\t\t\t} } },\n\t\t\tdescription: \"Bad Request. Usually due to missing parameters, or invalid parameters.\"\n\t\t},\n\t\t\"401\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } },\n\t\t\t\trequired: [\"message\"]\n\t\t\t} } },\n\t\t\tdescription: \"Unauthorized. Due to missing or invalid authentication.\"\n\t\t},\n\t\t\"403\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Forbidden. You do not have permission to access this resource or to perform this action.\"\n\t\t},\n\t\t\"404\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Not Found. The requested resource was not found.\"\n\t\t},\n\t\t\"429\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Too Many Requests. You have exceeded the rate limit. Try again later.\"\n\t\t},\n\t\t\"500\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Internal Server Error. This is a problem with the server that you cannot fix.\"\n\t\t},\n\t\t...responses\n\t};\n}\nfunction toOpenApiPath(path) {\n\treturn path.split(\"/\").map((part) => part.startsWith(\":\") ? `{${part.slice(1)}}` : part).join(\"/\");\n}\nasync function generator(ctx, options) {\n\tconst baseEndpoints = getEndpoints(ctx, {\n\t\t...options,\n\t\tplugins: []\n\t});\n\tconst tables = getAuthTables({\n\t\t...options,\n\t\tsession: {\n\t\t\t...options.session,\n\t\t\tstoreSessionInDatabase: true\n\t\t}\n\t});\n\tconst components = { schemas: { ...Object.entries(tables).reduce((acc, [key, value]) => {\n\t\tconst modelName = key.charAt(0).toUpperCase() + key.slice(1);\n\t\tconst fields = value.fields;\n\t\tconst required = [];\n\t\tconst properties = { id: { type: \"string\" } };\n\t\tObject.entries(fields).forEach(([fieldKey, fieldValue]) => {\n\t\t\tif (!fieldValue) return;\n\t\t\tproperties[fieldKey] = getFieldSchema(fieldValue);\n\t\t\tif (fieldValue.required && fieldValue.input !== false) required.push(fieldKey);\n\t\t});\n\t\tObject.entries(properties).forEach(([key$1, prop]) => {\n\t\t\tconst field = value.fields[key$1];\n\t\t\tif (field && field.type === \"date\" && prop.type === \"string\") prop.format = \"date-time\";\n\t\t});\n\t\tacc[modelName] = {\n\t\t\ttype: \"object\",\n\t\t\tproperties,\n\t\t\trequired\n\t\t};\n\t\treturn acc;\n\t}, {}) } };\n\tconst paths = {};\n\tObject.entries(baseEndpoints.api).forEach(([_, value]) => {\n\t\tif (ctx.options.disabledPaths?.includes(value.path)) return;\n\t\tconst options$1 = value.options;\n\t\tif (options$1.metadata?.SERVER_ONLY) return;\n\t\tconst path = toOpenApiPath(value.path);\n\t\tif (options$1.method === \"GET\" || options$1.method === \"DELETE\") paths[path] = {\n\t\t\t...paths[path],\n\t\t\t[options$1.method.toLowerCase()]: {\n\t\t\t\ttags: [\"Default\", ...options$1.metadata?.openapi?.tags || []],\n\t\t\t\tdescription: options$1.metadata?.openapi?.description,\n\t\t\t\toperationId: options$1.metadata?.openapi?.operationId,\n\t\t\t\tsecurity: [{ bearerAuth: [] }],\n\t\t\t\tparameters: getParameters(options$1),\n\t\t\t\tresponses: getResponse(options$1.metadata?.openapi?.responses)\n\t\t\t}\n\t\t};\n\t\tif (options$1.method === \"POST\" || options$1.method === \"PATCH\" || options$1.method === \"PUT\") {\n\t\t\tconst body = getRequestBody(options$1);\n\t\t\tpaths[path] = {\n\t\t\t\t...paths[path],\n\t\t\t\t[options$1.method.toLowerCase()]: {\n\t\t\t\t\ttags: [\"Default\", ...options$1.metadata?.openapi?.tags || []],\n\t\t\t\t\tdescription: options$1.metadata?.openapi?.description,\n\t\t\t\t\toperationId: options$1.metadata?.openapi?.operationId,\n\t\t\t\t\tsecurity: [{ bearerAuth: [] }],\n\t\t\t\t\tparameters: getParameters(options$1),\n\t\t\t\t\t...body ? { requestBody: body } : { requestBody: { content: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {}\n\t\t\t\t\t} } } } },\n\t\t\t\t\tresponses: getResponse(options$1.metadata?.openapi?.responses)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\tfor (const plugin of options.plugins || []) {\n\t\tif (plugin.id === \"open-api\") continue;\n\t\tconst pluginEndpoints = getEndpoints(ctx, {\n\t\t\t...options,\n\t\t\tplugins: [plugin]\n\t\t});\n\t\tconst api = Object.keys(pluginEndpoints.api).map((key) => {\n\t\t\tif (baseEndpoints.api[key] === void 0) return pluginEndpoints.api[key];\n\t\t\treturn null;\n\t\t}).filter((x) => x !== null);\n\t\tObject.entries(api).forEach(([key, value]) => {\n\t\t\tif (ctx.options.disabledPaths?.includes(value.path)) return;\n\t\t\tconst options$1 = value.options;\n\t\t\tif (options$1.metadata?.SERVER_ONLY) return;\n\t\t\tconst path = toOpenApiPath(value.path);\n\t\t\tif (options$1.method === \"GET\" || options$1.method === \"DELETE\") paths[path] = {\n\t\t\t\t...paths[path],\n\t\t\t\t[options$1.method.toLowerCase()]: {\n\t\t\t\t\ttags: options$1.metadata?.openapi?.tags || [plugin.id.charAt(0).toUpperCase() + plugin.id.slice(1)],\n\t\t\t\t\tdescription: options$1.metadata?.openapi?.description,\n\t\t\t\t\toperationId: options$1.metadata?.openapi?.operationId,\n\t\t\t\t\tsecurity: [{ bearerAuth: [] }],\n\t\t\t\t\tparameters: getParameters(options$1),\n\t\t\t\t\tresponses: getResponse(options$1.metadata?.openapi?.responses)\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (options$1.method === \"POST\" || options$1.method === \"PATCH\" || options$1.method === \"PUT\") paths[path] = {\n\t\t\t\t...paths[path],\n\t\t\t\t[options$1.method.toLowerCase()]: {\n\t\t\t\t\ttags: options$1.metadata?.openapi?.tags || [plugin.id.charAt(0).toUpperCase() + plugin.id.slice(1)],\n\t\t\t\t\tdescription: options$1.metadata?.openapi?.description,\n\t\t\t\t\toperationId: options$1.metadata?.openapi?.operationId,\n\t\t\t\t\tsecurity: [{ bearerAuth: [] }],\n\t\t\t\t\tparameters: getParameters(options$1),\n\t\t\t\t\trequestBody: getRequestBody(options$1),\n\t\t\t\t\tresponses: getResponse(options$1.metadata?.openapi?.responses)\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\treturn {\n\t\topenapi: \"3.1.1\",\n\t\tinfo: {\n\t\t\ttitle: \"Better Auth\",\n\t\t\tdescription: \"API Reference for your Better Auth Instance\",\n\t\t\tversion: \"1.1.0\"\n\t\t},\n\t\tcomponents: {\n\t\t\t...components,\n\t\t\tsecuritySchemes: {\n\t\t\t\tapiKeyCookie: {\n\t\t\t\t\ttype: \"apiKey\",\n\t\t\t\t\tin: \"cookie\",\n\t\t\t\t\tname: \"apiKeyCookie\",\n\t\t\t\t\tdescription: \"API Key authentication via cookie\"\n\t\t\t\t},\n\t\t\t\tbearerAuth: {\n\t\t\t\t\ttype: \"http\",\n\t\t\t\t\tscheme: \"bearer\",\n\t\t\t\t\tdescription: \"Bearer token authentication\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsecurity: [{\n\t\t\tapiKeyCookie: [],\n\t\t\tbearerAuth: []\n\t\t}],\n\t\tservers: [{ url: ctx.baseURL }],\n\t\ttags: [{\n\t\t\tname: \"Default\",\n\t\t\tdescription: \"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\"\n\t\t}],\n\t\tpaths\n\t};\n}\n\n//#endregion\n//#region src/plugins/open-api/logo.ts\nconst logo = `<svg width=\"75\" height=\"75\" viewBox=\"0 0 75 75\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<rect width=\"75\" height=\"75\" fill=\"url(#pattern0_21_12)\"/>\n<defs>\n<pattern id=\"pattern0_21_12\" patternContentUnits=\"objectBoundingBox\" width=\"1\" height=\"1\">\n<use xlink:href=\"#image0_21_12\" transform=\"scale(0.00094697)\"/>\n</pattern>\n<image id=\"image0_21_12\" width=\"1056\" height=\"1056\" xlink:href=\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAEIKADAAQAAAABAAAEIAAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/+ICKElDQ19QUk9GSUxFAAEBAAACGGFwcGwEAAAAbW50clJHQiBYWVogB+YAAQABAAAAAAAAYWNzcEFQUEwAAAAAQVBQTAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBs7P2jjjiFR8NttL1PetoYLwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKZGVzYwAAAPwAAAAwY3BydAAAASwAAABQd3RwdAAAAXwAAAAUclhZWgAAAZAAAAAUZ1hZWgAAAaQAAAAUYlhZWgAAAbgAAAAUclRSQwAAAcwAAAAgY2hhZAAAAewAAAAsYlRSQwAAAcwAAAAgZ1RSQwAAAcwAAAAgbWx1YwAAAAAAAAABAAAADGVuVVMAAAAUAAAAHABEAGkAcwBwAGwAYQB5ACAAUAAzbWx1YwAAAAAAAAABAAAADGVuVVMAAAA0AAAAHABDAG8AcAB5AHIAaQBnAGgAdAAgAEEAcABwAGwAZQAgAEkAbgBjAC4ALAAgADIAMAAyADJYWVogAAAAAAAA9tUAAQAAAADTLFhZWiAAAAAAAACD3wAAPb////+7WFlaIAAAAAAAAEq/AACxNwAACrlYWVogAAAAAAAAKDgAABELAADIuXBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbc2YzMgAAAAAAAQxCAAAF3v//8yYAAAeTAAD9kP//+6L///2jAAAD3AAAwG7/wAARCAQgBCADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9sAQwACAgICAgIDAgIDBAMDAwQFBAQEBAUHBQUFBQUHCAcHBwcHBwgICAgICAgICgoKCgoKCwsLCwsNDQ0NDQ0NDQ0N/9sAQwECAgIDAwMGAwMGDQkHCQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0N/90ABABC/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Ln/gq38a/in8Dvgp4T8R/CfxFdeG9SvvFMdlcXFoELyW5srqQxnzEcY3op4Gciv1Gr8Z/+C2X/JvXgj/sc4v/AE33lAH4z/8ADwv9tD/oq2tf9823/wAZo/4eF/tof9FW1r/vm2/+M18Z0UAfZn/Dwv8AbQ/6KtrX/fNt/wDGaP8Ah4X+2h/0VbWv++bb/wCM18Z0UAfZn/Dwv9tD/oq2tf8AfNt/8Zo/4eF/tof9FW1r/vm2/wDjNfGdFAH2Z/w8L/bQ/wCira1/3zbf/GaP+Hhf7aH/AEVbWv8Avm2/+M18Z0UAfZn/AA8L/bQ/6KtrX/fNt/8AGaP+Hhf7aH/RVta/75tv/jNfGdFAH2Z/w8L/AG0P+ira1/3zbf8Axmj/AIeF/tof9FW1r/vm2/8AjNfGdFAH63/sVftq/tTfEb9qb4deCfG3xF1TVtD1bVGgvbKdYBHPGIJW2ttiVsblB4I6V/UbX8Z//BPT/k9D4U/9hpv/AEmmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+M/wD4eF/tof8ARVta/wC+bb/4zR/w8L/bQ/6KtrX/AHzbf/Ga+M6KAPsz/h4X+2h/0VbWv++bb/4zR/w8L/bQ/wCira1/3zbf/Ga+M6KAPsz/AIeF/tof9FW1r/vm2/8AjNH/AA8L/bQ/6KtrX/fNt/8AGa+M6KAPsz/h4X+2h/0VbWv++bb/AOM0f8PC/wBtD/oq2tf9823/AMZr4zooA+zP+Hhf7aH/AEVbWv8Avm2/+M0f8PC/20P+ira1/wB823/xmvjOigD7M/4eF/tof9FW1r/vm2/+M0f8PC/20P8Aoq2tf9823/xmvjOigD7M/wCHhf7aH/RVta/75tv/AIzR/wAPC/20P+ira1/3zbf/ABmvjOigD7M/4eF/tof9FW1r/vm2/wDjNH/Dwv8AbQ/6KtrX/fNt/wDGa+M6KAPsz/h4X+2h/wBFW1r/AL5tv/jNH/Dwv9tD/oq2tf8AfNt/8Zr4zooA+zP+Hhf7aH/RVta/75tv/jNH/Dwv9tD/AKKtrX/fNt/8Zr4zooA+zP8Ah4X+2h/0VbWv++bb/wCM0f8ADwv9tD/oq2tf9823/wAZr4zooA+zP+Hhf7aH/RVta/75tv8A4zR/w8L/AG0P+ira1/3zbf8AxmvjOigD7M/4eF/tof8ARVta/wC+bb/4zR/w8L/bQ/6KtrX/AHzbf/Ga+M6KAP6tv+CUnxr+Kfxx+CnizxH8WPEV14k1Kx8UyWVvcXYQPHbiytZBGPLRBje7HkZya/Uavxn/AOCJv/JvXjf/ALHOX/032dfsxQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfxn/APBPT/k9D4U/9hpv/Saav7MKACiiigAooooAKKKKACiiigAooooAKKKKAP4A6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfwq/BT4r638Dvin4d+LHhy0tb7UvDd0bu3t70ObeRzG0eJBGyPjDnowOa/Ub/h9l+0L/ANCR4M/79ah/8m0Af0yUV/M3/wAPsv2hf+hI8Gf9+tQ/+TaP+H2X7Qv/AEJHgz/v1qH/AMm0Af0yUV/M3/w+y/aF/wChI8Gf9+tQ/wDk2j/h9l+0L/0JHgz/AL9ah/8AJtAH9MlFfzN/8Psv2hf+hI8Gf9+tQ/8Ak2j/AIfZftC/9CR4M/79ah/8m0Af0yUV/M3/AMPsv2hf+hI8Gf8AfrUP/k2j/h9l+0L/ANCR4M/79ah/8m0Af0yUV/M3/wAPsv2hf+hI8Gf9+tQ/+TaP+H2X7Qv/AEJHgz/v1qH/AMm0Af0yUV/M3/w+y/aF/wChI8Gf9+tQ/wDk2j/h9l+0L/0JHgz/AL9ah/8AJtAH4z0V/TJ/w5N/Z6/6Hfxn/wB/dP8A/kKj/hyb+z1/0O/jP/v7p/8A8hUAfzN0V/TJ/wAOTf2ev+h38Z/9/dP/APkKj/hyb+z1/wBDv4z/AO/un/8AyFQB/M3RX9Mn/Dk39nr/AKHfxn/390//AOQqP+HJv7PX/Q7+M/8Av7p//wAhUAfzN0V/TJ/w5N/Z6/6Hfxn/AN/dP/8AkKj/AIcm/s9f9Dv4z/7+6f8A/IVAH8zdFf0yf8OTf2ev+h38Z/8Af3T/AP5Co/4cm/s9f9Dv4z/7+6f/APIVAH8zdFf0yf8ADk39nr/od/Gf/f3T/wD5Co/4cm/s9f8AQ7+M/wDv7p//AMhUAfzN0V/TJ/w5N/Z6/wCh38Z/9/dP/wDkKvwV/ag+FGifA74++M/hP4cu7q+03w3fi0t7i9KG4kQxRyZkMaomcueigYoA8FooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/AOxzl/8ATfZ1+zFfjP8A8ETf+TevG/8A2Ocv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/v8ooooAKKKKACiiigAooooAKKKKACiiigAr+M//goX/wAnofFb/sNL/wCk0Nf2YV/Gf/wUL/5PQ+K3/YaX/wBJoaAPjOiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP7/KKKKACiiigAooooAKKKKACiiigAooooAK/jP/4KF/8AJ6HxW/7DS/8ApNDX9mFfxn/8FC/+T0Pit/2Gl/8ASaGgD4zooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+/yiiigAooooAKKKKACiiigAooooAKKKKACv4z/+Chf/ACeh8Vv+w0v/AKTQ1/ZhX8Z//BQv/k9D4rf9hpf/AEmhoA+M6KKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/v8ooooAKKKKACiiigAooooAKKKKACiiigAr+M//goX/wAnofFb/sNL/wCk0Nf2YV/Gf/wUL/5PQ+K3/YaX/wBJoaAPjOiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP7/KKKKACiiigAooooAKKKKACiiigAooooAK/jP/4KF/8AJ6HxW/7DS/8ApNDX9mFfxn/8FC/+T0Pit/2Gl/8ASaGgD4zooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+/yiiigAooooAKKKKACiiigAooooAKKKKACv4z/+Chf/ACeh8Vv+w0v/AKTQ1/ZhX8Z//BQv/k9D4rf9hpf/AEmhoA+M6KKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD1L4KfCjW/jj8U/Dvwn8OXdrY6l4kujaW9xelxbxuI2kzIY1d8YQ9FJzX6jf8OTf2hf8Aod/Bn/f3UP8A5Cr4z/4J6f8AJ6Hwp/7DTf8ApNNX9mFAH8zf/Dk39oX/AKHfwZ/391D/AOQqP+HJv7Qv/Q7+DP8Av7qH/wAhV/TJRQB/M3/w5N/aF/6HfwZ/391D/wCQqP8Ahyb+0L/0O/gz/v7qH/yFX9MlFAH8zf8Aw5N/aF/6HfwZ/wB/dQ/+QqP+HJv7Qv8A0O/gz/v7qH/yFX9MlFAH8zf/AA5N/aF/6HfwZ/391D/5Co/4cm/tC/8AQ7+DP+/uof8AyFX9MlFAH8zf/Dk39oX/AKHfwZ/391D/AOQqP+HJv7Qv/Q7+DP8Av7qH/wAhV/TJRQB/M3/w5N/aF/6HfwZ/391D/wCQqP8Ahyb+0L/0O/gz/v7qH/yFX9MlFAH4z/8AD7L9nr/oSPGf/frT/wD5No/4fZfs9f8AQkeM/wDv1p//AMm1/M3RQB/TJ/w+y/Z6/wChI8Z/9+tP/wDk2j/h9l+z1/0JHjP/AL9af/8AJtfzN0UAf0yf8Psv2ev+hI8Z/wDfrT//AJNo/wCH2X7PX/QkeM/+/Wn/APybX8zdFAH9Mn/D7L9nr/oSPGf/AH60/wD+TaP+H2X7PX/QkeM/+/Wn/wDybX8zdFAH9Mn/AA+y/Z6/6Ejxn/360/8A+TaP+H2X7PX/AEJHjP8A79af/wDJtfzN0UAf0yf8Psv2ev8AoSPGf/frT/8A5No/4fZfs9f9CR4z/wC/Wn//ACbX8zdFAH9Mn/D7L9nr/oSPGf8A360//wCTa/BX9qD4r6J8cfj74z+LHhy0urHTfEl+Lu3t70ILiNBFHHiQRs6Zyh6MRivBaKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/ACb143/7HOX/ANN9nX7MV+M//BE3/k3rxv8A9jnL/wCm+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfxn/APBPT/k9D4U/9hpv/Saav7MKACiiigAooooAKKKKACiiigAooooAKKKKAP4A6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+XP/BVv4KfFP44/BTwn4c+E/h268SalY+KY724t7QoHjtxZXUZkPmOgxvdRwc5NAH8pNFfZn/DvT9tD/olOtf99W3/AMeo/wCHen7aH/RKda/76tv/AI9QB8Z0V9mf8O9P20P+iU61/wB9W3/x6j/h3p+2h/0SnWv++rb/AOPUAfGdFfZn/DvT9tD/AKJTrX/fVt/8eo/4d6ftof8ARKda/wC+rb/49QB8Z0V9mf8ADvT9tD/olOtf99W3/wAeo/4d6ftof9Ep1r/vq2/+PUAfGdFfZn/DvT9tD/olOtf99W3/AMeo/wCHen7aH/RKda/76tv/AI9QB8Z0V9mf8O9P20P+iU61/wB9W3/x6j/h3p+2h/0SnWv++rb/AOPUAH/BPT/k9D4U/wDYab/0mmr+zCv5cv2Kv2Kv2pvhz+1N8OvG3jb4dappOh6TqjT3t7O0BjgjMEq7m2ys2NzAcA9a/qNoAKKKKACiiigAooooAKKKKACiiigAooooA/gDor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD9mP+CJv/JvXjf8A7HOX/wBN9nX7MV+XP/BKT4KfFP4HfBTxZ4c+LHh268N6lfeKZL23t7soXktzZWsYkHlu4xvRhyc5FfqNQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9f9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/2Q==\"/>\n</defs>\n</svg>\n`;\n\n//#endregion\n//#region src/plugins/open-api/index.ts\nconst getHTML = (apiReference, theme, nonce) => {\n\tconst nonceAttr = nonce ? `nonce=\"${nonce}\"` : \"\";\n\treturn `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    <\\/script>\n\t <script ${nonceAttr}>\n      var configuration = {\n\t  \tfavicon: \"data:image/svg+xml;utf8,${encodeURIComponent(logo)}\",\n\t   \ttheme: \"${theme || \"default\"}\",\n        metaData: {\n\t\t\ttitle: \"Better Auth API\",\n\t\t\tdescription: \"API Reference for your Better Auth Instance\",\n\t\t}\n      }\n\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    <\\/script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\" ${nonceAttr}><\\/script>\n  </body>\n</html>`;\n};\nconst openAPI = (options) => {\n\tconst path = options?.path ?? \"/reference\";\n\treturn {\n\t\tid: \"open-api\",\n\t\tendpoints: {\n\t\t\tgenerateOpenAPISchema: createAuthEndpoint(\"/open-api/generate-schema\", { method: \"GET\" }, async (ctx) => {\n\t\t\t\tconst schema = await generator(ctx.context, ctx.context.options);\n\t\t\t\treturn ctx.json(schema);\n\t\t\t}),\n\t\t\topenAPIReference: createAuthEndpoint(path, {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tmetadata: { isAction: false }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (options?.disableDefaultReference) throw new APIError(\"NOT_FOUND\");\n\t\t\t\tconst schema = await generator(ctx.context, ctx.context.options);\n\t\t\t\treturn new Response(getHTML(schema, options?.theme, options?.nonce), { headers: { \"Content-Type\": \"text/html\" } });\n\t\t\t})\n\t\t}\n\t};\n};\n\n//#endregion\nexport { openAPI as t };","import { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { r as getOrigin } from \"./url-CB8xCwz-.mjs\";\nimport { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport * as z from \"zod\";\nimport { utf8ToBytes } from \"@noble/hashes/utils.js\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { keccak_256 } from \"@noble/hashes/sha3.js\";\n\n//#region src/utils/hashing.ts\n/**\n* TS implementation of ERC-55 (\"Mixed-case checksum address encoding\") using @noble/hashes\n* @param address - The address to convert to a checksum address\n* @returns The checksummed address\n*/\nfunction toChecksumAddress(address) {\n\taddress = address.toLowerCase().replace(\"0x\", \"\");\n\tconst hash = [...keccak_256(utf8ToBytes(address))].map((v) => v.toString(16).padStart(2, \"0\")).join(\"\");\n\tlet ret = \"0x\";\n\tfor (let i = 0; i < 40; i++) if (parseInt(hash[i], 16) >= 8) ret += address[i].toUpperCase();\n\telse ret += address[i];\n\treturn ret;\n}\n\n//#endregion\n//#region src/plugins/siwe/schema.ts\nconst schema = { walletAddress: { fields: {\n\tuserId: {\n\t\ttype: \"string\",\n\t\treferences: {\n\t\t\tmodel: \"user\",\n\t\t\tfield: \"id\"\n\t\t},\n\t\trequired: true,\n\t\tindex: true\n\t},\n\taddress: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\tchainId: {\n\t\ttype: \"number\",\n\t\trequired: true\n\t},\n\tisPrimary: {\n\t\ttype: \"boolean\",\n\t\tdefaultValue: false\n\t},\n\tcreatedAt: {\n\t\ttype: \"date\",\n\t\trequired: true\n\t}\n} } };\n\n//#endregion\n//#region src/plugins/siwe/index.ts\nconst siwe = (options) => ({\n\tid: \"siwe\",\n\tschema: mergeSchema(schema, options?.schema),\n\tendpoints: {\n\t\tgetSiweNonce: createAuthEndpoint(\"/siwe/nonce\", {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: z.object({\n\t\t\t\twalletAddress: z.string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),\n\t\t\t\tchainId: z.number().int().positive().max(2147483647).optional().default(1)\n\t\t\t})\n\t\t}, async (ctx) => {\n\t\t\tconst { walletAddress: rawWalletAddress, chainId } = ctx.body;\n\t\t\tconst walletAddress = toChecksumAddress(rawWalletAddress);\n\t\t\tconst nonce = await options.getNonce();\n\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\tidentifier: `siwe:${walletAddress}:${chainId}`,\n\t\t\t\tvalue: nonce,\n\t\t\t\texpiresAt: new Date(Date.now() + 900 * 1e3)\n\t\t\t});\n\t\t\treturn ctx.json({ nonce });\n\t\t}),\n\t\tverifySiweMessage: createAuthEndpoint(\"/siwe/verify\", {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: z.object({\n\t\t\t\tmessage: z.string().min(1),\n\t\t\t\tsignature: z.string().min(1),\n\t\t\t\twalletAddress: z.string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),\n\t\t\t\tchainId: z.number().int().positive().max(2147483647).optional().default(1),\n\t\t\t\temail: z.email().optional()\n\t\t\t}).refine((data) => options.anonymous !== false || !!data.email, {\n\t\t\t\tmessage: \"Email is required when the anonymous plugin option is disabled.\",\n\t\t\t\tpath: [\"email\"]\n\t\t\t}),\n\t\t\trequireRequest: true\n\t\t}, async (ctx) => {\n\t\t\tconst { message, signature, walletAddress: rawWalletAddress, chainId, email } = ctx.body;\n\t\t\tconst walletAddress = toChecksumAddress(rawWalletAddress);\n\t\t\tconst isAnon = options.anonymous ?? true;\n\t\t\tif (!isAnon && !email) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Email is required when anonymous is disabled.\",\n\t\t\t\tstatus: 400\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tconst verification = await ctx.context.internalAdapter.findVerificationValue(`siwe:${walletAddress}:${chainId}`);\n\t\t\t\tif (!verification || /* @__PURE__ */ new Date() > verification.expiresAt) throw new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Unauthorized: Invalid or expired nonce\",\n\t\t\t\t\tstatus: 401,\n\t\t\t\t\tcode: \"UNAUTHORIZED_INVALID_OR_EXPIRED_NONCE\"\n\t\t\t\t});\n\t\t\t\tconst { value: nonce } = verification;\n\t\t\t\tif (!await options.verifyMessage({\n\t\t\t\t\tmessage,\n\t\t\t\t\tsignature,\n\t\t\t\t\taddress: walletAddress,\n\t\t\t\t\tchainId,\n\t\t\t\t\tcacao: {\n\t\t\t\t\t\th: { t: \"caip122\" },\n\t\t\t\t\t\tp: {\n\t\t\t\t\t\t\tdomain: options.domain,\n\t\t\t\t\t\t\taud: options.domain,\n\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\tiss: options.domain,\n\t\t\t\t\t\t\tversion: \"1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\ts: {\n\t\t\t\t\t\t\tt: \"eip191\",\n\t\t\t\t\t\t\ts: signature\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})) throw new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Unauthorized: Invalid SIWE signature\",\n\t\t\t\t\tstatus: 401\n\t\t\t\t});\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\t\t\t\tlet user = null;\n\t\t\t\tconst existingWalletAddress = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"walletAddress\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"address\",\n\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\tvalue: walletAddress\n\t\t\t\t\t}, {\n\t\t\t\t\t\tfield: \"chainId\",\n\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\tvalue: chainId\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (existingWalletAddress) user = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\tvalue: existingWalletAddress.userId\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\telse {\n\t\t\t\t\tconst anyWalletAddress = await ctx.context.adapter.findOne({\n\t\t\t\t\t\tmodel: \"walletAddress\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"address\",\n\t\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\t\tvalue: walletAddress\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (anyWalletAddress) user = await ctx.context.adapter.findOne({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\t\tvalue: anyWalletAddress.userId\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!user) {\n\t\t\t\t\tconst domain = options.emailDomainName ?? getOrigin(ctx.context.baseURL);\n\t\t\t\t\tconst userEmail = !isAnon && email ? email : `${walletAddress}@${domain}`;\n\t\t\t\t\tconst { name, avatar } = await options.ensLookup?.({ walletAddress }) ?? {};\n\t\t\t\t\tuser = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\t\tname: name ?? walletAddress,\n\t\t\t\t\t\temail: userEmail,\n\t\t\t\t\t\timage: avatar ?? \"\"\n\t\t\t\t\t});\n\t\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\t\tmodel: \"walletAddress\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\t\taddress: walletAddress,\n\t\t\t\t\t\t\tchainId,\n\t\t\t\t\t\t\tisPrimary: true,\n\t\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tawait ctx.context.internalAdapter.createAccount({\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tproviderId: \"siwe\",\n\t\t\t\t\t\taccountId: `${walletAddress}:${chainId}`,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t});\n\t\t\t\t} else if (!existingWalletAddress) {\n\t\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\t\tmodel: \"walletAddress\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\t\taddress: walletAddress,\n\t\t\t\t\t\t\tchainId,\n\t\t\t\t\t\t\tisPrimary: false,\n\t\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tawait ctx.context.internalAdapter.createAccount({\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tproviderId: \"siwe\",\n\t\t\t\t\t\taccountId: `${walletAddress}:${chainId}`,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.id);\n\t\t\t\tif (!session) throw new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: \"Internal Server Error\",\n\t\t\t\t\tstatus: 500\n\t\t\t\t});\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\twalletAddress,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof APIError) throw error;\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Something went wrong. Please try again later.\",\n\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t\t\t\tstatus: 401\n\t\t\t\t});\n\t\t\t}\n\t\t})\n\t}\n});\n\n//#endregion\nexport { siwe as t };","import \"../../get-model-name-D4DUV7S2.mjs\";\nimport \"../../utils-db7gNqd-.mjs\";\nimport \"../../crypto-CFUhAR9W.mjs\";\nimport \"../../misc-BwNc0MKr.mjs\";\nimport \"../../json-CnHxKYpj.mjs\";\nimport { t as createAdapterFactory } from \"../../adapter-factory-HF3JB9cT.mjs\";\nimport { logger } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { and, asc, count, desc, eq, gt, gte, inArray, like, lt, lte, ne, notInArray, or, sql } from \"drizzle-orm\";\n\n//#region src/adapters/drizzle-adapter/drizzle-adapter.ts\nconst drizzleAdapter = (db, config) => {\n\tlet lazyOptions = null;\n\tconst createCustomAdapter = (db$1) => ({ getFieldName, options }) => {\n\t\tfunction getSchema(model) {\n\t\t\tconst schema = config.schema || db$1._.fullSchema;\n\t\t\tif (!schema) throw new BetterAuthError(\"Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.\");\n\t\t\tconst schemaModel = schema[model];\n\t\t\tif (!schemaModel) throw new BetterAuthError(`[# Drizzle Adapter]: The model \"${model}\" was not found in the schema object. Please pass the schema directly to the adapter options.`);\n\t\t\treturn schemaModel;\n\t\t}\n\t\tconst withReturning = async (model, builder, data, where) => {\n\t\t\tif (config.provider !== \"mysql\") return (await builder.returning())[0];\n\t\t\tawait builder.execute();\n\t\t\tconst schemaModel = getSchema(model);\n\t\t\tconst builderVal = builder.config?.values;\n\t\t\tif (where?.length) {\n\t\t\t\tconst clause = convertWhereClause(where.map((w) => {\n\t\t\t\t\tif (data[w.field] !== void 0) return {\n\t\t\t\t\t\t...w,\n\t\t\t\t\t\tvalue: data[w.field]\n\t\t\t\t\t};\n\t\t\t\t\treturn w;\n\t\t\t\t}), model);\n\t\t\t\treturn (await db$1.select().from(schemaModel).where(...clause))[0];\n\t\t\t} else if (builderVal && builderVal[0]?.id?.value) {\n\t\t\t\tlet tId = builderVal[0]?.id?.value;\n\t\t\t\tif (!tId) tId = (await db$1.select({ id: sql`LAST_INSERT_ID()` }).from(schemaModel).orderBy(desc(schemaModel.id)).limit(1))[0].id;\n\t\t\t\treturn (await db$1.select().from(schemaModel).where(eq(schemaModel.id, tId)).limit(1).execute())[0];\n\t\t\t} else if (data.id) return (await db$1.select().from(schemaModel).where(eq(schemaModel.id, data.id)).limit(1).execute())[0];\n\t\t\telse {\n\t\t\t\tif (!(\"id\" in schemaModel)) throw new BetterAuthError(`The model \"${model}\" does not have an \"id\" field. Please use the \"id\" field as your primary key.`);\n\t\t\t\treturn (await db$1.select().from(schemaModel).orderBy(desc(schemaModel.id)).limit(1).execute())[0];\n\t\t\t}\n\t\t};\n\t\tfunction convertWhereClause(where, model) {\n\t\t\tconst schemaModel = getSchema(model);\n\t\t\tif (!where) return [];\n\t\t\tif (where.length === 1) {\n\t\t\t\tconst w = where[0];\n\t\t\t\tif (!w) return [];\n\t\t\t\tconst field = getFieldName({\n\t\t\t\t\tmodel,\n\t\t\t\t\tfield: w.field\n\t\t\t\t});\n\t\t\t\tif (!schemaModel[field]) throw new BetterAuthError(`The field \"${w.field}\" does not exist in the schema for the model \"${model}\". Please update your schema.`);\n\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\tif (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`);\n\t\t\t\t\treturn [inArray(schemaModel[field], w.value)];\n\t\t\t\t}\n\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\tif (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`);\n\t\t\t\t\treturn [notInArray(schemaModel[field], w.value)];\n\t\t\t\t}\n\t\t\t\tif (w.operator === \"contains\") return [like(schemaModel[field], `%${w.value}%`)];\n\t\t\t\tif (w.operator === \"starts_with\") return [like(schemaModel[field], `${w.value}%`)];\n\t\t\t\tif (w.operator === \"ends_with\") return [like(schemaModel[field], `%${w.value}`)];\n\t\t\t\tif (w.operator === \"lt\") return [lt(schemaModel[field], w.value)];\n\t\t\t\tif (w.operator === \"lte\") return [lte(schemaModel[field], w.value)];\n\t\t\t\tif (w.operator === \"ne\") return [ne(schemaModel[field], w.value)];\n\t\t\t\tif (w.operator === \"gt\") return [gt(schemaModel[field], w.value)];\n\t\t\t\tif (w.operator === \"gte\") return [gte(schemaModel[field], w.value)];\n\t\t\t\treturn [eq(schemaModel[field], w.value)];\n\t\t\t}\n\t\t\tconst andGroup = where.filter((w) => w.connector === \"AND\" || !w.connector);\n\t\t\tconst orGroup = where.filter((w) => w.connector === \"OR\");\n\t\t\tconst andClause = and(...andGroup.map((w) => {\n\t\t\t\tconst field = getFieldName({\n\t\t\t\t\tmodel,\n\t\t\t\t\tfield: w.field\n\t\t\t\t});\n\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\tif (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`);\n\t\t\t\t\treturn inArray(schemaModel[field], w.value);\n\t\t\t\t}\n\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\tif (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`);\n\t\t\t\t\treturn notInArray(schemaModel[field], w.value);\n\t\t\t\t}\n\t\t\t\tif (w.operator === \"contains\") return like(schemaModel[field], `%${w.value}%`);\n\t\t\t\tif (w.operator === \"starts_with\") return like(schemaModel[field], `${w.value}%`);\n\t\t\t\tif (w.operator === \"ends_with\") return like(schemaModel[field], `%${w.value}`);\n\t\t\t\tif (w.operator === \"lt\") return lt(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"lte\") return lte(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"gt\") return gt(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"gte\") return gte(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"ne\") return ne(schemaModel[field], w.value);\n\t\t\t\treturn eq(schemaModel[field], w.value);\n\t\t\t}));\n\t\t\tconst orClause = or(...orGroup.map((w) => {\n\t\t\t\tconst field = getFieldName({\n\t\t\t\t\tmodel,\n\t\t\t\t\tfield: w.field\n\t\t\t\t});\n\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\tif (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`);\n\t\t\t\t\treturn inArray(schemaModel[field], w.value);\n\t\t\t\t}\n\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\tif (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`);\n\t\t\t\t\treturn notInArray(schemaModel[field], w.value);\n\t\t\t\t}\n\t\t\t\tif (w.operator === \"contains\") return like(schemaModel[field], `%${w.value}%`);\n\t\t\t\tif (w.operator === \"starts_with\") return like(schemaModel[field], `${w.value}%`);\n\t\t\t\tif (w.operator === \"ends_with\") return like(schemaModel[field], `%${w.value}`);\n\t\t\t\tif (w.operator === \"lt\") return lt(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"lte\") return lte(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"gt\") return gt(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"gte\") return gte(schemaModel[field], w.value);\n\t\t\t\tif (w.operator === \"ne\") return ne(schemaModel[field], w.value);\n\t\t\t\treturn eq(schemaModel[field], w.value);\n\t\t\t}));\n\t\t\tconst clause = [];\n\t\t\tif (andGroup.length) clause.push(andClause);\n\t\t\tif (orGroup.length) clause.push(orClause);\n\t\t\treturn clause;\n\t\t}\n\t\tfunction checkMissingFields(schema, model, values) {\n\t\t\tif (!schema) throw new BetterAuthError(\"Drizzle adapter failed to initialize. Drizzle Schema not found. Please provide a schema object in the adapter options object.\");\n\t\t\tfor (const key in values) if (!schema[key]) throw new BetterAuthError(`The field \"${key}\" does not exist in the \"${model}\" Drizzle schema. Please update your drizzle schema or re-generate using \"npx @better-auth/cli@latest generate\".`);\n\t\t}\n\t\treturn {\n\t\t\tasync create({ model, data: values }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tcheckMissingFields(schemaModel, model, values);\n\t\t\t\treturn await withReturning(model, db$1.insert(schemaModel).values(values), values);\n\t\t\t},\n\t\t\tasync findOne({ model, where, join }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\tif (options.experimental?.joins) if (!db$1.query || !db$1.query[model]) {\n\t\t\t\t\tlogger.error(`[# Drizzle Adapter]: The model \"${model}\" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using \"npx @better-auth/cli@latest generate\".`);\n\t\t\t\t\tlogger.info(\"Falling back to regular query\");\n\t\t\t\t} else {\n\t\t\t\t\tlet includes;\n\t\t\t\t\tconst pluralJoinResults = [];\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tincludes = {};\n\t\t\t\t\t\tconst joinEntries = Object.entries(join);\n\t\t\t\t\t\tfor (const [model$1, joinAttr] of joinEntries) {\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;\n\t\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\t\tconst pluralSuffix = isUnique || config.usePlural ? \"\" : \"s\";\n\t\t\t\t\t\t\tincludes[`${model$1}${pluralSuffix}`] = isUnique ? true : { limit };\n\t\t\t\t\t\t\tif (!isUnique) pluralJoinResults.push(`${model$1}${pluralSuffix}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst res$1 = await db$1.query[model].findFirst({\n\t\t\t\t\t\twhere: clause[0],\n\t\t\t\t\t\twith: includes\n\t\t\t\t\t});\n\t\t\t\t\tif (res$1) for (const pluralJoinResult of pluralJoinResults) {\n\t\t\t\t\t\tlet singularKey = !config.usePlural ? pluralJoinResult.slice(0, -1) : pluralJoinResult;\n\t\t\t\t\t\tres$1[singularKey] = res$1[pluralJoinResult];\n\t\t\t\t\t\tif (pluralJoinResult !== singularKey) delete res$1[pluralJoinResult];\n\t\t\t\t\t}\n\t\t\t\t\treturn res$1;\n\t\t\t\t}\n\t\t\t\tconst res = await db$1.select().from(schemaModel).where(...clause);\n\t\t\t\tif (!res.length) return null;\n\t\t\t\treturn res[0];\n\t\t\t},\n\t\t\tasync findMany({ model, where, sortBy, limit, offset, join }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = where ? convertWhereClause(where, model) : [];\n\t\t\t\tconst sortFn = sortBy?.direction === \"desc\" ? desc : asc;\n\t\t\t\tif (options.experimental?.joins) if (!db$1.query[model]) {\n\t\t\t\t\tlogger.error(`[# Drizzle Adapter]: The model \"${model}\" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using \"npx @better-auth/cli@latest generate\".`);\n\t\t\t\t\tlogger.info(\"Falling back to regular query\");\n\t\t\t\t} else {\n\t\t\t\t\tlet includes;\n\t\t\t\t\tconst pluralJoinResults = [];\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tincludes = {};\n\t\t\t\t\t\tconst joinEntries = Object.entries(join);\n\t\t\t\t\t\tfor (const [model$1, joinAttr] of joinEntries) {\n\t\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\t\tconst limit$1 = joinAttr.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;\n\t\t\t\t\t\t\tlet pluralSuffix = isUnique || config.usePlural ? \"\" : \"s\";\n\t\t\t\t\t\t\tincludes[`${model$1}${pluralSuffix}`] = isUnique ? true : { limit: limit$1 };\n\t\t\t\t\t\t\tif (!isUnique) pluralJoinResults.push(`${model$1}${pluralSuffix}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet orderBy = void 0;\n\t\t\t\t\tif (sortBy?.field) orderBy = [sortFn(schemaModel[getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: sortBy?.field\n\t\t\t\t\t})])];\n\t\t\t\t\tlet res = await db$1.query[model].findMany({\n\t\t\t\t\t\twhere: clause[0],\n\t\t\t\t\t\twith: includes,\n\t\t\t\t\t\tlimit: limit ?? 100,\n\t\t\t\t\t\toffset: offset ?? 0,\n\t\t\t\t\t\torderBy\n\t\t\t\t\t});\n\t\t\t\t\tif (res) for (const item of res) for (const pluralJoinResult of pluralJoinResults) {\n\t\t\t\t\t\tconst singularKey = !config.usePlural ? pluralJoinResult.slice(0, -1) : pluralJoinResult;\n\t\t\t\t\t\tif (singularKey === pluralJoinResult) continue;\n\t\t\t\t\t\titem[singularKey] = item[pluralJoinResult];\n\t\t\t\t\t\tdelete item[pluralJoinResult];\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tlet builder = db$1.select().from(schemaModel);\n\t\t\t\tconst effectiveLimit = limit;\n\t\t\t\tconst effectiveOffset = offset;\n\t\t\t\tif (typeof effectiveLimit !== \"undefined\") builder = builder.limit(effectiveLimit);\n\t\t\t\tif (typeof effectiveOffset !== \"undefined\") builder = builder.offset(effectiveOffset);\n\t\t\t\tif (sortBy?.field) builder = builder.orderBy(sortFn(schemaModel[getFieldName({\n\t\t\t\t\tmodel,\n\t\t\t\t\tfield: sortBy?.field\n\t\t\t\t})]));\n\t\t\t\treturn await builder.where(...clause);\n\t\t\t},\n\t\t\tasync count({ model, where }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = where ? convertWhereClause(where, model) : [];\n\t\t\t\treturn (await db$1.select({ count: count() }).from(schemaModel).where(...clause))[0].count;\n\t\t\t},\n\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\treturn await withReturning(model, db$1.update(schemaModel).set(values).where(...clause), values, where);\n\t\t\t},\n\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\treturn await db$1.update(schemaModel).set(values).where(...clause);\n\t\t\t},\n\t\t\tasync delete({ model, where }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\treturn await db$1.delete(schemaModel).where(...clause);\n\t\t\t},\n\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\tconst res = await db$1.delete(schemaModel).where(...clause);\n\t\t\t\tlet count$1 = 0;\n\t\t\t\tif (res && \"rowCount\" in res) count$1 = res.rowCount;\n\t\t\t\telse if (Array.isArray(res)) count$1 = res.length;\n\t\t\t\telse if (res && (\"affectedRows\" in res || \"rowsAffected\" in res || \"changes\" in res)) count$1 = res.affectedRows ?? res.rowsAffected ?? res.changes;\n\t\t\t\tif (typeof count$1 !== \"number\") logger.error(\"[Drizzle Adapter] The result of the deleteMany operation is not a number. This is likely a bug in the adapter. Please report this issue to the Better Auth team.\", {\n\t\t\t\t\tres,\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere\n\t\t\t\t});\n\t\t\t\treturn count$1;\n\t\t\t},\n\t\t\toptions: config\n\t\t};\n\t};\n\tlet adapterOptions = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"drizzle\",\n\t\t\tadapterName: \"Drizzle Adapter\",\n\t\t\tusePlural: config.usePlural ?? false,\n\t\t\tdebugLogs: config.debugLogs ?? false,\n\t\t\tsupportsUUIDs: config.provider === \"pg\" ? true : false,\n\t\t\ttransaction: config.transaction ?? false ? (cb) => db.transaction((tx) => {\n\t\t\t\treturn cb(createAdapterFactory({\n\t\t\t\t\tconfig: adapterOptions.config,\n\t\t\t\t\tadapter: createCustomAdapter(tx)\n\t\t\t\t})(lazyOptions));\n\t\t\t}) : false\n\t\t},\n\t\tadapter: createCustomAdapter(db)\n\t};\n\tconst adapter = createAdapterFactory(adapterOptions);\n\treturn (options) => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n\n//#endregion\nexport { drizzleAdapter };","import { n as getKyselyDatabaseType } from \"./dialect-D9ZUZA4J.mjs\";\nimport { t as getMigrations, u as getAdapter } from \"./get-migration-Bf0TuCzm.mjs\";\nimport { n as createAuthContext, t as createBetterAuth } from \"./base-CiRMFqet.mjs\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\n//#region src/context/init.ts\nconst init = async (options) => {\n\tconst adapter = await getAdapter(options);\n\tconst getDatabaseType = (database) => getKyselyDatabaseType(database) || \"unknown\";\n\tconst ctx = await createAuthContext(adapter, options, getDatabaseType);\n\tctx.runMigrations = async function() {\n\t\tif (!options.database || \"updateMany\" in options.database) throw new BetterAuthError(\"Database is not provided or it's an adapter. Migrations are only supported with a database instance.\");\n\t\tconst { runMigrations } = await getMigrations(options);\n\t\tawait runMigrations();\n\t};\n\treturn ctx;\n};\n\n//#endregion\n//#region src/auth/auth.ts\n/**\n* Better Auth initializer for full mode (with Kysely)\n*\n* Check `minimal.ts` for minimal mode (without Kysely)\n*/\nconst betterAuth = (options) => {\n\treturn createBetterAuth(options, init);\n};\n\n//#endregion\nexport { betterAuth as t };","import { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { getCurrentAuthContext } from \"@better-auth/core/context\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { betterFetch } from \"@better-fetch/fetch\";\n\n//#region src/plugins/haveibeenpwned/index.ts\nconst ERROR_CODES = defineErrorCodes({ PASSWORD_COMPROMISED: \"The password you entered has been compromised. Please choose a different password.\" });\nasync function checkPasswordCompromise(password, customMessage) {\n\tif (!password) return;\n\tconst sha1Hash = (await createHash(\"SHA-1\", \"hex\").digest(password)).toUpperCase();\n\tconst prefix = sha1Hash.substring(0, 5);\n\tconst suffix = sha1Hash.substring(5);\n\ttry {\n\t\tconst { data, error } = await betterFetch(`https://api.pwnedpasswords.com/range/${prefix}`, { headers: {\n\t\t\t\"Add-Padding\": \"true\",\n\t\t\t\"User-Agent\": \"BetterAuth Password Checker\"\n\t\t} });\n\t\tif (error) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: `Failed to check password. Status: ${error.status}` });\n\t\tif (data.split(\"\\n\").some((line) => line.split(\":\")[0].toUpperCase() === suffix.toUpperCase())) throw new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: customMessage || ERROR_CODES.PASSWORD_COMPROMISED,\n\t\t\tcode: \"PASSWORD_COMPROMISED\"\n\t\t});\n\t} catch (error) {\n\t\tif (error instanceof APIError) throw error;\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Failed to check password. Please try again later.\" });\n\t}\n}\nconst haveIBeenPwned = (options) => {\n\tconst paths = options?.paths || [\n\t\t\"/sign-up/email\",\n\t\t\"/change-password\",\n\t\t\"/reset-password\"\n\t];\n\treturn {\n\t\tid: \"haveIBeenPwned\",\n\t\tinit(ctx) {\n\t\t\treturn { context: { password: {\n\t\t\t\t...ctx.password,\n\t\t\t\tasync hash(password) {\n\t\t\t\t\tconst c = await getCurrentAuthContext();\n\t\t\t\t\tif (!c.path || !paths.includes(c.path)) return ctx.password.hash(password);\n\t\t\t\t\tawait checkPasswordCompromise(password, options?.customPasswordCompromisedMessage);\n\t\t\t\t\treturn ctx.password.hash(password);\n\t\t\t\t}\n\t\t\t} } };\n\t\t},\n\t\t$ERROR_CODES: ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { haveIBeenPwned as t };","import { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport * as z from \"zod\";\nimport { createRemoteJWKSet, jwtVerify } from \"jose\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\n\n//#region src/utils/boolean.ts\nfunction toBoolean(value) {\n\treturn value === \"true\" || value === true;\n}\n\n//#endregion\n//#region src/plugins/one-tap/index.ts\nconst oneTap = (options) => ({\n\tid: \"one-tap\",\n\tendpoints: { oneTapCallback: createAuthEndpoint(\"/one-tap/callback\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({ idToken: z.string().meta({ description: \"Google ID token, which the client obtains from the One Tap API\" }) }),\n\t\tmetadata: { openapi: {\n\t\t\tsummary: \"One tap callback\",\n\t\t\tdescription: \"Use this endpoint to authenticate with Google One Tap\",\n\t\t\tresponses: {\n\t\t\t\t200: {\n\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" },\n\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t} } }\n\t\t\t\t},\n\t\t\t\t400: { description: \"Invalid token\" }\n\t\t\t}\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst { idToken } = ctx.body;\n\t\tlet payload;\n\t\ttry {\n\t\t\tconst { payload: verifiedPayload } = await jwtVerify(idToken, createRemoteJWKSet(new URL(\"https://www.googleapis.com/oauth2/v3/certs\")), {\n\t\t\t\tissuer: [\"https://accounts.google.com\", \"accounts.google.com\"],\n\t\t\t\taudience: options?.clientId || ctx.context.options.socialProviders?.google?.clientId\n\t\t\t});\n\t\t\tpayload = verifiedPayload;\n\t\t} catch (error) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"invalid id token\" });\n\t\t}\n\t\tconst { email, email_verified, name, picture, sub } = payload;\n\t\tif (!email) return ctx.json({ error: \"Email not available in token\" });\n\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\tif (!user) {\n\t\t\tif (options?.disableSignup) throw new APIError(\"BAD_GATEWAY\", { message: \"User not found\" });\n\t\t\tconst newUser = await ctx.context.internalAdapter.createOAuthUser({\n\t\t\t\temail,\n\t\t\t\temailVerified: typeof email_verified === \"boolean\" ? email_verified : toBoolean(email_verified),\n\t\t\t\tname,\n\t\t\t\timage: picture\n\t\t\t}, {\n\t\t\t\tproviderId: \"google\",\n\t\t\t\taccountId: sub\n\t\t\t});\n\t\t\tif (!newUser) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Could not create user\" });\n\t\t\tconst session$1 = await ctx.context.internalAdapter.createSession(newUser.user.id);\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tuser: newUser.user,\n\t\t\t\tsession: session$1\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\ttoken: session$1.token,\n\t\t\t\tuser: {\n\t\t\t\t\tid: newUser.user.id,\n\t\t\t\t\temail: newUser.user.email,\n\t\t\t\t\temailVerified: newUser.user.emailVerified,\n\t\t\t\t\tname: newUser.user.name,\n\t\t\t\t\timage: newUser.user.image,\n\t\t\t\t\tcreatedAt: newUser.user.createdAt,\n\t\t\t\t\tupdatedAt: newUser.user.updatedAt\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (!await ctx.context.internalAdapter.findAccount(sub)) {\n\t\t\tconst accountLinking = ctx.context.options.account?.accountLinking;\n\t\t\tif (accountLinking?.enabled && (accountLinking.trustedProviders?.includes(\"google\") || email_verified)) await ctx.context.internalAdapter.linkAccount({\n\t\t\t\tuserId: user.user.id,\n\t\t\t\tproviderId: \"google\",\n\t\t\t\taccountId: sub,\n\t\t\t\tscope: \"openid,profile,email\",\n\t\t\t\tidToken\n\t\t\t});\n\t\t\telse throw new APIError(\"UNAUTHORIZED\", { message: \"Google sub doesn't match\" });\n\t\t}\n\t\tconst session = await ctx.context.internalAdapter.createSession(user.user.id);\n\t\tawait setSessionCookie(ctx, {\n\t\t\tuser: user.user,\n\t\t\tsession\n\t\t});\n\t\treturn ctx.json({\n\t\t\ttoken: session.token,\n\t\t\tuser: {\n\t\t\t\tid: user.user.id,\n\t\t\t\temail: user.user.email,\n\t\t\t\temailVerified: user.user.emailVerified,\n\t\t\t\tname: user.user.name,\n\t\t\t\timage: user.user.image,\n\t\t\t\tcreatedAt: user.user.createdAt,\n\t\t\t\tupdatedAt: user.user.updatedAt\n\t\t\t}\n\t\t});\n\t}) }\n});\n\n//#endregion\nexport { oneTap as t };","import { base32 } from './base32.mjs';\nimport { createHMAC } from './hmac.mjs';\nimport './hex.mjs';\nimport './base64.mjs';\nimport './index.mjs';\n\nconst defaultPeriod = 30;\nconst defaultDigits = 6;\nasync function generateHOTP(secret, {\n  counter,\n  digits,\n  hash = \"SHA-1\"\n}) {\n  const _digits = digits ?? defaultDigits;\n  if (_digits < 1 || _digits > 8) {\n    throw new TypeError(\"Digits must be between 1 and 8\");\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigUint64(0, BigInt(counter), false);\n  const bytes = new Uint8Array(buffer);\n  const hmacResult = new Uint8Array(await createHMAC(hash).sign(secret, bytes));\n  const offset = hmacResult[hmacResult.length - 1] & 15;\n  const truncated = (hmacResult[offset] & 127) << 24 | (hmacResult[offset + 1] & 255) << 16 | (hmacResult[offset + 2] & 255) << 8 | hmacResult[offset + 3] & 255;\n  const otp = truncated % 10 ** _digits;\n  return otp.toString().padStart(_digits, \"0\");\n}\nasync function generateTOTP(secret, options) {\n  const digits = options?.digits ?? defaultDigits;\n  const period = options?.period ?? defaultPeriod;\n  const milliseconds = period * 1e3;\n  const counter = Math.floor(Date.now() / milliseconds);\n  return await generateHOTP(secret, { counter, digits, hash: options?.hash });\n}\nasync function verifyTOTP(otp, {\n  window = 1,\n  digits = defaultDigits,\n  secret,\n  period = defaultPeriod\n}) {\n  const milliseconds = period * 1e3;\n  const counter = Math.floor(Date.now() / milliseconds);\n  for (let i = -window; i <= window; i++) {\n    const generatedOTP = await generateHOTP(secret, {\n      counter: counter + i,\n      digits\n    });\n    if (otp === generatedOTP) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction generateQRCode({\n  issuer,\n  account,\n  secret,\n  digits = defaultDigits,\n  period = defaultPeriod\n}) {\n  const encodedIssuer = encodeURIComponent(issuer);\n  const encodedAccountName = encodeURIComponent(account);\n  const baseURI = `otpauth://totp/${encodedIssuer}:${encodedAccountName}`;\n  const params = new URLSearchParams({\n    secret: base32.encode(secret, {\n      padding: false\n    }),\n    issuer\n  });\n  if (digits !== void 0) {\n    params.set(\"digits\", digits.toString());\n  }\n  if (period !== void 0) {\n    params.set(\"period\", period.toString());\n  }\n  return `${baseURI}?${params.toString()}`;\n}\nconst createOTP = (secret, opts) => {\n  const digits = opts?.digits ?? defaultDigits;\n  const period = opts?.period ?? defaultPeriod;\n  return {\n    hotp: (counter) => generateHOTP(secret, { counter, digits }),\n    totp: () => generateTOTP(secret, { digits, period }),\n    verify: (otp, options) => verifyTOTP(otp, { secret, digits, period, ...options }),\n    url: (issuer, account) => generateQRCode({ issuer, account, secret, digits, period })\n  };\n};\n\nexport { createOTP };\n","import { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie, l as parseSetCookieHeader, n as deleteSessionCookie, o as parseCookies } from \"./cookies-D72PbWdz.mjs\";\nimport { u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/multi-session/index.ts\nconst ERROR_CODES = defineErrorCodes({ INVALID_SESSION_TOKEN: \"Invalid session token\" });\nconst multiSession = (options) => {\n\tconst opts = {\n\t\tmaximumSessions: 5,\n\t\t...options\n\t};\n\tconst isMultiSessionCookie = (key) => key.includes(\"_multi-\");\n\treturn {\n\t\tid: \"multi-session\",\n\t\tendpoints: {\n\t\t\tlistDeviceSessions: createAuthEndpoint(\"/multi-session/list-device-sessions\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\trequireHeaders: true\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\t\t\t\tif (!cookieHeader) return ctx.json([]);\n\t\t\t\tconst cookies = Object.fromEntries(parseCookies(cookieHeader));\n\t\t\t\tconst sessionTokens = (await Promise.all(Object.entries(cookies).filter(([key]) => isMultiSessionCookie(key)).map(async ([key]) => await ctx.getSignedCookie(key, ctx.context.secret)))).filter((v) => typeof v === \"string\");\n\t\t\t\tif (!sessionTokens.length) return ctx.json([]);\n\t\t\t\tconst uniqueUserSessions = (await ctx.context.internalAdapter.findSessions(sessionTokens)).filter((session) => session && session.session.expiresAt > /* @__PURE__ */ new Date()).reduce((acc, session) => {\n\t\t\t\t\tif (!acc.find((s) => s.user.id === session.user.id)) acc.push(session);\n\t\t\t\t\treturn acc;\n\t\t\t\t}, []);\n\t\t\t\treturn ctx.json(uniqueUserSessions);\n\t\t\t}),\n\t\t\tsetActiveSession: createAuthEndpoint(\"/multi-session/set-active\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ sessionToken: z.string().meta({ description: \"The session token to set as active\" }) }),\n\t\t\t\trequireHeaders: true,\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Set the active session\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { session: { $ref: \"#/components/schemas/Session\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst sessionToken = ctx.body.sessionToken;\n\t\t\t\tconst multiSessionCookieName = `${ctx.context.authCookies.sessionToken.name}_multi-${sessionToken.toLowerCase()}`;\n\t\t\t\tif (!await ctx.getSignedCookie(multiSessionCookieName, ctx.context.secret)) throw new APIError(\"UNAUTHORIZED\", { message: ERROR_CODES.INVALID_SESSION_TOKEN });\n\t\t\t\tconst session = await ctx.context.internalAdapter.findSession(sessionToken);\n\t\t\t\tif (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\tctx.setCookie(multiSessionCookieName, \"\", {\n\t\t\t\t\t\t...ctx.context.authCookies.sessionToken.options,\n\t\t\t\t\t\tmaxAge: 0\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: ERROR_CODES.INVALID_SESSION_TOKEN });\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(ctx, session);\n\t\t\t\treturn ctx.json(session);\n\t\t\t}),\n\t\t\trevokeDeviceSession: createAuthEndpoint(\"/multi-session/revoke\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ sessionToken: z.string().meta({ description: \"The session token to revoke\" }) }),\n\t\t\t\trequireHeaders: true,\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Revoke a device session\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst sessionToken = ctx.body.sessionToken;\n\t\t\t\tconst multiSessionCookieName = `${ctx.context.authCookies.sessionToken.name}_multi-${sessionToken.toLowerCase()}`;\n\t\t\t\tif (!await ctx.getSignedCookie(multiSessionCookieName, ctx.context.secret)) throw new APIError(\"UNAUTHORIZED\", { message: ERROR_CODES.INVALID_SESSION_TOKEN });\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(sessionToken);\n\t\t\t\tctx.setCookie(multiSessionCookieName, \"\", {\n\t\t\t\t\t...ctx.context.authCookies.sessionToken.options,\n\t\t\t\t\tmaxAge: 0\n\t\t\t\t});\n\t\t\t\tif (!(ctx.context.session?.session.token === sessionToken)) return ctx.json({ status: true });\n\t\t\t\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\t\t\t\tif (cookieHeader) {\n\t\t\t\t\tconst cookies = Object.fromEntries(parseCookies(cookieHeader));\n\t\t\t\t\tconst sessionTokens = (await Promise.all(Object.entries(cookies).filter(([key]) => isMultiSessionCookie(key)).map(async ([key]) => await ctx.getSignedCookie(key, ctx.context.secret)))).filter((v) => typeof v === \"string\");\n\t\t\t\t\tconst internalAdapter = ctx.context.internalAdapter;\n\t\t\t\t\tif (sessionTokens.length > 0) {\n\t\t\t\t\t\tconst validSessions = (await internalAdapter.findSessions(sessionTokens)).filter((session) => session && session.session.expiresAt > /* @__PURE__ */ new Date());\n\t\t\t\t\t\tif (validSessions.length > 0) {\n\t\t\t\t\t\t\tconst nextSession = validSessions[0];\n\t\t\t\t\t\t\tawait setSessionCookie(ctx, nextSession);\n\t\t\t\t\t\t} else deleteSessionCookie(ctx);\n\t\t\t\t\t} else deleteSessionCookie(ctx);\n\t\t\t\t} else deleteSessionCookie(ctx);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t})\n\t\t},\n\t\thooks: { after: [{\n\t\t\tmatcher: () => true,\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst cookieString = ctx.context.responseHeaders?.get(\"set-cookie\");\n\t\t\t\tif (!cookieString) return;\n\t\t\t\tconst setCookies = parseSetCookieHeader(cookieString);\n\t\t\t\tconst sessionCookieConfig = ctx.context.authCookies.sessionToken;\n\t\t\t\tconst sessionToken = ctx.context.newSession?.session.token;\n\t\t\t\tif (!sessionToken) return;\n\t\t\t\tconst cookies = parseCookies(ctx.headers?.get(\"cookie\") || \"\");\n\t\t\t\tconst cookieName = `${sessionCookieConfig.name}_multi-${sessionToken.toLowerCase()}`;\n\t\t\t\tif (setCookies.get(cookieName) || cookies.get(cookieName)) return;\n\t\t\t\tif (Object.keys(Object.fromEntries(cookies)).filter(isMultiSessionCookie).length + (cookieString.includes(\"session_token\") ? 1 : 0) >= opts.maximumSessions) return;\n\t\t\t\tawait ctx.setSignedCookie(cookieName, sessionToken, ctx.context.secret, sessionCookieConfig.options);\n\t\t\t})\n\t\t}, {\n\t\t\tmatcher: (context) => context.path === \"/sign-out\",\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\t\t\t\tif (!cookieHeader) return;\n\t\t\t\tconst cookies = Object.fromEntries(parseCookies(cookieHeader));\n\t\t\t\tconst multiSessionKeys = Object.keys(cookies).filter((key) => isMultiSessionCookie(key));\n\t\t\t\tconst verifiedTokens = (await Promise.all(multiSessionKeys.map(async (key) => {\n\t\t\t\t\tconst verifiedToken = await ctx.getSignedCookie(key, ctx.context.secret);\n\t\t\t\t\tif (verifiedToken) {\n\t\t\t\t\t\tctx.setCookie(key.toLowerCase().replace(\"__secure-\", \"__Secure-\"), \"\", {\n\t\t\t\t\t\t\t...ctx.context.authCookies.sessionToken.options,\n\t\t\t\t\t\t\tmaxAge: 0\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn verifiedToken;\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}))).filter((v) => typeof v === \"string\");\n\t\t\t\tif (verifiedTokens.length > 0) await ctx.context.internalAdapter.deleteSessions(verifiedTokens);\n\t\t\t})\n\t\t}] },\n\t\t$ERROR_CODES: ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { multiSession as t };","import { r as generateRandomString } from \"./crypto-CFUhAR9W.mjs\";\nimport { u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport * as z from \"zod\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { base64Url } from \"@better-auth/utils/base64\";\n\n//#region src/plugins/one-time-token/utils.ts\nconst defaultKeyHasher = async (token) => {\n\tconst hash = await createHash(\"SHA-256\").digest(new TextEncoder().encode(token));\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n};\n\n//#endregion\n//#region src/plugins/one-time-token/index.ts\nconst oneTimeToken = (options) => {\n\tconst opts = {\n\t\tstoreToken: \"plain\",\n\t\t...options\n\t};\n\tasync function storeToken(ctx, token) {\n\t\tif (opts.storeToken === \"hashed\") return await defaultKeyHasher(token);\n\t\tif (typeof opts.storeToken === \"object\" && \"type\" in opts.storeToken && opts.storeToken.type === \"custom-hasher\") return await opts.storeToken.hash(token);\n\t\treturn token;\n\t}\n\treturn {\n\t\tid: \"one-time-token\",\n\t\tendpoints: {\n\t\t\tgenerateOneTimeToken: createAuthEndpoint(\"/one-time-token/generate\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tuse: [sessionMiddleware]\n\t\t\t}, async (c) => {\n\t\t\t\tif (opts?.disableClientRequest && c.request) throw c.error(\"BAD_REQUEST\", { message: \"Client requests are disabled\" });\n\t\t\t\tconst session = c.context.session;\n\t\t\t\tconst token = opts?.generateToken ? await opts.generateToken(session, c) : generateRandomString(32);\n\t\t\t\tconst expiresAt = new Date(Date.now() + (opts?.expiresIn ?? 3) * 60 * 1e3);\n\t\t\t\tconst storedToken = await storeToken(c, token);\n\t\t\t\tawait c.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: session.session.token,\n\t\t\t\t\tidentifier: `one-time-token:${storedToken}`,\n\t\t\t\t\texpiresAt\n\t\t\t\t});\n\t\t\t\treturn c.json({ token });\n\t\t\t}),\n\t\t\tverifyOneTimeToken: createAuthEndpoint(\"/one-time-token/verify\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ token: z.string().meta({ description: \"The token to verify. Eg: \\\"some-token\\\"\" }) })\n\t\t\t}, async (c) => {\n\t\t\t\tconst { token } = c.body;\n\t\t\t\tconst storedToken = await storeToken(c, token);\n\t\t\t\tconst verificationValue = await c.context.internalAdapter.findVerificationValue(`one-time-token:${storedToken}`);\n\t\t\t\tif (!verificationValue) throw c.error(\"BAD_REQUEST\", { message: \"Invalid token\" });\n\t\t\t\tawait c.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw c.error(\"BAD_REQUEST\", { message: \"Token expired\" });\n\t\t\t\tconst session = await c.context.internalAdapter.findSession(verificationValue.value);\n\t\t\t\tif (!session) throw c.error(\"BAD_REQUEST\", { message: \"Session not found\" });\n\t\t\t\treturn c.json(session);\n\t\t\t})\n\t\t}\n\t};\n};\n\n//#endregion\nexport { oneTimeToken as t };","import { n as symmetricEncrypt, t as symmetricDecrypt } from \"./crypto-CFUhAR9W.mjs\";\nimport { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { getCurrentAuthContext } from \"@better-auth/core/context\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport * as z from \"zod\";\nimport { SignJWT, exportJWK, generateKeyPair, importJWK, jwtVerify } from \"jose\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\nimport { base64 } from \"@better-auth/utils/base64\";\nimport { getWebcryptoSubtle } from \"@better-auth/utils\";\n\n//#region src/plugins/jwt/adapter.ts\nconst getJwksAdapter = (adapter, options) => {\n\treturn {\n\t\tgetAllKeys: async (ctx) => {\n\t\t\tif (options?.adapter?.getJwks) return await options.adapter.getJwks(ctx);\n\t\t\treturn await adapter.findMany({ model: \"jwks\" });\n\t\t},\n\t\tgetLatestKey: async (ctx) => {\n\t\t\tif (options?.adapter?.getJwks) return (await options.adapter.getJwks(ctx))?.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0];\n\t\t\treturn (await adapter.findMany({ model: \"jwks\" }))?.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0];\n\t\t},\n\t\tcreateJwk: async (ctx, webKey) => {\n\t\t\tif (options?.adapter?.createJwk) return await options.adapter.createJwk(webKey, ctx);\n\t\t\treturn await adapter.create({\n\t\t\t\tmodel: \"jwks\",\n\t\t\t\tdata: {\n\t\t\t\t\t...webKey,\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/plugins/jwt/schema.ts\nconst schema = { jwks: { fields: {\n\tpublicKey: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\tprivateKey: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\tcreatedAt: {\n\t\ttype: \"date\",\n\t\trequired: true\n\t},\n\texpiresAt: {\n\t\ttype: \"date\",\n\t\trequired: false\n\t}\n} } };\n\n//#endregion\n//#region src/utils/time.ts\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\n/**\n* https://github.com/panva/jose/blob/723ee6152d7ee2fc81852d2d26777e86df6fce01/src/lib/secs.ts\n*/\nfunction joseSecs(str) {\n\tconst matched = REGEX.exec(str);\n\tif (!matched || matched[4] && matched[1]) throw new TypeError(\"Invalid time period format\");\n\tconst value = parseFloat(matched[2]);\n\tconst unit = matched[3].toLowerCase();\n\tlet numericDate;\n\tswitch (unit) {\n\t\tcase \"sec\":\n\t\tcase \"secs\":\n\t\tcase \"second\":\n\t\tcase \"seconds\":\n\t\tcase \"s\":\n\t\t\tnumericDate = Math.round(value);\n\t\t\tbreak;\n\t\tcase \"minute\":\n\t\tcase \"minutes\":\n\t\tcase \"min\":\n\t\tcase \"mins\":\n\t\tcase \"m\":\n\t\t\tnumericDate = Math.round(value * minute);\n\t\t\tbreak;\n\t\tcase \"hour\":\n\t\tcase \"hours\":\n\t\tcase \"hr\":\n\t\tcase \"hrs\":\n\t\tcase \"h\":\n\t\t\tnumericDate = Math.round(value * hour);\n\t\t\tbreak;\n\t\tcase \"day\":\n\t\tcase \"days\":\n\t\tcase \"d\":\n\t\t\tnumericDate = Math.round(value * day);\n\t\t\tbreak;\n\t\tcase \"week\":\n\t\tcase \"weeks\":\n\t\tcase \"w\":\n\t\t\tnumericDate = Math.round(value * week);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnumericDate = Math.round(value * year);\n\t\t\tbreak;\n\t}\n\tif (matched[1] === \"-\" || matched[4] === \"ago\") return -numericDate;\n\treturn numericDate;\n}\n\n//#endregion\n//#region src/plugins/jwt/utils.ts\n/**\n* Converts an expirationTime to ISO seconds expiration time (the format of JWT exp)\n*\n* See https://github.com/panva/jose/blob/main/src/lib/jwt_claims_set.ts#L245\n*\n* @param expirationTime - see options.jwt.expirationTime\n* @param iat - the iat time to consolidate on\n* @returns\n*/\nfunction toExpJWT(expirationTime, iat) {\n\tif (typeof expirationTime === \"number\") return expirationTime;\n\telse if (expirationTime instanceof Date) return Math.floor(expirationTime.getTime() / 1e3);\n\telse return iat + joseSecs(expirationTime);\n}\nasync function generateExportedKeyPair(options) {\n\tconst { alg, ...cfg } = options?.jwks?.keyPairConfig ?? {\n\t\talg: \"EdDSA\",\n\t\tcrv: \"Ed25519\"\n\t};\n\tconst { publicKey, privateKey } = await generateKeyPair(alg, {\n\t\t...cfg,\n\t\textractable: true\n\t});\n\treturn {\n\t\tpublicWebKey: await exportJWK(publicKey),\n\t\tprivateWebKey: await exportJWK(privateKey),\n\t\talg,\n\t\tcfg\n\t};\n}\n/**\n* Creates a Jwk on the database\n*\n* @param ctx\n* @param options\n* @returns\n*/\nasync function createJwk(ctx, options) {\n\tconst { publicWebKey, privateWebKey, alg, cfg } = await generateExportedKeyPair(options);\n\tconst stringifiedPrivateWebKey = JSON.stringify(privateWebKey);\n\tconst privateKeyEncryptionEnabled = !options?.jwks?.disablePrivateKeyEncryption;\n\tlet jwk = {\n\t\talg,\n\t\t...cfg && \"crv\" in cfg ? { crv: cfg.crv } : {},\n\t\tpublicKey: JSON.stringify(publicWebKey),\n\t\tprivateKey: privateKeyEncryptionEnabled ? JSON.stringify(await symmetricEncrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: stringifiedPrivateWebKey\n\t\t})) : stringifiedPrivateWebKey,\n\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t...options?.jwks?.rotationInterval ? { expiresAt: new Date(Date.now() + options.jwks.rotationInterval * 1e3) } : {}\n\t};\n\treturn await getJwksAdapter(ctx.context.adapter, options).createJwk(ctx, jwk);\n}\n\n//#endregion\n//#region src/plugins/jwt/sign.ts\nasync function signJWT(ctx, config) {\n\tconst { options, payload } = config;\n\tconst nowSeconds = Math.floor(Date.now() / 1e3);\n\tconst iat = payload.iat;\n\tlet exp = payload.exp;\n\tconst defaultExp = toExpJWT(options?.jwt?.expirationTime ?? \"15m\", iat ?? nowSeconds);\n\texp = exp ?? defaultExp;\n\tconst nbf = payload.nbf;\n\tconst iss = payload.iss;\n\tconst defaultIss = options?.jwt?.issuer ?? ctx.context.options.baseURL;\n\tconst aud = payload.aud;\n\tconst defaultAud = options?.jwt?.audience ?? ctx.context.options.baseURL;\n\tif (options?.jwt?.sign) {\n\t\tconst jwtPayload = {\n\t\t\t...payload,\n\t\t\tiat,\n\t\t\texp,\n\t\t\tnbf,\n\t\t\tiss: iss ?? defaultIss,\n\t\t\taud: aud ?? defaultAud\n\t\t};\n\t\treturn options.jwt.sign(jwtPayload);\n\t}\n\tlet key = await getJwksAdapter(ctx.context.adapter, options).getLatestKey(ctx);\n\tif (!key || key.expiresAt && key.expiresAt < /* @__PURE__ */ new Date()) key = await createJwk(ctx, options);\n\tlet privateWebKey = !options?.jwks?.disablePrivateKeyEncryption ? await symmetricDecrypt({\n\t\tkey: ctx.context.secret,\n\t\tdata: JSON.parse(key.privateKey)\n\t}).catch(() => {\n\t\tthrow new BetterAuthError(\"Failed to decrypt private key. Make sure the secret currently in use is the same as the one used to encrypt the private key. If you are using a different secret, either clean up your JWKS or disable private key encryption.\");\n\t}) : key.privateKey;\n\tconst alg = key.alg ?? options?.jwks?.keyPairConfig?.alg ?? \"EdDSA\";\n\tconst privateKey = await importJWK(JSON.parse(privateWebKey), alg);\n\tconst jwt$1 = new SignJWT(payload).setProtectedHeader({\n\t\talg,\n\t\tkid: key.id\n\t}).setExpirationTime(exp).setIssuer(iss ?? defaultIss).setAudience(aud ?? defaultAud);\n\tif (iat) jwt$1.setIssuedAt(iat);\n\tif (payload.sub) jwt$1.setSubject(payload.sub);\n\tif (payload.nbf) jwt$1.setNotBefore(payload.nbf);\n\tif (payload.jti) jwt$1.setJti(payload.jti);\n\treturn await jwt$1.sign(privateKey);\n}\nasync function getJwtToken(ctx, options) {\n\tconst payload = !options?.jwt?.definePayload ? ctx.context.session.user : await options?.jwt.definePayload(ctx.context.session);\n\treturn await signJWT(ctx, {\n\t\toptions,\n\t\tpayload: {\n\t\t\tiat: Math.floor(Date.now() / 1e3),\n\t\t\t...payload,\n\t\t\tsub: await options?.jwt?.getSubject?.(ctx.context.session) ?? ctx.context.session.user.id\n\t\t}\n\t});\n}\n\n//#endregion\n//#region src/plugins/jwt/verify.ts\n/**\n* Verify a JWT token using the JWKS public keys\n* Returns the payload if valid, null otherwise\n*/\nasync function verifyJWT(token, options) {\n\tconst ctx = await getCurrentAuthContext();\n\ttry {\n\t\tconst parts = token.split(\".\");\n\t\tif (parts.length !== 3) return null;\n\t\tconst headerStr = new TextDecoder().decode(base64.decode(parts[0]));\n\t\tconst kid = JSON.parse(headerStr).kid;\n\t\tif (!kid) {\n\t\t\tctx.context.logger.debug(\"JWT missing kid in header\");\n\t\t\treturn null;\n\t\t}\n\t\tconst keys = await getJwksAdapter(ctx.context.adapter, options).getAllKeys(ctx);\n\t\tif (!keys || keys.length === 0) {\n\t\t\tctx.context.logger.debug(\"No JWKS keys available\");\n\t\t\treturn null;\n\t\t}\n\t\tconst key = keys.find((k) => k.id === kid);\n\t\tif (!key) {\n\t\t\tctx.context.logger.debug(`No JWKS key found for kid: ${kid}`);\n\t\t\treturn null;\n\t\t}\n\t\tconst { payload } = await jwtVerify(token, await importJWK(JSON.parse(key.publicKey), key.alg ?? options?.jwks?.keyPairConfig?.alg ?? \"EdDSA\"), { issuer: options?.jwt?.issuer ?? ctx.context.options.baseURL });\n\t\tif (!payload.sub || !payload.aud) return null;\n\t\treturn payload;\n\t} catch (error) {\n\t\tctx.context.logger.debug(\"JWT verification failed\", error);\n\t\treturn null;\n\t}\n}\n\n//#endregion\n//#region src/plugins/jwt/index.ts\nconst jwt = (options) => {\n\tif (options?.jwt?.sign && !options.jwks?.remoteUrl) throw new BetterAuthError(\"jwks_config\", \"jwks.remoteUrl must be set when using jwt.sign\");\n\tif (options?.jwks?.remoteUrl && !options.jwks?.keyPairConfig?.alg) throw new BetterAuthError(\"jwks_config\", \"must specify alg when using the oidc plugin and jwks.remoteUrl\");\n\tconst jwksPath = options?.jwks?.jwksPath ?? \"/jwks\";\n\tif (typeof jwksPath !== \"string\" || jwksPath.length === 0 || !jwksPath.startsWith(\"/\") || jwksPath.includes(\"..\")) throw new BetterAuthError(\"jwks_config\", \"jwksPath must be a non-empty string starting with '/' and not contain '..'\");\n\treturn {\n\t\tid: \"jwt\",\n\t\toptions,\n\t\tendpoints: {\n\t\t\tgetJwks: createAuthEndpoint(jwksPath, {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"getJSONWebKeySet\",\n\t\t\t\t\tdescription: \"Get the JSON Web Key Set\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"JSON Web Key Set retrieved successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { keys: {\n\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\tdescription: \"Array of public JSON Web Keys\",\n\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tkid: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Key ID uniquely identifying the key, corresponds to the 'id' from the stored Jwk\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkty: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Key type (e.g., 'RSA', 'EC', 'OKP')\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\talg: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Algorithm intended for use with the key (e.g., 'EdDSA', 'RS256')\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tuse: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Intended use of the public key (e.g., 'sig' for signature)\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"sig\"],\n\t\t\t\t\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tn: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Modulus for RSA keys (base64url-encoded)\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\te: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Exponent for RSA keys (base64url-encoded)\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcrv: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Curve name for elliptic curve keys (e.g., 'Ed25519', 'P-256')\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"X coordinate for elliptic curve keys (base64url-encoded)\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Y coordinate for elliptic curve keys (base64url-encoded)\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\"kid\",\n\t\t\t\t\t\t\t\t\t\t\"kty\",\n\t\t\t\t\t\t\t\t\t\t\"alg\"\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} },\n\t\t\t\t\t\t\trequired: [\"keys\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (options?.jwks?.remoteUrl) throw new APIError(\"NOT_FOUND\");\n\t\t\t\tconst adapter = getJwksAdapter(ctx.context.adapter, options);\n\t\t\t\tlet keySets = await adapter.getAllKeys(ctx);\n\t\t\t\tif (!keySets || keySets?.length === 0) {\n\t\t\t\t\tawait createJwk(ctx, options);\n\t\t\t\t\tkeySets = await adapter.getAllKeys(ctx);\n\t\t\t\t}\n\t\t\t\tif (!keySets?.length) throw new BetterAuthError(\"No key sets found. Make sure you have a key in your database.\");\n\t\t\t\tconst now = Date.now();\n\t\t\t\tconst gracePeriod = (options?.jwks?.gracePeriod ?? 3600 * 24 * 30) * 1e3;\n\t\t\t\tconst keys = keySets.filter((key) => {\n\t\t\t\t\tif (!key.expiresAt) return true;\n\t\t\t\t\treturn key.expiresAt.getTime() + gracePeriod > now;\n\t\t\t\t});\n\t\t\t\tconst keyPairConfig = options?.jwks?.keyPairConfig;\n\t\t\t\tconst defaultCrv = keyPairConfig ? \"crv\" in keyPairConfig ? keyPairConfig.crv : void 0 : void 0;\n\t\t\t\treturn ctx.json({ keys: keys.map((keySet) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\talg: keySet.alg ?? options?.jwks?.keyPairConfig?.alg ?? \"EdDSA\",\n\t\t\t\t\t\tcrv: keySet.crv ?? defaultCrv,\n\t\t\t\t\t\t...JSON.parse(keySet.publicKey),\n\t\t\t\t\t\tkid: keySet.id\n\t\t\t\t\t};\n\t\t\t\t}) });\n\t\t\t}),\n\t\t\tgetToken: createAuthEndpoint(\"/token\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\trequireHeaders: true,\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"getJSONWebToken\",\n\t\t\t\t\tdescription: \"Get a JWT token\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { token: { type: \"string\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst jwt$1 = await getJwtToken(ctx, options);\n\t\t\t\treturn ctx.json({ token: jwt$1 });\n\t\t\t}),\n\t\t\tsignJWT: createAuthEndpoint(\"/sign-jwt\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmetadata: {\n\t\t\t\t\tSERVER_ONLY: true,\n\t\t\t\t\t$Infer: { body: {} }\n\t\t\t\t},\n\t\t\t\tbody: z.object({\n\t\t\t\t\tpayload: z.record(z.string(), z.any()),\n\t\t\t\t\toverrideOptions: z.record(z.string(), z.any()).optional()\n\t\t\t\t})\n\t\t\t}, async (c) => {\n\t\t\t\tconst jwt$1 = await signJWT(c, {\n\t\t\t\t\toptions: {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\t...c.body.overrideOptions\n\t\t\t\t\t},\n\t\t\t\t\tpayload: c.body.payload\n\t\t\t\t});\n\t\t\t\treturn c.json({ token: jwt$1 });\n\t\t\t}),\n\t\t\tverifyJWT: createAuthEndpoint(\"/verify-jwt\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmetadata: {\n\t\t\t\t\tSERVER_ONLY: true,\n\t\t\t\t\t$Infer: {\n\t\t\t\t\t\tbody: {},\n\t\t\t\t\t\tresponse: {}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tbody: z.object({\n\t\t\t\t\ttoken: z.string(),\n\t\t\t\t\tissuer: z.string().optional()\n\t\t\t\t})\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst overrideOptions = ctx.body.issuer ? {\n\t\t\t\t\t...options,\n\t\t\t\t\tjwt: {\n\t\t\t\t\t\t...options?.jwt,\n\t\t\t\t\t\tissuer: ctx.body.issuer\n\t\t\t\t\t}\n\t\t\t\t} : options;\n\t\t\t\tconst payload = await verifyJWT(ctx.body.token, overrideOptions);\n\t\t\t\treturn ctx.json({ payload });\n\t\t\t})\n\t\t},\n\t\thooks: { after: [{\n\t\t\tmatcher(context) {\n\t\t\t\treturn context.path === \"/get-session\";\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tif (options?.disableSettingJwtHeader) return;\n\t\t\t\tconst session = ctx.context.session || ctx.context.newSession;\n\t\t\t\tif (session && session.session) {\n\t\t\t\t\tconst jwt$1 = await getJwtToken(ctx, options);\n\t\t\t\t\tconst exposedHeaders = ctx.context.responseHeaders?.get(\"access-control-expose-headers\") || \"\";\n\t\t\t\t\tconst headersSet = new Set(exposedHeaders.split(\",\").map((header) => header.trim()).filter(Boolean));\n\t\t\t\t\theadersSet.add(\"set-auth-jwt\");\n\t\t\t\t\tctx.setHeader(\"set-auth-jwt\", jwt$1);\n\t\t\t\t\tctx.setHeader(\"Access-Control-Expose-Headers\", Array.from(headersSet).join(\", \"));\n\t\t\t\t}\n\t\t\t})\n\t\t}] },\n\t\tschema: mergeSchema(schema, options?.schema)\n\t};\n};\n\n//#endregion\nexport { generateExportedKeyPair as a, createJwk as i, verifyJWT as n, getJwtToken as r, jwt as t };","import { c as symmetricEncodeJWT, l as verifyJWT, o as signJWT, s as symmetricDecodeJWT } from \"./crypto-CFUhAR9W.mjs\";\nimport { l as parseUserOutput, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as safeJSONParse } from \"./json-CnHxKYpj.mjs\";\nimport { t as getBaseURL } from \"./url-CB8xCwz-.mjs\";\nimport { env, isProduction } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport * as z from \"zod\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport { ms } from \"ms\";\n\n//#region src/cookies/session-store.ts\nconst ALLOWED_COOKIE_SIZE = 4096;\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 200;\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;\n/**\n* Parse cookies from the request headers\n*/\nfunction parseCookiesFromContext(ctx) {\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) return {};\n\tconst cookies = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) cookies[name] = valueParts.join(\"=\");\n\t}\n\treturn cookies;\n}\n/**\n* Extract the chunk index from a cookie name\n*/\nfunction getChunkIndex(cookieName) {\n\tconst parts = cookieName.split(\".\");\n\tconst lastPart = parts[parts.length - 1];\n\tconst index = parseInt(lastPart || \"0\", 10);\n\treturn isNaN(index) ? 0 : index;\n}\n/**\n* Read all existing chunks from cookies\n*/\nfunction readExistingChunks(cookieName, ctx) {\n\tconst chunks = {};\n\tconst cookies = parseCookiesFromContext(ctx);\n\tfor (const [name, value] of Object.entries(cookies)) if (name.startsWith(cookieName)) chunks[name] = value;\n\treturn chunks;\n}\n/**\n* Get the full session data by joining all chunks\n*/\nfunction joinChunks(chunks) {\n\treturn Object.keys(chunks).sort((a, b) => {\n\t\treturn getChunkIndex(a) - getChunkIndex(b);\n\t}).map((key) => chunks[key]).join(\"\");\n}\n/**\n* Split a cookie value into chunks if needed\n*/\nfunction chunkCookie(storeName, cookie, chunks, logger$1) {\n\tconst chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);\n\tif (chunkCount === 1) {\n\t\tchunks[cookie.name] = cookie.value;\n\t\treturn [cookie];\n\t}\n\tconst cookies = [];\n\tfor (let i = 0; i < chunkCount; i++) {\n\t\tconst name = `${cookie.name}.${i}`;\n\t\tconst start = i * CHUNK_SIZE;\n\t\tconst value = cookie.value.substring(start, start + CHUNK_SIZE);\n\t\tcookies.push({\n\t\t\t...cookie,\n\t\t\tname,\n\t\t\tvalue\n\t\t});\n\t\tchunks[name] = value;\n\t}\n\tlogger$1.debug(`CHUNKING_${storeName.toUpperCase()}_COOKIE`, {\n\t\tmessage: `${storeName} cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n\t\temptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n\t\tvalueSize: cookie.value.length,\n\t\tchunkCount,\n\t\tchunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE)\n\t});\n\treturn cookies;\n}\n/**\n* Get all cookies that should be cleaned (removed)\n*/\nfunction getCleanCookies(chunks, cookieOptions) {\n\tconst cleanedChunks = {};\n\tfor (const name in chunks) cleanedChunks[name] = {\n\t\tname,\n\t\tvalue: \"\",\n\t\toptions: {\n\t\t\t...cookieOptions,\n\t\t\tmaxAge: 0\n\t\t}\n\t};\n\treturn cleanedChunks;\n}\n/**\n* Create a session store for handling cookie chunking.\n* When session data exceeds 4KB, it automatically splits it into multiple cookies.\n*\n* Based on next-auth's SessionStore implementation.\n* @see https://github.com/nextauthjs/next-auth/blob/27b2519b84b8eb9cf053775dea29d577d2aa0098/packages/next-auth/src/core/lib/cookie.ts\n*/\nconst storeFactory = (storeName) => (cookieName, cookieOptions, ctx) => {\n\tconst chunks = readExistingChunks(cookieName, ctx);\n\tconst logger$1 = ctx.context.logger;\n\treturn {\n\t\tgetValue() {\n\t\t\treturn joinChunks(chunks);\n\t\t},\n\t\thasChunks() {\n\t\t\treturn Object.keys(chunks).length > 0;\n\t\t},\n\t\tchunk(value, options) {\n\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\tfor (const name in chunks) delete chunks[name];\n\t\t\tconst cookies = cleanedChunks;\n\t\t\tconst chunked = chunkCookie(storeName, {\n\t\t\t\tname: cookieName,\n\t\t\t\tvalue,\n\t\t\t\toptions: {\n\t\t\t\t\t...cookieOptions,\n\t\t\t\t\t...options\n\t\t\t\t}\n\t\t\t}, chunks, logger$1);\n\t\t\tfor (const chunk of chunked) cookies[chunk.name] = chunk;\n\t\t\treturn Object.values(cookies);\n\t\t},\n\t\tclean() {\n\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\tfor (const name in chunks) delete chunks[name];\n\t\t\treturn Object.values(cleanedChunks);\n\t\t},\n\t\tsetCookies(cookies) {\n\t\t\tfor (const cookie of cookies) ctx.setCookie(cookie.name, cookie.value, cookie.options);\n\t\t}\n\t};\n};\nconst createSessionStore = storeFactory(\"Session\");\nconst createAccountStore = storeFactory(\"Account\");\nfunction getChunkedCookie(ctx, cookieName) {\n\tconst value = ctx.getCookie(cookieName);\n\tif (value) return value;\n\tconst chunks = [];\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) return null;\n\tconst cookies = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) cookies[name] = valueParts.join(\"=\");\n\t}\n\tfor (const [name, val] of Object.entries(cookies)) if (name.startsWith(cookieName + \".\")) {\n\t\tconst indexStr = name.split(\".\").at(-1);\n\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\tif (!isNaN(index)) chunks.push({\n\t\t\tindex,\n\t\t\tvalue: val\n\t\t});\n\t}\n\tif (chunks.length > 0) {\n\t\tchunks.sort((a, b) => a.index - b.index);\n\t\treturn chunks.map((c) => c.value).join(\"\");\n\t}\n\treturn null;\n}\nasync function setAccountCookie(c, accountData) {\n\tconst accountDataCookie = c.context.authCookies.accountData;\n\tconst options = {\n\t\tmaxAge: 300,\n\t\t...accountDataCookie.options\n\t};\n\tconst data = await symmetricEncodeJWT(accountData, c.context.secret, \"better-auth-account\", options.maxAge);\n\tif (data.length > ALLOWED_COOKIE_SIZE) {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\t\tconst cookies = accountStore.chunk(data, options);\n\t\taccountStore.setCookies(cookies);\n\t} else {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\t\tif (accountStore.hasChunks()) {\n\t\t\tconst cleanCookies = accountStore.clean();\n\t\t\taccountStore.setCookies(cleanCookies);\n\t\t}\n\t\tc.setCookie(accountDataCookie.name, data, options);\n\t}\n}\nasync function getAccountCookie(c) {\n\tconst accountCookie = getChunkedCookie(c, c.context.authCookies.accountData.name);\n\tif (accountCookie) {\n\t\tconst accountData = safeJSONParse(await symmetricDecodeJWT(accountCookie, c.context.secret, \"better-auth-account\"));\n\t\tif (accountData) return accountData;\n\t}\n\treturn null;\n}\nconst getSessionQuerySchema = z.optional(z.object({\n\tdisableCookieCache: z.coerce.boolean().meta({ description: \"Disable cookie cache and fetch session from database\" }).optional(),\n\tdisableRefresh: z.coerce.boolean().meta({ description: \"Disable session refresh. Useful for checking session status, without updating the session\" }).optional()\n}));\n\n//#endregion\n//#region src/cookies/cookie-utils.ts\nfunction parseSetCookieHeader(setCookie) {\n\tconst cookies = /* @__PURE__ */ new Map();\n\tsetCookie.split(\", \").forEach((cookieString) => {\n\t\tconst [nameValue, ...attributes] = cookieString.split(\";\").map((part) => part.trim());\n\t\tconst [name, ...valueParts] = (nameValue || \"\").split(\"=\");\n\t\tconst value = valueParts.join(\"=\");\n\t\tif (!name || value === void 0) return;\n\t\tconst attrObj = { value };\n\t\tattributes.forEach((attribute) => {\n\t\t\tconst [attrName, ...attrValueParts] = attribute.split(\"=\");\n\t\t\tconst attrValue = attrValueParts.join(\"=\");\n\t\t\tconst normalizedAttrName = attrName.trim().toLowerCase();\n\t\t\tswitch (normalizedAttrName) {\n\t\t\t\tcase \"max-age\":\n\t\t\t\t\tattrObj[\"max-age\"] = attrValue ? parseInt(attrValue.trim(), 10) : void 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"expires\":\n\t\t\t\t\tattrObj.expires = attrValue ? new Date(attrValue.trim()) : void 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"domain\":\n\t\t\t\t\tattrObj.domain = attrValue ? attrValue.trim() : void 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"path\":\n\t\t\t\t\tattrObj.path = attrValue ? attrValue.trim() : void 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"secure\":\n\t\t\t\t\tattrObj.secure = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"httponly\":\n\t\t\t\t\tattrObj.httponly = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"samesite\":\n\t\t\t\t\tattrObj.samesite = attrValue ? attrValue.trim().toLowerCase() : void 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tattrObj[normalizedAttrName] = attrValue ? attrValue.trim() : true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\tcookies.set(name, attrObj);\n\t});\n\treturn cookies;\n}\nfunction setCookieToHeader(headers) {\n\treturn (context) => {\n\t\tconst setCookieHeader = context.response.headers.get(\"set-cookie\");\n\t\tif (!setCookieHeader) return;\n\t\tconst cookieMap = /* @__PURE__ */ new Map();\n\t\t(headers.get(\"cookie\") || \"\").split(\";\").forEach((cookie) => {\n\t\t\tconst [name, ...rest] = cookie.trim().split(\"=\");\n\t\t\tif (name && rest.length > 0) cookieMap.set(name, rest.join(\"=\"));\n\t\t});\n\t\tsetCookieHeader.split(\",\").forEach((header) => {\n\t\t\tparseSetCookieHeader(header).forEach((value, name) => {\n\t\t\t\tcookieMap.set(name, value.value);\n\t\t\t});\n\t\t});\n\t\tconst updatedCookies = Array.from(cookieMap.entries()).map(([name, value]) => `${name}=${value}`).join(\"; \");\n\t\theaders.set(\"cookie\", updatedCookies);\n\t};\n}\n\n//#endregion\n//#region src/cookies/index.ts\nfunction createCookieGetter(options) {\n\tconst secureCookiePrefix = (options.advanced?.useSecureCookies !== void 0 ? options.advanced?.useSecureCookies : options.baseURL !== void 0 ? options.baseURL.startsWith(\"https://\") ? true : false : isProduction) ? \"__Secure-\" : \"\";\n\tconst crossSubdomainEnabled = !!options.advanced?.crossSubDomainCookies?.enabled;\n\tconst domain = crossSubdomainEnabled ? options.advanced?.crossSubDomainCookies?.domain || (options.baseURL ? new URL(options.baseURL).hostname : void 0) : void 0;\n\tif (crossSubdomainEnabled && !domain) throw new BetterAuthError(\"baseURL is required when crossSubdomainCookies are enabled\");\n\tfunction createCookie(cookieName, overrideAttributes = {}) {\n\t\tconst prefix = options.advanced?.cookiePrefix || \"better-auth\";\n\t\tconst name = options.advanced?.cookies?.[cookieName]?.name || `${prefix}.${cookieName}`;\n\t\tconst attributes = options.advanced?.cookies?.[cookieName]?.attributes;\n\t\treturn {\n\t\t\tname: `${secureCookiePrefix}${name}`,\n\t\t\tattributes: {\n\t\t\t\tsecure: !!secureCookiePrefix,\n\t\t\t\tsameSite: \"lax\",\n\t\t\t\tpath: \"/\",\n\t\t\t\thttpOnly: true,\n\t\t\t\t...crossSubdomainEnabled ? { domain } : {},\n\t\t\t\t...options.advanced?.defaultCookieAttributes,\n\t\t\t\t...overrideAttributes,\n\t\t\t\t...attributes\n\t\t\t}\n\t\t};\n\t}\n\treturn createCookie;\n}\nfunction getCookies(options) {\n\tconst createCookie = createCookieGetter(options);\n\tconst sessionToken = createCookie(\"session_token\", { maxAge: options.session?.expiresIn || ms(\"7d\") / 1e3 });\n\tconst sessionData = createCookie(\"session_data\", { maxAge: options.session?.cookieCache?.maxAge || 300 });\n\tconst accountData = createCookie(\"account_data\", { maxAge: options.session?.cookieCache?.maxAge || 300 });\n\tconst dontRememberToken = createCookie(\"dont_remember\");\n\treturn {\n\t\tsessionToken: {\n\t\t\tname: sessionToken.name,\n\t\t\toptions: sessionToken.attributes\n\t\t},\n\t\tsessionData: {\n\t\t\tname: sessionData.name,\n\t\t\toptions: sessionData.attributes\n\t\t},\n\t\tdontRememberToken: {\n\t\t\tname: dontRememberToken.name,\n\t\t\toptions: dontRememberToken.attributes\n\t\t},\n\t\taccountData: {\n\t\t\tname: accountData.name,\n\t\t\toptions: accountData.attributes\n\t\t}\n\t};\n}\nasync function setCookieCache(ctx, session, dontRememberMe) {\n\tif (ctx.context.options.session?.cookieCache?.enabled) {\n\t\tconst filteredSession = Object.entries(session.session).reduce((acc, [key, value]) => {\n\t\t\tconst fieldConfig = ctx.context.options.session?.additionalFields?.[key];\n\t\t\tif (!fieldConfig || fieldConfig.returned !== false) acc[key] = value;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tconst filteredUser = parseUserOutput(ctx.context.options, session.user);\n\t\tconst versionConfig = ctx.context.options.session?.cookieCache?.version;\n\t\tlet version = \"1\";\n\t\tif (versionConfig) {\n\t\t\tif (typeof versionConfig === \"string\") version = versionConfig;\n\t\t\telse if (typeof versionConfig === \"function\") {\n\t\t\t\tconst result = versionConfig(session.session, session.user);\n\t\t\t\tversion = result instanceof Promise ? await result : result;\n\t\t\t}\n\t\t}\n\t\tconst sessionData = {\n\t\t\tsession: filteredSession,\n\t\t\tuser: filteredUser,\n\t\t\tupdatedAt: Date.now(),\n\t\t\tversion\n\t\t};\n\t\tconst options = {\n\t\t\t...ctx.context.authCookies.sessionData.options,\n\t\t\tmaxAge: dontRememberMe ? void 0 : ctx.context.authCookies.sessionData.options.maxAge\n\t\t};\n\t\tconst expiresAtDate = getDate(options.maxAge || 60, \"sec\").getTime();\n\t\tconst strategy = ctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\t\tlet data;\n\t\tif (strategy === \"jwe\") data = await symmetricEncodeJWT(sessionData, ctx.context.secret, \"better-auth-session\", options.maxAge || 300);\n\t\telse if (strategy === \"jwt\") data = await signJWT(sessionData, ctx.context.secret, options.maxAge || 300);\n\t\telse data = base64Url.encode(JSON.stringify({\n\t\t\tsession: sessionData,\n\t\t\texpiresAt: expiresAtDate,\n\t\t\tsignature: await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(ctx.context.secret, JSON.stringify({\n\t\t\t\t...sessionData,\n\t\t\t\texpiresAt: expiresAtDate\n\t\t\t}))\n\t\t}), { padding: false });\n\t\tif (data.length > 4093) {\n\t\t\tconst sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, options, ctx);\n\t\t\tconst cookies = sessionStore.chunk(data, options);\n\t\t\tsessionStore.setCookies(cookies);\n\t\t} else {\n\t\t\tconst sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, options, ctx);\n\t\t\tif (sessionStore.hasChunks()) {\n\t\t\t\tconst cleanCookies = sessionStore.clean();\n\t\t\t\tsessionStore.setCookies(cleanCookies);\n\t\t\t}\n\t\t\tctx.setCookie(ctx.context.authCookies.sessionData.name, data, options);\n\t\t}\n\t}\n}\nasync function setSessionCookie(ctx, session, dontRememberMe, overrides) {\n\tconst dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);\n\tdontRememberMe = dontRememberMe !== void 0 ? dontRememberMe : !!dontRememberMeCookie;\n\tconst options = ctx.context.authCookies.sessionToken.options;\n\tconst maxAge = dontRememberMe ? void 0 : ctx.context.sessionConfig.expiresIn;\n\tawait ctx.setSignedCookie(ctx.context.authCookies.sessionToken.name, session.session.token, ctx.context.secret, {\n\t\t...options,\n\t\tmaxAge,\n\t\t...overrides\n\t});\n\tif (dontRememberMe) await ctx.setSignedCookie(ctx.context.authCookies.dontRememberToken.name, \"true\", ctx.context.secret, ctx.context.authCookies.dontRememberToken.options);\n\tawait setCookieCache(ctx, session, dontRememberMe);\n\tctx.context.setNewSession(session);\n\t/**\n\t* If secondary storage is enabled, store the session data in the secondary storage\n\t* This is useful if the session got updated and we want to update the session data in the\n\t* secondary storage\n\t*/\n\tif (ctx.context.options.secondaryStorage) await ctx.context.secondaryStorage?.set(session.session.token, JSON.stringify({\n\t\tuser: session.user,\n\t\tsession: session.session\n\t}), Math.floor((new Date(session.session.expiresAt).getTime() - Date.now()) / 1e3));\n}\nfunction deleteSessionCookie(ctx, skipDontRememberMe) {\n\tctx.setCookie(ctx.context.authCookies.sessionToken.name, \"\", {\n\t\t...ctx.context.authCookies.sessionToken.options,\n\t\tmaxAge: 0\n\t});\n\tconst sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, ctx.context.authCookies.sessionData.options, ctx);\n\tconst cleanCookies = sessionStore.clean();\n\tsessionStore.setCookies(cleanCookies);\n\tif (!skipDontRememberMe) ctx.setCookie(ctx.context.authCookies.dontRememberToken.name, \"\", {\n\t\t...ctx.context.authCookies.dontRememberToken.options,\n\t\tmaxAge: 0\n\t});\n}\nfunction parseCookies(cookieHeader) {\n\tconst cookies = cookieHeader.split(\"; \");\n\tconst cookieMap = /* @__PURE__ */ new Map();\n\tcookies.forEach((cookie) => {\n\t\tconst [name, value] = cookie.split(\"=\");\n\t\tcookieMap.set(name, value);\n\t});\n\treturn cookieMap;\n}\nconst getSessionCookie = (request, config) => {\n\tif (config?.cookiePrefix) if (config.cookieName) config.cookiePrefix = `${config.cookiePrefix}-`;\n\telse config.cookiePrefix = `${config.cookiePrefix}.`;\n\tconst headers = \"headers\" in request ? request.headers : request;\n\tconst req = request instanceof Request ? request : void 0;\n\tgetBaseURL(req?.url, config?.path, req);\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) return null;\n\tconst { cookieName = \"session_token\", cookiePrefix = \"better-auth.\" } = config || {};\n\tconst name = `${cookiePrefix}${cookieName}`;\n\tconst secureCookieName = `__Secure-${name}`;\n\tconst parsedCookie = parseCookies(cookies);\n\tconst sessionToken = parsedCookie.get(name) || parsedCookie.get(secureCookieName);\n\tif (sessionToken) return sessionToken;\n\treturn null;\n};\nconst getCookieCache = async (request, config) => {\n\tconst cookies = (request instanceof Headers ? request : request.headers).get(\"cookie\");\n\tif (!cookies) return null;\n\tconst { cookieName = \"session_data\", cookiePrefix = \"better-auth\" } = config || {};\n\tconst name = config?.isSecure !== void 0 ? config.isSecure ? `__Secure-${cookiePrefix}.${cookieName}` : `${cookiePrefix}.${cookieName}` : isProduction ? `__Secure-${cookiePrefix}.${cookieName}` : `${cookiePrefix}.${cookieName}`;\n\tconst parsedCookie = parseCookies(cookies);\n\tlet sessionData = parsedCookie.get(name);\n\tif (!sessionData) {\n\t\tconst chunks = [];\n\t\tfor (const [cookieName$1, value] of parsedCookie.entries()) if (cookieName$1.startsWith(name + \".\")) {\n\t\t\tconst parts = cookieName$1.split(\".\");\n\t\t\tconst indexStr = parts[parts.length - 1];\n\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\tif (!isNaN(index)) chunks.push({\n\t\t\t\tindex,\n\t\t\t\tvalue\n\t\t\t});\n\t\t}\n\t\tif (chunks.length > 0) {\n\t\t\tchunks.sort((a, b) => a.index - b.index);\n\t\t\tsessionData = chunks.map((c) => c.value).join(\"\");\n\t\t}\n\t}\n\tif (sessionData) {\n\t\tconst secret = config?.secret || env.BETTER_AUTH_SECRET;\n\t\tif (!secret) throw new BetterAuthError(\"getCookieCache requires a secret to be provided. Either pass it as an option or set the BETTER_AUTH_SECRET environment variable\");\n\t\tconst strategy = config?.strategy || \"compact\";\n\t\tif (strategy === \"jwe\") {\n\t\t\tconst payload = await symmetricDecodeJWT(sessionData, secret, \"better-auth-session\");\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") expectedVersion = config.version;\n\t\t\t\t\telse if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = result instanceof Promise ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) return null;\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else if (strategy === \"jwt\") {\n\t\t\tconst payload = await verifyJWT(sessionData, secret);\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") expectedVersion = config.version;\n\t\t\t\t\telse if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = result instanceof Promise ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) return null;\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst sessionDataPayload = safeJSONParse(binary.decode(base64Url.decode(sessionData)));\n\t\t\tif (!sessionDataPayload) return null;\n\t\t\tif (!await createHMAC(\"SHA-256\", \"base64urlnopad\").verify(secret, JSON.stringify({\n\t\t\t\t...sessionDataPayload.session,\n\t\t\t\texpiresAt: sessionDataPayload.expiresAt\n\t\t\t}), sessionDataPayload.signature)) return null;\n\t\t\tif (config?.version && sessionDataPayload.session) {\n\t\t\t\tconst cookieVersion = sessionDataPayload.session.version || \"1\";\n\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\tif (typeof config.version === \"string\") expectedVersion = config.version;\n\t\t\t\telse if (typeof config.version === \"function\") {\n\t\t\t\t\tconst result = config.version(sessionDataPayload.session.session, sessionDataPayload.session.user);\n\t\t\t\t\texpectedVersion = result instanceof Promise ? await result : result;\n\t\t\t\t}\n\t\t\t\tif (cookieVersion !== expectedVersion) return null;\n\t\t\t}\n\t\t\treturn sessionDataPayload.session;\n\t\t}\n\t}\n\treturn null;\n};\n\n//#endregion\nexport { getSessionCookie as a, setSessionCookie as c, createSessionStore as d, getAccountCookie as f, setAccountCookie as h, getCookies as i, parseSetCookieHeader as l, getSessionQuerySchema as m, deleteSessionCookie as n, parseCookies as o, getChunkedCookie as p, getCookieCache as r, setCookieCache as s, createCookieGetter as t, setCookieToHeader as u };","import \"../crypto-CFUhAR9W.mjs\";\nimport \"../schema-Bb7wzeK_.mjs\";\nimport \"../json-CnHxKYpj.mjs\";\nimport \"../url-CB8xCwz-.mjs\";\nimport { l as parseSetCookieHeader } from \"../cookies-D72PbWdz.mjs\";\nimport { createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/integrations/next-js.ts\nfunction toNextJsHandler(auth) {\n\tconst handler = async (request) => {\n\t\treturn \"handler\" in auth ? auth.handler(request) : auth(request);\n\t};\n\treturn {\n\t\tGET: handler,\n\t\tPOST: handler,\n\t\tPATCH: handler,\n\t\tPUT: handler,\n\t\tDELETE: handler\n\t};\n}\nconst nextCookies = () => {\n\treturn {\n\t\tid: \"next-cookies\",\n\t\thooks: { after: [{\n\t\t\tmatcher(ctx) {\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst returned = ctx.context.responseHeaders;\n\t\t\t\tif (\"_flag\" in ctx && ctx._flag === \"router\") return;\n\t\t\t\tif (returned instanceof Headers) {\n\t\t\t\t\tconst setCookies = returned?.get(\"set-cookie\");\n\t\t\t\t\tif (!setCookies) return;\n\t\t\t\t\tconst parsed = parseSetCookieHeader(setCookies);\n\t\t\t\t\tconst { cookies } = await import(\"next/headers\");\n\t\t\t\t\tlet cookieHelper;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcookieHelper = await cookies();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof Error && error.message.startsWith(\"`cookies` was called outside a request scope.\")) return;\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t\tparsed.forEach((value, key) => {\n\t\t\t\t\t\tif (!key) return;\n\t\t\t\t\t\tconst opts = {\n\t\t\t\t\t\t\tsameSite: value.samesite,\n\t\t\t\t\t\t\tsecure: value.secure,\n\t\t\t\t\t\t\tmaxAge: value[\"max-age\"],\n\t\t\t\t\t\t\thttpOnly: value.httponly,\n\t\t\t\t\t\t\tdomain: value.domain,\n\t\t\t\t\t\t\tpath: value.path\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookieHelper.set(key, decodeURIComponent(value.value), opts);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t})\n\t\t}] }\n\t};\n};\n\n//#endregion\nexport { nextCookies, toNextJsHandler };","import { r as generateRandomString } from \"./crypto-CFUhAR9W.mjs\";\nimport { L as originCheck } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport * as z from \"zod\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { base64Url } from \"@better-auth/utils/base64\";\n\n//#region src/plugins/magic-link/utils.ts\nconst defaultKeyHasher = async (otp) => {\n\tconst hash = await createHash(\"SHA-256\").digest(new TextEncoder().encode(otp));\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n};\n\n//#endregion\n//#region src/plugins/magic-link/index.ts\nconst magicLink = (options) => {\n\tconst opts = {\n\t\tstoreToken: \"plain\",\n\t\t...options\n\t};\n\tasync function storeToken(ctx, token) {\n\t\tif (opts.storeToken === \"hashed\") return await defaultKeyHasher(token);\n\t\tif (typeof opts.storeToken === \"object\" && \"type\" in opts.storeToken && opts.storeToken.type === \"custom-hasher\") return await opts.storeToken.hash(token);\n\t\treturn token;\n\t}\n\treturn {\n\t\tid: \"magic-link\",\n\t\tendpoints: {\n\t\t\tsignInMagicLink: createAuthEndpoint(\"/sign-in/magic-link\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\trequireHeaders: true,\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.email().meta({ description: \"Email address to send the magic link\" }),\n\t\t\t\t\tname: z.string().meta({ description: \"User display name. Only used if the user is registering for the first time. Eg: \\\"my-name\\\"\" }).optional(),\n\t\t\t\t\tcallbackURL: z.string().meta({ description: \"URL to redirect after magic link verification\" }).optional(),\n\t\t\t\t\tnewUserCallbackURL: z.string().meta({ description: \"URL to redirect after new user signup. Only used if the user is registering for the first time.\" }).optional(),\n\t\t\t\t\terrorCallbackURL: z.string().meta({ description: \"URL to redirect after error.\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"signInWithMagicLink\",\n\t\t\t\t\tdescription: \"Sign in with magic link\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { email } = ctx.body;\n\t\t\t\tconst verificationToken = opts?.generateToken ? await opts.generateToken(email) : generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst storedToken = await storeToken(ctx, verificationToken);\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tidentifier: storedToken,\n\t\t\t\t\tvalue: JSON.stringify({\n\t\t\t\t\t\temail,\n\t\t\t\t\t\tname: ctx.body.name\n\t\t\t\t\t}),\n\t\t\t\t\texpiresAt: new Date(Date.now() + (opts.expiresIn || 300) * 1e3)\n\t\t\t\t});\n\t\t\t\tconst realBaseURL = new URL(ctx.context.baseURL);\n\t\t\t\tconst pathname = realBaseURL.pathname === \"/\" ? \"\" : realBaseURL.pathname;\n\t\t\t\tconst basePath = pathname ? \"\" : ctx.context.options.basePath || \"\";\n\t\t\t\tconst url = new URL(`${pathname}${basePath}/magic-link/verify`, realBaseURL.origin);\n\t\t\t\turl.searchParams.set(\"token\", verificationToken);\n\t\t\t\turl.searchParams.set(\"callbackURL\", ctx.body.callbackURL || \"/\");\n\t\t\t\tif (ctx.body.newUserCallbackURL) url.searchParams.set(\"newUserCallbackURL\", ctx.body.newUserCallbackURL);\n\t\t\t\tif (ctx.body.errorCallbackURL) url.searchParams.set(\"errorCallbackURL\", ctx.body.errorCallbackURL);\n\t\t\t\tawait options.sendMagicLink({\n\t\t\t\t\temail,\n\t\t\t\t\turl: url.toString(),\n\t\t\t\t\ttoken: verificationToken\n\t\t\t\t}, ctx);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t}),\n\t\t\tmagicLinkVerify: createAuthEndpoint(\"/magic-link/verify\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: z.object({\n\t\t\t\t\ttoken: z.string().meta({ description: \"Verification token\" }),\n\t\t\t\t\tcallbackURL: z.string().meta({ description: \"URL to redirect after magic link verification, if not provided the user will be redirected to the root URL. Eg: \\\"/dashboard\\\"\" }).optional(),\n\t\t\t\t\terrorCallbackURL: z.string().meta({ description: \"URL to redirect after error.\" }).optional(),\n\t\t\t\t\tnewUserCallbackURL: z.string().meta({ description: \"URL to redirect after new user signup. Only used if the user is registering for the first time.\" }).optional()\n\t\t\t\t}),\n\t\t\t\tuse: [\n\t\t\t\t\toriginCheck((ctx) => {\n\t\t\t\t\t\treturn ctx.query.callbackURL ? decodeURIComponent(ctx.query.callbackURL) : \"/\";\n\t\t\t\t\t}),\n\t\t\t\t\toriginCheck((ctx) => {\n\t\t\t\t\t\treturn ctx.query.newUserCallbackURL ? decodeURIComponent(ctx.query.newUserCallbackURL) : \"/\";\n\t\t\t\t\t}),\n\t\t\t\t\toriginCheck((ctx) => {\n\t\t\t\t\t\treturn ctx.query.errorCallbackURL ? decodeURIComponent(ctx.query.errorCallbackURL) : \"/\";\n\t\t\t\t\t})\n\t\t\t\t],\n\t\t\t\trequireHeaders: true,\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"verifyMagicLink\",\n\t\t\t\t\tdescription: \"Verify magic link\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" },\n\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst token = ctx.query.token;\n\t\t\t\tconst callbackURL = new URL(ctx.query.callbackURL ? decodeURIComponent(ctx.query.callbackURL) : \"/\", ctx.context.baseURL).toString();\n\t\t\t\tconst errorCallbackURL = new URL(ctx.query.errorCallbackURL ? decodeURIComponent(ctx.query.errorCallbackURL) : callbackURL, ctx.context.baseURL).toString();\n\t\t\t\tconst newUserCallbackURL = new URL(ctx.query.newUserCallbackURL ? decodeURIComponent(ctx.query.newUserCallbackURL) : callbackURL, ctx.context.baseURL).toString();\n\t\t\t\tcallbackURL?.startsWith(\"http\") || (callbackURL ? `${ctx.context.options.baseURL}${callbackURL}` : ctx.context.options.baseURL);\n\t\t\t\tconst storedToken = await storeToken(ctx, token);\n\t\t\t\tconst tokenValue = await ctx.context.internalAdapter.findVerificationValue(storedToken);\n\t\t\t\tif (!tokenValue) throw ctx.redirect(`${errorCallbackURL}?error=INVALID_TOKEN`);\n\t\t\t\tif (tokenValue.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(tokenValue.id);\n\t\t\t\t\tthrow ctx.redirect(`${errorCallbackURL}?error=EXPIRED_TOKEN`);\n\t\t\t\t}\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(tokenValue.id);\n\t\t\t\tconst { email, name } = JSON.parse(tokenValue.value);\n\t\t\t\tlet isNewUser = false;\n\t\t\t\tlet user = await ctx.context.internalAdapter.findUserByEmail(email).then((res) => res?.user);\n\t\t\t\tif (!user) if (!opts.disableSignUp) {\n\t\t\t\t\tconst newUser = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\t\temail,\n\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t\tname: name || \"\"\n\t\t\t\t\t});\n\t\t\t\t\tisNewUser = true;\n\t\t\t\t\tuser = newUser;\n\t\t\t\t\tif (!user) throw ctx.redirect(`${errorCallbackURL}?error=failed_to_create_user`);\n\t\t\t\t} else throw ctx.redirect(`${errorCallbackURL}?error=new_user_signup_disabled`);\n\t\t\t\tif (!user.emailVerified) user = await ctx.context.internalAdapter.updateUser(user.id, { emailVerified: true });\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.id);\n\t\t\t\tif (!session) throw ctx.redirect(`${errorCallbackURL}?error=failed_to_create_session`);\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser\n\t\t\t\t});\n\t\t\t\tif (!ctx.query.callbackURL) return ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\temailVerified: user.emailVerified,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\tcreatedAt: user.createdAt,\n\t\t\t\t\t\tupdatedAt: user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (isNewUser) throw ctx.redirect(newUserCallbackURL);\n\t\t\t\tthrow ctx.redirect(callbackURL);\n\t\t\t})\n\t\t},\n\t\trateLimit: [{\n\t\t\tpathMatcher(path) {\n\t\t\t\treturn path.startsWith(\"/sign-in/magic-link\") || path.startsWith(\"/magic-link/verify\");\n\t\t\t},\n\t\t\twindow: opts.rateLimit?.window || 60,\n\t\t\tmax: opts.rateLimit?.max || 5\n\t\t}]\n\t};\n};\n\n//#endregion\nexport { magicLink as t };","import { r as generateRandomString } from \"./crypto-CFUhAR9W.mjs\";\nimport { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { r as getSessionFromCtx } from \"./session-AaRl3_x-.mjs\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { ms } from \"ms\";\n\n//#region src/plugins/device-authorization/error-codes.ts\nconst DEVICE_AUTHORIZATION_ERROR_CODES = defineErrorCodes({\n\tINVALID_DEVICE_CODE: \"Invalid device code\",\n\tEXPIRED_DEVICE_CODE: \"Device code has expired\",\n\tEXPIRED_USER_CODE: \"User code has expired\",\n\tAUTHORIZATION_PENDING: \"Authorization pending\",\n\tACCESS_DENIED: \"Access denied\",\n\tINVALID_USER_CODE: \"Invalid user code\",\n\tDEVICE_CODE_ALREADY_PROCESSED: \"Device code already processed\",\n\tPOLLING_TOO_FREQUENTLY: \"Polling too frequently\",\n\tUSER_NOT_FOUND: \"User not found\",\n\tFAILED_TO_CREATE_SESSION: \"Failed to create session\",\n\tINVALID_DEVICE_CODE_STATUS: \"Invalid device code status\",\n\tAUTHENTICATION_REQUIRED: \"Authentication required\"\n});\n\n//#endregion\n//#region src/plugins/device-authorization/schema.ts\nconst schema = { deviceCode: { fields: {\n\tdeviceCode: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\tuserCode: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\tuserId: {\n\t\ttype: \"string\",\n\t\trequired: false\n\t},\n\texpiresAt: {\n\t\ttype: \"date\",\n\t\trequired: true\n\t},\n\tstatus: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\tlastPolledAt: {\n\t\ttype: \"date\",\n\t\trequired: false\n\t},\n\tpollingInterval: {\n\t\ttype: \"number\",\n\t\trequired: false\n\t},\n\tclientId: {\n\t\ttype: \"string\",\n\t\trequired: false\n\t},\n\tscope: {\n\t\ttype: \"string\",\n\t\trequired: false\n\t}\n} } };\nconst deviceCode = z.object({\n\tid: z.string(),\n\tdeviceCode: z.string(),\n\tuserCode: z.string(),\n\tuserId: z.string().optional(),\n\texpiresAt: z.date(),\n\tstatus: z.string(),\n\tlastPolledAt: z.date().optional(),\n\tpollingInterval: z.number().optional(),\n\tclientId: z.string().optional(),\n\tscope: z.string().optional()\n});\n\n//#endregion\n//#region src/plugins/device-authorization/index.ts\nconst msStringValueSchema = z.custom((val) => {\n\ttry {\n\t\tms(val);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\treturn true;\n}, { message: \"Invalid time string format. Use formats like '30m', '5s', '1h', etc.\" });\nconst deviceAuthorizationOptionsSchema = z.object({\n\texpiresIn: msStringValueSchema.default(\"30m\").describe(\"Time in seconds until the device code expires. Use formats like '30m', '5s', '1h', etc.\"),\n\tinterval: msStringValueSchema.default(\"5s\").describe(\"Time in seconds between polling attempts. Use formats like '30m', '5s', '1h', etc.\"),\n\tdeviceCodeLength: z.number().int().positive().default(40).describe(\"Length of the device code to be generated. Default is 40 characters.\"),\n\tuserCodeLength: z.number().int().positive().default(8).describe(\"Length of the user code to be generated. Default is 8 characters.\"),\n\tgenerateDeviceCode: z.custom((val) => typeof val === \"function\", { message: \"generateDeviceCode must be a function that returns a string or a promise that resolves to a string.\" }).optional().describe(\"Function to generate a device code. If not provided, a default random string generator will be used.\"),\n\tgenerateUserCode: z.custom((val) => typeof val === \"function\", { message: \"generateUserCode must be a function that returns a string or a promise that resolves to a string.\" }).optional().describe(\"Function to generate a user code. If not provided, a default random string generator will be used.\"),\n\tvalidateClient: z.custom((val) => typeof val === \"function\", { message: \"validateClient must be a function that returns a boolean or a promise that resolves to a boolean.\" }).optional().describe(\"Function to validate the client ID. If not provided, no validation will be performed.\"),\n\tonDeviceAuthRequest: z.custom((val) => typeof val === \"function\", { message: \"onDeviceAuthRequest must be a function that returns void or a promise that resolves to void.\" }).optional().describe(\"Function to handle device authorization requests. If not provided, no additional actions will be taken.\"),\n\tverificationUri: z.string().optional().describe(\"The URI where users verify their device code. Can be an absolute URL (https://example.com/device) or relative path (/custom-path). This will be returned as verification_uri in the device code response. If not provided, defaults to /device.\"),\n\tschema: z.custom(() => true)\n});\nconst defaultCharset = \"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\";\n/**\n* @internal\n*/\nconst defaultGenerateDeviceCode = (length) => {\n\treturn generateRandomString(length, \"a-z\", \"A-Z\", \"0-9\");\n};\n/**\n* @internal\n*/\nconst defaultGenerateUserCode = (length) => {\n\tconst chars = new Uint8Array(length);\n\treturn Array.from(crypto.getRandomValues(chars)).map((byte) => defaultCharset[byte % 32]).join(\"\");\n};\n/**\n* @internal\n*/\nconst buildVerificationUris = (verificationUri, baseURL, userCode) => {\n\tconst uri = verificationUri || \"/device\";\n\tlet verificationUrl;\n\ttry {\n\t\tverificationUrl = new URL(uri);\n\t} catch {\n\t\tverificationUrl = new URL(uri, baseURL);\n\t}\n\tconst verificationUriCompleteUrl = new URL(verificationUrl);\n\tverificationUriCompleteUrl.searchParams.set(\"user_code\", userCode);\n\treturn {\n\t\tverificationUri: verificationUrl.toString(),\n\t\tverificationUriComplete: verificationUriCompleteUrl.toString()\n\t};\n};\nconst deviceAuthorization = (options = {}) => {\n\tconst opts = deviceAuthorizationOptionsSchema.parse(options);\n\tconst generateDeviceCode = async () => {\n\t\tif (opts.generateDeviceCode) return opts.generateDeviceCode();\n\t\treturn defaultGenerateDeviceCode(opts.deviceCodeLength);\n\t};\n\tconst generateUserCode = async () => {\n\t\tif (opts.generateUserCode) return opts.generateUserCode();\n\t\treturn defaultGenerateUserCode(opts.userCodeLength);\n\t};\n\treturn {\n\t\tid: \"device-authorization\",\n\t\tschema: mergeSchema(schema, options?.schema),\n\t\tendpoints: {\n\t\t\tdeviceCode: createAuthEndpoint(\"/device/code\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tclient_id: z.string().meta({ description: \"The client ID of the application\" }),\n\t\t\t\t\tscope: z.string().meta({ description: \"Space-separated list of scopes\" }).optional()\n\t\t\t\t}),\n\t\t\t\terror: z.object({\n\t\t\t\t\terror: z.enum([\"invalid_request\", \"invalid_client\"]).meta({ description: \"Error code\" }),\n\t\t\t\t\terror_description: z.string().meta({ description: \"Detailed error description\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: `Request a device and user code\n\nFollow [rfc8628#section-3.2](https://datatracker.ietf.org/doc/html/rfc8628#section-3.2)`,\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t200: {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tdevice_code: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The device verification code\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tuser_code: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The user code to display\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverification_uri: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The URL for user verification. Defaults to /device if not configured.\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverification_uri_complete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The complete URL with user code as query parameter.\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpires_in: {\n\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Lifetime in seconds of the device code\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tinterval: {\n\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Minimum polling interval in seconds\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t400: {\n\t\t\t\t\t\t\tdescription: \"Error response\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tenum: [\"invalid_request\", \"invalid_client\"]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\terror_description: { type: \"string\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (opts.validateClient) {\n\t\t\t\t\tif (!await opts.validateClient(ctx.body.client_id)) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client\",\n\t\t\t\t\t\terror_description: \"Invalid client ID\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (opts.onDeviceAuthRequest) await opts.onDeviceAuthRequest(ctx.body.client_id, ctx.body.scope);\n\t\t\t\tconst deviceCode$1 = await generateDeviceCode();\n\t\t\t\tconst userCode = await generateUserCode();\n\t\t\t\tconst expiresIn = ms(opts.expiresIn);\n\t\t\t\tconst expiresAt = new Date(Date.now() + expiresIn);\n\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tdeviceCode: deviceCode$1,\n\t\t\t\t\t\tuserCode,\n\t\t\t\t\t\texpiresAt,\n\t\t\t\t\t\tstatus: \"pending\",\n\t\t\t\t\t\tpollingInterval: ms(opts.interval),\n\t\t\t\t\t\tclientId: ctx.body.client_id,\n\t\t\t\t\t\tscope: ctx.body.scope\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst { verificationUri, verificationUriComplete } = buildVerificationUris(opts.verificationUri, ctx.context.baseURL, userCode);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tdevice_code: deviceCode$1,\n\t\t\t\t\tuser_code: userCode,\n\t\t\t\t\tverification_uri: verificationUri,\n\t\t\t\t\tverification_uri_complete: verificationUriComplete,\n\t\t\t\t\texpires_in: Math.floor(expiresIn / 1e3),\n\t\t\t\t\tinterval: Math.floor(ms(opts.interval) / 1e3)\n\t\t\t\t}, { headers: { \"Cache-Control\": \"no-store\" } });\n\t\t\t}),\n\t\t\tdeviceToken: createAuthEndpoint(\"/device/token\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tgrant_type: z.literal(\"urn:ietf:params:oauth:grant-type:device_code\").meta({ description: \"The grant type for device flow\" }),\n\t\t\t\t\tdevice_code: z.string().meta({ description: \"The device verification code\" }),\n\t\t\t\t\tclient_id: z.string().meta({ description: \"The client ID of the application\" })\n\t\t\t\t}),\n\t\t\t\terror: z.object({\n\t\t\t\t\terror: z.enum([\n\t\t\t\t\t\t\"authorization_pending\",\n\t\t\t\t\t\t\"slow_down\",\n\t\t\t\t\t\t\"expired_token\",\n\t\t\t\t\t\t\"access_denied\",\n\t\t\t\t\t\t\"invalid_request\",\n\t\t\t\t\t\t\"invalid_grant\"\n\t\t\t\t\t]).meta({ description: \"Error code\" }),\n\t\t\t\t\terror_description: z.string().meta({ description: \"Detailed error description\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: `Exchange device code for access token\n\nFollow [rfc8628#section-3.4](https://datatracker.ietf.org/doc/html/rfc8628#section-3.4)`,\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t200: {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" },\n\t\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t400: {\n\t\t\t\t\t\t\tdescription: \"Error response\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tenum: [\n\t\t\t\t\t\t\t\t\t\t\t\"authorization_pending\",\n\t\t\t\t\t\t\t\t\t\t\t\"slow_down\",\n\t\t\t\t\t\t\t\t\t\t\t\"expired_token\",\n\t\t\t\t\t\t\t\t\t\t\t\"access_denied\",\n\t\t\t\t\t\t\t\t\t\t\t\"invalid_request\",\n\t\t\t\t\t\t\t\t\t\t\t\"invalid_grant\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\terror_description: { type: \"string\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { device_code, client_id } = ctx.body;\n\t\t\t\tif (opts.validateClient) {\n\t\t\t\t\tif (!await opts.validateClient(client_id)) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_grant\",\n\t\t\t\t\t\terror_description: \"Invalid client ID\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst deviceCodeRecord = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"deviceCode\",\n\t\t\t\t\t\tvalue: device_code\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!deviceCodeRecord) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_grant\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_DEVICE_CODE\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.clientId && deviceCodeRecord.clientId !== client_id) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_grant\",\n\t\t\t\t\terror_description: \"Client ID mismatch\"\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.lastPolledAt && deviceCodeRecord.pollingInterval) {\n\t\t\t\t\tif (Date.now() - new Date(deviceCodeRecord.lastPolledAt).getTime() < deviceCodeRecord.pollingInterval) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"slow_down\",\n\t\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.POLLING_TOO_FREQUENTLY\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait ctx.context.adapter.update({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: deviceCodeRecord.id\n\t\t\t\t\t}],\n\t\t\t\t\tupdate: { lastPolledAt: /* @__PURE__ */ new Date() }\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\tvalue: deviceCodeRecord.id\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"expired_token\",\n\t\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_DEVICE_CODE\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (deviceCodeRecord.status === \"pending\") throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"authorization_pending\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHORIZATION_PENDING\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.status === \"denied\") {\n\t\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\tvalue: deviceCodeRecord.id\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"access_denied\",\n\t\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.ACCESS_DENIED\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (deviceCodeRecord.status === \"approved\" && deviceCodeRecord.userId) {\n\t\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(deviceCodeRecord.userId);\n\t\t\t\t\tif (!user) throw new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\terror: \"server_error\",\n\t\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.USER_NOT_FOUND\n\t\t\t\t\t});\n\t\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.id);\n\t\t\t\t\tif (!session) throw new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\terror: \"server_error\",\n\t\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.FAILED_TO_CREATE_SESSION\n\t\t\t\t\t});\n\t\t\t\t\tctx.context.setNewSession({\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tuser\n\t\t\t\t\t});\n\t\t\t\t\tif (ctx.context.options.secondaryStorage) await ctx.context.secondaryStorage?.set(session.token, JSON.stringify({\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\tsession\n\t\t\t\t\t}), Math.floor((new Date(session.expiresAt).getTime() - Date.now()) / 1e3));\n\t\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\tvalue: deviceCodeRecord.id\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\taccess_token: session.token,\n\t\t\t\t\t\ttoken_type: \"Bearer\",\n\t\t\t\t\t\texpires_in: Math.floor((new Date(session.expiresAt).getTime() - Date.now()) / 1e3),\n\t\t\t\t\t\tscope: deviceCodeRecord.scope || \"\"\n\t\t\t\t\t}, { headers: {\n\t\t\t\t\t\t\"Cache-Control\": \"no-store\",\n\t\t\t\t\t\tPragma: \"no-cache\"\n\t\t\t\t\t} });\n\t\t\t\t}\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\terror: \"server_error\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_DEVICE_CODE_STATUS\n\t\t\t\t});\n\t\t\t}),\n\t\t\tdeviceVerify: createAuthEndpoint(\"/device\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: z.object({ user_code: z.string().meta({ description: \"The user code to verify\" }) }),\n\t\t\t\terror: z.object({\n\t\t\t\t\terror: z.enum([\"invalid_request\"]).meta({ description: \"Error code\" }),\n\t\t\t\t\terror_description: z.string().meta({ description: \"Detailed error description\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Verify user code and get device authorization status\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Device authorization status\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tuser_code: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"The user code to verify\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tenum: [\n\t\t\t\t\t\t\t\t\t\t\"pending\",\n\t\t\t\t\t\t\t\t\t\t\"approved\",\n\t\t\t\t\t\t\t\t\t\t\"denied\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tdescription: \"Current status of the device authorization\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { user_code } = ctx.query;\n\t\t\t\tconst cleanUserCode = user_code.replace(/-/g, \"\");\n\t\t\t\tconst deviceCodeRecord = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userCode\",\n\t\t\t\t\t\tvalue: cleanUserCode\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!deviceCodeRecord) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"expired_token\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tuser_code,\n\t\t\t\t\tstatus: deviceCodeRecord.status\n\t\t\t\t});\n\t\t\t}),\n\t\t\tdeviceApprove: createAuthEndpoint(\"/device/approve\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userCode: z.string().meta({ description: \"The user code to approve\" }) }),\n\t\t\t\terror: z.object({\n\t\t\t\t\terror: z.enum([\n\t\t\t\t\t\t\"invalid_request\",\n\t\t\t\t\t\t\"expired_token\",\n\t\t\t\t\t\t\"device_code_already_processed\"\n\t\t\t\t\t]).meta({ description: \"Error code\" }),\n\t\t\t\t\terror_description: z.string().meta({ description: \"Detailed error description\" })\n\t\t\t\t}),\n\t\t\t\trequireHeaders: true,\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Approve device authorization\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tif (!session) throw new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\terror: \"unauthorized\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHENTICATION_REQUIRED\n\t\t\t\t});\n\t\t\t\tconst { userCode } = ctx.body;\n\t\t\t\tconst cleanUserCode = userCode.replace(/-/g, \"\");\n\t\t\t\tconst deviceCodeRecord = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userCode\",\n\t\t\t\t\t\tvalue: cleanUserCode\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!deviceCodeRecord) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"expired_token\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.status !== \"pending\") throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED\n\t\t\t\t});\n\t\t\t\tawait ctx.context.adapter.update({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: deviceCodeRecord.id\n\t\t\t\t\t}],\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\tstatus: \"approved\",\n\t\t\t\t\t\tuserId: session.user.id\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t}),\n\t\t\tdeviceDeny: createAuthEndpoint(\"/device/deny\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userCode: z.string().meta({ description: \"The user code to deny\" }) }),\n\t\t\t\terror: z.object({\n\t\t\t\t\terror: z.enum([\"invalid_request\", \"expired_token\"]).meta({ description: \"Error code\" }),\n\t\t\t\t\terror_description: z.string().meta({ description: \"Detailed error description\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Deny device authorization\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { userCode } = ctx.body;\n\t\t\t\tconst cleanUserCode = userCode.replace(/-/g, \"\");\n\t\t\t\tconst deviceCodeRecord = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userCode\",\n\t\t\t\t\t\tvalue: cleanUserCode\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!deviceCodeRecord) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"expired_token\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE\n\t\t\t\t});\n\t\t\t\tif (deviceCodeRecord.status !== \"pending\") throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\terror_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED\n\t\t\t\t});\n\t\t\t\tawait ctx.context.adapter.update({\n\t\t\t\t\tmodel: \"deviceCode\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: deviceCodeRecord.id\n\t\t\t\t\t}],\n\t\t\t\t\tupdate: { status: \"denied\" }\n\t\t\t\t});\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t})\n\t\t},\n\t\t$ERROR_CODES: DEVICE_AUTHORIZATION_ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { deviceAuthorizationOptionsSchema as n, deviceAuthorization as t };","import { t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie, l as parseSetCookieHeader } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx } from \"./session-AaRl3_x-.mjs\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/anonymous/error-codes.ts\nconst ANONYMOUS_ERROR_CODES = defineErrorCodes({\n\tINVALID_EMAIL_FORMAT: \"Email was not generated in a valid format\",\n\tFAILED_TO_CREATE_USER: \"Failed to create user\",\n\tCOULD_NOT_CREATE_SESSION: \"Could not create session\",\n\tANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY: \"Anonymous users cannot sign in again anonymously\"\n});\n\n//#endregion\n//#region src/plugins/anonymous/schema.ts\nconst schema = { user: { fields: { isAnonymous: {\n\ttype: \"boolean\",\n\trequired: false,\n\tinput: false,\n\tdefaultValue: false\n} } } };\n\n//#endregion\n//#region src/plugins/anonymous/index.ts\nasync function getAnonUserEmail(options) {\n\tconst customEmail = await options?.generateRandomEmail?.();\n\tif (customEmail) {\n\t\tif (!z.email().safeParse(customEmail).success) throw new APIError(\"BAD_REQUEST\", { message: ANONYMOUS_ERROR_CODES.INVALID_EMAIL_FORMAT });\n\t\treturn customEmail;\n\t}\n\tconst id = generateId();\n\tif (options?.emailDomainName) return `temp-${id}@${options.emailDomainName}`;\n\treturn `temp@${id}.com`;\n}\nconst anonymous = (options) => {\n\treturn {\n\t\tid: \"anonymous\",\n\t\tendpoints: { signInAnonymous: createAuthEndpoint(\"/sign-in/anonymous\", {\n\t\t\tmethod: \"POST\",\n\t\t\tmetadata: { openapi: {\n\t\t\t\tdescription: \"Sign in anonymously\",\n\t\t\t\tresponses: { 200: {\n\t\t\t\t\tdescription: \"Sign in anonymously\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" },\n\t\t\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t} }\n\t\t}, async (ctx) => {\n\t\t\tif ((await getSessionFromCtx(ctx, { disableRefresh: true }))?.user.isAnonymous) throw new APIError(\"BAD_REQUEST\", { message: ANONYMOUS_ERROR_CODES.ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY });\n\t\t\tconst email = await getAnonUserEmail(options);\n\t\t\tconst name = await options?.generateName?.(ctx) || \"Anonymous\";\n\t\t\tconst newUser = await ctx.context.internalAdapter.createUser({\n\t\t\t\temail,\n\t\t\t\temailVerified: false,\n\t\t\t\tisAnonymous: true,\n\t\t\t\tname,\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t});\n\t\t\tif (!newUser) throw ctx.error(\"INTERNAL_SERVER_ERROR\", { message: ANONYMOUS_ERROR_CODES.FAILED_TO_CREATE_USER });\n\t\t\tconst session = await ctx.context.internalAdapter.createSession(newUser.id);\n\t\t\tif (!session) return ctx.json(null, {\n\t\t\t\tstatus: 400,\n\t\t\t\tbody: { message: ANONYMOUS_ERROR_CODES.COULD_NOT_CREATE_SESSION }\n\t\t\t});\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession,\n\t\t\t\tuser: newUser\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\ttoken: session.token,\n\t\t\t\tuser: {\n\t\t\t\t\tid: newUser.id,\n\t\t\t\t\temail: newUser.email,\n\t\t\t\t\temailVerified: newUser.emailVerified,\n\t\t\t\t\tname: newUser.name,\n\t\t\t\t\tcreatedAt: newUser.createdAt,\n\t\t\t\t\tupdatedAt: newUser.updatedAt\n\t\t\t\t}\n\t\t\t});\n\t\t}) },\n\t\thooks: { after: [{\n\t\t\tmatcher(ctx) {\n\t\t\t\treturn ctx.path.startsWith(\"/sign-in\") || ctx.path.startsWith(\"/sign-up\") || ctx.path.startsWith(\"/callback\") || ctx.path.startsWith(\"/oauth2/callback\") || ctx.path.startsWith(\"/magic-link/verify\") || ctx.path.startsWith(\"/email-otp/verify-email\") || ctx.path.startsWith(\"/one-tap/callback\") || ctx.path.startsWith(\"/passkey/verify-authentication\") || ctx.path.startsWith(\"/phone-number/verify\");\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst setCookie = ctx.context.responseHeaders?.get(\"set-cookie\");\n\t\t\t\t/**\n\t\t\t\t* We can consider the user is about to sign in or sign up\n\t\t\t\t* if the response contains a session token.\n\t\t\t\t*/\n\t\t\t\tconst sessionTokenName = ctx.context.authCookies.sessionToken.name;\n\t\t\t\tif (!parseSetCookieHeader(setCookie || \"\").get(sessionTokenName)?.value.split(\".\")[0]) return;\n\t\t\t\t/**\n\t\t\t\t* Make sure the user had an anonymous session.\n\t\t\t\t*/\n\t\t\t\tconst session = await getSessionFromCtx(ctx, { disableRefresh: true });\n\t\t\t\tif (!session || !session.user.isAnonymous) return;\n\t\t\t\tif (ctx.path === \"/sign-in/anonymous\" && !ctx.context.newSession) throw new APIError(\"BAD_REQUEST\", { message: ANONYMOUS_ERROR_CODES.ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY });\n\t\t\t\tconst newSession = ctx.context.newSession;\n\t\t\t\tif (!newSession) return;\n\t\t\t\tif (options?.onLinkAccount) await options?.onLinkAccount?.({\n\t\t\t\t\tanonymousUser: session,\n\t\t\t\t\tnewUser: newSession,\n\t\t\t\t\tctx\n\t\t\t\t});\n\t\t\t\tif (!options?.disableDeleteAnonymousUser) await ctx.context.internalAdapter.deleteUser(session.user.id);\n\t\t\t})\n\t\t}] },\n\t\tschema: mergeSchema(schema, options?.schema),\n\t\t$ERROR_CODES: ANONYMOUS_ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { anonymous as t };","import { n as symmetricEncrypt, t as symmetricDecrypt } from \"./crypto-CFUhAR9W.mjs\";\nimport { r as getOrigin } from \"./url-CB8xCwz-.mjs\";\nimport { L as originCheck } from \"./api-CkmycQ2x.mjs\";\nimport { l as parseSetCookieHeader } from \"./cookies-D72PbWdz.mjs\";\nimport { t as parseJSON } from \"./parser-pHp5yoAv.mjs\";\nimport { env } from \"@better-auth/core/env\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/oauth-proxy/utils.ts\n/**\n* Get base URL from vendor-specific environment variables\n*/\nfunction getVendorBaseURL() {\n\tconst vercel = env.VERCEL_URL ? `https://${env.VERCEL_URL}` : void 0;\n\tconst netlify = env.NETLIFY_URL;\n\tconst render = env.RENDER_URL;\n\tconst aws = env.AWS_LAMBDA_FUNCTION_NAME;\n\tconst google = env.GOOGLE_CLOUD_FUNCTION_NAME;\n\tconst azure = env.AZURE_FUNCTION_NAME;\n\treturn vercel || netlify || render || aws || google || azure;\n}\n/**\n* Resolve the current URL from various sources\n*/\nfunction resolveCurrentURL(ctx, opts) {\n\treturn new URL(opts?.currentURL || ctx.request?.url || getVendorBaseURL() || ctx.context.baseURL);\n}\n/**\n* Check if the proxy should be skipped for this request\n*/\nfunction checkSkipProxy(ctx, opts) {\n\tif (ctx.request?.headers.get(\"x-skip-oauth-proxy\")) return true;\n\tconst productionURL = opts?.productionURL || env.BETTER_AUTH_URL;\n\tif (!productionURL) return false;\n\tconst currentURL = ctx.request?.url || getVendorBaseURL();\n\tif (!currentURL) return false;\n\treturn getOrigin(productionURL) === getOrigin(currentURL);\n}\n\n//#endregion\n//#region src/plugins/oauth-proxy/index.ts\nconst oAuthProxy = (opts) => {\n\treturn {\n\t\tid: \"oauth-proxy\",\n\t\toptions: opts,\n\t\tendpoints: { oAuthProxy: createAuthEndpoint(\"/oauth-proxy-callback\", {\n\t\t\tmethod: \"GET\",\n\t\t\toperationId: \"oauthProxyCallback\",\n\t\t\tquery: z.object({\n\t\t\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after the proxy\" }),\n\t\t\t\tcookies: z.string().meta({ description: \"The cookies to set after the proxy\" })\n\t\t\t}),\n\t\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\t\tmetadata: { openapi: {\n\t\t\t\toperationId: \"oauthProxyCallback\",\n\t\t\t\tdescription: \"OAuth Proxy Callback\",\n\t\t\t\tparameters: [{\n\t\t\t\t\tin: \"query\",\n\t\t\t\t\tname: \"callbackURL\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tdescription: \"The URL to redirect to after the proxy\"\n\t\t\t\t}, {\n\t\t\t\t\tin: \"query\",\n\t\t\t\t\tname: \"cookies\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tdescription: \"The cookies to set after the proxy\"\n\t\t\t\t}],\n\t\t\t\tresponses: { 302: {\n\t\t\t\t\tdescription: \"Redirect\",\n\t\t\t\t\theaders: { Location: {\n\t\t\t\t\t\tdescription: \"The URL to redirect to\",\n\t\t\t\t\t\tschema: { type: \"string\" }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t} }\n\t\t}, async (ctx) => {\n\t\t\tconst decryptedCookies = await symmetricDecrypt({\n\t\t\t\tkey: ctx.context.secret,\n\t\t\t\tdata: ctx.query.cookies\n\t\t\t}).catch((e) => {\n\t\t\t\tctx.context.logger.error(\"Failed to decrypt OAuth proxy cookies:\", e);\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tif (!decryptedCookies) {\n\t\t\t\tconst errorURL = ctx.context.options.onAPIError?.errorURL || `${ctx.context.options.baseURL}/api/auth/error`;\n\t\t\t\tthrow ctx.redirect(`${errorURL}?error=OAuthProxy - Invalid cookies or secret`);\n\t\t\t}\n\t\t\tconst isSecureContext = resolveCurrentURL(ctx, opts).protocol === \"https:\";\n\t\t\tconst parsedCookies = parseSetCookieHeader(decryptedCookies);\n\t\t\tconst processedCookies = Array.from(parsedCookies.entries()).map(([name, attrs]) => {\n\t\t\t\tconst options = {};\n\t\t\t\tif (attrs.path) options.path = attrs.path;\n\t\t\t\tif (attrs.expires) options.expires = attrs.expires;\n\t\t\t\tif (attrs.samesite) options.sameSite = attrs.samesite;\n\t\t\t\tif (attrs.httponly) options.httpOnly = true;\n\t\t\t\tif (attrs[\"max-age\"] !== void 0) options.maxAge = attrs[\"max-age\"];\n\t\t\t\tif (isSecureContext) options.secure = true;\n\t\t\t\treturn {\n\t\t\t\t\tname,\n\t\t\t\t\toptions,\n\t\t\t\t\tvalue: decodeURIComponent(attrs.value)\n\t\t\t\t};\n\t\t\t});\n\t\t\tfor (const cookie of processedCookies) ctx.setCookie(cookie.name, cookie.value, cookie.options);\n\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t}) },\n\t\thooks: {\n\t\t\tbefore: [\n\t\t\t\t{\n\t\t\t\t\tmatcher(context) {\n\t\t\t\t\t\treturn !!(context.path?.startsWith(\"/sign-in/social\") || context.path?.startsWith(\"/sign-in/oauth2\"));\n\t\t\t\t\t},\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tif (checkSkipProxy(ctx, opts)) return;\n\t\t\t\t\t\tconst currentURL = resolveCurrentURL(ctx, opts);\n\t\t\t\t\t\tconst originalCallbackURL = ctx.body?.callbackURL || ctx.context.baseURL;\n\t\t\t\t\t\tconst newCallbackURL = `${currentURL.origin}${ctx.context.options.basePath || \"/api/auth\"}/oauth-proxy-callback?callbackURL=${encodeURIComponent(originalCallbackURL)}`;\n\t\t\t\t\t\tif (!ctx.body) return;\n\t\t\t\t\t\tctx.body.callbackURL = newCallbackURL;\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmatcher(context) {\n\t\t\t\t\t\treturn !!(context.path?.startsWith(\"/callback\") || context.path?.startsWith(\"/oauth2/callback\"));\n\t\t\t\t\t},\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tconst state = ctx.query?.state || ctx.body?.state;\n\t\t\t\t\t\tif (!state || typeof state !== \"string\") return;\n\t\t\t\t\t\tlet statePackage;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tstatePackage = parseJSON(await symmetricDecrypt({\n\t\t\t\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\t\t\t\tdata: state\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!statePackage.isOAuthProxy || !statePackage.state || !statePackage.stateCookie) return;\n\t\t\t\t\t\tlet stateCookieValue;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tstateCookieValue = await symmetricDecrypt({\n\t\t\t\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\t\t\t\tdata: statePackage.stateCookie\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparseJSON(stateCookieValue);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tctx.context.logger.error(\"Failed to decrypt OAuth proxy state cookie:\", e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.context._oauthProxySnapshot = {\n\t\t\t\t\t\t\tstoreStateStrategy: ctx.context.oauthConfig.storeStateStrategy,\n\t\t\t\t\t\t\tskipStateCookieCheck: ctx.context.oauthConfig.skipStateCookieCheck,\n\t\t\t\t\t\t\tinternalAdapter: ctx.context.internalAdapter\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst originalAdapter = ctx.context.internalAdapter;\n\t\t\t\t\t\tconst capturedStatePackage = statePackage;\n\t\t\t\t\t\tctx.context.oauthConfig.storeStateStrategy = \"database\";\n\t\t\t\t\t\tctx.context.internalAdapter = {\n\t\t\t\t\t\t\t...ctx.context.internalAdapter,\n\t\t\t\t\t\t\tfindVerificationValue: async (identifier) => {\n\t\t\t\t\t\t\t\tif (identifier === capturedStatePackage.state) return {\n\t\t\t\t\t\t\t\t\tid: `oauth-proxy-${capturedStatePackage.state}`,\n\t\t\t\t\t\t\t\t\tidentifier: capturedStatePackage.state,\n\t\t\t\t\t\t\t\t\tvalue: stateCookieValue,\n\t\t\t\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(Date.now() + 600 * 1e3)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturn originalAdapter.findVerificationValue(identifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (ctx.query?.state) ctx.query.state = statePackage.state;\n\t\t\t\t\t\tif (ctx.body?.state) ctx.body.state = statePackage.state;\n\t\t\t\t\t\tctx.context.oauthConfig.skipStateCookieCheck = true;\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmatcher() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tif (ctx.path !== \"/callback/:id\") return;\n\t\t\t\t\t\tif (ctx.context.oauthConfig.storeStateStrategy === \"cookie\") return;\n\t\t\t\t\t\tif (ctx.context._oauthProxySnapshot) return;\n\t\t\t\t\t\tconst state = ctx.query?.state || ctx.body?.state;\n\t\t\t\t\t\tif (!state) return;\n\t\t\t\t\t\tconst data = await ctx.context.internalAdapter.findVerificationValue(state);\n\t\t\t\t\t\tif (!data) return;\n\t\t\t\t\t\tlet parsedState;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tparsedState = parseJSON(data.value);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\tparsedState = void 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!parsedState?.callbackURL?.includes(\"/oauth-proxy-callback\")) return;\n\t\t\t\t\t\tctx.context._oauthProxySnapshot = {\n\t\t\t\t\t\t\tstoreStateStrategy: ctx.context.oauthConfig.storeStateStrategy,\n\t\t\t\t\t\t\tskipStateCookieCheck: ctx.context.oauthConfig.skipStateCookieCheck,\n\t\t\t\t\t\t\tinternalAdapter: ctx.context.internalAdapter\n\t\t\t\t\t\t};\n\t\t\t\t\t\tctx.context.oauthConfig.skipStateCookieCheck = true;\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t],\n\t\t\tafter: [\n\t\t\t\t{\n\t\t\t\t\tmatcher(context) {\n\t\t\t\t\t\treturn !!(context.path?.startsWith(\"/sign-in/social\") || context.path?.startsWith(\"/sign-in/oauth2\"));\n\t\t\t\t\t},\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tif (checkSkipProxy(ctx, opts)) return;\n\t\t\t\t\t\tif (ctx.context.oauthConfig.storeStateStrategy !== \"cookie\") return;\n\t\t\t\t\t\tconst signInResponse = ctx.context.returned;\n\t\t\t\t\t\tif (!signInResponse || typeof signInResponse !== \"object\" || !(\"url\" in signInResponse)) return;\n\t\t\t\t\t\tconst { url: providerURL } = signInResponse;\n\t\t\t\t\t\tif (typeof providerURL !== \"string\") return;\n\t\t\t\t\t\tconst oauthURL = new URL(providerURL);\n\t\t\t\t\t\tconst originalState = oauthURL.searchParams.get(\"state\");\n\t\t\t\t\t\tif (!originalState) return;\n\t\t\t\t\t\tconst setCookieHeader = ctx.context.responseHeaders?.get(\"set-cookie\");\n\t\t\t\t\t\tif (!setCookieHeader) return;\n\t\t\t\t\t\tconst stateCookie = ctx.context.createAuthCookie(\"oauth_state\");\n\t\t\t\t\t\tconst stateCookieAttrs = parseSetCookieHeader(setCookieHeader).get(stateCookie.name);\n\t\t\t\t\t\tif (!stateCookieAttrs?.value) return;\n\t\t\t\t\t\tconst stateCookieValue = stateCookieAttrs.value;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst statePackage = {\n\t\t\t\t\t\t\t\tstate: originalState,\n\t\t\t\t\t\t\t\tstateCookie: stateCookieValue,\n\t\t\t\t\t\t\t\tisOAuthProxy: true\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst encryptedPackage = await symmetricEncrypt({\n\t\t\t\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\t\t\t\tdata: JSON.stringify(statePackage)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\toauthURL.searchParams.set(\"state\", encryptedPackage);\n\t\t\t\t\t\t\tctx.context.returned = {\n\t\t\t\t\t\t\t\t...signInResponse,\n\t\t\t\t\t\t\t\turl: oauthURL.toString()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tctx.context.logger.error(\"Failed to encrypt OAuth proxy state package:\", e);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmatcher(context) {\n\t\t\t\t\t\treturn !!(context.path?.startsWith(\"/callback\") || context.path?.startsWith(\"/oauth2/callback\"));\n\t\t\t\t\t},\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tconst headers = ctx.context.responseHeaders;\n\t\t\t\t\t\tconst location = headers?.get(\"location\");\n\t\t\t\t\t\tif (!location?.includes(\"/oauth-proxy-callback?callbackURL\") || !location.startsWith(\"http\")) return;\n\t\t\t\t\t\tconst productionOrigin = getOrigin(opts?.productionURL || ctx.context.options.baseURL || ctx.context.baseURL);\n\t\t\t\t\t\tconst locationURL = new URL(location);\n\t\t\t\t\t\tif (locationURL.origin === productionOrigin) {\n\t\t\t\t\t\t\tconst newLocation = locationURL.searchParams.get(\"callbackURL\");\n\t\t\t\t\t\t\tif (!newLocation) return;\n\t\t\t\t\t\t\tctx.setHeader(\"location\", newLocation);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst setCookies = headers?.get(\"set-cookie\");\n\t\t\t\t\t\tif (!setCookies) return;\n\t\t\t\t\t\tconst encryptedCookies = await symmetricEncrypt({\n\t\t\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\t\t\tdata: setCookies\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst locationWithCookies = `${location}&cookies=${encodeURIComponent(encryptedCookies)}`;\n\t\t\t\t\t\tctx.setHeader(\"location\", locationWithCookies);\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmatcher(context) {\n\t\t\t\t\t\treturn !!(context.path?.startsWith(\"/callback\") || context.path?.startsWith(\"/oauth2/callback\"));\n\t\t\t\t\t},\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tconst contextWithSnapshot = ctx.context;\n\t\t\t\t\t\tconst snapshot = contextWithSnapshot._oauthProxySnapshot;\n\t\t\t\t\t\tif (snapshot) {\n\t\t\t\t\t\t\tctx.context.oauthConfig.storeStateStrategy = snapshot.storeStateStrategy;\n\t\t\t\t\t\t\tctx.context.oauthConfig.skipStateCookieCheck = snapshot.skipStateCookieCheck;\n\t\t\t\t\t\t\tctx.context.internalAdapter = snapshot.internalAdapter;\n\t\t\t\t\t\t\tcontextWithSnapshot._oauthProxySnapshot = void 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t};\n};\n\n//#endregion\nexport { oAuthProxy as t };","import { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { C as createEmailVerificationToken } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/username/error-codes.ts\nconst USERNAME_ERROR_CODES = defineErrorCodes({\n\tINVALID_USERNAME_OR_PASSWORD: \"Invalid username or password\",\n\tEMAIL_NOT_VERIFIED: \"Email not verified\",\n\tUNEXPECTED_ERROR: \"Unexpected error\",\n\tUSERNAME_IS_ALREADY_TAKEN: \"Username is already taken. Please try another.\",\n\tUSERNAME_TOO_SHORT: \"Username is too short\",\n\tUSERNAME_TOO_LONG: \"Username is too long\",\n\tINVALID_USERNAME: \"Username is invalid\",\n\tINVALID_DISPLAY_USERNAME: \"Display username is invalid\"\n});\n\n//#endregion\n//#region src/plugins/username/schema.ts\nconst getSchema = (normalizer) => {\n\treturn { user: { fields: {\n\t\tusername: {\n\t\t\ttype: \"string\",\n\t\t\trequired: false,\n\t\t\tsortable: true,\n\t\t\tunique: true,\n\t\t\treturned: true,\n\t\t\ttransform: { input(value) {\n\t\t\t\treturn typeof value !== \"string\" ? value : normalizer.username(value);\n\t\t\t} }\n\t\t},\n\t\tdisplayUsername: {\n\t\t\ttype: \"string\",\n\t\t\trequired: false,\n\t\t\ttransform: { input(value) {\n\t\t\t\treturn typeof value !== \"string\" ? value : normalizer.displayUsername(value);\n\t\t\t} }\n\t\t}\n\t} } };\n};\n\n//#endregion\n//#region src/plugins/username/index.ts\nfunction defaultUsernameValidator(username$1) {\n\treturn /^[a-zA-Z0-9_.]+$/.test(username$1);\n}\nconst username = (options) => {\n\tconst normalizer = (username$1) => {\n\t\tif (options?.usernameNormalization === false) return username$1;\n\t\tif (options?.usernameNormalization) return options.usernameNormalization(username$1);\n\t\treturn username$1.toLowerCase();\n\t};\n\tconst displayUsernameNormalizer = (displayUsername) => {\n\t\treturn options?.displayUsernameNormalization ? options.displayUsernameNormalization(displayUsername) : displayUsername;\n\t};\n\treturn {\n\t\tid: \"username\",\n\t\tinit(ctx) {\n\t\t\treturn { options: { databaseHooks: { user: {\n\t\t\t\tcreate: { async before(user, context) {\n\t\t\t\t\tconst username$1 = \"username\" in user ? user.username : null;\n\t\t\t\t\tconst displayUsername = \"displayUsername\" in user ? user.displayUsername : null;\n\t\t\t\t\treturn { data: {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\t...username$1 ? { username: normalizer(username$1) } : {},\n\t\t\t\t\t\t...displayUsername ? { displayUsername: displayUsernameNormalizer(displayUsername) } : {}\n\t\t\t\t\t} };\n\t\t\t\t} },\n\t\t\t\tupdate: { async before(user, context) {\n\t\t\t\t\tconst username$1 = \"username\" in user ? user.username : null;\n\t\t\t\t\tconst displayUsername = \"displayUsername\" in user ? user.displayUsername : null;\n\t\t\t\t\treturn { data: {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\t...username$1 ? { username: normalizer(username$1) } : {},\n\t\t\t\t\t\t...displayUsername ? { displayUsername: displayUsernameNormalizer(displayUsername) } : {}\n\t\t\t\t\t} };\n\t\t\t\t} }\n\t\t\t} } } };\n\t\t},\n\t\tendpoints: {\n\t\t\tsignInUsername: createAuthEndpoint(\"/sign-in/username\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tusername: z.string().meta({ description: \"The username of the user\" }),\n\t\t\t\t\tpassword: z.string().meta({ description: \"The password of the user\" }),\n\t\t\t\t\trememberMe: z.boolean().meta({ description: \"Remember the user session\" }).optional(),\n\t\t\t\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after email verification\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Sign in with username\",\n\t\t\t\t\tdescription: \"Sign in with username\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t200: {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Session token for the authenticated session\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"token\", \"user\"]\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t422: {\n\t\t\t\t\t\t\tdescription: \"Unprocessable Entity. Validation error\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!ctx.body.username || !ctx.body.password) {\n\t\t\t\t\tctx.context.logger.error(\"Username or password not found\");\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });\n\t\t\t\t}\n\t\t\t\tconst username$1 = options?.validationOrder?.username === \"pre-normalization\" ? normalizer(ctx.body.username) : ctx.body.username;\n\t\t\t\tconst minUsernameLength = options?.minUsernameLength || 3;\n\t\t\t\tconst maxUsernameLength = options?.maxUsernameLength || 30;\n\t\t\t\tif (username$1.length < minUsernameLength) {\n\t\t\t\t\tctx.context.logger.error(\"Username too short\", { username: username$1 });\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tcode: \"USERNAME_TOO_SHORT\",\n\t\t\t\t\t\tmessage: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (username$1.length > maxUsernameLength) {\n\t\t\t\t\tctx.context.logger.error(\"Username too long\", { username: username$1 });\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });\n\t\t\t\t}\n\t\t\t\tif (!(options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError(\"UNPROCESSABLE_ENTITY\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });\n\t\t\t\tconst user = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"username\",\n\t\t\t\t\t\tvalue: normalizer(username$1)\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!user) {\n\t\t\t\t\tawait ctx.context.password.hash(ctx.body.password);\n\t\t\t\t\tctx.context.logger.error(\"User not found\", { username: username$1 });\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });\n\t\t\t\t}\n\t\t\t\tconst account = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: user.id\n\t\t\t\t\t}, {\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\tvalue: \"credential\"\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!account) throw new APIError(\"UNAUTHORIZED\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });\n\t\t\t\tconst currentPassword = account?.password;\n\t\t\t\tif (!currentPassword) {\n\t\t\t\t\tctx.context.logger.error(\"Password not found\", { username: username$1 });\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });\n\t\t\t\t}\n\t\t\t\tif (!await ctx.context.password.verify({\n\t\t\t\t\thash: currentPassword,\n\t\t\t\t\tpassword: ctx.body.password\n\t\t\t\t})) {\n\t\t\t\t\tctx.context.logger.error(\"Invalid password\");\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });\n\t\t\t\t}\n\t\t\t\tif (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.emailVerified) {\n\t\t\t\t\tif (!ctx.context.options?.emailVerification?.sendVerificationEmail) throw new APIError(\"FORBIDDEN\", { message: USERNAME_ERROR_CODES.EMAIL_NOT_VERIFIED });\n\t\t\t\t\tif (ctx.context.options?.emailVerification?.sendOnSignIn) {\n\t\t\t\t\t\tconst token = await createEmailVerificationToken(ctx.context.secret, user.email, void 0, ctx.context.options.emailVerification?.expiresIn);\n\t\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\t\t\t\t\tawait ctx.context.options.emailVerification.sendVerificationEmail({\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken\n\t\t\t\t\t\t}, ctx.request);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: USERNAME_ERROR_CODES.EMAIL_NOT_VERIFIED });\n\t\t\t\t}\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.id, ctx.body.rememberMe === false);\n\t\t\t\tif (!session) return ctx.json(null, {\n\t\t\t\t\tstatus: 500,\n\t\t\t\t\tbody: { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION }\n\t\t\t\t});\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser\n\t\t\t\t}, ctx.body.rememberMe === false);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\temailVerified: user.emailVerified,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\tdisplayUsername: user.displayUsername,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\tcreatedAt: user.createdAt,\n\t\t\t\t\t\tupdatedAt: user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tisUsernameAvailable: createAuthEndpoint(\"/is-username-available\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ username: z.string().meta({ description: \"The username to check\" }) })\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst username$1 = ctx.body.username;\n\t\t\t\tif (!username$1) throw new APIError(\"UNPROCESSABLE_ENTITY\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });\n\t\t\t\tconst minUsernameLength = options?.minUsernameLength || 3;\n\t\t\t\tconst maxUsernameLength = options?.maxUsernameLength || 30;\n\t\t\t\tif (username$1.length < minUsernameLength) throw new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\tcode: \"USERNAME_TOO_SHORT\",\n\t\t\t\t\tmessage: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT\n\t\t\t\t});\n\t\t\t\tif (username$1.length > maxUsernameLength) throw new APIError(\"UNPROCESSABLE_ENTITY\", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });\n\t\t\t\tif (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError(\"UNPROCESSABLE_ENTITY\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });\n\t\t\t\tif (await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"username\",\n\t\t\t\t\t\tvalue: normalizer(username$1)\n\t\t\t\t\t}]\n\t\t\t\t})) return ctx.json({ available: false });\n\t\t\t\treturn ctx.json({ available: true });\n\t\t\t})\n\t\t},\n\t\tschema: mergeSchema(getSchema({\n\t\t\tusername: normalizer,\n\t\t\tdisplayUsername: displayUsernameNormalizer\n\t\t}), options?.schema),\n\t\thooks: { before: [{\n\t\t\tmatcher(context) {\n\t\t\t\treturn context.path === \"/sign-up/email\" || context.path === \"/update-user\";\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst username$1 = typeof ctx.body.username === \"string\" && options?.validationOrder?.username === \"post-normalization\" ? normalizer(ctx.body.username) : ctx.body.username;\n\t\t\t\tif (username$1 !== void 0 && typeof username$1 === \"string\") {\n\t\t\t\t\tconst minUsernameLength = options?.minUsernameLength || 3;\n\t\t\t\t\tconst maxUsernameLength = options?.maxUsernameLength || 30;\n\t\t\t\t\tif (username$1.length < minUsernameLength) throw new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tcode: \"USERNAME_TOO_SHORT\",\n\t\t\t\t\t\tmessage: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT\n\t\t\t\t\t});\n\t\t\t\t\tif (username$1.length > maxUsernameLength) throw new APIError(\"BAD_REQUEST\", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });\n\t\t\t\t\tif (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError(\"BAD_REQUEST\", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });\n\t\t\t\t\tconst user = await ctx.context.adapter.findOne({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"username\",\n\t\t\t\t\t\t\tvalue: username$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tconst blockChangeSignUp = ctx.path === \"/sign-up/email\" && user;\n\t\t\t\t\tconst blockChangeUpdateUser = ctx.path === \"/update-user\" && user && ctx.context.session && user.id !== ctx.context.session.session.userId;\n\t\t\t\t\tif (blockChangeSignUp || blockChangeUpdateUser) throw new APIError(\"BAD_REQUEST\", { message: USERNAME_ERROR_CODES.USERNAME_IS_ALREADY_TAKEN });\n\t\t\t\t}\n\t\t\t\tconst displayUsername = typeof ctx.body.displayUsername === \"string\" && options?.validationOrder?.displayUsername === \"post-normalization\" ? displayUsernameNormalizer(ctx.body.displayUsername) : ctx.body.displayUsername;\n\t\t\t\tif (displayUsername !== void 0 && typeof displayUsername === \"string\") {\n\t\t\t\t\tif (options?.displayUsernameValidator) {\n\t\t\t\t\t\tif (!await options.displayUsernameValidator(displayUsername)) throw new APIError(\"BAD_REQUEST\", { message: USERNAME_ERROR_CODES.INVALID_DISPLAY_USERNAME });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}, {\n\t\t\tmatcher(context) {\n\t\t\t\treturn context.path === \"/sign-up/email\" || context.path === \"/update-user\";\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tif (ctx.body.username && !ctx.body.displayUsername) ctx.body.displayUsername = ctx.body.username;\n\t\t\t\tif (ctx.body.displayUsername && !ctx.body.username) ctx.body.username = ctx.body.displayUsername;\n\t\t\t})\n\t\t}] },\n\t\t$ERROR_CODES: USERNAME_ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { USERNAME_ERROR_CODES as n, username as t };","import { r as generateRandomString } from \"./crypto-CFUhAR9W.mjs\";\nimport { t as mergeSchema, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx } from \"./session-AaRl3_x-.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/phone-number/error-codes.ts\nconst PHONE_NUMBER_ERROR_CODES = defineErrorCodes({\n\tINVALID_PHONE_NUMBER: \"Invalid phone number\",\n\tPHONE_NUMBER_EXIST: \"Phone number already exists\",\n\tPHONE_NUMBER_NOT_EXIST: \"phone number isn't registered\",\n\tINVALID_PHONE_NUMBER_OR_PASSWORD: \"Invalid phone number or password\",\n\tUNEXPECTED_ERROR: \"Unexpected error\",\n\tOTP_NOT_FOUND: \"OTP not found\",\n\tOTP_EXPIRED: \"OTP expired\",\n\tINVALID_OTP: \"Invalid OTP\",\n\tPHONE_NUMBER_NOT_VERIFIED: \"Phone number not verified\",\n\tPHONE_NUMBER_CANNOT_BE_UPDATED: \"Phone number cannot be updated\",\n\tSEND_OTP_NOT_IMPLEMENTED: \"sendOTP not implemented\",\n\tTOO_MANY_ATTEMPTS: \"Too many attempts\"\n});\n\n//#endregion\n//#region src/plugins/phone-number/schema.ts\nconst schema = { user: { fields: {\n\tphoneNumber: {\n\t\ttype: \"string\",\n\t\trequired: false,\n\t\tunique: true,\n\t\tsortable: true,\n\t\treturned: true\n\t},\n\tphoneNumberVerified: {\n\t\ttype: \"boolean\",\n\t\trequired: false,\n\t\treturned: true,\n\t\tinput: false\n\t}\n} } };\n\n//#endregion\n//#region src/plugins/phone-number/index.ts\nfunction generateOTP(size) {\n\treturn generateRandomString(size, \"0-9\");\n}\nconst phoneNumber = (options) => {\n\tconst opts = {\n\t\texpiresIn: options?.expiresIn || 300,\n\t\totpLength: options?.otpLength || 6,\n\t\t...options,\n\t\tphoneNumber: \"phoneNumber\",\n\t\tphoneNumberVerified: \"phoneNumberVerified\",\n\t\tcode: \"code\",\n\t\tcreatedAt: \"createdAt\"\n\t};\n\treturn {\n\t\tid: \"phone-number\",\n\t\thooks: { before: [{\n\t\t\tmatcher: (ctx) => ctx.path === \"/update-user\" && \"phoneNumber\" in ctx.body,\n\t\t\thandler: createAuthMiddleware(async (_ctx) => {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_CANNOT_BE_UPDATED });\n\t\t\t})\n\t\t}] },\n\t\tendpoints: {\n\t\t\tsignInPhoneNumber: createAuthEndpoint(\"/sign-in/phone-number\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tphoneNumber: z.string().meta({ description: \"Phone number to sign in. Eg: \\\"+1234567890\\\"\" }),\n\t\t\t\t\tpassword: z.string().meta({ description: \"Password to use for sign in.\" }),\n\t\t\t\t\trememberMe: z.boolean().meta({ description: \"Remember the session. Eg: true\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Sign in with phone number\",\n\t\t\t\t\tdescription: \"Use this endpoint to sign in with phone number\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t200: {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" },\n\t\t\t\t\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t400: { description: \"Invalid phone number or password\" }\n\t\t\t\t\t}\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { password, phoneNumber: phoneNumber$1 } = ctx.body;\n\t\t\t\tif (opts.phoneNumberValidator) {\n\t\t\t\t\tif (!await opts.phoneNumberValidator(ctx.body.phoneNumber)) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER });\n\t\t\t\t}\n\t\t\t\tconst user = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"phoneNumber\",\n\t\t\t\t\t\tvalue: phoneNumber$1\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!user) throw new APIError(\"UNAUTHORIZED\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });\n\t\t\t\tif (opts.requireVerification) {\n\t\t\t\t\tif (!user.phoneNumberVerified) {\n\t\t\t\t\t\tconst otp = generateOTP(opts.otpLength);\n\t\t\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\t\t\tvalue: otp,\n\t\t\t\t\t\t\tidentifier: phoneNumber$1,\n\t\t\t\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait opts.sendOTP?.({\n\t\t\t\t\t\t\tphoneNumber: phoneNumber$1,\n\t\t\t\t\t\t\tcode: otp\n\t\t\t\t\t\t}, ctx);\n\t\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_NOT_VERIFIED });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst credentialAccount = (await ctx.context.internalAdapter.findAccountByUserId(user.id)).find((a) => a.providerId === \"credential\");\n\t\t\t\tif (!credentialAccount) {\n\t\t\t\t\tctx.context.logger.error(\"Credential account not found\", { phoneNumber: phoneNumber$1 });\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });\n\t\t\t\t}\n\t\t\t\tconst currentPassword = credentialAccount?.password;\n\t\t\t\tif (!currentPassword) {\n\t\t\t\t\tctx.context.logger.error(\"Password not found\", { phoneNumber: phoneNumber$1 });\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: PHONE_NUMBER_ERROR_CODES.UNEXPECTED_ERROR });\n\t\t\t\t}\n\t\t\t\tif (!await ctx.context.password.verify({\n\t\t\t\t\thash: currentPassword,\n\t\t\t\t\tpassword\n\t\t\t\t})) {\n\t\t\t\t\tctx.context.logger.error(\"Invalid password\");\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });\n\t\t\t\t}\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.id, ctx.body.rememberMe === false);\n\t\t\t\tif (!session) {\n\t\t\t\t\tctx.context.logger.error(\"Failed to create session\");\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser\n\t\t\t\t}, ctx.body.rememberMe === false);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\temailVerified: user.emailVerified,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\tphoneNumber: user.phoneNumber,\n\t\t\t\t\t\tphoneNumberVerified: user.phoneNumberVerified,\n\t\t\t\t\t\tcreatedAt: user.createdAt,\n\t\t\t\t\t\tupdatedAt: user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tsendPhoneNumberOTP: createAuthEndpoint(\"/phone-number/send-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ phoneNumber: z.string().meta({ description: \"Phone number to send OTP. Eg: \\\"+1234567890\\\"\" }) }),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Send OTP to phone number\",\n\t\t\t\t\tdescription: \"Use this endpoint to send OTP to phone number\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!options?.sendOTP) {\n\t\t\t\t\tctx.context.logger.warn(\"sendOTP not implemented\");\n\t\t\t\t\tthrow new APIError(\"NOT_IMPLEMENTED\", { message: PHONE_NUMBER_ERROR_CODES.SEND_OTP_NOT_IMPLEMENTED });\n\t\t\t\t}\n\t\t\t\tif (opts.phoneNumberValidator) {\n\t\t\t\t\tif (!await opts.phoneNumberValidator(ctx.body.phoneNumber)) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER });\n\t\t\t\t}\n\t\t\t\tconst code = generateOTP(opts.otpLength);\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: `${code}:0`,\n\t\t\t\t\tidentifier: ctx.body.phoneNumber,\n\t\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t\t});\n\t\t\t\tawait options.sendOTP({\n\t\t\t\t\tphoneNumber: ctx.body.phoneNumber,\n\t\t\t\t\tcode\n\t\t\t\t}, ctx);\n\t\t\t\treturn ctx.json({ message: \"code sent\" });\n\t\t\t}),\n\t\t\tverifyPhoneNumber: createAuthEndpoint(\"/phone-number/verify\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tphoneNumber: z.string().meta({ description: \"Phone number to verify. Eg: \\\"+1234567890\\\"\" }),\n\t\t\t\t\tcode: z.string().meta({ description: \"OTP code. Eg: \\\"123456\\\"\" }),\n\t\t\t\t\tdisableSession: z.boolean().meta({ description: \"Disable session creation after verification. Eg: false\" }).optional(),\n\t\t\t\t\tupdatePhoneNumber: z.boolean().meta({ description: \"Check if there is a session and update the phone number. Eg: true\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Verify phone number\",\n\t\t\t\t\tdescription: \"Use this endpoint to verify phone number\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Phone number verified successfully\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the verification was successful\",\n\t\t\t\t\t\t\t\t\t\tenum: [true]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"Session token if session is created, null if disableSession is true or no session is created\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier of the user\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's email address\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email is verified\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's name\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's profile image URL\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tphoneNumber: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's phone number\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tphoneNumberVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the phone number is verified\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the user was created\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the user was last updated\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\"phoneNumber\",\n\t\t\t\t\t\t\t\t\t\t\t\"phoneNumberVerified\",\n\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\tdescription: \"User object with phone number details, null if no user is created or found\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"status\"]\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t400: { description: \"Invalid OTP\" }\n\t\t\t\t\t}\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (options?.verifyOTP) {\n\t\t\t\t\tif (!await options.verifyOTP({\n\t\t\t\t\t\tphoneNumber: ctx.body.phoneNumber,\n\t\t\t\t\t\tcode: ctx.body.code\n\t\t\t\t\t}, ctx)) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });\n\t\t\t\t\tconst otp = await ctx.context.internalAdapter.findVerificationValue(ctx.body.phoneNumber);\n\t\t\t\t\tif (otp) await ctx.context.internalAdapter.deleteVerificationValue(otp.id);\n\t\t\t\t} else {\n\t\t\t\t\tconst otp = await ctx.context.internalAdapter.findVerificationValue(ctx.body.phoneNumber);\n\t\t\t\t\tif (!otp || otp.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\t\tif (otp && otp.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.OTP_EXPIRED });\n\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.OTP_NOT_FOUND });\n\t\t\t\t\t}\n\t\t\t\t\tconst [otpValue, attempts] = otp.value.split(\":\");\n\t\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 3;\n\t\t\t\t\tif (attempts && parseInt(attempts) >= allowedAttempts) {\n\t\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(otp.id);\n\t\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: PHONE_NUMBER_ERROR_CODES.TOO_MANY_ATTEMPTS });\n\t\t\t\t\t}\n\t\t\t\t\tif (otpValue !== ctx.body.code) {\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(otp.id, { value: `${otpValue}:${parseInt(attempts || \"0\") + 1}` });\n\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });\n\t\t\t\t\t}\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(otp.id);\n\t\t\t\t}\n\t\t\t\tif (ctx.body.updatePhoneNumber) {\n\t\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\t\tif (!session) throw new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\t\tif ((await ctx.context.adapter.findMany({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"phoneNumber\",\n\t\t\t\t\t\t\tvalue: ctx.body.phoneNumber\n\t\t\t\t\t\t}]\n\t\t\t\t\t})).length) throw ctx.error(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_EXIST });\n\t\t\t\t\tlet user$1 = await ctx.context.internalAdapter.updateUser(session.user.id, {\n\t\t\t\t\t\t[opts.phoneNumber]: ctx.body.phoneNumber,\n\t\t\t\t\t\t[opts.phoneNumberVerified]: true\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\ttoken: session.session.token,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: user$1.id,\n\t\t\t\t\t\t\temail: user$1.email,\n\t\t\t\t\t\t\temailVerified: user$1.emailVerified,\n\t\t\t\t\t\t\tname: user$1.name,\n\t\t\t\t\t\t\timage: user$1.image,\n\t\t\t\t\t\t\tphoneNumber: user$1.phoneNumber,\n\t\t\t\t\t\t\tphoneNumberVerified: user$1.phoneNumberVerified,\n\t\t\t\t\t\t\tcreatedAt: user$1.createdAt,\n\t\t\t\t\t\t\tupdatedAt: user$1.updatedAt\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tlet user = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tvalue: ctx.body.phoneNumber,\n\t\t\t\t\t\tfield: opts.phoneNumber\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!user) {\n\t\t\t\t\tif (options?.signUpOnVerification) {\n\t\t\t\t\t\tuser = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\t\t\temail: options.signUpOnVerification.getTempEmail(ctx.body.phoneNumber),\n\t\t\t\t\t\t\tname: options.signUpOnVerification.getTempName ? options.signUpOnVerification.getTempName(ctx.body.phoneNumber) : ctx.body.phoneNumber,\n\t\t\t\t\t\t\t[opts.phoneNumber]: ctx.body.phoneNumber,\n\t\t\t\t\t\t\t[opts.phoneNumberVerified]: true\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!user) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });\n\t\t\t\t\t}\n\t\t\t\t} else user = await ctx.context.internalAdapter.updateUser(user.id, { [opts.phoneNumberVerified]: true });\n\t\t\t\tif (!user) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: BASE_ERROR_CODES.FAILED_TO_UPDATE_USER });\n\t\t\t\tawait options?.callbackOnVerification?.({\n\t\t\t\t\tphoneNumber: ctx.body.phoneNumber,\n\t\t\t\t\tuser\n\t\t\t\t}, ctx);\n\t\t\t\tif (!ctx.body.disableSession) {\n\t\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.id);\n\t\t\t\t\tif (!session) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tuser\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\ttoken: session.token,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\t\temailVerified: user.emailVerified,\n\t\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\t\tphoneNumber: user.phoneNumber,\n\t\t\t\t\t\t\tphoneNumberVerified: user.phoneNumberVerified,\n\t\t\t\t\t\t\tcreatedAt: user.createdAt,\n\t\t\t\t\t\t\tupdatedAt: user.updatedAt\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tstatus: true,\n\t\t\t\t\ttoken: null,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\temailVerified: user.emailVerified,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\tphoneNumber: user.phoneNumber,\n\t\t\t\t\t\tphoneNumberVerified: user.phoneNumberVerified,\n\t\t\t\t\t\tcreatedAt: user.createdAt,\n\t\t\t\t\t\tupdatedAt: user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\trequestPasswordResetPhoneNumber: createAuthEndpoint(\"/phone-number/request-password-reset\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ phoneNumber: z.string() }),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Request OTP for password reset via phone number\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"OTP sent successfully for password reset\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: {\n\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\tdescription: \"Indicates if the OTP was sent successfully\",\n\t\t\t\t\t\t\t\tenum: [true]\n\t\t\t\t\t\t\t} },\n\t\t\t\t\t\t\trequired: [\"status\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tvalue: ctx.body.phoneNumber,\n\t\t\t\t\t\tfield: opts.phoneNumber\n\t\t\t\t\t}]\n\t\t\t\t})) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_NOT_EXIST });\n\t\t\t\tconst code = generateOTP(opts.otpLength);\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: `${code}:0`,\n\t\t\t\t\tidentifier: `${ctx.body.phoneNumber}-request-password-reset`,\n\t\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t\t});\n\t\t\t\tawait options?.sendPasswordResetOTP?.({\n\t\t\t\t\tphoneNumber: ctx.body.phoneNumber,\n\t\t\t\t\tcode\n\t\t\t\t}, ctx);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t}),\n\t\t\tresetPasswordPhoneNumber: createAuthEndpoint(\"/phone-number/reset-password\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\totp: z.string().meta({ description: \"The one time password to reset the password. Eg: \\\"123456\\\"\" }),\n\t\t\t\t\tphoneNumber: z.string().meta({ description: \"The phone number to the account which intends to reset the password for. Eg: \\\"+1234567890\\\"\" }),\n\t\t\t\t\tnewPassword: z.string().meta({ description: `The new password. Eg: \"new-and-secure-password\"` })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Reset password using phone number OTP\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Password reset successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: {\n\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\tdescription: \"Indicates if the password was reset successfully\",\n\t\t\t\t\t\t\t\tenum: [true]\n\t\t\t\t\t\t\t} },\n\t\t\t\t\t\t\trequired: [\"status\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst verification = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.phoneNumber}-request-password-reset`);\n\t\t\t\tif (!verification) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.OTP_NOT_FOUND });\n\t\t\t\tif (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.OTP_EXPIRED });\n\t\t\t\tconst [otpValue, attempts] = verification.value.split(\":\");\n\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 3;\n\t\t\t\tif (attempts && parseInt(attempts) >= allowedAttempts) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: PHONE_NUMBER_ERROR_CODES.TOO_MANY_ATTEMPTS });\n\t\t\t\t}\n\t\t\t\tif (ctx.body.otp !== otpValue) {\n\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(verification.id, { value: `${otpValue}:${parseInt(attempts || \"0\") + 1}` });\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });\n\t\t\t\t}\n\t\t\t\tconst user = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"phoneNumber\",\n\t\t\t\t\t\tvalue: ctx.body.phoneNumber\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!user) throw new APIError(\"BAD_REQUEST\", { message: PHONE_NUMBER_ERROR_CODES.UNEXPECTED_ERROR });\n\t\t\t\tconst hashedPassword = await ctx.context.password.hash(ctx.body.newPassword);\n\t\t\t\tawait ctx.context.internalAdapter.updatePassword(user.id, hashedPassword);\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t})\n\t\t},\n\t\tschema: mergeSchema(schema, options?.schema),\n\t\trateLimit: [{\n\t\t\tpathMatcher(path) {\n\t\t\t\treturn path.startsWith(\"/phone-number\");\n\t\t\t},\n\t\t\twindow: 60 * 1e3,\n\t\t\tmax: 10\n\t\t}],\n\t\t$ERROR_CODES: PHONE_NUMBER_ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { phoneNumber as t };","import { l as parseUserOutput, t as mergeSchema, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie, n as deleteSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx } from \"./session-AaRl3_x-.mjs\";\nimport { t as hasPermission } from \"./has-permission-qCjQqGds.mjs\";\nimport { t as getEndpointResponse } from \"./plugin-helper-zFdFWLgL.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/plugins/admin/error-codes.ts\nconst ADMIN_ERROR_CODES = defineErrorCodes({\n\tFAILED_TO_CREATE_USER: \"Failed to create user\",\n\tUSER_ALREADY_EXISTS: \"User already exists.\",\n\tUSER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: \"User already exists. Use another email.\",\n\tYOU_CANNOT_BAN_YOURSELF: \"You cannot ban yourself\",\n\tYOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: \"You are not allowed to change users role\",\n\tYOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: \"You are not allowed to create users\",\n\tYOU_ARE_NOT_ALLOWED_TO_LIST_USERS: \"You are not allowed to list users\",\n\tYOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: \"You are not allowed to list users sessions\",\n\tYOU_ARE_NOT_ALLOWED_TO_BAN_USERS: \"You are not allowed to ban users\",\n\tYOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: \"You are not allowed to impersonate users\",\n\tYOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: \"You are not allowed to revoke users sessions\",\n\tYOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: \"You are not allowed to delete users\",\n\tYOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: \"You are not allowed to set users password\",\n\tBANNED_USER: \"You have been banned from this application\",\n\tYOU_ARE_NOT_ALLOWED_TO_GET_USER: \"You are not allowed to get user\",\n\tNO_DATA_TO_UPDATE: \"No data to update\",\n\tYOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS: \"You are not allowed to update users\",\n\tYOU_CANNOT_REMOVE_YOURSELF: \"You cannot remove yourself\",\n\tYOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE: \"You are not allowed to set a non-existent role value\"\n});\n\n//#endregion\n//#region src/plugins/admin/schema.ts\nconst schema = {\n\tuser: { fields: {\n\t\trole: {\n\t\t\ttype: \"string\",\n\t\t\trequired: false,\n\t\t\tinput: false\n\t\t},\n\t\tbanned: {\n\t\t\ttype: \"boolean\",\n\t\t\tdefaultValue: false,\n\t\t\trequired: false,\n\t\t\tinput: false\n\t\t},\n\t\tbanReason: {\n\t\t\ttype: \"string\",\n\t\t\trequired: false,\n\t\t\tinput: false\n\t\t},\n\t\tbanExpires: {\n\t\t\ttype: \"date\",\n\t\t\trequired: false,\n\t\t\tinput: false\n\t\t}\n\t} },\n\tsession: { fields: { impersonatedBy: {\n\t\ttype: \"string\",\n\t\trequired: false\n\t} } }\n};\n\n//#endregion\n//#region src/plugins/admin/admin.ts\nfunction parseRoles(roles) {\n\treturn Array.isArray(roles) ? roles.join(\",\") : roles;\n}\nconst admin = (options) => {\n\tconst opts = {\n\t\tdefaultRole: options?.defaultRole ?? \"user\",\n\t\tadminRoles: options?.adminRoles ?? [\"admin\"],\n\t\tbannedUserMessage: options?.bannedUserMessage ?? \"You have been banned from this application. Please contact support if you believe this is an error.\",\n\t\t...options\n\t};\n\t/**\n\t* Ensures a valid session, if not will throw.\n\t* Will also provide additional types on the user to include role types.\n\t*/\n\tconst adminMiddleware = createAuthMiddleware(async (ctx) => {\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session) throw new APIError(\"UNAUTHORIZED\");\n\t\treturn { session };\n\t});\n\treturn {\n\t\tid: \"admin\",\n\t\tinit() {\n\t\t\treturn { options: { databaseHooks: {\n\t\t\t\tuser: { create: { async before(user) {\n\t\t\t\t\treturn { data: {\n\t\t\t\t\t\trole: options?.defaultRole ?? \"user\",\n\t\t\t\t\t\t...user\n\t\t\t\t\t} };\n\t\t\t\t} } },\n\t\t\t\tsession: { create: { async before(session, ctx) {\n\t\t\t\t\tif (!ctx) return;\n\t\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(session.userId);\n\t\t\t\t\tif (user.banned) {\n\t\t\t\t\t\tif (user.banExpires && new Date(user.banExpires).getTime() < Date.now()) {\n\t\t\t\t\t\t\tawait ctx.context.internalAdapter.updateUser(session.userId, {\n\t\t\t\t\t\t\t\tbanned: false,\n\t\t\t\t\t\t\t\tbanReason: null,\n\t\t\t\t\t\t\t\tbanExpires: null\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx && (ctx.path.startsWith(\"/callback\") || ctx.path.startsWith(\"/oauth2/callback\"))) {\n\t\t\t\t\t\t\tconst redirectURI = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;\n\t\t\t\t\t\t\tthrow ctx.redirect(`${redirectURI}?error=banned&error_description=${opts.bannedUserMessage}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\t\t\tmessage: opts.bannedUserMessage,\n\t\t\t\t\t\t\tcode: \"BANNED_USER\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} } }\n\t\t\t} } };\n\t\t},\n\t\thooks: { after: [{\n\t\t\tmatcher(context) {\n\t\t\t\treturn context.path === \"/list-sessions\";\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst response = await getEndpointResponse(ctx);\n\t\t\t\tif (!response) return;\n\t\t\t\tconst newJson = response.filter((session) => {\n\t\t\t\t\treturn !session.impersonatedBy;\n\t\t\t\t});\n\t\t\t\treturn ctx.json(newJson);\n\t\t\t})\n\t\t}] },\n\t\tendpoints: {\n\t\t\tsetRole: createAuthEndpoint(\"/admin/set-role\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tuserId: z.coerce.string().meta({ description: \"The user id\" }),\n\t\t\t\t\trole: z.union([z.string().meta({ description: \"The role to set. `admin` or `user` by default\" }), z.array(z.string().meta({ description: \"The roles to set. `admin` or `user` by default\" }))]).meta({ description: \"The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`\" })\n\t\t\t\t}),\n\t\t\t\trequireHeaders: true,\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: {\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\toperationId: \"setUserRole\",\n\t\t\t\t\t\tsummary: \"Set the role of a user\",\n\t\t\t\t\t\tdescription: \"Set the role of a user\",\n\t\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\t\tdescription: \"User role updated\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: { user: { $ref: \"#/components/schemas/User\" } }\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t},\n\t\t\t\t\t$Infer: { body: {} }\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: ctx.context.session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"set-role\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });\n\t\t\t\tconst roles = opts.roles;\n\t\t\t\tif (roles) {\n\t\t\t\t\tconst inputRoles = Array.isArray(ctx.body.role) ? ctx.body.role : [ctx.body.role];\n\t\t\t\t\tfor (const role of inputRoles) if (!roles[role]) throw new APIError(\"BAD_REQUEST\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });\n\t\t\t\t}\n\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, { role: parseRoles(ctx.body.role) });\n\t\t\t\treturn ctx.json({ user: updatedUser });\n\t\t\t}),\n\t\t\tgetUser: createAuthEndpoint(\"/admin/get-user\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: z.object({ id: z.string().meta({ description: \"The id of the User\" }) }),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"getUser\",\n\t\t\t\t\tsummary: \"Get an existing user\",\n\t\t\t\t\tdescription: \"Get an existing user\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"User\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { user: { $ref: \"#/components/schemas/User\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { id } = ctx.query;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: ctx.context.session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"get\"] }\n\t\t\t\t})) throw ctx.error(\"FORBIDDEN\", {\n\t\t\t\t\tmessage: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_USER,\n\t\t\t\t\tcode: \"YOU_ARE_NOT_ALLOWED_TO_GET_USER\"\n\t\t\t\t});\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(id);\n\t\t\t\tif (!user) throw new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\treturn parseUserOutput(ctx.context.options, user);\n\t\t\t}),\n\t\t\tcreateUser: createAuthEndpoint(\"/admin/create-user\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.string().meta({ description: \"The email of the user\" }),\n\t\t\t\t\tpassword: z.string().meta({ description: \"The password of the user\" }),\n\t\t\t\t\tname: z.string().meta({ description: \"The name of the user\" }),\n\t\t\t\t\trole: z.union([z.string().meta({ description: \"The role of the user\" }), z.array(z.string().meta({ description: \"The roles of user\" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: \\\"user\\\"` }),\n\t\t\t\t\tdata: z.record(z.string(), z.any()).optional().meta({ description: \"Extra fields for the user. Including custom additional fields.\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: {\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\toperationId: \"createUser\",\n\t\t\t\t\t\tsummary: \"Create a new user\",\n\t\t\t\t\t\tdescription: \"Create a new user\",\n\t\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\t\tdescription: \"User created\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: { user: { $ref: \"#/components/schemas/User\" } }\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t},\n\t\t\t\t\t$Infer: { body: {} }\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tif (!session && (ctx.request || ctx.headers)) throw ctx.error(\"UNAUTHORIZED\");\n\t\t\t\tif (session) {\n\t\t\t\t\tif (!hasPermission({\n\t\t\t\t\t\tuserId: session.user.id,\n\t\t\t\t\t\trole: session.user.role,\n\t\t\t\t\t\toptions: opts,\n\t\t\t\t\t\tpermissions: { user: [\"create\"] }\n\t\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });\n\t\t\t\t}\n\t\t\t\tconst email = ctx.body.email.toLowerCase();\n\t\t\t\tif (!z.email().safeParse(email).success) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\t\t\t\tif (await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError(\"BAD_REQUEST\", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });\n\t\t\t\tconst user = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\temail,\n\t\t\t\t\tname: ctx.body.name,\n\t\t\t\t\trole: (ctx.body.role && parseRoles(ctx.body.role)) ?? options?.defaultRole ?? \"user\",\n\t\t\t\t\t...ctx.body.data\n\t\t\t\t});\n\t\t\t\tif (!user) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });\n\t\t\t\tconst hashedPassword = await ctx.context.password.hash(ctx.body.password);\n\t\t\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\t\t\taccountId: user.id,\n\t\t\t\t\tproviderId: \"credential\",\n\t\t\t\t\tpassword: hashedPassword,\n\t\t\t\t\tuserId: user.id\n\t\t\t\t});\n\t\t\t\treturn ctx.json({ user });\n\t\t\t}),\n\t\t\tadminUpdateUser: createAuthEndpoint(\"/admin/update-user\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tuserId: z.coerce.string().meta({ description: \"The user id\" }),\n\t\t\t\t\tdata: z.record(z.any(), z.any()).meta({ description: \"The user data to update\" })\n\t\t\t\t}),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"updateUser\",\n\t\t\t\t\tsummary: \"Update a user\",\n\t\t\t\t\tdescription: \"Update a user's details\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"User updated\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { user: { $ref: \"#/components/schemas/User\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: ctx.context.session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"update\"] }\n\t\t\t\t})) throw ctx.error(\"FORBIDDEN\", {\n\t\t\t\t\tmessage: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS,\n\t\t\t\t\tcode: \"YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS\"\n\t\t\t\t});\n\t\t\t\tif (Object.keys(ctx.body.data).length === 0) throw new APIError(\"BAD_REQUEST\", { message: ADMIN_ERROR_CODES.NO_DATA_TO_UPDATE });\n\t\t\t\tif (ctx.body.data?.role) ctx.body.data.role = parseRoles(ctx.body.data.role);\n\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, ctx.body.data);\n\t\t\t\treturn ctx.json(updatedUser);\n\t\t\t}),\n\t\t\tlistUsers: createAuthEndpoint(\"/admin/list-users\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tquery: z.object({\n\t\t\t\t\tsearchValue: z.string().optional().meta({ description: \"The value to search for. Eg: \\\"some name\\\"\" }),\n\t\t\t\t\tsearchField: z.enum([\"email\", \"name\"]).meta({ description: \"The field to search in, defaults to email. Can be `email` or `name`. Eg: \\\"name\\\"\" }).optional(),\n\t\t\t\t\tsearchOperator: z.enum([\n\t\t\t\t\t\t\"contains\",\n\t\t\t\t\t\t\"starts_with\",\n\t\t\t\t\t\t\"ends_with\"\n\t\t\t\t\t]).meta({ description: \"The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: \\\"contains\\\"\" }).optional(),\n\t\t\t\t\tlimit: z.string().meta({ description: \"The number of users to return\" }).or(z.number()).optional(),\n\t\t\t\t\toffset: z.string().meta({ description: \"The offset to start from\" }).or(z.number()).optional(),\n\t\t\t\t\tsortBy: z.string().meta({ description: \"The field to sort by\" }).optional(),\n\t\t\t\t\tsortDirection: z.enum([\"asc\", \"desc\"]).meta({ description: \"The direction to sort by\" }).optional(),\n\t\t\t\t\tfilterField: z.string().meta({ description: \"The field to filter by\" }).optional(),\n\t\t\t\t\tfilterValue: z.string().meta({ description: \"The value to filter by\" }).or(z.number()).or(z.boolean()).optional(),\n\t\t\t\t\tfilterOperator: z.enum([\n\t\t\t\t\t\t\"eq\",\n\t\t\t\t\t\t\"ne\",\n\t\t\t\t\t\t\"lt\",\n\t\t\t\t\t\t\"lte\",\n\t\t\t\t\t\t\"gt\",\n\t\t\t\t\t\t\"gte\",\n\t\t\t\t\t\t\"contains\"\n\t\t\t\t\t]).meta({ description: \"The operator to use for the filter\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"listUsers\",\n\t\t\t\t\tsummary: \"List users\",\n\t\t\t\t\tdescription: \"List users\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"List of users\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tusers: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttotal: { type: \"number\" },\n\t\t\t\t\t\t\t\tlimit: { type: \"number\" },\n\t\t\t\t\t\t\t\toffset: { type: \"number\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"users\", \"total\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"list\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS });\n\t\t\t\tconst where = [];\n\t\t\t\tif (ctx.query?.searchValue) where.push({\n\t\t\t\t\tfield: ctx.query.searchField || \"email\",\n\t\t\t\t\toperator: ctx.query.searchOperator || \"contains\",\n\t\t\t\t\tvalue: ctx.query.searchValue\n\t\t\t\t});\n\t\t\t\tif (ctx.query?.filterValue) where.push({\n\t\t\t\t\tfield: ctx.query.filterField || \"email\",\n\t\t\t\t\toperator: ctx.query.filterOperator || \"eq\",\n\t\t\t\t\tvalue: ctx.query.filterValue\n\t\t\t\t});\n\t\t\t\ttry {\n\t\t\t\t\tconst users = await ctx.context.internalAdapter.listUsers(Number(ctx.query?.limit) || void 0, Number(ctx.query?.offset) || void 0, ctx.query?.sortBy ? {\n\t\t\t\t\t\tfield: ctx.query.sortBy,\n\t\t\t\t\t\tdirection: ctx.query.sortDirection || \"asc\"\n\t\t\t\t\t} : void 0, where.length ? where : void 0);\n\t\t\t\t\tconst total = await ctx.context.internalAdapter.countTotalUsers(where.length ? where : void 0);\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tusers,\n\t\t\t\t\t\ttotal,\n\t\t\t\t\t\tlimit: Number(ctx.query?.limit) || void 0,\n\t\t\t\t\t\toffset: Number(ctx.query?.offset) || void 0\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tusers: [],\n\t\t\t\t\t\ttotal: 0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}),\n\t\t\tlistUserSessions: createAuthEndpoint(\"/admin/list-user-sessions\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tbody: z.object({ userId: z.coerce.string().meta({ description: \"The user id\" }) }),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"listUserSessions\",\n\t\t\t\t\tsummary: \"List user sessions\",\n\t\t\t\t\tdescription: \"List user sessions\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"List of user sessions\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { sessions: {\n\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\titems: { $ref: \"#/components/schemas/Session\" }\n\t\t\t\t\t\t\t} }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { session: [\"list\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS });\n\t\t\t\treturn { sessions: await ctx.context.internalAdapter.listSessions(ctx.body.userId) };\n\t\t\t}),\n\t\t\tunbanUser: createAuthEndpoint(\"/admin/unban-user\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userId: z.coerce.string().meta({ description: \"The user id\" }) }),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"unbanUser\",\n\t\t\t\t\tsummary: \"Unban a user\",\n\t\t\t\t\tdescription: \"Unban a user\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"User unbanned\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { user: { $ref: \"#/components/schemas/User\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"ban\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });\n\t\t\t\tconst user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {\n\t\t\t\t\tbanned: false,\n\t\t\t\t\tbanExpires: null,\n\t\t\t\t\tbanReason: null,\n\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t});\n\t\t\t\treturn ctx.json({ user });\n\t\t\t}),\n\t\t\tbanUser: createAuthEndpoint(\"/admin/ban-user\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tuserId: z.coerce.string().meta({ description: \"The user id\" }),\n\t\t\t\t\tbanReason: z.string().meta({ description: \"The reason for the ban\" }).optional(),\n\t\t\t\t\tbanExpiresIn: z.number().meta({ description: \"The number of seconds until the ban expires\" }).optional()\n\t\t\t\t}),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"banUser\",\n\t\t\t\t\tsummary: \"Ban a user\",\n\t\t\t\t\tdescription: \"Ban a user\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"User banned\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { user: { $ref: \"#/components/schemas/User\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"ban\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });\n\t\t\t\tif (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\tif (ctx.body.userId === ctx.context.session.user.id) throw new APIError(\"BAD_REQUEST\", { message: ADMIN_ERROR_CODES.YOU_CANNOT_BAN_YOURSELF });\n\t\t\t\tconst user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {\n\t\t\t\t\tbanned: true,\n\t\t\t\t\tbanReason: ctx.body.banReason || options?.defaultBanReason || \"No reason\",\n\t\t\t\t\tbanExpires: ctx.body.banExpiresIn ? getDate(ctx.body.banExpiresIn, \"sec\") : options?.defaultBanExpiresIn ? getDate(options.defaultBanExpiresIn, \"sec\") : void 0,\n\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t});\n\t\t\t\tawait ctx.context.internalAdapter.deleteSessions(ctx.body.userId);\n\t\t\t\treturn ctx.json({ user });\n\t\t\t}),\n\t\t\timpersonateUser: createAuthEndpoint(\"/admin/impersonate-user\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userId: z.coerce.string().meta({ description: \"The user id\" }) }),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"impersonateUser\",\n\t\t\t\t\tsummary: \"Impersonate a user\",\n\t\t\t\t\tdescription: \"Impersonate a user\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Impersonation session created\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" },\n\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: ctx.context.session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"impersonate\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS });\n\t\t\t\tconst targetUser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);\n\t\t\t\tif (!targetUser) throw new APIError(\"NOT_FOUND\", { message: \"User not found\" });\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(targetUser.id, true, {\n\t\t\t\t\timpersonatedBy: ctx.context.session.user.id,\n\t\t\t\t\texpiresAt: options?.impersonationSessionDuration ? getDate(options.impersonationSessionDuration, \"sec\") : getDate(3600, \"sec\")\n\t\t\t\t}, true);\n\t\t\t\tif (!session) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });\n\t\t\t\tconst authCookies = ctx.context.authCookies;\n\t\t\t\tdeleteSessionCookie(ctx);\n\t\t\t\tconst dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);\n\t\t\t\tconst adminCookieProp = ctx.context.createAuthCookie(\"admin_session\");\n\t\t\t\tawait ctx.setSignedCookie(adminCookieProp.name, `${ctx.context.session.session.token}:${dontRememberMeCookie || \"\"}`, ctx.context.secret, authCookies.sessionToken.options);\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: targetUser\n\t\t\t\t}, true);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: targetUser\n\t\t\t\t});\n\t\t\t}),\n\t\t\tstopImpersonating: createAuthEndpoint(\"/admin/stop-impersonating\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\trequireHeaders: true\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tif (!session) throw new APIError(\"UNAUTHORIZED\");\n\t\t\t\tif (!session.session.impersonatedBy) throw new APIError(\"BAD_REQUEST\", { message: \"You are not impersonating anyone\" });\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(session.session.impersonatedBy);\n\t\t\t\tif (!user) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Failed to find user\" });\n\t\t\t\tconst adminCookieName = ctx.context.createAuthCookie(\"admin_session\").name;\n\t\t\t\tconst adminCookie = await ctx.getSignedCookie(adminCookieName, ctx.context.secret);\n\t\t\t\tif (!adminCookie) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Failed to find admin session\" });\n\t\t\t\tconst [adminSessionToken, dontRememberMeCookie] = adminCookie?.split(\":\");\n\t\t\t\tconst adminSession = await ctx.context.internalAdapter.findSession(adminSessionToken);\n\t\t\t\tif (!adminSession || adminSession.session.userId !== user.id) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Failed to find admin session\" });\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(session.session.token);\n\t\t\t\tawait setSessionCookie(ctx, adminSession, !!dontRememberMeCookie);\n\t\t\t\treturn ctx.json(adminSession);\n\t\t\t}),\n\t\t\trevokeUserSession: createAuthEndpoint(\"/admin/revoke-user-session\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ sessionToken: z.string().meta({ description: \"The session token\" }) }),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"revokeUserSession\",\n\t\t\t\t\tsummary: \"Revoke a user session\",\n\t\t\t\t\tdescription: \"Revoke a user session\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Session revoked\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { session: [\"revoke\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(ctx.body.sessionToken);\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t}),\n\t\t\trevokeUserSessions: createAuthEndpoint(\"/admin/revoke-user-sessions\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userId: z.coerce.string().meta({ description: \"The user id\" }) }),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"revokeUserSessions\",\n\t\t\t\t\tsummary: \"Revoke all user sessions\",\n\t\t\t\t\tdescription: \"Revoke all user sessions\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Sessions revoked\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { session: [\"revoke\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });\n\t\t\t\tawait ctx.context.internalAdapter.deleteSessions(ctx.body.userId);\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t}),\n\t\t\tremoveUser: createAuthEndpoint(\"/admin/remove-user\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userId: z.coerce.string().meta({ description: \"The user id\" }) }),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"removeUser\",\n\t\t\t\t\tsummary: \"Remove a user\",\n\t\t\t\t\tdescription: \"Delete a user and all their sessions and accounts. Cannot be undone.\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"User removed\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst session = ctx.context.session;\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"delete\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS });\n\t\t\t\tif (ctx.body.userId === ctx.context.session.user.id) throw new APIError(\"BAD_REQUEST\", { message: ADMIN_ERROR_CODES.YOU_CANNOT_REMOVE_YOURSELF });\n\t\t\t\tif (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError(\"NOT_FOUND\", { message: \"User not found\" });\n\t\t\t\tawait ctx.context.internalAdapter.deleteUser(ctx.body.userId);\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t}),\n\t\t\tsetUserPassword: createAuthEndpoint(\"/admin/set-user-password\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tnewPassword: z.string().nonempty(\"newPassword cannot be empty\").meta({ description: \"The new password\" }),\n\t\t\t\t\tuserId: z.coerce.string().nonempty(\"userId cannot be empty\").meta({ description: \"The user id\" })\n\t\t\t\t}),\n\t\t\t\tuse: [adminMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"setUserPassword\",\n\t\t\t\t\tsummary: \"Set a user's password\",\n\t\t\t\t\tdescription: \"Set a user's password\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Password set\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!hasPermission({\n\t\t\t\t\tuserId: ctx.context.session.user.id,\n\t\t\t\t\trole: ctx.context.session.user.role,\n\t\t\t\t\toptions: opts,\n\t\t\t\t\tpermissions: { user: [\"set-password\"] }\n\t\t\t\t})) throw new APIError(\"FORBIDDEN\", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD });\n\t\t\t\tconst { newPassword, userId } = ctx.body;\n\t\t\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\t\t\tif (newPassword.length < minPasswordLength) {\n\t\t\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });\n\t\t\t\t}\n\t\t\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\t\t\t\tif (newPassword.length > maxPasswordLength) {\n\t\t\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });\n\t\t\t\t}\n\t\t\t\tconst hashedPassword = await ctx.context.password.hash(newPassword);\n\t\t\t\tawait ctx.context.internalAdapter.updatePassword(userId, hashedPassword);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t}),\n\t\t\tuserHasPermission: createAuthEndpoint(\"/admin/has-permission\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tuserId: z.coerce.string().optional().meta({ description: `The user id. Eg: \"user-id\"` }),\n\t\t\t\t\trole: z.string().optional().meta({ description: `The role to check permission for. Eg: \"admin\"` })\n\t\t\t\t}).and(z.union([z.object({\n\t\t\t\t\tpermission: z.record(z.string(), z.array(z.string())),\n\t\t\t\t\tpermissions: z.undefined()\n\t\t\t\t}), z.object({\n\t\t\t\t\tpermission: z.undefined(),\n\t\t\t\t\tpermissions: z.record(z.string(), z.array(z.string()))\n\t\t\t\t})])),\n\t\t\t\tmetadata: {\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\tdescription: \"Check if the user has permission\",\n\t\t\t\t\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tpermission: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tdescription: \"The permission to check\",\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tdescription: \"The permission to check\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"permissions\"]\n\t\t\t\t\t\t} } } },\n\t\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\terror: { type: \"string\" },\n\t\t\t\t\t\t\t\t\tsuccess: { type: \"boolean\" }\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"success\"]\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t},\n\t\t\t\t\t$Infer: { body: {} }\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!ctx.body?.permission && !ctx.body?.permissions) throw new APIError(\"BAD_REQUEST\", { message: \"invalid permission check. no permission(s) were passed.\" });\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tif (!session && (ctx.request || ctx.headers)) throw new APIError(\"UNAUTHORIZED\");\n\t\t\t\tif (!session && !ctx.body.userId && !ctx.body.role) throw new APIError(\"BAD_REQUEST\", { message: \"user id or role is required\" });\n\t\t\t\tconst user = session?.user || (ctx.body.role ? {\n\t\t\t\t\tid: ctx.body.userId || \"\",\n\t\t\t\t\trole: ctx.body.role\n\t\t\t\t} : null) || await ctx.context.internalAdapter.findUserById(ctx.body.userId);\n\t\t\t\tif (!user) throw new APIError(\"BAD_REQUEST\", { message: \"user not found\" });\n\t\t\t\tconst result = hasPermission({\n\t\t\t\t\tuserId: user.id,\n\t\t\t\t\trole: user.role,\n\t\t\t\t\toptions,\n\t\t\t\t\tpermissions: ctx.body.permissions ?? ctx.body.permission\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\terror: null,\n\t\t\t\t\tsuccess: result\n\t\t\t\t});\n\t\t\t})\n\t\t},\n\t\t$ERROR_CODES: ADMIN_ERROR_CODES,\n\t\tschema: mergeSchema(schema, opts.schema),\n\t\toptions\n\t};\n};\n\n//#endregion\nexport { admin as t };","import { l as verifyJWT, s as symmetricDecodeJWT } from \"./crypto-CFUhAR9W.mjs\";\nimport { l as parseUserOutput, s as parseSessionOutput, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as safeJSONParse } from \"./json-CnHxKYpj.mjs\";\nimport { c as setSessionCookie, m as getSessionQuerySchema, n as deleteSessionCookie, p as getChunkedCookie, s as setCookieCache } from \"./cookies-D72PbWdz.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\n\n//#region src/api/routes/session.ts\nconst getSession = () => createAuthEndpoint(\"/get-session\", {\n\tmethod: \"GET\",\n\toperationId: \"getSession\",\n\tquery: getSessionQuerySchema,\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\toperationId: \"getSession\",\n\t\tdescription: \"Get the current session\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tsession: { $ref: \"#/components/schemas/Session\" },\n\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t},\n\t\t\t\trequired: [\"session\", \"user\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\ttry {\n\t\tconst sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);\n\t\tif (!sessionCookieToken) return null;\n\t\tconst sessionDataCookie = getChunkedCookie(ctx, ctx.context.authCookies.sessionData.name);\n\t\tlet sessionDataPayload = null;\n\t\tif (sessionDataCookie) {\n\t\t\tconst strategy = ctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\t\t\tif (strategy === \"jwe\") {\n\t\t\t\tconst payload = await symmetricDecodeJWT(sessionDataCookie, ctx.context.secret, \"better-auth-session\");\n\t\t\t\tif (payload && payload.session && payload.user) sessionDataPayload = {\n\t\t\t\t\tsession: {\n\t\t\t\t\t\tsession: payload.session,\n\t\t\t\t\t\tuser: payload.user,\n\t\t\t\t\t\tupdatedAt: payload.updatedAt,\n\t\t\t\t\t\tversion: payload.version\n\t\t\t\t\t},\n\t\t\t\t\texpiresAt: payload.exp ? payload.exp * 1e3 : Date.now()\n\t\t\t\t};\n\t\t\t\telse {\n\t\t\t\t\tconst dataCookie = ctx.context.authCookies.sessionData.name;\n\t\t\t\t\tctx.setCookie(dataCookie, \"\", { maxAge: 0 });\n\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t}\n\t\t\t} else if (strategy === \"jwt\") {\n\t\t\t\tconst payload = await verifyJWT(sessionDataCookie, ctx.context.secret);\n\t\t\t\tif (payload && payload.session && payload.user) sessionDataPayload = {\n\t\t\t\t\tsession: {\n\t\t\t\t\t\tsession: payload.session,\n\t\t\t\t\t\tuser: payload.user,\n\t\t\t\t\t\tupdatedAt: payload.updatedAt,\n\t\t\t\t\t\tversion: payload.version\n\t\t\t\t\t},\n\t\t\t\t\texpiresAt: payload.exp ? payload.exp * 1e3 : Date.now()\n\t\t\t\t};\n\t\t\t\telse {\n\t\t\t\t\tconst dataCookie = ctx.context.authCookies.sessionData.name;\n\t\t\t\t\tctx.setCookie(dataCookie, \"\", { maxAge: 0 });\n\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst parsed = safeJSONParse(binary.decode(base64Url.decode(sessionDataCookie)));\n\t\t\t\tif (parsed) if (await createHMAC(\"SHA-256\", \"base64urlnopad\").verify(ctx.context.secret, JSON.stringify({\n\t\t\t\t\t...parsed.session,\n\t\t\t\t\texpiresAt: parsed.expiresAt\n\t\t\t\t}), parsed.signature)) sessionDataPayload = parsed;\n\t\t\t\telse {\n\t\t\t\t\tconst dataCookie = ctx.context.authCookies.sessionData.name;\n\t\t\t\t\tctx.setCookie(dataCookie, \"\", { maxAge: 0 });\n\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);\n\t\t/**\n\t\t* If session data is present in the cookie, check if it should be used or refreshed\n\t\t*/\n\t\tif (sessionDataPayload?.session && ctx.context.options.session?.cookieCache?.enabled && !ctx.query?.disableCookieCache) {\n\t\t\tconst session$1 = sessionDataPayload.session;\n\t\t\tconst versionConfig = ctx.context.options.session?.cookieCache?.version;\n\t\t\tlet expectedVersion = \"1\";\n\t\t\tif (versionConfig) {\n\t\t\t\tif (typeof versionConfig === \"string\") expectedVersion = versionConfig;\n\t\t\t\telse if (typeof versionConfig === \"function\") {\n\t\t\t\t\tconst result = versionConfig(session$1.session, session$1.user);\n\t\t\t\t\texpectedVersion = result instanceof Promise ? await result : result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((session$1.version || \"1\") !== expectedVersion) {\n\t\t\t\tconst dataCookie = ctx.context.authCookies.sessionData.name;\n\t\t\t\tctx.setCookie(dataCookie, \"\", { maxAge: 0 });\n\t\t\t} else if (sessionDataPayload.expiresAt < Date.now() || session$1.session.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\tconst dataCookie = ctx.context.authCookies.sessionData.name;\n\t\t\t\tctx.setCookie(dataCookie, \"\", { maxAge: 0 });\n\t\t\t} else {\n\t\t\t\tconst cookieRefreshCache = ctx.context.sessionConfig.cookieRefreshCache;\n\t\t\t\tif (cookieRefreshCache === false) {\n\t\t\t\t\tctx.context.session = session$1;\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tsession: session$1.session,\n\t\t\t\t\t\tuser: session$1.user\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (sessionDataPayload.expiresAt - Date.now() < cookieRefreshCache.updateAge * 1e3) {\n\t\t\t\t\tconst newExpiresAt = getDate(ctx.context.options.session?.cookieCache?.maxAge || 300, \"sec\");\n\t\t\t\t\tconst refreshedSession = {\n\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t...session$1.session,\n\t\t\t\t\t\t\texpiresAt: newExpiresAt\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuser: session$1.user,\n\t\t\t\t\t\tupdatedAt: Date.now()\n\t\t\t\t\t};\n\t\t\t\t\tawait setCookieCache(ctx, refreshedSession, false);\n\t\t\t\t\tconst parsedRefreshedSession = parseSessionOutput(ctx.context.options, {\n\t\t\t\t\t\t...refreshedSession.session,\n\t\t\t\t\t\texpiresAt: new Date(refreshedSession.session.expiresAt),\n\t\t\t\t\t\tcreatedAt: new Date(refreshedSession.session.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(refreshedSession.session.updatedAt)\n\t\t\t\t\t});\n\t\t\t\t\tconst parsedRefreshedUser = parseUserOutput(ctx.context.options, {\n\t\t\t\t\t\t...refreshedSession.user,\n\t\t\t\t\t\tcreatedAt: new Date(refreshedSession.user.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(refreshedSession.user.updatedAt)\n\t\t\t\t\t});\n\t\t\t\t\tctx.context.session = {\n\t\t\t\t\t\tsession: parsedRefreshedSession,\n\t\t\t\t\t\tuser: parsedRefreshedUser\n\t\t\t\t\t};\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tsession: parsedRefreshedSession,\n\t\t\t\t\t\tuser: parsedRefreshedUser\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst parsedSession = parseSessionOutput(ctx.context.options, {\n\t\t\t\t\t...session$1.session,\n\t\t\t\t\texpiresAt: new Date(session$1.session.expiresAt),\n\t\t\t\t\tcreatedAt: new Date(session$1.session.createdAt),\n\t\t\t\t\tupdatedAt: new Date(session$1.session.updatedAt)\n\t\t\t\t});\n\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, {\n\t\t\t\t\t...session$1.user,\n\t\t\t\t\tcreatedAt: new Date(session$1.user.createdAt),\n\t\t\t\t\tupdatedAt: new Date(session$1.user.updatedAt)\n\t\t\t\t});\n\t\t\t\tctx.context.session = {\n\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\tuser: parsedUser\n\t\t\t\t};\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\tuser: parsedUser\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst session = await ctx.context.internalAdapter.findSession(sessionCookieToken);\n\t\tctx.context.session = session;\n\t\tif (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\tdeleteSessionCookie(ctx);\n\t\t\tif (session)\n /**\n\t\t\t* if session expired clean up the session\n\t\t\t*/\n\t\t\tawait ctx.context.internalAdapter.deleteSession(session.session.token);\n\t\t\treturn ctx.json(null);\n\t\t}\n\t\t/**\n\t\t* We don't need to update the session if the user doesn't want to be remembered\n\t\t* or if the session refresh is disabled\n\t\t*/\n\t\tif (dontRememberMe || ctx.query?.disableRefresh) {\n\t\t\tconst parsedSession = parseSessionOutput(ctx.context.options, session.session);\n\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\treturn ctx.json({\n\t\t\t\tsession: parsedSession,\n\t\t\t\tuser: parsedUser\n\t\t\t});\n\t\t}\n\t\tconst expiresIn = ctx.context.sessionConfig.expiresIn;\n\t\tconst updateAge = ctx.context.sessionConfig.updateAge;\n\t\tif (session.session.expiresAt.valueOf() - expiresIn * 1e3 + updateAge * 1e3 <= Date.now() && (!ctx.query?.disableRefresh || !ctx.context.options.session?.disableSessionRefresh)) {\n\t\t\tconst updatedSession = await ctx.context.internalAdapter.updateSession(session.session.token, {\n\t\t\t\texpiresAt: getDate(ctx.context.sessionConfig.expiresIn, \"sec\"),\n\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t});\n\t\t\tif (!updatedSession) {\n\t\t\t\t/**\n\t\t\t\t* Handle case where session update fails (e.g., concurrent deletion)\n\t\t\t\t*/\n\t\t\t\tdeleteSessionCookie(ctx);\n\t\t\t\treturn ctx.json(null, { status: 401 });\n\t\t\t}\n\t\t\tconst maxAge = (updatedSession.expiresAt.valueOf() - Date.now()) / 1e3;\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: updatedSession,\n\t\t\t\tuser: session.user\n\t\t\t}, false, { maxAge });\n\t\t\tconst parsedUpdatedSession = parseSessionOutput(ctx.context.options, updatedSession);\n\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\treturn ctx.json({\n\t\t\t\tsession: parsedUpdatedSession,\n\t\t\t\tuser: parsedUser\n\t\t\t});\n\t\t}\n\t\tawait setCookieCache(ctx, session, !!dontRememberMe);\n\t\treturn ctx.json(session);\n\t} catch (error) {\n\t\tctx.context.logger.error(\"INTERNAL_SERVER_ERROR\", error);\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });\n\t}\n});\nconst getSessionFromCtx = async (ctx, config) => {\n\tif (ctx.context.session) return ctx.context.session;\n\tconst session = await getSession()({\n\t\t...ctx,\n\t\tasResponse: false,\n\t\theaders: ctx.headers,\n\t\treturnHeaders: false,\n\t\treturnStatus: false,\n\t\tquery: {\n\t\t\t...config,\n\t\t\t...ctx.query\n\t\t}\n\t}).catch((e) => {\n\t\treturn null;\n\t});\n\tctx.context.session = session;\n\treturn session;\n};\n/**\n* The middleware forces the endpoint to require a valid session.\n*/\nconst sessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session) throw new APIError(\"UNAUTHORIZED\");\n\treturn { session };\n});\n/**\n* This middleware forces the endpoint to require a valid session and ignores cookie cache.\n* This should be used for sensitive operations like password changes, account deletion, etc.\n* to ensure that revoked sessions cannot be used even if they're still cached in cookies.\n*/\nconst sensitiveSessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx, { disableCookieCache: true });\n\tif (!session?.session) throw new APIError(\"UNAUTHORIZED\");\n\treturn { session };\n});\n/**\n* This middleware allows you to call the endpoint on the client if session is valid.\n* However, if called on the server, no session is required.\n*/\nconst requestOnlySessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session && (ctx.request || ctx.headers)) throw new APIError(\"UNAUTHORIZED\");\n\treturn { session };\n});\n/**\n* This middleware forces the endpoint to require a valid session,\n* as well as making sure the session is fresh before proceeding.\n*\n* Session freshness check will be skipped if the session config's freshAge\n* is set to 0\n*/\nconst freshSessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session) throw new APIError(\"UNAUTHORIZED\");\n\tif (ctx.context.sessionConfig.freshAge === 0) return { session };\n\tconst freshAge = ctx.context.sessionConfig.freshAge;\n\tconst lastUpdated = new Date(session.session.updatedAt || session.session.createdAt).getTime();\n\tif (!(Date.now() - lastUpdated < freshAge * 1e3)) throw new APIError(\"FORBIDDEN\", { message: \"Session is not fresh\" });\n\treturn { session };\n});\n/**\n* user active sessions list\n*/\nconst listSessions = () => createAuthEndpoint(\"/list-sessions\", {\n\tmethod: \"GET\",\n\toperationId: \"listUserSessions\",\n\tuse: [sessionMiddleware],\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\toperationId: \"listUserSessions\",\n\t\tdescription: \"List all active sessions for the user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: { $ref: \"#/components/schemas/Session\" }\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\ttry {\n\t\tconst activeSessions = (await ctx.context.internalAdapter.listSessions(ctx.context.session.user.id)).filter((session) => {\n\t\t\treturn session.expiresAt > /* @__PURE__ */ new Date();\n\t\t});\n\t\treturn ctx.json(activeSessions);\n\t} catch (e) {\n\t\tctx.context.logger.error(e);\n\t\tthrow ctx.error(\"INTERNAL_SERVER_ERROR\");\n\t}\n});\n/**\n* revoke a single session\n*/\nconst revokeSession = createAuthEndpoint(\"/revoke-session\", {\n\tmethod: \"POST\",\n\tbody: z.object({ token: z.string().meta({ description: \"The token to revoke\" }) }),\n\tuse: [sensitiveSessionMiddleware],\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\tdescription: \"Revoke a single session\",\n\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\ttype: \"object\",\n\t\t\tproperties: { token: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: \"The token to revoke\"\n\t\t\t} },\n\t\t\trequired: [\"token\"]\n\t\t} } } },\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { status: {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\tdescription: \"Indicates if the session was revoked successfully\"\n\t\t\t\t} },\n\t\t\t\trequired: [\"status\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst token = ctx.body.token;\n\tif ((await ctx.context.internalAdapter.findSession(token))?.session.userId === ctx.context.session.user.id) try {\n\t\tawait ctx.context.internalAdapter.deleteSession(token);\n\t} catch (error) {\n\t\tctx.context.logger.error(error && typeof error === \"object\" && \"name\" in error ? error.name : \"\", error);\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\");\n\t}\n\treturn ctx.json({ status: true });\n});\n/**\n* revoke all user sessions\n*/\nconst revokeSessions = createAuthEndpoint(\"/revoke-sessions\", {\n\tmethod: \"POST\",\n\tuse: [sensitiveSessionMiddleware],\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\tdescription: \"Revoke all sessions for the user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { status: {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\tdescription: \"Indicates if all sessions were revoked successfully\"\n\t\t\t\t} },\n\t\t\t\trequired: [\"status\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\ttry {\n\t\tawait ctx.context.internalAdapter.deleteSessions(ctx.context.session.user.id);\n\t} catch (error) {\n\t\tctx.context.logger.error(error && typeof error === \"object\" && \"name\" in error ? error.name : \"\", error);\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\");\n\t}\n\treturn ctx.json({ status: true });\n});\nconst revokeOtherSessions = createAuthEndpoint(\"/revoke-other-sessions\", {\n\tmethod: \"POST\",\n\trequireHeaders: true,\n\tuse: [sensitiveSessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Revoke all other sessions for the user except the current one\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { status: {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\tdescription: \"Indicates if all other sessions were revoked successfully\"\n\t\t\t\t} },\n\t\t\t\trequired: [\"status\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tif (!session.user) throw new APIError(\"UNAUTHORIZED\");\n\tconst otherSessions = (await ctx.context.internalAdapter.listSessions(session.user.id)).filter((session$1) => {\n\t\treturn session$1.expiresAt > /* @__PURE__ */ new Date();\n\t}).filter((session$1) => session$1.token !== ctx.context.session.session.token);\n\tawait Promise.all(otherSessions.map((session$1) => ctx.context.internalAdapter.deleteSession(session$1.token)));\n\treturn ctx.json({ status: true });\n});\n\n//#endregion\nexport { requestOnlySessionMiddleware as a, revokeSessions as c, listSessions as i, sensitiveSessionMiddleware as l, getSession as n, revokeOtherSessions as o, getSessionFromCtx as r, revokeSession as s, freshSessionMiddleware as t, sessionMiddleware as u };","import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt, u as constantTimeEqual } from \"./crypto-CFUhAR9W.mjs\";\nimport { u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as APIError } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie, s as setCookieCache } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx } from \"./session-AaRl3_x-.mjs\";\nimport { t as getEndpointResponse } from \"./plugin-helper-zFdFWLgL.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\nimport { base64Url } from \"@better-auth/utils/base64\";\n\n//#region src/plugins/email-otp/utils.ts\nconst defaultKeyHasher = async (otp) => {\n\tconst hash = await createHash(\"SHA-256\").digest(new TextEncoder().encode(otp));\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n};\nfunction splitAtLastColon(input) {\n\tconst idx = input.lastIndexOf(\":\");\n\tif (idx === -1) return [input, \"\"];\n\treturn [input.slice(0, idx), input.slice(idx + 1)];\n}\n\n//#endregion\n//#region src/plugins/email-otp/index.ts\nconst types = [\n\t\"email-verification\",\n\t\"sign-in\",\n\t\"forget-password\"\n];\nconst defaultOTPGenerator = (options) => generateRandomString(options.otpLength ?? 6, \"0-9\");\nconst ERROR_CODES = defineErrorCodes({\n\tOTP_EXPIRED: \"OTP expired\",\n\tINVALID_OTP: \"Invalid OTP\",\n\tTOO_MANY_ATTEMPTS: \"Too many attempts\"\n});\nconst emailOTP = (options) => {\n\tconst opts = {\n\t\texpiresIn: 300,\n\t\tgenerateOTP: () => defaultOTPGenerator(options),\n\t\tstoreOTP: \"plain\",\n\t\t...options\n\t};\n\tasync function storeOTP(ctx, otp) {\n\t\tif (opts.storeOTP === \"encrypted\") return await symmetricEncrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: otp\n\t\t});\n\t\tif (opts.storeOTP === \"hashed\") return await defaultKeyHasher(otp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"hash\" in opts.storeOTP) return await opts.storeOTP.hash(otp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"encrypt\" in opts.storeOTP) return await opts.storeOTP.encrypt(otp);\n\t\treturn otp;\n\t}\n\tasync function verifyStoredOTP(ctx, storedOtp, otp) {\n\t\tif (opts.storeOTP === \"encrypted\") return constantTimeEqual(await symmetricDecrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: storedOtp\n\t\t}), otp);\n\t\tif (opts.storeOTP === \"hashed\") return constantTimeEqual(await defaultKeyHasher(otp), storedOtp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"hash\" in opts.storeOTP) return constantTimeEqual(await opts.storeOTP.hash(otp), storedOtp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"decrypt\" in opts.storeOTP) return constantTimeEqual(await opts.storeOTP.decrypt(storedOtp), otp);\n\t\treturn constantTimeEqual(otp, storedOtp);\n\t}\n\tconst endpoints = { sendVerificationOTP: createAuthEndpoint(\"/email-otp/send-verification-otp\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\temail: z.string({}).meta({ description: \"Email address to send the OTP\" }),\n\t\t\ttype: z.enum(types).meta({ description: \"Type of the OTP\" })\n\t\t}),\n\t\tmetadata: { openapi: {\n\t\t\toperationId: \"sendEmailVerificationOTP\",\n\t\t\tdescription: \"Send a verification OTP to an email\",\n\t\t\tresponses: { 200: {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tif (!options?.sendVerificationOTP) {\n\t\t\tctx.context.logger.error(\"send email verification is not implemented\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"send email verification is not implemented\" });\n\t\t}\n\t\tconst email = ctx.body.email.toLowerCase();\n\t\tif (!z.email().safeParse(email).success) throw ctx.error(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\t\tlet otp = opts.generateOTP({\n\t\t\temail,\n\t\t\ttype: ctx.body.type\n\t\t}, ctx) || defaultOTPGenerator(opts);\n\t\tlet storedOTP = await storeOTP(ctx, otp);\n\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\tvalue: `${storedOTP}:0`,\n\t\t\tidentifier: `${ctx.body.type}-otp-${email}`,\n\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t}).catch(async (error) => {\n\t\t\tawait ctx.context.internalAdapter.deleteVerificationByIdentifier(`${ctx.body.type}-otp-${email}`);\n\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\tvalue: `${storedOTP}:0`,\n\t\t\t\tidentifier: `${ctx.body.type}-otp-${email}`,\n\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t});\n\t\t});\n\t\tif (!await ctx.context.internalAdapter.findUserByEmail(email)) if (ctx.body.type === \"sign-in\" && !opts.disableSignUp) {} else {\n\t\t\tawait ctx.context.internalAdapter.deleteVerificationByIdentifier(`${ctx.body.type}-otp-${email}`);\n\t\t\treturn ctx.json({ success: true });\n\t\t}\n\t\tawait options.sendVerificationOTP({\n\t\t\temail,\n\t\t\totp,\n\t\t\ttype: ctx.body.type\n\t\t}, ctx);\n\t\treturn ctx.json({ success: true });\n\t}) };\n\treturn {\n\t\tid: \"email-otp\",\n\t\tinit(ctx) {\n\t\t\tif (!opts.overrideDefaultEmailVerification) return;\n\t\t\treturn { options: { emailVerification: { async sendVerificationEmail(data, request) {\n\t\t\t\tawait endpoints.sendVerificationOTP({\n\t\t\t\t\tcontext: ctx,\n\t\t\t\t\trequest,\n\t\t\t\t\tbody: {\n\t\t\t\t\t\temail: data.user.email,\n\t\t\t\t\t\ttype: \"email-verification\"\n\t\t\t\t\t},\n\t\t\t\t\tctx\n\t\t\t\t});\n\t\t\t} } } };\n\t\t},\n\t\tendpoints: {\n\t\t\t...endpoints,\n\t\t\tcreateVerificationOTP: createAuthEndpoint(\"/email-otp/create-verification-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.string({}).meta({ description: \"Email address to send the OTP\" }),\n\t\t\t\t\ttype: z.enum(types).meta({\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"Type of the OTP\"\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t\tmetadata: {\n\t\t\t\t\tSERVER_ONLY: true,\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\toperationId: \"createEmailVerificationOTP\",\n\t\t\t\t\t\tdescription: \"Create a verification OTP for an email\",\n\t\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: { type: \"string\" } } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.body.email.toLowerCase();\n\t\t\t\tconst otp = opts.generateOTP({\n\t\t\t\t\temail,\n\t\t\t\t\ttype: ctx.body.type\n\t\t\t\t}, ctx) || defaultOTPGenerator(opts);\n\t\t\t\tlet storedOTP = await storeOTP(ctx, otp);\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: `${storedOTP}:0`,\n\t\t\t\t\tidentifier: `${ctx.body.type}-otp-${email}`,\n\t\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t\t});\n\t\t\t\treturn otp;\n\t\t\t}),\n\t\t\tgetVerificationOTP: createAuthEndpoint(\"/email-otp/get-verification-otp\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: z.object({\n\t\t\t\t\temail: z.string({}).meta({ description: \"Email address the OTP was sent to\" }),\n\t\t\t\t\ttype: z.enum(types).meta({\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"Type of the OTP\"\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t\tmetadata: {\n\t\t\t\t\tSERVER_ONLY: true,\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\toperationId: \"getEmailVerificationOTP\",\n\t\t\t\t\t\tdescription: \"Get a verification OTP for an email\",\n\t\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\t\tdescription: \"OTP retrieved successfully or not found/expired\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: { otp: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"The stored OTP, or null if not found or expired\"\n\t\t\t\t\t\t\t\t} },\n\t\t\t\t\t\t\t\trequired: [\"otp\"]\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.query.email.toLowerCase();\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.query.type}-otp-${email}`);\n\t\t\t\tif (!verificationValue || verificationValue.expiresAt < /* @__PURE__ */ new Date()) return ctx.json({ otp: null });\n\t\t\t\tif (opts.storeOTP === \"hashed\" || typeof opts.storeOTP === \"object\" && \"hash\" in opts.storeOTP) throw new APIError(\"BAD_REQUEST\", { message: \"OTP is hashed, cannot return the plain text OTP\" });\n\t\t\t\tlet [storedOtp, _attempts] = splitAtLastColon(verificationValue.value);\n\t\t\t\tlet otp = storedOtp;\n\t\t\t\tif (opts.storeOTP === \"encrypted\") otp = await symmetricDecrypt({\n\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\tdata: storedOtp\n\t\t\t\t});\n\t\t\t\tif (typeof opts.storeOTP === \"object\" && \"decrypt\" in opts.storeOTP) otp = await opts.storeOTP.decrypt(storedOtp);\n\t\t\t\treturn ctx.json({ otp });\n\t\t\t}),\n\t\t\tcheckVerificationOTP: createAuthEndpoint(\"/email-otp/check-verification-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.string().meta({ description: \"Email address the OTP was sent to\" }),\n\t\t\t\t\ttype: z.enum(types).meta({\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"Type of the OTP\"\n\t\t\t\t\t}),\n\t\t\t\t\totp: z.string().meta({\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"OTP to verify\"\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"verifyEmailWithOTP\",\n\t\t\t\t\tdescription: \"Verify an email with an OTP\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.body.email.toLowerCase();\n\t\t\t\tif (!z.email().safeParse(email).success) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\t\t\t\tif (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.type}-otp-${email}`);\n\t\t\t\tif (!verificationValue) throw new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.OTP_EXPIRED });\n\t\t\t\t}\n\t\t\t\tconst [otpValue, attempts] = splitAtLastColon(verificationValue.value);\n\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 3;\n\t\t\t\tif (attempts && parseInt(attempts) >= allowedAttempts) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });\n\t\t\t\t}\n\t\t\t\tif (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {\n\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || \"0\") + 1}` });\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\t}\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t}),\n\t\t\tverifyEmailOTP: createAuthEndpoint(\"/email-otp/verify-email\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.string({}).meta({ description: \"Email address to verify\" }),\n\t\t\t\t\totp: z.string().meta({\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"OTP to verify\"\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Verify email with OTP\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the verification was successful\",\n\t\t\t\t\t\t\t\t\tenum: [true]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"Session token if autoSignInAfterVerification is enabled, otherwise null\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\"status\",\n\t\t\t\t\t\t\t\t\"token\",\n\t\t\t\t\t\t\t\t\"user\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.body.email.toLowerCase();\n\t\t\t\tif (!z.email().safeParse(email).success) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(`email-verification-otp-${email}`);\n\t\t\t\tif (!verificationValue) throw new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.OTP_EXPIRED });\n\t\t\t\tconst [otpValue, attempts] = splitAtLastColon(verificationValue.value);\n\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 3;\n\t\t\t\tif (attempts && parseInt(attempts) >= allowedAttempts) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });\n\t\t\t\t}\n\t\t\t\tif (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {\n\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || \"0\") + 1}` });\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\t}\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\t\t\tif (!user)\n /**\n\t\t\t\t* safe to leak the existence of a user, given the user has already the OTP from the\n\t\t\t\t* email\n\t\t\t\t*/\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(user.user.id, {\n\t\t\t\t\temail,\n\t\t\t\t\temailVerified: true\n\t\t\t\t});\n\t\t\t\tawait ctx.context.options.emailVerification?.onEmailVerification?.(updatedUser, ctx.request);\n\t\t\t\tif (ctx.context.options.emailVerification?.autoSignInAfterVerification) {\n\t\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(updatedUser.id);\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tuser: updatedUser\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\ttoken: session.token,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: updatedUser.id,\n\t\t\t\t\t\t\temail: updatedUser.email,\n\t\t\t\t\t\t\temailVerified: updatedUser.emailVerified,\n\t\t\t\t\t\t\tname: updatedUser.name,\n\t\t\t\t\t\t\timage: updatedUser.image,\n\t\t\t\t\t\t\tcreatedAt: updatedUser.createdAt,\n\t\t\t\t\t\t\tupdatedAt: updatedUser.updatedAt\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst currentSession = await getSessionFromCtx(ctx);\n\t\t\t\tif (currentSession && updatedUser.emailVerified) {\n\t\t\t\t\tconst dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);\n\t\t\t\t\tawait setCookieCache(ctx, {\n\t\t\t\t\t\tsession: currentSession.session,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t...currentSession.user,\n\t\t\t\t\t\t\temailVerified: true\n\t\t\t\t\t\t}\n\t\t\t\t\t}, !!dontRememberMeCookie);\n\t\t\t\t}\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tstatus: true,\n\t\t\t\t\ttoken: null,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: updatedUser.id,\n\t\t\t\t\t\temail: updatedUser.email,\n\t\t\t\t\t\temailVerified: updatedUser.emailVerified,\n\t\t\t\t\t\tname: updatedUser.name,\n\t\t\t\t\t\timage: updatedUser.image,\n\t\t\t\t\t\tcreatedAt: updatedUser.createdAt,\n\t\t\t\t\t\tupdatedAt: updatedUser.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tsignInEmailOTP: createAuthEndpoint(\"/sign-in/email-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.string({}).meta({ description: \"Email address to sign in\" }),\n\t\t\t\t\totp: z.string().meta({\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"OTP sent to the email\"\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"signInWithEmailOTP\",\n\t\t\t\t\tdescription: \"Sign in with email and OTP\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Session token for the authenticated session\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser: { $ref: \"#/components/schemas/User\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"token\", \"user\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.body.email.toLowerCase();\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(`sign-in-otp-${email}`);\n\t\t\t\tif (!verificationValue) throw new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.OTP_EXPIRED });\n\t\t\t\tconst [otpValue, attempts] = splitAtLastColon(verificationValue.value);\n\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 3;\n\t\t\t\tif (attempts && parseInt(attempts) >= allowedAttempts) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });\n\t\t\t\t}\n\t\t\t\tif (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {\n\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || \"0\") + 1}` });\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\t}\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\t\t\tif (!user) {\n\t\t\t\t\tif (opts.disableSignUp) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\t\tconst newUser = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\t\temail,\n\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t\tname: \"\"\n\t\t\t\t\t});\n\t\t\t\t\tconst session$1 = await ctx.context.internalAdapter.createSession(newUser.id);\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: session$1,\n\t\t\t\t\t\tuser: newUser\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\ttoken: session$1.token,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: newUser.id,\n\t\t\t\t\t\t\temail: newUser.email,\n\t\t\t\t\t\t\temailVerified: newUser.emailVerified,\n\t\t\t\t\t\t\tname: newUser.name,\n\t\t\t\t\t\t\timage: newUser.image,\n\t\t\t\t\t\t\tcreatedAt: newUser.createdAt,\n\t\t\t\t\t\t\tupdatedAt: newUser.updatedAt\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!user.user.emailVerified) await ctx.context.internalAdapter.updateUser(user.user.id, { emailVerified: true });\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.user.id);\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user.user\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.user.id,\n\t\t\t\t\t\temail: user.user.email,\n\t\t\t\t\t\temailVerified: user.user.emailVerified,\n\t\t\t\t\t\tname: user.user.name,\n\t\t\t\t\t\timage: user.user.image,\n\t\t\t\t\t\tcreatedAt: user.user.createdAt,\n\t\t\t\t\t\tupdatedAt: user.user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tforgetPasswordEmailOTP: createAuthEndpoint(\"/forget-password/email-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ email: z.string().meta({ description: \"Email address to send the OTP\" }) }),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"forgetPasswordWithEmailOTP\",\n\t\t\t\t\tdescription: \"Forget password with email and OTP\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: {\n\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\tdescription: \"Indicates if the OTP was sent successfully\"\n\t\t\t\t\t\t\t} }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.body.email;\n\t\t\t\tconst otp = opts.generateOTP({\n\t\t\t\t\temail,\n\t\t\t\t\ttype: \"forget-password\"\n\t\t\t\t}, ctx) || defaultOTPGenerator(opts);\n\t\t\t\tlet storedOTP = await storeOTP(ctx, otp);\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: `${storedOTP}:0`,\n\t\t\t\t\tidentifier: `forget-password-otp-${email}`,\n\t\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t\t});\n\t\t\t\tif (!await ctx.context.internalAdapter.findUserByEmail(email)) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationByIdentifier(`forget-password-otp-${email}`);\n\t\t\t\t\treturn ctx.json({ success: true });\n\t\t\t\t}\n\t\t\t\tawait options.sendVerificationOTP({\n\t\t\t\t\temail,\n\t\t\t\t\totp,\n\t\t\t\t\ttype: \"forget-password\"\n\t\t\t\t}, ctx).catch((e) => {\n\t\t\t\t\tctx.context.logger.error(\"Failed to send OTP\", e);\n\t\t\t\t});\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t}),\n\t\t\tresetPasswordEmailOTP: createAuthEndpoint(\"/email-otp/reset-password\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\temail: z.string().meta({ description: \"Email address to reset the password\" }),\n\t\t\t\t\totp: z.string().meta({ description: \"OTP sent to the email\" }),\n\t\t\t\t\tpassword: z.string().meta({ description: \"New password\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\toperationId: \"resetPasswordWithEmailOTP\",\n\t\t\t\t\tdescription: \"Reset password with email and OTP\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontnt: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst email = ctx.body.email;\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(`forget-password-otp-${email}`);\n\t\t\t\tif (!verificationValue) throw new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.OTP_EXPIRED });\n\t\t\t\t}\n\t\t\t\tconst [otpValue, attempts] = splitAtLastColon(verificationValue.value);\n\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 3;\n\t\t\t\tif (attempts && parseInt(attempts) >= allowedAttempts) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });\n\t\t\t\t}\n\t\t\t\tif (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {\n\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || \"0\") + 1}` });\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_OTP });\n\t\t\t\t}\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });\n\t\t\t\tif (!user) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\t\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\t\t\tif (ctx.body.password.length < minPasswordLength) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });\n\t\t\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\t\t\t\tif (ctx.body.password.length > maxPasswordLength) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });\n\t\t\t\tconst passwordHash = await ctx.context.password.hash(ctx.body.password);\n\t\t\t\tif (!user.accounts?.find((account) => account.providerId === \"credential\")) await ctx.context.internalAdapter.createAccount({\n\t\t\t\t\tuserId: user.user.id,\n\t\t\t\t\tproviderId: \"credential\",\n\t\t\t\t\taccountId: user.user.id,\n\t\t\t\t\tpassword: passwordHash\n\t\t\t\t});\n\t\t\t\telse await ctx.context.internalAdapter.updatePassword(user.user.id, passwordHash);\n\t\t\t\tif (ctx.context.options.emailAndPassword?.onPasswordReset) await ctx.context.options.emailAndPassword.onPasswordReset({ user: user.user }, ctx.request);\n\t\t\t\tif (!user.user.emailVerified) await ctx.context.internalAdapter.updateUser(user.user.id, { emailVerified: true });\n\t\t\t\tif (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) await ctx.context.internalAdapter.deleteSessions(user.user.id);\n\t\t\t\treturn ctx.json({ success: true });\n\t\t\t})\n\t\t},\n\t\thooks: { after: [{\n\t\t\tmatcher(context) {\n\t\t\t\treturn !!(context.path?.startsWith(\"/sign-up\") && opts.sendVerificationOnSignUp && !opts.overrideDefaultEmailVerification);\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst email = (await getEndpointResponse(ctx))?.user.email;\n\t\t\t\tif (email) {\n\t\t\t\t\tconst otp = opts.generateOTP({\n\t\t\t\t\t\temail,\n\t\t\t\t\t\ttype: ctx.body.type\n\t\t\t\t\t}, ctx) || defaultOTPGenerator(opts);\n\t\t\t\t\tlet storedOTP = await storeOTP(ctx, otp);\n\t\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\t\tvalue: `${storedOTP}:0`,\n\t\t\t\t\t\tidentifier: `email-verification-otp-${email}`,\n\t\t\t\t\t\texpiresAt: getDate(opts.expiresIn, \"sec\")\n\t\t\t\t\t});\n\t\t\t\t\tawait options.sendVerificationOTP({\n\t\t\t\t\t\temail,\n\t\t\t\t\t\totp,\n\t\t\t\t\t\ttype: \"email-verification\"\n\t\t\t\t\t}, ctx);\n\t\t\t\t}\n\t\t\t})\n\t\t}] },\n\t\t$ERROR_CODES: ERROR_CODES,\n\t\trateLimit: [\n\t\t\t{\n\t\t\t\tpathMatcher(path) {\n\t\t\t\t\treturn path === \"/email-otp/send-verification-otp\";\n\t\t\t\t},\n\t\t\t\twindow: 60,\n\t\t\t\tmax: 3\n\t\t\t},\n\t\t\t{\n\t\t\t\tpathMatcher(path) {\n\t\t\t\t\treturn path === \"/email-otp/check-verification-otp\";\n\t\t\t\t},\n\t\t\t\twindow: 60,\n\t\t\t\tmax: 3\n\t\t\t},\n\t\t\t{\n\t\t\t\tpathMatcher(path) {\n\t\t\t\t\treturn path === \"/email-otp/verify-email\";\n\t\t\t\t},\n\t\t\t\twindow: 60,\n\t\t\t\tmax: 3\n\t\t\t},\n\t\t\t{\n\t\t\t\tpathMatcher(path) {\n\t\t\t\t\treturn path === \"/sign-in/email-otp\";\n\t\t\t\t},\n\t\t\t\twindow: 60,\n\t\t\t\tmax: 3\n\t\t\t}\n\t\t]\n\t};\n};\n\n//#endregion\nexport { emailOTP as t };","import { i as parseState, n as HIDE_METADATA, r as generateState } from \"./utils-db7gNqd-.mjs\";\nimport { O as handleOAuthUserInfo } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { createAuthorizationURL, refreshAccessToken, validateAuthorizationCode } from \"@better-auth/core/oauth2\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { decodeJwt } from \"jose\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { betterFetch } from \"@better-fetch/fetch\";\n\n//#region src/plugins/generic-oauth/error-codes.ts\nconst GENERIC_OAUTH_ERROR_CODES = defineErrorCodes({\n\tINVALID_OAUTH_CONFIGURATION: \"Invalid OAuth configuration\",\n\tTOKEN_URL_NOT_FOUND: \"Invalid OAuth configuration. Token URL not found.\",\n\tPROVIDER_CONFIG_NOT_FOUND: \"No config found for provider\",\n\tPROVIDER_ID_REQUIRED: \"Provider ID is required\",\n\tINVALID_OAUTH_CONFIG: \"Invalid OAuth configuration.\",\n\tSESSION_REQUIRED: \"Session is required\"\n});\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/auth0.ts\n/**\n* Auth0 OAuth provider helper\n*\n* @example\n* ```ts\n* import { genericOAuth, auth0 } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         auth0({\n*           clientId: process.env.AUTH0_CLIENT_ID,\n*           clientSecret: process.env.AUTH0_CLIENT_SECRET,\n*           domain: process.env.AUTH0_DOMAIN,\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction auth0(options) {\n\tconst defaultScopes = [\n\t\t\"openid\",\n\t\t\"profile\",\n\t\t\"email\"\n\t];\n\tconst domain = options.domain.replace(/^https?:\\/\\//, \"\");\n\tconst discoveryUrl = `https://${domain}/.well-known/openid-configuration`;\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tconst { data: profile, error } = await betterFetch(`https://${domain}/userinfo`, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });\n\t\tif (error || !profile) return null;\n\t\treturn {\n\t\t\tid: profile.sub,\n\t\t\tname: profile.name ?? profile.nickname ?? void 0,\n\t\t\temail: profile.email ?? void 0,\n\t\t\timage: profile.picture,\n\t\t\temailVerified: profile.email_verified ?? false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: \"auth0\",\n\t\tdiscoveryUrl,\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/hubspot.ts\n/**\n* HubSpot OAuth provider helper\n*\n* @example\n* ```ts\n* import { genericOAuth, hubspot } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         hubspot({\n*           clientId: process.env.HUBSPOT_CLIENT_ID,\n*           clientSecret: process.env.HUBSPOT_CLIENT_SECRET,\n*           scopes: [\"oauth\", \"contacts\"],\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction hubspot(options) {\n\tconst defaultScopes = [\"oauth\"];\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tconst { data: profile, error } = await betterFetch(`https://api.hubapi.com/oauth/v1/access-tokens/${tokens.accessToken}`, { headers: { \"Content-Type\": \"application/json\" } });\n\t\tif (error || !profile) return null;\n\t\tconst id = profile.user_id ?? profile.signed_access_token?.userId;\n\t\tif (!id) return null;\n\t\treturn {\n\t\t\tid,\n\t\t\tname: profile.user,\n\t\t\temail: profile.user,\n\t\t\timage: void 0,\n\t\t\temailVerified: false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: \"hubspot\",\n\t\tauthorizationUrl: \"https://app.hubspot.com/oauth/authorize\",\n\t\ttokenUrl: \"https://api.hubapi.com/oauth/v1/token\",\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tauthentication: \"post\",\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/keycloak.ts\n/**\n* Keycloak OAuth provider helper\n*\n* @example\n* ```ts\n* import { genericOAuth, keycloak } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         keycloak({\n*           clientId: process.env.KEYCLOAK_CLIENT_ID,\n*           clientSecret: process.env.KEYCLOAK_CLIENT_SECRET,\n*           issuer: process.env.KEYCLOAK_ISSUER,\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction keycloak(options) {\n\tconst defaultScopes = [\n\t\t\"openid\",\n\t\t\"profile\",\n\t\t\"email\"\n\t];\n\tconst issuer = options.issuer.replace(/\\/$/, \"\");\n\tconst discoveryUrl = `${issuer}/.well-known/openid-configuration`;\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tconst { data: profile, error } = await betterFetch(`${issuer}/protocol/openid-connect/userinfo`, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });\n\t\tif (error || !profile) return null;\n\t\treturn {\n\t\t\tid: profile.sub,\n\t\t\tname: profile.name ?? profile.preferred_username ?? void 0,\n\t\t\temail: profile.email ?? void 0,\n\t\t\timage: profile.picture,\n\t\t\temailVerified: profile.email_verified ?? false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: \"keycloak\",\n\t\tdiscoveryUrl,\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/line.ts\n/**\n* LINE OAuth provider helper\n*\n* LINE requires separate channels for different countries (Japan, Thailand, Taiwan, etc.).\n* Each channel has its own clientId and clientSecret. To support multiple countries,\n* call this function multiple times with different providerIds and credentials.\n*\n* @example\n* ```ts\n* import { genericOAuth, line } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         // Japan channel\n*         line({\n*           providerId: \"line-jp\",\n*           clientId: process.env.LINE_JP_CLIENT_ID,\n*           clientSecret: process.env.LINE_JP_CLIENT_SECRET,\n*         }),\n*         // Thailand channel\n*         line({\n*           providerId: \"line-th\",\n*           clientId: process.env.LINE_TH_CLIENT_ID,\n*           clientSecret: process.env.LINE_TH_CLIENT_SECRET,\n*         }),\n*         // Taiwan channel\n*         line({\n*           providerId: \"line-tw\",\n*           clientId: process.env.LINE_TW_CLIENT_ID,\n*           clientSecret: process.env.LINE_TW_CLIENT_SECRET,\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction line(options) {\n\tconst defaultScopes = [\n\t\t\"openid\",\n\t\t\"profile\",\n\t\t\"email\"\n\t];\n\tconst authorizationUrl = \"https://access.line.me/oauth2/v2.1/authorize\";\n\tconst tokenUrl = \"https://api.line.me/oauth2/v2.1/token\";\n\tconst userInfoUrl = \"https://api.line.me/oauth2/v2.1/userinfo\";\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tlet profile = null;\n\t\tif (tokens.idToken) try {\n\t\t\tprofile = decodeJwt(tokens.idToken);\n\t\t} catch {}\n\t\tif (!profile) {\n\t\t\tconst { data, error } = await betterFetch(userInfoUrl, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });\n\t\t\tif (error || !data) return null;\n\t\t\tprofile = data;\n\t\t}\n\t\tif (!profile) return null;\n\t\treturn {\n\t\t\tid: profile.sub,\n\t\t\tname: profile.name,\n\t\t\temail: profile.email,\n\t\t\timage: profile.picture,\n\t\t\temailVerified: false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: options.providerId ?? \"line\",\n\t\tauthorizationUrl,\n\t\ttokenUrl,\n\t\tuserInfoUrl,\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/microsoft-entra-id.ts\n/**\n* Microsoft Entra ID (Azure AD) OAuth provider helper\n*\n* @example\n* ```ts\n* import { genericOAuth, microsoftEntraId } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         microsoftEntraId({\n*           clientId: process.env.MS_APP_ID,\n*           clientSecret: process.env.MS_CLIENT_SECRET,\n*           tenantId: process.env.MS_TENANT_ID,\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction microsoftEntraId(options) {\n\tconst defaultScopes = [\n\t\t\"openid\",\n\t\t\"profile\",\n\t\t\"email\"\n\t];\n\tconst tenantId = options.tenantId;\n\tconst authorizationUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;\n\tconst tokenUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;\n\tconst userInfoUrl = \"https://graph.microsoft.com/oidc/userinfo\";\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tconst { data: profile, error } = await betterFetch(userInfoUrl, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });\n\t\tif (error || !profile) return null;\n\t\treturn {\n\t\t\tid: profile.sub,\n\t\t\tname: profile.name ?? (`${profile.given_name ?? \"\"} ${profile.family_name ?? \"\"}`.trim() || void 0),\n\t\t\temail: profile.email ?? profile.preferred_username ?? void 0,\n\t\t\timage: profile.picture,\n\t\t\temailVerified: profile.email_verified ?? false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: \"microsoft-entra-id\",\n\t\tauthorizationUrl,\n\t\ttokenUrl,\n\t\tuserInfoUrl,\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/okta.ts\n/**\n* Okta OAuth provider helper\n*\n* @example\n* ```ts\n* import { genericOAuth, okta } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         okta({\n*           clientId: process.env.OKTA_CLIENT_ID,\n*           clientSecret: process.env.OKTA_CLIENT_SECRET,\n*           issuer: process.env.OKTA_ISSUER,\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction okta(options) {\n\tconst defaultScopes = [\n\t\t\"openid\",\n\t\t\"profile\",\n\t\t\"email\"\n\t];\n\tconst issuer = options.issuer.replace(/\\/$/, \"\");\n\tconst discoveryUrl = `${issuer}/.well-known/openid-configuration`;\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tconst { data: profile, error } = await betterFetch(`${issuer}/v1/userinfo`, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });\n\t\tif (error || !profile) return null;\n\t\treturn {\n\t\t\tid: profile.sub,\n\t\t\tname: profile.name ?? profile.preferred_username ?? void 0,\n\t\t\temail: profile.email ?? void 0,\n\t\t\timage: profile.picture,\n\t\t\temailVerified: profile.email_verified ?? false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: \"okta\",\n\t\tdiscoveryUrl,\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/providers/slack.ts\n/**\n* Slack OAuth provider helper\n*\n* @example\n* ```ts\n* import { genericOAuth, slack } from \"better-auth/plugins/generic-oauth\";\n*\n* export const auth = betterAuth({\n*   plugins: [\n*     genericOAuth({\n*       config: [\n*         slack({\n*           clientId: process.env.SLACK_CLIENT_ID,\n*           clientSecret: process.env.SLACK_CLIENT_SECRET,\n*         }),\n*       ],\n*     }),\n*   ],\n* });\n* ```\n*/\nfunction slack(options) {\n\tconst defaultScopes = [\n\t\t\"openid\",\n\t\t\"profile\",\n\t\t\"email\"\n\t];\n\tconst getUserInfo$1 = async (tokens) => {\n\t\tconst { data: profile, error } = await betterFetch(\"https://slack.com/api/openid.connect.userInfo\", { headers: { Authorization: `Bearer ${tokens.accessToken}` } });\n\t\tif (error || !profile) return null;\n\t\treturn {\n\t\t\tid: profile[\"https://slack.com/user_id\"] ?? profile.sub,\n\t\t\tname: profile.name,\n\t\t\temail: profile.email,\n\t\t\timage: profile.picture ?? profile[\"https://slack.com/user_image_512\"],\n\t\t\temailVerified: profile.email_verified ?? false\n\t\t};\n\t};\n\treturn {\n\t\tproviderId: \"slack\",\n\t\tauthorizationUrl: \"https://slack.com/openid/connect/authorize\",\n\t\ttokenUrl: \"https://slack.com/api/openid.connect.token\",\n\t\tuserInfoUrl: \"https://slack.com/api/openid.connect.userInfo\",\n\t\tclientId: options.clientId,\n\t\tclientSecret: options.clientSecret,\n\t\tscopes: options.scopes ?? defaultScopes,\n\t\tredirectURI: options.redirectURI,\n\t\tpkce: options.pkce,\n\t\tdisableImplicitSignUp: options.disableImplicitSignUp,\n\t\tdisableSignUp: options.disableSignUp,\n\t\toverrideUserInfo: options.overrideUserInfo,\n\t\tgetUserInfo: getUserInfo$1\n\t};\n}\n\n//#endregion\n//#region src/plugins/generic-oauth/index.ts\nasync function getUserInfo(tokens, finalUserInfoUrl) {\n\tif (tokens.idToken) {\n\t\tconst decoded = decodeJwt(tokens.idToken);\n\t\tif (decoded) {\n\t\t\tif (decoded.sub && decoded.email) return {\n\t\t\t\tid: decoded.sub,\n\t\t\t\temailVerified: decoded.email_verified,\n\t\t\t\timage: decoded.picture,\n\t\t\t\t...decoded\n\t\t\t};\n\t\t}\n\t}\n\tif (!finalUserInfoUrl) return null;\n\tconst userInfo = await betterFetch(finalUserInfoUrl, {\n\t\tmethod: \"GET\",\n\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` }\n\t});\n\treturn {\n\t\tid: userInfo.data?.sub ?? \"\",\n\t\temailVerified: userInfo.data?.email_verified ?? false,\n\t\temail: userInfo.data?.email,\n\t\timage: userInfo.data?.picture,\n\t\tname: userInfo.data?.name,\n\t\t...userInfo.data\n\t};\n}\n/**\n* A generic OAuth plugin that can be used to add OAuth support to any provider\n*/\nconst genericOAuth = (options) => {\n\treturn {\n\t\tid: \"generic-oauth\",\n\t\tinit: (ctx) => {\n\t\t\treturn { context: { socialProviders: options.config.map((c) => {\n\t\t\t\tlet finalUserInfoUrl = c.userInfoUrl;\n\t\t\t\treturn {\n\t\t\t\t\tid: c.providerId,\n\t\t\t\t\tname: c.providerId,\n\t\t\t\t\tasync createAuthorizationURL(data) {\n\t\t\t\t\t\tlet finalAuthUrl = c.authorizationUrl;\n\t\t\t\t\t\tif (!finalAuthUrl && c.discoveryUrl) {\n\t\t\t\t\t\t\tconst discovery = await betterFetch(c.discoveryUrl, {\n\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\theaders: c.discoveryHeaders\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (discovery.data) {\n\t\t\t\t\t\t\t\tfinalAuthUrl = discovery.data.authorization_endpoint;\n\t\t\t\t\t\t\t\tfinalUserInfoUrl = finalUserInfoUrl ?? discovery.data.userinfo_endpoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!finalAuthUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });\n\t\t\t\t\t\treturn createAuthorizationURL({\n\t\t\t\t\t\t\tid: c.providerId,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\tclientId: c.clientId,\n\t\t\t\t\t\t\t\tclientSecret: c.clientSecret,\n\t\t\t\t\t\t\t\tredirectURI: c.redirectURI\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tauthorizationEndpoint: finalAuthUrl,\n\t\t\t\t\t\t\tstate: data.state,\n\t\t\t\t\t\t\tcodeVerifier: c.pkce ? data.codeVerifier : void 0,\n\t\t\t\t\t\t\tscopes: c.scopes || [],\n\t\t\t\t\t\t\tredirectURI: `${ctx.baseURL}/oauth2/callback/${c.providerId}`\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tasync validateAuthorizationCode(data) {\n\t\t\t\t\t\tif (c.getToken) return c.getToken(data);\n\t\t\t\t\t\tlet finalTokenUrl = c.tokenUrl;\n\t\t\t\t\t\tif (c.discoveryUrl) {\n\t\t\t\t\t\t\tconst discovery = await betterFetch(c.discoveryUrl, {\n\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\theaders: c.discoveryHeaders\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (discovery.data) {\n\t\t\t\t\t\t\t\tfinalTokenUrl = discovery.data.token_endpoint;\n\t\t\t\t\t\t\t\tfinalUserInfoUrl = discovery.data.userinfo_endpoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!finalTokenUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.TOKEN_URL_NOT_FOUND });\n\t\t\t\t\t\treturn validateAuthorizationCode({\n\t\t\t\t\t\t\theaders: c.authorizationHeaders,\n\t\t\t\t\t\t\tcode: data.code,\n\t\t\t\t\t\t\tcodeVerifier: data.codeVerifier,\n\t\t\t\t\t\t\tredirectURI: data.redirectURI,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\tclientId: c.clientId,\n\t\t\t\t\t\t\t\tclientSecret: c.clientSecret,\n\t\t\t\t\t\t\t\tredirectURI: c.redirectURI\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttokenEndpoint: finalTokenUrl,\n\t\t\t\t\t\t\tauthentication: c.authentication\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tasync refreshAccessToken(refreshToken) {\n\t\t\t\t\t\tlet finalTokenUrl = c.tokenUrl;\n\t\t\t\t\t\tif (c.discoveryUrl) {\n\t\t\t\t\t\t\tconst discovery = await betterFetch(c.discoveryUrl, {\n\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\theaders: c.discoveryHeaders\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (discovery.data) finalTokenUrl = discovery.data.token_endpoint;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!finalTokenUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.TOKEN_URL_NOT_FOUND });\n\t\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\tclientId: c.clientId,\n\t\t\t\t\t\t\t\tclientSecret: c.clientSecret\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tauthentication: c.authentication,\n\t\t\t\t\t\t\ttokenEndpoint: finalTokenUrl\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tasync getUserInfo(tokens) {\n\t\t\t\t\t\tconst userInfo = c.getUserInfo ? await c.getUserInfo(tokens) : await getUserInfo(tokens, finalUserInfoUrl);\n\t\t\t\t\t\tif (!userInfo) return null;\n\t\t\t\t\t\tconst userMap = await c.mapProfileToUser?.(userInfo);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\tid: userInfo?.id,\n\t\t\t\t\t\t\t\temail: userInfo?.email,\n\t\t\t\t\t\t\t\temailVerified: userInfo?.emailVerified,\n\t\t\t\t\t\t\t\timage: userInfo?.image,\n\t\t\t\t\t\t\t\tname: userInfo?.name,\n\t\t\t\t\t\t\t\t...userMap\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdata: userInfo\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\toptions: { overrideUserInfoOnSignIn: c.overrideUserInfo }\n\t\t\t\t};\n\t\t\t}).concat(ctx.socialProviders) } };\n\t\t},\n\t\tendpoints: {\n\t\t\tsignInWithOAuth2: createAuthEndpoint(\"/sign-in/oauth2\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tproviderId: z.string().meta({ description: \"The provider ID for the OAuth provider\" }),\n\t\t\t\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after sign in\" }).optional(),\n\t\t\t\t\terrorCallbackURL: z.string().meta({ description: \"The URL to redirect to if an error occurs\" }).optional(),\n\t\t\t\t\tnewUserCallbackURL: z.string().meta({ description: \"The URL to redirect to after login if the user is new. Eg: \\\"/welcome\\\"\" }).optional(),\n\t\t\t\t\tdisableRedirect: z.boolean().meta({ description: \"Disable redirect\" }).optional(),\n\t\t\t\t\tscopes: z.array(z.string()).meta({ description: \"Scopes to be passed to the provider authorization request.\" }).optional(),\n\t\t\t\t\trequestSignUp: z.boolean().meta({ description: \"Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. Eg: false\" }).optional(),\n\t\t\t\t\tadditionalData: z.record(z.string(), z.any()).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Sign in with OAuth2\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Sign in with OAuth2\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\turl: { type: \"string\" },\n\t\t\t\t\t\t\t\tredirect: { type: \"boolean\" }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { providerId } = ctx.body;\n\t\t\t\tconst config = options.config.find((c) => c.providerId === providerId);\n\t\t\t\tif (!config) throw new APIError(\"BAD_REQUEST\", { message: `${GENERIC_OAUTH_ERROR_CODES.PROVIDER_CONFIG_NOT_FOUND} ${providerId}` });\n\t\t\t\tconst { discoveryUrl, authorizationUrl, tokenUrl, clientId, clientSecret, scopes, redirectURI, responseType, pkce, prompt, accessType, authorizationUrlParams, responseMode, authentication } = config;\n\t\t\t\tlet finalAuthUrl = authorizationUrl;\n\t\t\t\tlet finalTokenUrl = tokenUrl;\n\t\t\t\tif (discoveryUrl) {\n\t\t\t\t\tconst discovery = await betterFetch(discoveryUrl, {\n\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\theaders: config.discoveryHeaders,\n\t\t\t\t\t\tonError(context) {\n\t\t\t\t\t\t\tctx.context.logger.error(context.error.message, context.error, { discoveryUrl });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (discovery.data) {\n\t\t\t\t\t\tfinalAuthUrl = discovery.data.authorization_endpoint;\n\t\t\t\t\t\tfinalTokenUrl = discovery.data.token_endpoint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!finalAuthUrl || !finalTokenUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });\n\t\t\t\tif (authorizationUrlParams) {\n\t\t\t\t\tconst withAdditionalParams = new URL(finalAuthUrl);\n\t\t\t\t\tfor (const [paramName, paramValue] of Object.entries(authorizationUrlParams)) withAdditionalParams.searchParams.set(paramName, paramValue);\n\t\t\t\t\tfinalAuthUrl = withAdditionalParams.toString();\n\t\t\t\t}\n\t\t\t\tconst additionalParams = typeof authorizationUrlParams === \"function\" ? authorizationUrlParams(ctx) : authorizationUrlParams;\n\t\t\t\tconst { state, codeVerifier } = await generateState(ctx, void 0, ctx.body.additionalData);\n\t\t\t\tconst authUrl = await createAuthorizationURL({\n\t\t\t\t\tid: providerId,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tclientId,\n\t\t\t\t\t\tclientSecret,\n\t\t\t\t\t\tredirectURI\n\t\t\t\t\t},\n\t\t\t\t\tauthorizationEndpoint: finalAuthUrl,\n\t\t\t\t\tstate,\n\t\t\t\t\tcodeVerifier: pkce ? codeVerifier : void 0,\n\t\t\t\t\tscopes: ctx.body.scopes ? [...ctx.body.scopes, ...scopes || []] : scopes || [],\n\t\t\t\t\tredirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerId}`,\n\t\t\t\t\tprompt,\n\t\t\t\t\taccessType,\n\t\t\t\t\tresponseType,\n\t\t\t\t\tresponseMode,\n\t\t\t\t\tadditionalParams\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\turl: authUrl.toString(),\n\t\t\t\t\tredirect: !ctx.body.disableRedirect\n\t\t\t\t});\n\t\t\t}),\n\t\t\toAuth2Callback: createAuthEndpoint(\"/oauth2/callback/:providerId\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: z.object({\n\t\t\t\t\tcode: z.string().meta({ description: \"The OAuth2 code\" }).optional(),\n\t\t\t\t\terror: z.string().meta({ description: \"The error message, if any\" }).optional(),\n\t\t\t\t\terror_description: z.string().meta({ description: \"The error description, if any\" }).optional(),\n\t\t\t\t\tstate: z.string().meta({ description: \"The state parameter from the OAuth2 request\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: {\n\t\t\t\t\t...HIDE_METADATA,\n\t\t\t\t\tallowedMediaTypes: [\"application/x-www-form-urlencoded\", \"application/json\"],\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\tdescription: \"OAuth2 callback\",\n\t\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\t\tdescription: \"OAuth2 callback\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: { url: { type: \"string\" } }\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst defaultErrorURL = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;\n\t\t\t\tif (ctx.query.error || !ctx.query.code) throw ctx.redirect(`${defaultErrorURL}?error=${ctx.query.error || \"oAuth_code_missing\"}&error_description=${ctx.query.error_description}`);\n\t\t\t\tconst providerId = ctx.params?.providerId;\n\t\t\t\tif (!providerId) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.PROVIDER_ID_REQUIRED });\n\t\t\t\tconst providerConfig = options.config.find((p) => p.providerId === providerId);\n\t\t\t\tif (!providerConfig) throw new APIError(\"BAD_REQUEST\", { message: `${GENERIC_OAUTH_ERROR_CODES.PROVIDER_CONFIG_NOT_FOUND} ${providerId}` });\n\t\t\t\tlet tokens = void 0;\n\t\t\t\tconst { callbackURL, codeVerifier, errorURL, requestSignUp, newUserURL, link } = await parseState(ctx);\n\t\t\t\tconst code = ctx.query.code;\n\t\t\t\tfunction redirectOnError(error) {\n\t\t\t\t\tconst defaultErrorURL$1 = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;\n\t\t\t\t\tlet url = errorURL || defaultErrorURL$1;\n\t\t\t\t\tif (url.includes(\"?\")) url = `${url}&error=${error}`;\n\t\t\t\t\telse url = `${url}?error=${error}`;\n\t\t\t\t\tthrow ctx.redirect(url);\n\t\t\t\t}\n\t\t\t\tlet finalTokenUrl = providerConfig.tokenUrl;\n\t\t\t\tlet finalUserInfoUrl = providerConfig.userInfoUrl;\n\t\t\t\tif (providerConfig.discoveryUrl) {\n\t\t\t\t\tconst discovery = await betterFetch(providerConfig.discoveryUrl, {\n\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\theaders: providerConfig.discoveryHeaders\n\t\t\t\t\t});\n\t\t\t\t\tif (discovery.data) {\n\t\t\t\t\t\tfinalTokenUrl = discovery.data.token_endpoint;\n\t\t\t\t\t\tfinalUserInfoUrl = discovery.data.userinfo_endpoint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (providerConfig.getToken) tokens = await providerConfig.getToken({\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tredirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerConfig.providerId}`,\n\t\t\t\t\t\tcodeVerifier: providerConfig.pkce ? codeVerifier : void 0\n\t\t\t\t\t});\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!finalTokenUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIG });\n\t\t\t\t\t\tconst additionalParams = typeof providerConfig.tokenUrlParams === \"function\" ? providerConfig.tokenUrlParams(ctx) : providerConfig.tokenUrlParams;\n\t\t\t\t\t\ttokens = await validateAuthorizationCode({\n\t\t\t\t\t\t\theaders: providerConfig.authorizationHeaders,\n\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\tcodeVerifier: providerConfig.pkce ? codeVerifier : void 0,\n\t\t\t\t\t\t\tredirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerConfig.providerId}`,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\tclientId: providerConfig.clientId,\n\t\t\t\t\t\t\t\tclientSecret: providerConfig.clientSecret,\n\t\t\t\t\t\t\t\tredirectURI: providerConfig.redirectURI\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttokenEndpoint: finalTokenUrl,\n\t\t\t\t\t\t\tauthentication: providerConfig.authentication,\n\t\t\t\t\t\t\tadditionalParams\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tctx.context.logger.error(e && typeof e === \"object\" && \"name\" in e ? e.name : \"\", e);\n\t\t\t\t\tthrow redirectOnError(\"oauth_code_verification_failed\");\n\t\t\t\t}\n\t\t\t\tif (!tokens) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIG });\n\t\t\t\tconst userInfo = await (async function handleUserInfo() {\n\t\t\t\t\tconst userInfo$1 = providerConfig.getUserInfo ? await providerConfig.getUserInfo(tokens) : await getUserInfo(tokens, finalUserInfoUrl);\n\t\t\t\t\tif (!userInfo$1) throw redirectOnError(\"user_info_is_missing\");\n\t\t\t\t\tconst mapUser = providerConfig.mapProfileToUser ? await providerConfig.mapProfileToUser(userInfo$1) : userInfo$1;\n\t\t\t\t\tconst email = mapUser.email ? mapUser.email.toLowerCase() : userInfo$1.email?.toLowerCase();\n\t\t\t\t\tif (!email) {\n\t\t\t\t\t\tctx.context.logger.error(\"Unable to get user info\", userInfo$1);\n\t\t\t\t\t\tthrow redirectOnError(\"email_is_missing\");\n\t\t\t\t\t}\n\t\t\t\t\tconst id = mapUser.id ? String(mapUser.id) : String(userInfo$1.id);\n\t\t\t\t\tconst name = mapUser.name ? mapUser.name : userInfo$1.name;\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\tctx.context.logger.error(\"Unable to get user info\", userInfo$1);\n\t\t\t\t\t\tthrow redirectOnError(\"name_is_missing\");\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...userInfo$1,\n\t\t\t\t\t\t...mapUser,\n\t\t\t\t\t\temail,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tname\n\t\t\t\t\t};\n\t\t\t\t})();\n\t\t\t\tif (link) {\n\t\t\t\t\tif (ctx.context.options.account?.accountLinking?.allowDifferentEmails !== true && link.email !== userInfo.email) return redirectOnError(\"email_doesn't_match\");\n\t\t\t\t\tconst existingAccount = await ctx.context.internalAdapter.findAccountByProviderId(String(userInfo.id), providerConfig.providerId);\n\t\t\t\t\tif (existingAccount) {\n\t\t\t\t\t\tif (existingAccount.userId !== link.userId) return redirectOnError(\"account_already_linked_to_different_user\");\n\t\t\t\t\t\tconst updateData = Object.fromEntries(Object.entries({\n\t\t\t\t\t\t\taccessToken: tokens.accessToken,\n\t\t\t\t\t\t\tidToken: tokens.idToken,\n\t\t\t\t\t\t\trefreshToken: tokens.refreshToken,\n\t\t\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\t\t\tscope: tokens.scopes?.join(\",\")\n\t\t\t\t\t\t}).filter(([_, value]) => value !== void 0));\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateAccount(existingAccount.id, updateData);\n\t\t\t\t\t} else if (!await ctx.context.internalAdapter.createAccount({\n\t\t\t\t\t\tuserId: link.userId,\n\t\t\t\t\t\tproviderId: providerConfig.providerId,\n\t\t\t\t\t\taccountId: userInfo.id,\n\t\t\t\t\t\taccessToken: tokens.accessToken,\n\t\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t\t\t\t\trefreshToken: tokens.refreshToken,\n\t\t\t\t\t\tidToken: tokens.idToken\n\t\t\t\t\t})) return redirectOnError(\"unable_to_link_account\");\n\t\t\t\t\tlet toRedirectTo$1;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttoRedirectTo$1 = callbackURL.toString();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\ttoRedirectTo$1 = callbackURL;\n\t\t\t\t\t}\n\t\t\t\t\tthrow ctx.redirect(toRedirectTo$1);\n\t\t\t\t}\n\t\t\t\tconst result = await handleOAuthUserInfo(ctx, {\n\t\t\t\t\tuserInfo,\n\t\t\t\t\taccount: {\n\t\t\t\t\t\tproviderId: providerConfig.providerId,\n\t\t\t\t\t\taccountId: userInfo.id,\n\t\t\t\t\t\t...tokens,\n\t\t\t\t\t\tscope: tokens.scopes?.join(\",\")\n\t\t\t\t\t},\n\t\t\t\t\tcallbackURL,\n\t\t\t\t\tdisableSignUp: providerConfig.disableImplicitSignUp && !requestSignUp || providerConfig.disableSignUp,\n\t\t\t\t\toverrideUserInfo: providerConfig.overrideUserInfo\n\t\t\t\t});\n\t\t\t\tif (result.error) return redirectOnError(result.error.split(\" \").join(\"_\"));\n\t\t\t\tconst { session, user } = result.data;\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser\n\t\t\t\t});\n\t\t\t\tlet toRedirectTo;\n\t\t\t\ttry {\n\t\t\t\t\ttoRedirectTo = (result.isRegister ? newUserURL || callbackURL : callbackURL).toString();\n\t\t\t\t} catch {\n\t\t\t\t\ttoRedirectTo = result.isRegister ? newUserURL || callbackURL : callbackURL;\n\t\t\t\t}\n\t\t\t\tthrow ctx.redirect(toRedirectTo);\n\t\t\t}),\n\t\t\toAuth2LinkAccount: createAuthEndpoint(\"/oauth2/link\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tproviderId: z.string(),\n\t\t\t\t\tcallbackURL: z.string(),\n\t\t\t\t\tscopes: z.array(z.string()).meta({ description: \"Additional scopes to request when linking the account\" }).optional(),\n\t\t\t\t\terrorCallbackURL: z.string().meta({ description: \"The URL to redirect to if there is an error during the link process\" }).optional()\n\t\t\t\t}),\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Link an OAuth2 account to the current user session\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Authorization URL generated successfully for linking an OAuth2 account\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\tdescription: \"The authorization URL to redirect the user to for linking the OAuth2 account\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\tdescription: \"Indicates that the client should redirect to the provided URL\",\n\t\t\t\t\t\t\t\t\tenum: [true]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"url\", \"redirect\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (c) => {\n\t\t\t\tconst session = c.context.session;\n\t\t\t\tif (!session) throw new APIError(\"UNAUTHORIZED\", { message: GENERIC_OAUTH_ERROR_CODES.SESSION_REQUIRED });\n\t\t\t\tconst provider = options.config.find((p) => p.providerId === c.body.providerId);\n\t\t\t\tif (!provider) throw new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });\n\t\t\t\tconst { providerId, clientId, clientSecret, redirectURI, authorizationUrl, discoveryUrl, pkce, scopes, prompt, accessType, authorizationUrlParams } = provider;\n\t\t\t\tlet finalAuthUrl = authorizationUrl;\n\t\t\t\tif (!finalAuthUrl) {\n\t\t\t\t\tif (!discoveryUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });\n\t\t\t\t\tconst discovery = await betterFetch(discoveryUrl, {\n\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\theaders: provider.discoveryHeaders,\n\t\t\t\t\t\tonError(context) {\n\t\t\t\t\t\t\tc.context.logger.error(context.error.message, context.error, { discoveryUrl });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (discovery.data) finalAuthUrl = discovery.data.authorization_endpoint;\n\t\t\t\t}\n\t\t\t\tif (!finalAuthUrl) throw new APIError(\"BAD_REQUEST\", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });\n\t\t\t\tconst state = await generateState(c, {\n\t\t\t\t\tuserId: session.user.id,\n\t\t\t\t\temail: session.user.email\n\t\t\t\t}, void 0);\n\t\t\t\tconst additionalParams = typeof authorizationUrlParams === \"function\" ? authorizationUrlParams(c) : authorizationUrlParams;\n\t\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\t\tid: providerId,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tclientId,\n\t\t\t\t\t\tclientSecret,\n\t\t\t\t\t\tredirectURI: redirectURI || `${c.context.baseURL}/oauth2/callback/${providerId}`\n\t\t\t\t\t},\n\t\t\t\t\tauthorizationEndpoint: finalAuthUrl,\n\t\t\t\t\tstate: state.state,\n\t\t\t\t\tcodeVerifier: pkce ? state.codeVerifier : void 0,\n\t\t\t\t\tscopes: c.body.scopes || scopes || [],\n\t\t\t\t\tredirectURI: redirectURI || `${c.context.baseURL}/oauth2/callback/${providerId}`,\n\t\t\t\t\tprompt,\n\t\t\t\t\taccessType,\n\t\t\t\t\tadditionalParams\n\t\t\t\t});\n\t\t\t\treturn c.json({\n\t\t\t\t\turl: url.toString(),\n\t\t\t\t\tredirect: true\n\t\t\t\t});\n\t\t\t})\n\t\t},\n\t\t$ERROR_CODES: GENERIC_OAUTH_ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { line as a, auth0 as c, microsoftEntraId as i, slack as n, keycloak as o, okta as r, hubspot as s, genericOAuth as t };","import { i as parseState, n as HIDE_METADATA, r as generateState, t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport { n as symmetricEncrypt, o as signJWT, r as generateRandomString, t as symmetricDecrypt } from \"./crypto-CFUhAR9W.mjs\";\nimport { c as parseUserInput, l as parseUserOutput, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as getIp } from \"./get-request-ip-D6st-mto.mjs\";\nimport { t as safeJSONParse } from \"./json-CnHxKYpj.mjs\";\nimport { i as getProtocol, n as getHost, r as getOrigin } from \"./url-CB8xCwz-.mjs\";\nimport { c as setSessionCookie, f as getAccountCookie, h as setAccountCookie, n as deleteSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { c as revokeSessions, i as listSessions, l as sensitiveSessionMiddleware, n as getSession, o as revokeOtherSessions, r as getSessionFromCtx, s as revokeSession, t as freshSessionMiddleware, u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { hasRequestState, runWithEndpointContext, runWithRequestState, runWithTransaction } from \"@better-auth/core/context\";\nimport { isDevelopment, isProduction, logger, shouldPublishLog } from \"@better-auth/core/env\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError, APIError as APIError$1, createRouter, toResponse } from \"better-call\";\nimport * as z from \"zod\";\nimport { jwtVerify } from \"jose\";\nimport { SocialProviderListEnum } from \"@better-auth/core/social-providers\";\nimport { createDefu } from \"defu\";\nimport { createAuthEndpoint, createAuthEndpoint as createAuthEndpoint$1, createAuthMiddleware, createAuthMiddleware as createAuthMiddleware$1, optionsMiddleware } from \"@better-auth/core/api\";\nimport { JWTExpired } from \"jose/errors\";\n\n//#region src/utils/wildcard.ts\n/**\n* Escapes a character if it has a special meaning in regular expressions\n* and returns the character as is if it doesn't\n*/\nfunction escapeRegExpChar(char) {\n\tif (char === \"-\" || char === \"^\" || char === \"$\" || char === \"+\" || char === \".\" || char === \"(\" || char === \")\" || char === \"|\" || char === \"[\" || char === \"]\" || char === \"{\" || char === \"}\" || char === \"*\" || char === \"?\" || char === \"\\\\\") return `\\\\${char}`;\n\telse return char;\n}\n/**\n* Escapes all characters in a given string that have a special meaning in regular expressions\n*/\nfunction escapeRegExpString(str) {\n\tlet result = \"\";\n\tfor (let i = 0; i < str.length; i++) result += escapeRegExpChar(str[i]);\n\treturn result;\n}\n/**\n* Transforms one or more glob patterns into a RegExp pattern\n*/\nfunction transform(pattern, separator = true) {\n\tif (Array.isArray(pattern)) return `(?:${pattern.map((p) => `^${transform(p, separator)}$`).join(\"|\")})`;\n\tlet separatorSplitter = \"\";\n\tlet separatorMatcher = \"\";\n\tlet wildcard = \".\";\n\tif (separator === true) {\n\t\tseparatorSplitter = \"/\";\n\t\tseparatorMatcher = \"[/\\\\\\\\]\";\n\t\twildcard = \"[^/\\\\\\\\]\";\n\t} else if (separator) {\n\t\tseparatorSplitter = separator;\n\t\tseparatorMatcher = escapeRegExpString(separatorSplitter);\n\t\tif (separatorMatcher.length > 1) {\n\t\t\tseparatorMatcher = `(?:${separatorMatcher})`;\n\t\t\twildcard = `((?!${separatorMatcher}).)`;\n\t\t} else wildcard = `[^${separatorMatcher}]`;\n\t}\n\tlet requiredSeparator = separator ? `${separatorMatcher}+?` : \"\";\n\tlet optionalSeparator = separator ? `${separatorMatcher}*?` : \"\";\n\tlet segments = separator ? pattern.split(separatorSplitter) : [pattern];\n\tlet result = \"\";\n\tfor (let s = 0; s < segments.length; s++) {\n\t\tlet segment = segments[s];\n\t\tlet nextSegment = segments[s + 1];\n\t\tlet currentSeparator = \"\";\n\t\tif (!segment && s > 0) continue;\n\t\tif (separator) if (s === segments.length - 1) currentSeparator = optionalSeparator;\n\t\telse if (nextSegment !== \"**\") currentSeparator = requiredSeparator;\n\t\telse currentSeparator = \"\";\n\t\tif (separator && segment === \"**\") {\n\t\t\tif (currentSeparator) {\n\t\t\t\tresult += s === 0 ? \"\" : currentSeparator;\n\t\t\t\tresult += `(?:${wildcard}*?${currentSeparator})*?`;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let c = 0; c < segment.length; c++) {\n\t\t\tlet char = segment[c];\n\t\t\tif (char === \"\\\\\") {\n\t\t\t\tif (c < segment.length - 1) {\n\t\t\t\t\tresult += escapeRegExpChar(segment[c + 1]);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t} else if (char === \"?\") result += wildcard;\n\t\t\telse if (char === \"*\") result += `${wildcard}*?`;\n\t\t\telse result += escapeRegExpChar(char);\n\t\t}\n\t\tresult += currentSeparator;\n\t}\n\treturn result;\n}\nfunction isMatch(regexp, sample) {\n\tif (typeof sample !== \"string\") throw new TypeError(`Sample must be a string, but ${typeof sample} given`);\n\treturn regexp.test(sample);\n}\n/**\n* Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n* The isMatch function takes a sample string as its only argument and returns `true`\n* if the string matches the pattern(s).\n*\n* ```js\n* wildcardMatch('src/*.js')('src/index.js') //=> true\n* ```\n*\n* ```js\n* const isMatch = wildcardMatch('*.example.com', '.')\n* isMatch('foo.example.com') //=> true\n* isMatch('foo.bar.com') //=> false\n* ```\n*/\nfunction wildcardMatch(pattern, options) {\n\tif (typeof pattern !== \"string\" && !Array.isArray(pattern)) throw new TypeError(`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`);\n\tif (typeof options === \"string\" || typeof options === \"boolean\") options = { separator: options };\n\tif (arguments.length === 2 && !(typeof options === \"undefined\" || typeof options === \"object\" && options !== null && !Array.isArray(options))) throw new TypeError(`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`);\n\toptions = options || {};\n\tif (options.separator === \"\\\\\") throw new Error(\"\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead\");\n\tlet regexpPattern = transform(pattern, options.separator);\n\tlet regexp = new RegExp(`^${regexpPattern}$`, options.flags);\n\tlet fn = isMatch.bind(null, regexp);\n\tfn.options = options;\n\tfn.pattern = pattern;\n\tfn.regexp = regexp;\n\treturn fn;\n}\n\n//#endregion\n//#region src/api/middlewares/origin-check.ts\n/**\n* A middleware to validate callbackURL and origin against\n* trustedOrigins.\n*/\nconst originCheckMiddleware = createAuthMiddleware(async (ctx) => {\n\tif (ctx.request?.method === \"GET\" || ctx.request?.method === \"OPTIONS\" || ctx.request?.method === \"HEAD\" || !ctx.request) return;\n\tconst headers = ctx.request?.headers;\n\tconst request = ctx.request;\n\tconst { body, query, context } = ctx;\n\tconst originHeader = headers?.get(\"origin\") || headers?.get(\"referer\") || \"\";\n\tconst callbackURL = body?.callbackURL || query?.callbackURL;\n\tconst redirectURL = body?.redirectTo;\n\tconst errorCallbackURL = body?.errorCallbackURL;\n\tconst newUserCallbackURL = body?.newUserCallbackURL;\n\tconst trustedOrigins = Array.isArray(context.options.trustedOrigins) ? context.trustedOrigins : [...context.trustedOrigins, ...await context.options.trustedOrigins?.(request) || []];\n\tconst useCookies = headers?.has(\"cookie\");\n\tconst matchesPattern = (url, pattern) => {\n\t\tif (url.startsWith(\"/\")) return false;\n\t\tif (pattern.includes(\"*\")) {\n\t\t\tif (pattern.includes(\"://\")) return wildcardMatch(pattern)(getOrigin(url) || url);\n\t\t\tconst host = getHost(url);\n\t\t\tif (!host) return false;\n\t\t\treturn wildcardMatch(pattern)(host);\n\t\t}\n\t\tconst protocol = getProtocol(url);\n\t\treturn protocol === \"http:\" || protocol === \"https:\" || !protocol ? pattern === getOrigin(url) : url.startsWith(pattern);\n\t};\n\tconst validateURL = (url, label) => {\n\t\tif (!url) return;\n\t\tif (!trustedOrigins.some((origin) => matchesPattern(url, origin) || url?.startsWith(\"/\") && label !== \"origin\" && /^\\/(?!\\/|\\\\|%2f|%5c)[\\w\\-.\\+/@]*(?:\\?[\\w\\-.\\+/=&%@]*)?$/.test(url))) {\n\t\t\tctx.context.logger.error(`Invalid ${label}: ${url}`);\n\t\t\tctx.context.logger.info(`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\\n`, `Current list of trustedOrigins: ${trustedOrigins}`);\n\t\t\tthrow new APIError(\"FORBIDDEN\", { message: `Invalid ${label}` });\n\t\t}\n\t};\n\tif (useCookies && !ctx.context.skipCSRFCheck && !ctx.context.skipOriginCheck) {\n\t\tif (!originHeader || originHeader === \"null\") throw new APIError(\"FORBIDDEN\", { message: \"Missing or null Origin\" });\n\t\tvalidateURL(originHeader, \"origin\");\n\t}\n\tcallbackURL && validateURL(callbackURL, \"callbackURL\");\n\tredirectURL && validateURL(redirectURL, \"redirectURL\");\n\terrorCallbackURL && validateURL(errorCallbackURL, \"errorCallbackURL\");\n\tnewUserCallbackURL && validateURL(newUserCallbackURL, \"newUserCallbackURL\");\n});\nconst originCheck = (getValue) => createAuthMiddleware(async (ctx) => {\n\tif (!ctx.request) return;\n\tconst { context } = ctx;\n\tconst callbackURL = getValue(ctx);\n\tconst trustedOrigins = Array.isArray(context.options.trustedOrigins) ? context.trustedOrigins : [...context.trustedOrigins, ...await context.options.trustedOrigins?.(ctx.request) || []];\n\tconst matchesPattern = (url, pattern) => {\n\t\tif (url.startsWith(\"/\")) return false;\n\t\tif (pattern.includes(\"*\")) {\n\t\t\tif (pattern.includes(\"://\")) return wildcardMatch(pattern)(getOrigin(url) || url);\n\t\t\tconst host = getHost(url);\n\t\t\tif (!host) return false;\n\t\t\treturn wildcardMatch(pattern)(host);\n\t\t}\n\t\tconst protocol = getProtocol(url);\n\t\treturn protocol === \"http:\" || protocol === \"https:\" || !protocol ? pattern === getOrigin(url) : url.startsWith(pattern);\n\t};\n\tconst validateURL = (url, label) => {\n\t\tif (!url) return;\n\t\tif (!trustedOrigins.some((origin) => matchesPattern(url, origin) || url?.startsWith(\"/\") && label !== \"origin\" && /^\\/(?!\\/|\\\\|%2f|%5c)[\\w\\-.\\+/@]*(?:\\?[\\w\\-.\\+/=&%@]*)?$/.test(url))) {\n\t\t\tctx.context.logger.error(`Invalid ${label}: ${url}`);\n\t\t\tctx.context.logger.info(`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\\n`, `Current list of trustedOrigins: ${trustedOrigins}`);\n\t\t\tthrow new APIError(\"FORBIDDEN\", { message: `Invalid ${label}` });\n\t\t}\n\t};\n\tconst callbacks = Array.isArray(callbackURL) ? callbackURL : [callbackURL];\n\tfor (const url of callbacks) validateURL(url, \"callbackURL\");\n});\n\n//#endregion\n//#region src/api/rate-limiter/index.ts\nfunction shouldRateLimit(max, window, rateLimitData) {\n\tconst now = Date.now();\n\tconst windowInMs = window * 1e3;\n\treturn now - rateLimitData.lastRequest < windowInMs && rateLimitData.count >= max;\n}\nfunction rateLimitResponse(retryAfter) {\n\treturn new Response(JSON.stringify({ message: \"Too many requests. Please try again later.\" }), {\n\t\tstatus: 429,\n\t\tstatusText: \"Too Many Requests\",\n\t\theaders: { \"X-Retry-After\": retryAfter.toString() }\n\t});\n}\nfunction getRetryAfter(lastRequest, window) {\n\tconst now = Date.now();\n\tconst windowInMs = window * 1e3;\n\treturn Math.ceil((lastRequest + windowInMs - now) / 1e3);\n}\nfunction createDBStorage(ctx) {\n\tconst model = \"rateLimit\";\n\tconst db = ctx.adapter;\n\treturn {\n\t\tget: async (key) => {\n\t\t\tconst data = (await db.findMany({\n\t\t\t\tmodel,\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"key\",\n\t\t\t\t\tvalue: key\n\t\t\t\t}]\n\t\t\t}))[0];\n\t\t\tif (typeof data?.lastRequest === \"bigint\") data.lastRequest = Number(data.lastRequest);\n\t\t\treturn data;\n\t\t},\n\t\tset: async (key, value, _update) => {\n\t\t\ttry {\n\t\t\t\tif (_update) await db.updateMany({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"key\",\n\t\t\t\t\t\tvalue: key\n\t\t\t\t\t}],\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\tcount: value.count,\n\t\t\t\t\t\tlastRequest: value.lastRequest\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\telse await db.create({\n\t\t\t\t\tmodel,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tcount: value.count,\n\t\t\t\t\t\tlastRequest: value.lastRequest\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tctx.logger.error(\"Error setting rate limit\", e);\n\t\t\t}\n\t\t}\n\t};\n}\nconst memory = /* @__PURE__ */ new Map();\nfunction getRateLimitStorage(ctx, rateLimitSettings) {\n\tif (ctx.options.rateLimit?.customStorage) return ctx.options.rateLimit.customStorage;\n\tconst storage = ctx.rateLimit.storage;\n\tif (storage === \"secondary-storage\") return {\n\t\tget: async (key) => {\n\t\t\tconst data = await ctx.options.secondaryStorage?.get(key);\n\t\t\treturn data ? safeJSONParse(data) : void 0;\n\t\t},\n\t\tset: async (key, value, _update) => {\n\t\t\tconst ttl = rateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;\n\t\t\tawait ctx.options.secondaryStorage?.set?.(key, JSON.stringify(value), ttl);\n\t\t}\n\t};\n\telse if (storage === \"memory\") return {\n\t\tasync get(key) {\n\t\t\treturn memory.get(key);\n\t\t},\n\t\tasync set(key, value, _update) {\n\t\t\tmemory.set(key, value);\n\t\t}\n\t};\n\treturn createDBStorage(ctx);\n}\nasync function onRequestRateLimit(req, ctx) {\n\tif (!ctx.rateLimit.enabled) return;\n\tconst path = new URL(req.url).pathname.replace(ctx.options.basePath || \"/api/auth\", \"\");\n\tlet window = ctx.rateLimit.window;\n\tlet max = ctx.rateLimit.max;\n\tconst ip = getIp(req, ctx.options);\n\tif (!ip) return;\n\tconst key = ip + path;\n\tconst specialRule = getDefaultSpecialRules().find((rule) => rule.pathMatcher(path));\n\tif (specialRule) {\n\t\twindow = specialRule.window;\n\t\tmax = specialRule.max;\n\t}\n\tfor (const plugin of ctx.options.plugins || []) if (plugin.rateLimit) {\n\t\tconst matchedRule = plugin.rateLimit.find((rule) => rule.pathMatcher(path));\n\t\tif (matchedRule) {\n\t\t\twindow = matchedRule.window;\n\t\t\tmax = matchedRule.max;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ctx.rateLimit.customRules) {\n\t\tconst _path = Object.keys(ctx.rateLimit.customRules).find((p) => {\n\t\t\tif (p.includes(\"*\")) return wildcardMatch(p)(path);\n\t\t\treturn p === path;\n\t\t});\n\t\tif (_path) {\n\t\t\tconst customRule = ctx.rateLimit.customRules[_path];\n\t\t\tconst resolved = typeof customRule === \"function\" ? await customRule(req) : customRule;\n\t\t\tif (resolved) {\n\t\t\t\twindow = resolved.window;\n\t\t\t\tmax = resolved.max;\n\t\t\t}\n\t\t\tif (resolved === false) return;\n\t\t}\n\t}\n\tconst storage = getRateLimitStorage(ctx, { window });\n\tconst data = await storage.get(key);\n\tconst now = Date.now();\n\tif (!data) await storage.set(key, {\n\t\tkey,\n\t\tcount: 1,\n\t\tlastRequest: now\n\t});\n\telse {\n\t\tconst timeSinceLastRequest = now - data.lastRequest;\n\t\tif (shouldRateLimit(max, window, data)) return rateLimitResponse(getRetryAfter(data.lastRequest, window));\n\t\telse if (timeSinceLastRequest > window * 1e3) await storage.set(key, {\n\t\t\t...data,\n\t\t\tcount: 1,\n\t\t\tlastRequest: now\n\t\t}, true);\n\t\telse await storage.set(key, {\n\t\t\t...data,\n\t\t\tcount: data.count + 1,\n\t\t\tlastRequest: now\n\t\t}, true);\n\t}\n}\nfunction getDefaultSpecialRules() {\n\treturn [{\n\t\tpathMatcher(path) {\n\t\t\treturn path.startsWith(\"/sign-in\") || path.startsWith(\"/sign-up\") || path.startsWith(\"/change-password\") || path.startsWith(\"/change-email\");\n\t\t},\n\t\twindow: 10,\n\t\tmax: 3\n\t}];\n}\n\n//#endregion\n//#region src/oauth2/utils.ts\nfunction decryptOAuthToken(token, ctx) {\n\tif (!token) return token;\n\tif (ctx.options.account?.encryptOAuthTokens) return symmetricDecrypt({\n\t\tkey: ctx.secret,\n\t\tdata: token\n\t});\n\treturn token;\n}\nfunction setTokenUtil(token, ctx) {\n\tif (ctx.options.account?.encryptOAuthTokens && token) return symmetricEncrypt({\n\t\tkey: ctx.secret,\n\t\tdata: token\n\t});\n\treturn token;\n}\n\n//#endregion\n//#region src/api/routes/account.ts\nconst listUserAccounts = createAuthEndpoint(\"/list-accounts\", {\n\tmethod: \"GET\",\n\tuse: [sessionMiddleware],\n\tmetadata: { openapi: {\n\t\toperationId: \"listUserAccounts\",\n\t\tdescription: \"List all accounts linked to the user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\t\tproviderId: { type: \"string\" },\n\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\taccountId: { type: \"string\" },\n\t\t\t\t\t\tuserId: { type: \"string\" },\n\t\t\t\t\t\tscopes: {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\titems: { type: \"string\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"providerId\",\n\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\"accountId\",\n\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\"scopes\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (c) => {\n\tconst session = c.context.session;\n\tconst accounts = await c.context.internalAdapter.findAccounts(session.user.id);\n\treturn c.json(accounts.map((a) => ({\n\t\tid: a.id,\n\t\tproviderId: a.providerId,\n\t\tcreatedAt: a.createdAt,\n\t\tupdatedAt: a.updatedAt,\n\t\taccountId: a.accountId,\n\t\tuserId: a.userId,\n\t\tscopes: a.scope?.split(\",\") || []\n\t})));\n});\nconst linkSocialAccount = createAuthEndpoint(\"/link-social\", {\n\tmethod: \"POST\",\n\trequireHeaders: true,\n\tbody: z.object({\n\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after the user has signed in\" }).optional(),\n\t\tprovider: SocialProviderListEnum,\n\t\tidToken: z.object({\n\t\t\ttoken: z.string(),\n\t\t\tnonce: z.string().optional(),\n\t\t\taccessToken: z.string().optional(),\n\t\t\trefreshToken: z.string().optional(),\n\t\t\tscopes: z.array(z.string()).optional()\n\t\t}).optional(),\n\t\trequestSignUp: z.boolean().optional(),\n\t\tscopes: z.array(z.string()).meta({ description: \"Additional scopes to request from the provider\" }).optional(),\n\t\terrorCallbackURL: z.string().meta({ description: \"The URL to redirect to if there is an error during the link process\" }).optional(),\n\t\tdisableRedirect: z.boolean().meta({ description: \"Disable automatic redirection to the provider. Useful for handling the redirection yourself\" }).optional(),\n\t\tadditionalData: z.record(z.string(), z.any()).optional()\n\t}),\n\tuse: [sessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Link a social account to the user\",\n\t\toperationId: \"linkSocialAccount\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\turl: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The authorization URL to redirect the user to\"\n\t\t\t\t\t},\n\t\t\t\t\tredirect: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the user should be redirected to the authorization URL\"\n\t\t\t\t\t},\n\t\t\t\t\tstatus: { type: \"boolean\" }\n\t\t\t\t},\n\t\t\t\trequired: [\"redirect\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (c) => {\n\tconst session = c.context.session;\n\tconst provider = c.context.socialProviders.find((p) => p.id === c.body.provider);\n\tif (!provider) {\n\t\tc.context.logger.error(\"Provider not found. Make sure to add the provider in your auth config\", { provider: c.body.provider });\n\t\tthrow new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });\n\t}\n\tif (c.body.idToken) {\n\t\tif (!provider.verifyIdToken) {\n\t\t\tc.context.logger.error(\"Provider does not support id token verification\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED });\n\t\t}\n\t\tconst { token, nonce } = c.body.idToken;\n\t\tif (!await provider.verifyIdToken(token, nonce)) {\n\t\t\tc.context.logger.error(\"Invalid id token\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.INVALID_TOKEN });\n\t\t}\n\t\tconst linkingUserInfo = await provider.getUserInfo({\n\t\t\tidToken: token,\n\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\trefreshToken: c.body.idToken.refreshToken\n\t\t});\n\t\tif (!linkingUserInfo || !linkingUserInfo?.user) {\n\t\t\tc.context.logger.error(\"Failed to get user info\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });\n\t\t}\n\t\tconst linkingUserId = String(linkingUserInfo.user.id);\n\t\tif (!linkingUserInfo.user.email) {\n\t\t\tc.context.logger.error(\"User email not found\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND });\n\t\t}\n\t\tif ((await c.context.internalAdapter.findAccounts(session.user.id)).find((a) => a.providerId === provider.id && a.accountId === linkingUserId)) return c.json({\n\t\t\turl: \"\",\n\t\t\tstatus: true,\n\t\t\tredirect: false\n\t\t});\n\t\tif (!(c.context.options.account?.accountLinking?.trustedProviders)?.includes(provider.id) && !linkingUserInfo.user.emailVerified || c.context.options.account?.accountLinking?.enabled === false) throw new APIError(\"UNAUTHORIZED\", { message: \"Account not linked - linking not allowed\" });\n\t\tif (linkingUserInfo.user.email !== session.user.email && c.context.options.account?.accountLinking?.allowDifferentEmails !== true) throw new APIError(\"UNAUTHORIZED\", { message: \"Account not linked - different emails not allowed\" });\n\t\ttry {\n\t\t\tawait c.context.internalAdapter.createAccount({\n\t\t\t\tuserId: session.user.id,\n\t\t\t\tproviderId: provider.id,\n\t\t\t\taccountId: linkingUserId,\n\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\tidToken: token,\n\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t\tscope: c.body.idToken.scopes?.join(\",\")\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tthrow new APIError(\"EXPECTATION_FAILED\", { message: \"Account not linked - unable to create account\" });\n\t\t}\n\t\tif (c.context.options.account?.accountLinking?.updateUserInfoOnLink === true) try {\n\t\t\tawait c.context.internalAdapter.updateUser(session.user.id, {\n\t\t\t\tname: linkingUserInfo.user?.name,\n\t\t\t\timage: linkingUserInfo.user?.image\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"Could not update user - \" + e.toString());\n\t\t}\n\t\treturn c.json({\n\t\t\turl: \"\",\n\t\t\tstatus: true,\n\t\t\tredirect: false\n\t\t});\n\t}\n\tconst state = await generateState(c, {\n\t\tuserId: session.user.id,\n\t\temail: session.user.email\n\t}, c.body.additionalData);\n\tconst url = await provider.createAuthorizationURL({\n\t\tstate: state.state,\n\t\tcodeVerifier: state.codeVerifier,\n\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\tscopes: c.body.scopes\n\t});\n\treturn c.json({\n\t\turl: url.toString(),\n\t\tredirect: !c.body.disableRedirect\n\t});\n});\nconst unlinkAccount = createAuthEndpoint(\"/unlink-account\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tproviderId: z.string(),\n\t\taccountId: z.string().optional()\n\t}),\n\tuse: [freshSessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Unlink an account\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst { providerId, accountId } = ctx.body;\n\tconst accounts = await ctx.context.internalAdapter.findAccounts(ctx.context.session.user.id);\n\tif (accounts.length === 1 && !ctx.context.options.account?.accountLinking?.allowUnlinkingAll) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.FAILED_TO_UNLINK_LAST_ACCOUNT });\n\tconst accountExist = accounts.find((account) => accountId ? account.accountId === accountId && account.providerId === providerId : account.providerId === providerId);\n\tif (!accountExist) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.ACCOUNT_NOT_FOUND });\n\tawait ctx.context.internalAdapter.deleteAccount(accountExist.id);\n\treturn ctx.json({ status: true });\n});\nconst getAccessToken = createAuthEndpoint(\"/get-access-token\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tproviderId: z.string().meta({ description: \"The provider ID for the OAuth provider\" }),\n\t\taccountId: z.string().meta({ description: \"The account ID associated with the refresh token\" }).optional(),\n\t\tuserId: z.string().meta({ description: \"The user ID associated with the account\" }).optional()\n\t}),\n\tmetadata: { openapi: {\n\t\tdescription: \"Get a valid access token, doing a refresh if needed\",\n\t\tresponses: {\n\t\t\t200: {\n\t\t\t\tdescription: \"A Valid access token\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\ttokenType: { type: \"string\" },\n\t\t\t\t\t\tidToken: { type: \"string\" },\n\t\t\t\t\t\taccessToken: { type: \"string\" },\n\t\t\t\t\t\trefreshToken: { type: \"string\" },\n\t\t\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefreshTokenExpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} } }\n\t\t\t},\n\t\t\t400: { description: \"Invalid refresh token or provider configuration\" }\n\t\t}\n\t} }\n}, async (ctx) => {\n\tconst { providerId, accountId, userId } = ctx.body || {};\n\tconst req = ctx.request;\n\tconst session = await getSessionFromCtx(ctx);\n\tif (req && !session) throw ctx.error(\"UNAUTHORIZED\");\n\tlet resolvedUserId = session?.user?.id || userId;\n\tif (!resolvedUserId) throw ctx.error(\"UNAUTHORIZED\");\n\tif (!ctx.context.socialProviders.find((p) => p.id === providerId)) throw new APIError(\"BAD_REQUEST\", { message: `Provider ${providerId} is not supported.` });\n\tconst accountData = await getAccountCookie(ctx);\n\tlet account = void 0;\n\tif (accountData && providerId === accountData.providerId && (!accountId || accountData.id === accountId)) account = accountData;\n\telse account = (await ctx.context.internalAdapter.findAccounts(resolvedUserId)).find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);\n\tif (!account) throw new APIError(\"BAD_REQUEST\", { message: \"Account not found\" });\n\tconst provider = ctx.context.socialProviders.find((p) => p.id === providerId);\n\tif (!provider) throw new APIError(\"BAD_REQUEST\", { message: `Provider ${providerId} not found.` });\n\ttry {\n\t\tlet newTokens = null;\n\t\tconst accessTokenExpired = account.accessTokenExpiresAt && new Date(account.accessTokenExpiresAt).getTime() - Date.now() < 5e3;\n\t\tif (account.refreshToken && accessTokenExpired && provider.refreshAccessToken) {\n\t\t\tconst refreshToken$1 = await decryptOAuthToken(account.refreshToken, ctx.context);\n\t\t\tnewTokens = await provider.refreshAccessToken(refreshToken$1);\n\t\t\tconst updatedAccount = await ctx.context.internalAdapter.updateAccount(account.id, {\n\t\t\t\taccessToken: await setTokenUtil(newTokens.accessToken, ctx.context),\n\t\t\t\taccessTokenExpiresAt: newTokens.accessTokenExpiresAt,\n\t\t\t\trefreshToken: await setTokenUtil(newTokens.refreshToken, ctx.context),\n\t\t\t\trefreshTokenExpiresAt: newTokens.refreshTokenExpiresAt\n\t\t\t});\n\t\t\tif (ctx.context.options.account?.storeAccountCookie && updatedAccount) await setAccountCookie(ctx, updatedAccount);\n\t\t}\n\t\tconst tokens = {\n\t\t\taccessToken: newTokens?.accessToken ?? await decryptOAuthToken(account.accessToken ?? \"\", ctx.context),\n\t\t\taccessTokenExpiresAt: newTokens?.accessTokenExpiresAt ?? account.accessTokenExpiresAt ?? void 0,\n\t\t\tscopes: account.scope?.split(\",\") ?? [],\n\t\t\tidToken: newTokens?.idToken ?? account.idToken ?? void 0\n\t\t};\n\t\treturn ctx.json(tokens);\n\t} catch (error$1) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Failed to get a valid access token\",\n\t\t\tcause: error$1\n\t\t});\n\t}\n});\nconst refreshToken = createAuthEndpoint(\"/refresh-token\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tproviderId: z.string().meta({ description: \"The provider ID for the OAuth provider\" }),\n\t\taccountId: z.string().meta({ description: \"The account ID associated with the refresh token\" }).optional(),\n\t\tuserId: z.string().meta({ description: \"The user ID associated with the account\" }).optional()\n\t}),\n\tmetadata: { openapi: {\n\t\tdescription: \"Refresh the access token using a refresh token\",\n\t\tresponses: {\n\t\t\t200: {\n\t\t\t\tdescription: \"Access token refreshed successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\ttokenType: { type: \"string\" },\n\t\t\t\t\t\tidToken: { type: \"string\" },\n\t\t\t\t\t\taccessToken: { type: \"string\" },\n\t\t\t\t\t\trefreshToken: { type: \"string\" },\n\t\t\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefreshTokenExpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} } }\n\t\t\t},\n\t\t\t400: { description: \"Invalid refresh token or provider configuration\" }\n\t\t}\n\t} }\n}, async (ctx) => {\n\tconst { providerId, accountId, userId } = ctx.body;\n\tconst req = ctx.request;\n\tconst session = await getSessionFromCtx(ctx);\n\tif (req && !session) throw ctx.error(\"UNAUTHORIZED\");\n\tlet resolvedUserId = session?.user?.id || userId;\n\tif (!resolvedUserId) throw new APIError(\"BAD_REQUEST\", { message: `Either userId or session is required` });\n\tconst provider = ctx.context.socialProviders.find((p) => p.id === providerId);\n\tif (!provider) throw new APIError(\"BAD_REQUEST\", { message: `Provider ${providerId} not found.` });\n\tif (!provider.refreshAccessToken) throw new APIError(\"BAD_REQUEST\", { message: `Provider ${providerId} does not support token refreshing.` });\n\tlet account = void 0;\n\tconst accountData = await getAccountCookie(ctx);\n\tif (accountData && (!providerId || providerId === accountData?.providerId)) account = accountData;\n\telse account = (await ctx.context.internalAdapter.findAccounts(resolvedUserId)).find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);\n\tif (!account) throw new APIError(\"BAD_REQUEST\", { message: \"Account not found\" });\n\tlet refreshToken$1 = void 0;\n\tif (accountData && providerId === accountData.providerId) refreshToken$1 = accountData.refreshToken ?? void 0;\n\telse refreshToken$1 = account.refreshToken ?? void 0;\n\tif (!refreshToken$1) throw new APIError(\"BAD_REQUEST\", { message: \"Refresh token not found\" });\n\ttry {\n\t\tconst decryptedRefreshToken = await decryptOAuthToken(refreshToken$1, ctx.context);\n\t\tconst tokens = await provider.refreshAccessToken(decryptedRefreshToken);\n\t\tif (account.id) {\n\t\t\tconst updateData = {\n\t\t\t\t...account || {},\n\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, ctx.context),\n\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),\n\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\tscope: tokens.scopes?.join(\",\") || account.scope,\n\t\t\t\tidToken: tokens.idToken || account.idToken\n\t\t\t};\n\t\t\tawait ctx.context.internalAdapter.updateAccount(account.id, updateData);\n\t\t}\n\t\tif (accountData && providerId === accountData.providerId && ctx.context.options.account?.storeAccountCookie) await setAccountCookie(ctx, {\n\t\t\t...accountData,\n\t\t\taccessToken: await setTokenUtil(tokens.accessToken, ctx.context),\n\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),\n\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\tscope: tokens.scopes?.join(\",\") || accountData.scope,\n\t\t\tidToken: tokens.idToken || accountData.idToken\n\t\t});\n\t\treturn ctx.json({\n\t\t\taccessToken: tokens.accessToken,\n\t\t\trefreshToken: tokens.refreshToken,\n\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\tscope: tokens.scopes?.join(\",\") || account.scope,\n\t\t\tidToken: tokens.idToken || account.idToken,\n\t\t\tproviderId: account.providerId,\n\t\t\taccountId: account.accountId\n\t\t});\n\t} catch (error$1) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Failed to refresh access token\",\n\t\t\tcause: error$1\n\t\t});\n\t}\n});\nconst accountInfoQuerySchema = z.optional(z.object({ accountId: z.string().meta({ description: \"The provider given account id for which to get the account info\" }).optional() }));\nconst accountInfo = createAuthEndpoint(\"/account-info\", {\n\tmethod: \"GET\",\n\tuse: [sessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Get the account info provided by the provider\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\t\t\tname: { type: \"string\" },\n\t\t\t\t\t\t\temail: { type: \"string\" },\n\t\t\t\t\t\t\timage: { type: \"string\" },\n\t\t\t\t\t\t\temailVerified: { type: \"boolean\" }\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\"id\", \"emailVerified\"]\n\t\t\t\t\t},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\"user\", \"data\"],\n\t\t\t\tadditionalProperties: false\n\t\t\t} } }\n\t\t} }\n\t} },\n\tquery: accountInfoQuerySchema\n}, async (ctx) => {\n\tconst providedAccountId = ctx.query?.accountId;\n\tlet account = void 0;\n\tif (!providedAccountId) {\n\t\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\t\tconst accountData = await getAccountCookie(ctx);\n\t\t\tif (accountData) account = accountData;\n\t\t}\n\t} else {\n\t\tconst accountData = await ctx.context.internalAdapter.findAccount(providedAccountId);\n\t\tif (accountData) account = accountData;\n\t}\n\tif (!account || account.userId !== ctx.context.session.user.id) throw new APIError(\"BAD_REQUEST\", { message: \"Account not found\" });\n\tconst provider = ctx.context.socialProviders.find((p) => p.id === account.providerId);\n\tif (!provider) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: `Provider account provider is ${account.providerId} but it is not configured` });\n\tconst tokens = await getAccessToken({\n\t\t...ctx,\n\t\tmethod: \"POST\",\n\t\tbody: {\n\t\t\taccountId: account.id,\n\t\t\tproviderId: account.providerId\n\t\t},\n\t\treturnHeaders: false,\n\t\treturnStatus: false\n\t});\n\tif (!tokens.accessToken) throw new APIError(\"BAD_REQUEST\", { message: \"Access token not found\" });\n\tconst info = await provider.getUserInfo({\n\t\t...tokens,\n\t\taccessToken: tokens.accessToken\n\t});\n\treturn ctx.json(info);\n});\n\n//#endregion\n//#region src/oauth2/link-account.ts\nasync function handleOAuthUserInfo(c, { userInfo, account, callbackURL, disableSignUp, overrideUserInfo }) {\n\tconst dbUser = await c.context.internalAdapter.findOAuthUser(userInfo.email.toLowerCase(), account.accountId, account.providerId).catch((e) => {\n\t\tlogger.error(\"Better auth was unable to query your database.\\nError: \", e);\n\t\tconst errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\t\tthrow c.redirect(`${errorURL}?error=internal_server_error`);\n\t});\n\tlet user = dbUser?.user;\n\tlet isRegister = !user;\n\tif (dbUser) {\n\t\tconst hasBeenLinked = dbUser.accounts.find((a) => a.providerId === account.providerId && a.accountId === account.accountId);\n\t\tif (!hasBeenLinked) {\n\t\t\tif (!(c.context.options.account?.accountLinking?.trustedProviders)?.includes(account.providerId) && !userInfo.emailVerified || c.context.options.account?.accountLinking?.enabled === false) {\n\t\t\t\tif (isDevelopment()) logger.warn(`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`);\n\t\t\t\treturn {\n\t\t\t\t\terror: \"account not linked\",\n\t\t\t\t\tdata: null\n\t\t\t\t};\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait c.context.internalAdapter.linkAccount({\n\t\t\t\t\tproviderId: account.providerId,\n\t\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t\t\tuserId: dbUser.user.id,\n\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\tscope: account.scope\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Unable to link account\", e);\n\t\t\t\treturn {\n\t\t\t\t\terror: \"unable to link account\",\n\t\t\t\t\tdata: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (userInfo.emailVerified && !dbUser.user.emailVerified && userInfo.email.toLowerCase() === dbUser.user.email) await c.context.internalAdapter.updateUser(dbUser.user.id, { emailVerified: true });\n\t\t} else {\n\t\t\tif (c.context.options.account?.updateAccountOnSignIn !== false) {\n\t\t\t\tconst updateData = Object.fromEntries(Object.entries({\n\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\tscope: account.scope\n\t\t\t\t}).filter(([_, value]) => value !== void 0));\n\t\t\t\tif (c.context.options.account?.storeAccountCookie) await setAccountCookie(c, updateData);\n\t\t\t\tif (Object.keys(updateData).length > 0) await c.context.internalAdapter.updateAccount(hasBeenLinked.id, updateData);\n\t\t\t}\n\t\t\tif (userInfo.emailVerified && !dbUser.user.emailVerified && userInfo.email.toLowerCase() === dbUser.user.email) await c.context.internalAdapter.updateUser(dbUser.user.id, { emailVerified: true });\n\t\t}\n\t\tif (overrideUserInfo) {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\tuser = await c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t...restUserInfo,\n\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\temailVerified: userInfo.email.toLowerCase() === dbUser.user.email ? dbUser.user.emailVerified || userInfo.emailVerified : userInfo.emailVerified\n\t\t\t});\n\t\t}\n\t} else {\n\t\tif (disableSignUp) return {\n\t\t\terror: \"signup disabled\",\n\t\t\tdata: null,\n\t\t\tisRegister: false\n\t\t};\n\t\ttry {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\tconst accountData = {\n\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\tidToken: account.idToken,\n\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\tscope: account.scope,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t\taccountId: userInfo.id.toString()\n\t\t\t};\n\t\t\tconst { user: createdUser, account: createdAccount } = await c.context.internalAdapter.createOAuthUser({\n\t\t\t\t...restUserInfo,\n\t\t\t\temail: userInfo.email.toLowerCase()\n\t\t\t}, accountData);\n\t\t\tuser = createdUser;\n\t\t\tif (c.context.options.account?.storeAccountCookie) await setAccountCookie(c, createdAccount);\n\t\t\tif (!userInfo.emailVerified && user && c.context.options.emailVerification?.sendOnSignUp) {\n\t\t\t\tconst token = await createEmailVerificationToken(c.context.secret, user.email, void 0, c.context.options.emailVerification?.expiresIn);\n\t\t\t\tconst url = `${c.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\t\tawait c.context.options.emailVerification?.sendVerificationEmail?.({\n\t\t\t\t\tuser,\n\t\t\t\t\turl,\n\t\t\t\t\ttoken\n\t\t\t\t}, c.request);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlogger.error(e);\n\t\t\tif (e instanceof APIError$1) return {\n\t\t\t\terror: e.message,\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false\n\t\t\t};\n\t\t\treturn {\n\t\t\t\terror: \"unable to create user\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false\n\t\t\t};\n\t\t}\n\t}\n\tif (!user) return {\n\t\terror: \"unable to create user\",\n\t\tdata: null,\n\t\tisRegister: false\n\t};\n\tconst session = await c.context.internalAdapter.createSession(user.id);\n\tif (!session) return {\n\t\terror: \"unable to create session\",\n\t\tdata: null,\n\t\tisRegister: false\n\t};\n\treturn {\n\t\tdata: {\n\t\t\tsession,\n\t\t\tuser\n\t\t},\n\t\terror: null,\n\t\tisRegister\n\t};\n}\n\n//#endregion\n//#region src/api/routes/callback.ts\nconst schema = z.object({\n\tcode: z.string().optional(),\n\terror: z.string().optional(),\n\tdevice_id: z.string().optional(),\n\terror_description: z.string().optional(),\n\tstate: z.string().optional(),\n\tuser: z.string().optional()\n});\nconst callbackOAuth = createAuthEndpoint(\"/callback/:id\", {\n\tmethod: [\"GET\", \"POST\"],\n\toperationId: \"handleOAuthCallback\",\n\tbody: schema.optional(),\n\tquery: schema.optional(),\n\tmetadata: {\n\t\t...HIDE_METADATA,\n\t\tallowedMediaTypes: [\"application/x-www-form-urlencoded\", \"application/json\"]\n\t}\n}, async (c) => {\n\tlet queryOrBody;\n\tconst defaultErrorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\tif (c.method === \"POST\") {\n\t\tconst postData = c.body ? schema.parse(c.body) : {};\n\t\tconst queryData = c.query ? schema.parse(c.query) : {};\n\t\tconst mergedData = schema.parse({\n\t\t\t...postData,\n\t\t\t...queryData\n\t\t});\n\t\tconst params = new URLSearchParams();\n\t\tfor (const [key, value] of Object.entries(mergedData)) if (value !== void 0 && value !== null) params.set(key, String(value));\n\t\tconst redirectURL = `${c.context.baseURL}/callback/${c.params.id}?${params.toString()}`;\n\t\tthrow c.redirect(redirectURL);\n\t}\n\ttry {\n\t\tif (c.method === \"GET\") queryOrBody = schema.parse(c.query);\n\t\telse if (c.method === \"POST\") queryOrBody = schema.parse(c.body);\n\t\telse throw new Error(\"Unsupported method\");\n\t} catch (e) {\n\t\tc.context.logger.error(\"INVALID_CALLBACK_REQUEST\", e);\n\t\tthrow c.redirect(`${defaultErrorURL}?error=invalid_callback_request`);\n\t}\n\tconst { code, error: error$1, state, error_description, device_id } = queryOrBody;\n\tif (!state) {\n\t\tc.context.logger.error(\"State not found\", error$1);\n\t\tconst url = `${defaultErrorURL}${defaultErrorURL.includes(\"?\") ? \"&\" : \"?\"}state=state_not_found`;\n\t\tthrow c.redirect(url);\n\t}\n\tconst { codeVerifier, callbackURL, link, errorURL, newUserURL, requestSignUp } = await parseState(c);\n\tfunction redirectOnError(error$2, description) {\n\t\tconst baseURL = errorURL ?? defaultErrorURL;\n\t\tconst params = new URLSearchParams({ error: error$2 });\n\t\tif (description) params.set(\"error_description\", description);\n\t\tconst url = `${baseURL}${baseURL.includes(\"?\") ? \"&\" : \"?\"}${params.toString()}`;\n\t\tthrow c.redirect(url);\n\t}\n\tif (error$1) redirectOnError(error$1, error_description);\n\tif (!code) {\n\t\tc.context.logger.error(\"Code not found\");\n\t\tthrow redirectOnError(\"no_code\");\n\t}\n\tconst provider = c.context.socialProviders.find((p) => p.id === c.params.id);\n\tif (!provider) {\n\t\tc.context.logger.error(\"Oauth provider with id\", c.params.id, \"not found\");\n\t\tthrow redirectOnError(\"oauth_provider_not_found\");\n\t}\n\tlet tokens;\n\ttry {\n\t\ttokens = await provider.validateAuthorizationCode({\n\t\t\tcode,\n\t\t\tcodeVerifier,\n\t\t\tdeviceId: device_id,\n\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`\n\t\t});\n\t} catch (e) {\n\t\tc.context.logger.error(\"\", e);\n\t\tthrow redirectOnError(\"invalid_code\");\n\t}\n\tconst userInfo = await provider.getUserInfo({\n\t\t...tokens,\n\t\tuser: c.body?.user ? safeJSONParse(c.body.user) : void 0\n\t}).then((res) => res?.user);\n\tif (!userInfo) {\n\t\tc.context.logger.error(\"Unable to get user info\");\n\t\treturn redirectOnError(\"unable_to_get_user_info\");\n\t}\n\tif (!callbackURL) {\n\t\tc.context.logger.error(\"No callback URL found\");\n\t\tthrow redirectOnError(\"no_callback_url\");\n\t}\n\tif (link) {\n\t\tif (!(c.context.options.account?.accountLinking?.trustedProviders)?.includes(provider.id) && !userInfo.emailVerified || c.context.options.account?.accountLinking?.enabled === false) {\n\t\t\tc.context.logger.error(\"Unable to link account - untrusted provider\");\n\t\t\treturn redirectOnError(\"unable_to_link_account\");\n\t\t}\n\t\tif (userInfo.email !== link.email && c.context.options.account?.accountLinking?.allowDifferentEmails !== true) return redirectOnError(\"email_doesn't_match\");\n\t\tconst existingAccount = await c.context.internalAdapter.findAccount(String(userInfo.id));\n\t\tif (existingAccount) {\n\t\t\tif (existingAccount.userId.toString() !== link.userId.toString()) return redirectOnError(\"account_already_linked_to_different_user\");\n\t\t\tconst updateData = Object.fromEntries(Object.entries({\n\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, c.context),\n\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, c.context),\n\t\t\t\tidToken: tokens.idToken,\n\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\tscope: tokens.scopes?.join(\",\")\n\t\t\t}).filter(([_, value]) => value !== void 0));\n\t\t\tawait c.context.internalAdapter.updateAccount(existingAccount.id, updateData);\n\t\t} else if (!await c.context.internalAdapter.createAccount({\n\t\t\tuserId: link.userId,\n\t\t\tproviderId: provider.id,\n\t\t\taccountId: String(userInfo.id),\n\t\t\t...tokens,\n\t\t\taccessToken: await setTokenUtil(tokens.accessToken, c.context),\n\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, c.context),\n\t\t\tscope: tokens.scopes?.join(\",\")\n\t\t})) return redirectOnError(\"unable_to_link_account\");\n\t\tlet toRedirectTo$1;\n\t\ttry {\n\t\t\ttoRedirectTo$1 = callbackURL.toString();\n\t\t} catch {\n\t\t\ttoRedirectTo$1 = callbackURL;\n\t\t}\n\t\tthrow c.redirect(toRedirectTo$1);\n\t}\n\tif (!userInfo.email) {\n\t\tc.context.logger.error(\"Provider did not return email. This could be due to misconfiguration in the provider settings.\");\n\t\treturn redirectOnError(\"email_not_found\");\n\t}\n\tconst accountData = {\n\t\tproviderId: provider.id,\n\t\taccountId: String(userInfo.id),\n\t\t...tokens,\n\t\tscope: tokens.scopes?.join(\",\")\n\t};\n\tconst result = await handleOAuthUserInfo(c, {\n\t\tuserInfo: {\n\t\t\t...userInfo,\n\t\t\tid: String(userInfo.id),\n\t\t\temail: userInfo.email,\n\t\t\tname: userInfo.name || userInfo.email\n\t\t},\n\t\taccount: accountData,\n\t\tcallbackURL,\n\t\tdisableSignUp: provider.disableImplicitSignUp && !requestSignUp || provider.options?.disableSignUp,\n\t\toverrideUserInfo: provider.options?.overrideUserInfoOnSignIn\n\t});\n\tif (result.error) {\n\t\tc.context.logger.error(result.error.split(\" \").join(\"_\"));\n\t\treturn redirectOnError(result.error.split(\" \").join(\"_\"));\n\t}\n\tconst { session, user } = result.data;\n\tawait setSessionCookie(c, {\n\t\tsession,\n\t\tuser\n\t});\n\tlet toRedirectTo;\n\ttry {\n\t\ttoRedirectTo = (result.isRegister ? newUserURL || callbackURL : callbackURL).toString();\n\t} catch {\n\t\ttoRedirectTo = result.isRegister ? newUserURL || callbackURL : callbackURL;\n\t}\n\tthrow c.redirect(toRedirectTo);\n});\n\n//#endregion\n//#region src/api/routes/email-verification.ts\nasync function createEmailVerificationToken(secret, email, updateTo, expiresIn = 3600, extraPayload) {\n\treturn await signJWT({\n\t\temail: email.toLowerCase(),\n\t\tupdateTo,\n\t\t...extraPayload\n\t}, secret, expiresIn);\n}\n/**\n* A function to send a verification email to the user\n*/\nasync function sendVerificationEmailFn(ctx, user) {\n\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Verification email isn't enabled\" });\n\t}\n\tconst token = await createEmailVerificationToken(ctx.context.secret, user.email, void 0, ctx.context.options.emailVerification?.expiresIn);\n\tconst callbackURL = ctx.body.callbackURL ? encodeURIComponent(ctx.body.callbackURL) : encodeURIComponent(\"/\");\n\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\tawait ctx.context.options.emailVerification.sendVerificationEmail({\n\t\tuser,\n\t\turl,\n\t\ttoken\n\t}, ctx.request);\n}\nconst sendVerificationEmail = createAuthEndpoint(\"/send-verification-email\", {\n\tmethod: \"POST\",\n\toperationId: \"sendVerificationEmail\",\n\tbody: z.object({\n\t\temail: z.email().meta({ description: \"The email to send the verification email to\" }),\n\t\tcallbackURL: z.string().meta({ description: \"The URL to use for email verification callback\" }).optional()\n\t}),\n\tmetadata: { openapi: {\n\t\toperationId: \"sendVerificationEmail\",\n\t\tdescription: \"Send a verification email to the user\",\n\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\ttype: \"object\",\n\t\t\tproperties: {\n\t\t\t\temail: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The email to send the verification email to\",\n\t\t\t\t\texample: \"user@example.com\"\n\t\t\t\t},\n\t\t\t\tcallbackURL: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The URL to use for email verification callback\",\n\t\t\t\t\texample: \"https://example.com/callback\",\n\t\t\t\t\tnullable: true\n\t\t\t\t}\n\t\t\t},\n\t\t\trequired: [\"email\"]\n\t\t} } } },\n\t\tresponses: {\n\t\t\t\"200\": {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { status: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the email was sent successfully\",\n\t\t\t\t\t\texample: true\n\t\t\t\t\t} }\n\t\t\t\t} } }\n\t\t\t},\n\t\t\t\"400\": {\n\t\t\t\tdescription: \"Bad Request\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { message: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"Error message\",\n\t\t\t\t\t\texample: \"Verification email isn't enabled\"\n\t\t\t\t\t} }\n\t\t\t\t} } }\n\t\t\t}\n\t\t}\n\t} }\n}, async (ctx) => {\n\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Verification email isn't enabled\" });\n\t}\n\tconst { email } = ctx.body;\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) {\n\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\tif (!user) {\n\t\t\tawait createEmailVerificationToken(ctx.context.secret, email, void 0, ctx.context.options.emailVerification?.expiresIn);\n\t\t\treturn ctx.json({ status: true });\n\t\t}\n\t\tawait sendVerificationEmailFn(ctx, user.user);\n\t\treturn ctx.json({ status: true });\n\t}\n\tif (session?.user.emailVerified) throw new APIError(\"BAD_REQUEST\", { message: \"You can only send a verification email to an unverified email\" });\n\tif (session?.user.email !== email) throw new APIError(\"BAD_REQUEST\", { message: \"You can only send a verification email to your own email\" });\n\tawait sendVerificationEmailFn(ctx, session.user);\n\treturn ctx.json({ status: true });\n});\nconst verifyEmail = createAuthEndpoint(\"/verify-email\", {\n\tmethod: \"GET\",\n\toperationId: \"verifyEmail\",\n\tquery: z.object({\n\t\ttoken: z.string().meta({ description: \"The token to verify the email\" }),\n\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after email verification\" }).optional()\n\t}),\n\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\tmetadata: { openapi: {\n\t\tdescription: \"Verify the email of the user\",\n\t\tparameters: [{\n\t\t\tname: \"token\",\n\t\t\tin: \"query\",\n\t\t\tdescription: \"The token to verify the email\",\n\t\t\trequired: true,\n\t\t\tschema: { type: \"string\" }\n\t\t}, {\n\t\t\tname: \"callbackURL\",\n\t\t\tin: \"query\",\n\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\trequired: false,\n\t\t\tschema: { type: \"string\" }\n\t\t}],\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t$ref: \"#/components/schemas/User\"\n\t\t\t\t\t},\n\t\t\t\t\tstatus: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the email was verified successfully\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\"user\", \"status\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tfunction redirectOnError(error$1) {\n\t\tif (ctx.query.callbackURL) {\n\t\t\tif (ctx.query.callbackURL.includes(\"?\")) throw ctx.redirect(`${ctx.query.callbackURL}&error=${error$1}`);\n\t\t\tthrow ctx.redirect(`${ctx.query.callbackURL}?error=${error$1}`);\n\t\t}\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: error$1 });\n\t}\n\tconst { token } = ctx.query;\n\tlet jwt;\n\ttry {\n\t\tjwt = await jwtVerify(token, new TextEncoder().encode(ctx.context.secret), { algorithms: [\"HS256\"] });\n\t} catch (e) {\n\t\tif (e instanceof JWTExpired) return redirectOnError(\"token_expired\");\n\t\treturn redirectOnError(\"invalid_token\");\n\t}\n\tconst parsed = z.object({\n\t\temail: z.email(),\n\t\tupdateTo: z.string().optional(),\n\t\trequestType: z.string().optional()\n\t}).parse(jwt.payload);\n\tconst user = await ctx.context.internalAdapter.findUserByEmail(parsed.email);\n\tif (!user) return redirectOnError(\"user_not_found\");\n\tif (parsed.updateTo) {\n\t\tlet session = await getSessionFromCtx(ctx);\n\t\tif (session && session.user.email !== parsed.email) return redirectOnError(\"unauthorized\");\n\t\tif (parsed.requestType === \"change-email-confirmation\") {\n\t\t\tconst newToken$1 = await createEmailVerificationToken(ctx.context.secret, parsed.email, parsed.updateTo, ctx.context.options.emailVerification?.expiresIn, { requestType: \"change-email-verification\" });\n\t\t\tconst updateCallbackURL$1 = ctx.query.callbackURL ? encodeURIComponent(ctx.query.callbackURL) : encodeURIComponent(\"/\");\n\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${newToken$1}&callbackURL=${updateCallbackURL$1}`;\n\t\t\tawait ctx.context.options.emailVerification?.sendVerificationEmail?.({\n\t\t\t\tuser: {\n\t\t\t\t\t...user.user,\n\t\t\t\t\temail: parsed.updateTo\n\t\t\t\t},\n\t\t\t\turl,\n\t\t\t\ttoken: newToken$1\n\t\t\t}, ctx.request);\n\t\t\tif (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);\n\t\t\treturn ctx.json({ status: true });\n\t\t}\n\t\tif (!session) {\n\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(user.user.id);\n\t\t\tif (!newSession) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Failed to create session\" });\n\t\t\tsession = {\n\t\t\t\tsession: newSession,\n\t\t\t\tuser: user.user\n\t\t\t};\n\t\t}\n\t\tif (parsed.requestType === \"change-email-verification\") {\n\t\t\tconst updatedUser$2 = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {\n\t\t\t\temail: parsed.updateTo,\n\t\t\t\temailVerified: true\n\t\t\t});\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: session.session,\n\t\t\t\tuser: {\n\t\t\t\t\t...session.user,\n\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\temailVerified: true\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t\tuser: updatedUser$2\n\t\t\t});\n\t\t}\n\t\tconst updatedUser$1 = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {\n\t\t\temail: parsed.updateTo,\n\t\t\temailVerified: false\n\t\t});\n\t\tconst newToken = await createEmailVerificationToken(ctx.context.secret, parsed.updateTo);\n\t\tconst updateCallbackURL = ctx.query.callbackURL ? encodeURIComponent(ctx.query.callbackURL) : encodeURIComponent(\"/\");\n\t\tawait ctx.context.options.emailVerification?.sendVerificationEmail?.({\n\t\t\tuser: updatedUser$1,\n\t\t\turl: `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`,\n\t\t\ttoken: newToken\n\t\t}, ctx.request);\n\t\tawait setSessionCookie(ctx, {\n\t\t\tsession: session.session,\n\t\t\tuser: {\n\t\t\t\t...session.user,\n\t\t\t\temail: parsed.updateTo,\n\t\t\t\temailVerified: false\n\t\t\t}\n\t\t});\n\t\tif (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tuser: {\n\t\t\t\tid: updatedUser$1.id,\n\t\t\t\temail: updatedUser$1.email,\n\t\t\t\tname: updatedUser$1.name,\n\t\t\t\timage: updatedUser$1.image,\n\t\t\t\temailVerified: updatedUser$1.emailVerified,\n\t\t\t\tcreatedAt: updatedUser$1.createdAt,\n\t\t\t\tupdatedAt: updatedUser$1.updatedAt\n\t\t\t}\n\t\t});\n\t}\n\tif (user.user.emailVerified) {\n\t\tif (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tuser: null\n\t\t});\n\t}\n\tif (ctx.context.options.emailVerification?.onEmailVerification) await ctx.context.options.emailVerification.onEmailVerification(user.user, ctx.request);\n\tconst updatedUser = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, { emailVerified: true });\n\tif (ctx.context.options.emailVerification?.afterEmailVerification) await ctx.context.options.emailVerification.afterEmailVerification(updatedUser, ctx.request);\n\tif (ctx.context.options.emailVerification?.autoSignInAfterVerification) {\n\t\tconst currentSession = await getSessionFromCtx(ctx);\n\t\tif (!currentSession || currentSession.user.email !== parsed.email) {\n\t\t\tconst session = await ctx.context.internalAdapter.createSession(user.user.id);\n\t\t\tif (!session) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"Failed to create session\" });\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession,\n\t\t\t\tuser: {\n\t\t\t\t\t...user.user,\n\t\t\t\t\temailVerified: true\n\t\t\t\t}\n\t\t\t});\n\t\t} else await setSessionCookie(ctx, {\n\t\t\tsession: currentSession.session,\n\t\t\tuser: {\n\t\t\t\t...currentSession.user,\n\t\t\t\temailVerified: true\n\t\t\t}\n\t\t});\n\t}\n\tif (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);\n\treturn ctx.json({\n\t\tstatus: true,\n\t\tuser: null\n\t});\n});\n\n//#endregion\n//#region src/api/routes/error.ts\nfunction sanitize(input) {\n\treturn input.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/&(?!amp;|lt;|gt;|quot;|#39;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, \"&amp;\");\n}\nconst html = (options, code = \"Unknown\", description = null) => {\n\tconst custom = options.onAPIError?.customizeDefaultErrorPage;\n\treturn `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Error</title>\n    <style>\n      * {\n        box-sizing: border-box;\n      }\n      body {\n        font-family: ${custom?.font?.defaultFamily || \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif\"};\n        background: ${custom?.colors?.background || \"var(--background)\"};\n        color: var(--foreground);\n        margin: 0;\n      }\n      :root,\n      :host {\n        --spacing: 0.25rem;\n        --container-md: 28rem;\n        --text-sm: ${custom?.size?.textSm || \"0.875rem\"};\n        --text-sm--line-height: calc(1.25 / 0.875);\n        --text-2xl: ${custom?.size?.text2xl || \"1.5rem\"};\n        --text-2xl--line-height: calc(2 / 1.5);\n        --text-4xl: ${custom?.size?.text4xl || \"2.25rem\"};\n        --text-4xl--line-height: calc(2.5 / 2.25);\n        --text-6xl: ${custom?.size?.text6xl || \"3rem\"};\n        --text-6xl--line-height: 1;\n        --font-weight-medium: 500;\n        --font-weight-semibold: 600;\n        --font-weight-bold: 700;\n        --default-transition-duration: 150ms;\n        --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n        --radius: ${custom?.size?.radiusSm || \"0.625rem\"};\n        --default-mono-font-family: ${custom?.font?.monoFamily || \"var(--font-geist-mono)\"};\n        --primary: ${custom?.colors?.primary || \"black\"};\n        --primary-foreground: ${custom?.colors?.primaryForeground || \"white\"};\n        --background: ${custom?.colors?.background || \"white\"};\n        --foreground: ${custom?.colors?.foreground || \"oklch(0.271 0 0)\"};\n        --border: ${custom?.colors?.border || \"oklch(0.89 0 0)\"};\n        --destructive: ${custom?.colors?.destructive || \"oklch(0.55 0.15 25.723)\"};\n        --muted-foreground: ${custom?.colors?.mutedForeground || \"oklch(0.545 0 0)\"};\n        --corner-border: ${custom?.colors?.cornerBorder || \"#404040\"};\n      }\n\n      button, .btn {\n        cursor: pointer;\n        background: none;\n        border: none;\n        color: inherit;\n        font: inherit;\n        transition: all var(--default-transition-duration)\n          var(--default-transition-timing-function);\n      }\n      button:hover, .btn:hover {\n        opacity: 0.8;\n      }\n\n      @media (prefers-color-scheme: dark) {\n        :root,\n        :host {\n          --primary: ${custom?.colors?.primary || \"white\"};\n          --primary-foreground: ${custom?.colors?.primaryForeground || \"black\"};\n          --background: ${custom?.colors?.background || \"oklch(0.15 0 0)\"};\n          --foreground: ${custom?.colors?.foreground || \"oklch(0.98 0 0)\"};\n          --border: ${custom?.colors?.border || \"oklch(0.27 0 0)\"};\n          --destructive: ${custom?.colors?.destructive || \"oklch(0.65 0.15 25.723)\"};\n          --muted-foreground: ${custom?.colors?.mutedForeground || \"oklch(0.65 0 0)\"};\n          --corner-border: ${custom?.colors?.cornerBorder || \"#a0a0a0\"};\n        }\n      }\n      @media (max-width: 640px) {\n        :root, :host {\n          --text-6xl: 2.5rem;\n          --text-2xl: 1.25rem;\n          --text-sm: 0.8125rem;\n        }\n      }\n      @media (max-width: 480px) {\n        :root, :host {\n          --text-6xl: 2rem;\n          --text-2xl: 1.125rem;\n        }\n      }\n    </style>\n  </head>\n  <body style=\"width: 100vw; min-height: 100vh; overflow-x: hidden; overflow-y: auto;\">\n    <div\n        style=\"\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            gap: 1.5rem;\n            position: relative;\n            width: 100%;\n            min-height: 100vh;\n            padding: 1rem;\n        \"\n        >\n${custom?.disableBackgroundGrid ? \"\" : `\n      <div\n        style=\"\n          position: absolute;\n          inset: 0;\n          background-image: linear-gradient(to right, ${custom?.colors?.gridColor || \"var(--border)\"} 1px, transparent 1px),\n            linear-gradient(to bottom, ${custom?.colors?.gridColor || \"var(--border)\"} 1px, transparent 1px);\n          background-size: 40px 40px;\n          opacity: 0.6;\n          pointer-events: none;\n          width: 100vw;\n          height: 100vh;\n        \"\n      ></div>\n      <div\n        style=\"\n          position: absolute;\n          inset: 0;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          background: ${custom?.colors?.background || \"var(--background)\"};\n          mask-image: radial-gradient(ellipse at center, transparent 20%, black);\n          -webkit-mask-image: radial-gradient(ellipse at center, transparent 20%, black);\n          pointer-events: none;\n        \"\n      ></div>\n`}\n\n<div\n  style=\"\n    position: relative;\n    z-index: 10;\n    border: 2px solid var(--border);\n    background: ${custom?.colors?.cardBackground || \"var(--background)\"};\n    padding: 1.5rem;\n    max-width: 42rem;\n    width: 100%;\n  \"\n>\n    ${custom?.disableCornerDecorations ? \"\" : `\n        <!-- Corner decorations -->\n        <div\n          style=\"\n            position: absolute;\n            top: -2px;\n            left: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-top: 4px solid var(--corner-border);\n            border-left: 4px solid var(--corner-border);\n          \"\n        ></div>\n        <div\n          style=\"\n            position: absolute;\n            top: -2px;\n            right: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-top: 4px solid var(--corner-border);\n            border-right: 4px solid var(--corner-border);\n          \"\n        ></div>\n  \n        <div\n          style=\"\n            position: absolute;\n            bottom: -2px;\n            left: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-bottom: 4px solid var(--corner-border);\n            border-left: 4px solid var(--corner-border);\n          \"\n        ></div>\n        <div\n          style=\"\n            position: absolute;\n            bottom: -2px;\n            right: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-bottom: 4px solid var(--corner-border);\n            border-right: 4px solid var(--corner-border);\n          \"\n        ></div>`}\n\n        <div style=\"text-align: center; margin-bottom: 1.5rem;\">\n          <div style=\"margin-bottom: 1.5rem;\">\n            <div\n              style=\"\n                display: inline-block;\n                border: 2px solid ${custom?.disableTitleBorder ? \"transparent\" : custom?.colors?.titleBorder || \"var(--destructive)\"};\n                padding: 0.375rem 1rem;\n              \"\n            >\n              <h1\n                style=\"\n                  font-size: var(--text-6xl);\n                  font-weight: var(--font-weight-semibold);\n                  color: ${custom?.colors?.titleColor || \"var(--foreground)\"};\n                  letter-spacing: -0.02em;\n                  margin: 0;\n                \"\n              >\n                ERROR\n              </h1>\n            </div>\n            <div\n              style=\"\n                height: 2px;\n                background-color: var(--border);\n                width: calc(100% + 3rem);\n                margin-left: -1.5rem;\n                margin-top: 1.5rem;\n              \"\n            ></div>\n          </div>\n\n          <h2\n            style=\"\n              font-size: var(--text-2xl);\n              font-weight: var(--font-weight-semibold);\n              color: var(--foreground);\n              margin: 0 0 1rem;\n            \"\n          >\n            Something went wrong\n          </h2>\n\n          <div\n            style=\"\n                display: inline-flex;\n                align-items: center;\n                gap: 0.5rem;\n                border: 2px solid var(--border);\n                background-color: var(--muted);\n                padding: 0.375rem 0.75rem;\n                margin: 0 0 1rem;\n                flex-wrap: wrap;\n                justify-content: center;\n            \"\n            >\n            <span\n                style=\"\n                font-size: 0.75rem;\n                color: var(--muted-foreground);\n                font-weight: var(--font-weight-semibold);\n                \"\n            >\n                CODE:\n            </span>\n            <span\n                style=\"\n                font-size: var(--text-sm);\n                font-family: var(--default-mono-font-family, monospace);\n                color: var(--foreground);\n                word-break: break-all;\n                \"\n            >\n                ${sanitize(code)}\n            </span>\n            </div>\n\n          <p\n            style=\"\n              color: var(--muted-foreground);\n              max-width: 28rem;\n              margin: 0 auto;\n              font-size: var(--text-sm);\n              line-height: 1.5;\n              text-wrap: pretty;\n            \"\n          >\n            ${!description ? `We encountered an unexpected error. Please try again or return to the home page. If you're a developer, you can find more information about the error <a href='https://better-auth.com/docs/errors/${encodeURIComponent(code)}' target='_blank' rel=\"noopener noreferrer\" style='color: var(--foreground); text-decoration: underline;'>here</a>.` : description}\n          </p>\n        </div>\n\n        <div\n          style=\"\n            display: flex;\n            gap: 0.75rem;\n            margin-top: 1.5rem;\n            justify-content: center;\n            flex-wrap: wrap;\n          \"\n        >\n          <a\n            href=\"/\"\n            style=\"\n              text-decoration: none;\n            \"\n          >\n            <div\n              style=\"\n                border: 2px solid var(--border);\n                background: var(--primary);\n                color: var(--primary-foreground);\n                padding: 0.5rem 1rem;\n                border-radius: 0;\n                white-space: nowrap;\n              \"\n              class=\"btn\"\n            >\n              Go Home\n            </div>\n          </a>\n          <a\n            href=\"https://better-auth.com/docs/errors/${encodeURIComponent(code)}?askai=${encodeURIComponent(`What does the error code ${code} mean?`)}\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            style=\"\n              text-decoration: none;\n            \"\n          >\n            <div\n              style=\"\n                border: 2px solid var(--border);\n                background: transparent;\n                color: var(--foreground);\n                padding: 0.5rem 1rem;\n                border-radius: 0;\n                white-space: nowrap;\n              \"\n              class=\"btn\"\n            >\n              Ask AI\n            </div>\n          </a>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>`;\n};\nconst error = createAuthEndpoint(\"/error\", {\n\tmethod: \"GET\",\n\tmetadata: {\n\t\t...HIDE_METADATA,\n\t\topenapi: {\n\t\t\tdescription: \"Displays an error page\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"text/html\": { schema: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The HTML content of the error page\"\n\t\t\t\t} } }\n\t\t\t} }\n\t\t}\n\t}\n}, async (c) => {\n\tconst url = new URL(c.request?.url || \"\");\n\tconst unsanitizedCode = url.searchParams.get(\"error\") || \"UNKNOWN\";\n\tconst unsanitizedDescription = url.searchParams.get(\"error_description\") || null;\n\tconst safeCode = /^[\\'A-Za-z0-9_-]+$/.test(unsanitizedCode || \"\") ? unsanitizedCode : \"UNKNOWN\";\n\tconst safeDescription = unsanitizedDescription ? sanitize(unsanitizedDescription) : null;\n\tconst queryParams = new URLSearchParams();\n\tqueryParams.set(\"error\", safeCode);\n\tif (unsanitizedDescription) queryParams.set(\"error_description\", unsanitizedDescription);\n\tconst options = c.context.options;\n\tconst errorURL = options.onAPIError?.errorURL;\n\tif (errorURL) return new Response(null, {\n\t\tstatus: 302,\n\t\theaders: { Location: `${errorURL}${errorURL.includes(\"?\") ? \"&\" : \"?\"}${queryParams.toString()}` }\n\t});\n\tif (isProduction && !options.onAPIError?.customizeDefaultErrorPage) return new Response(null, {\n\t\tstatus: 302,\n\t\theaders: { Location: `/?${queryParams.toString()}` }\n\t});\n\treturn new Response(html(c.context.options, safeCode, safeDescription), { headers: { \"Content-Type\": \"text/html\" } });\n});\n\n//#endregion\n//#region src/api/routes/ok.ts\nconst ok = createAuthEndpoint(\"/ok\", {\n\tmethod: \"GET\",\n\tmetadata: {\n\t\t...HIDE_METADATA,\n\t\topenapi: {\n\t\t\tdescription: \"Check if the API is working\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"API is working\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { ok: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the API is working\"\n\t\t\t\t\t} },\n\t\t\t\t\trequired: [\"ok\"]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t}\n\t}\n}, async (ctx) => {\n\treturn ctx.json({ ok: true });\n});\n\n//#endregion\n//#region src/api/routes/reset-password.ts\nfunction redirectError(ctx, callbackURL, query) {\n\tconst url = callbackURL ? new URL(callbackURL, ctx.baseURL) : new URL(`${ctx.baseURL}/error`);\n\tif (query) Object.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));\n\treturn url.href;\n}\nfunction redirectCallback(ctx, callbackURL, query) {\n\tconst url = new URL(callbackURL, ctx.baseURL);\n\tif (query) Object.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));\n\treturn url.href;\n}\nconst requestPasswordReset = createAuthEndpoint(\"/request-password-reset\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\temail: z.email().meta({ description: \"The email address of the user to send a password reset email to\" }),\n\t\tredirectTo: z.string().meta({ description: \"The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN\" }).optional()\n\t}),\n\tmetadata: { openapi: {\n\t\toperationId: \"requestPasswordReset\",\n\t\tdescription: \"Send a password reset email to the user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tstatus: { type: \"boolean\" },\n\t\t\t\t\tmessage: { type: \"string\" }\n\t\t\t\t}\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tif (!ctx.context.options.emailAndPassword?.sendResetPassword) {\n\t\tctx.context.logger.error(\"Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Reset password isn't enabled\" });\n\t}\n\tconst { email, redirectTo } = ctx.body;\n\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });\n\tif (!user) {\n\t\t/**\n\t\t* We simulate the verification token generation and the database lookup\n\t\t* to mitigate timing attacks.\n\t\t*/\n\t\tgenerateId(24);\n\t\tawait ctx.context.internalAdapter.findVerificationValue(\"dummy-verification-token\");\n\t\tctx.context.logger.error(\"Reset Password: User not found\", { email });\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tmessage: \"If this email exists in our system, check your email for the reset link\"\n\t\t});\n\t}\n\tconst expiresAt = getDate(ctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn || 3600 * 1, \"sec\");\n\tconst verificationToken = generateId(24);\n\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\tvalue: user.user.id,\n\t\tidentifier: `reset-password:${verificationToken}`,\n\t\texpiresAt\n\t});\n\tconst callbackURL = redirectTo ? encodeURIComponent(redirectTo) : \"\";\n\tconst url = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;\n\tawait ctx.context.options.emailAndPassword.sendResetPassword({\n\t\tuser: user.user,\n\t\turl,\n\t\ttoken: verificationToken\n\t}, ctx.request).catch((e) => {\n\t\tctx.context.logger.error(\"Failed to send reset password email\", e);\n\t});\n\treturn ctx.json({\n\t\tstatus: true,\n\t\tmessage: \"If this email exists in our system, check your email for the reset link\"\n\t});\n});\nconst requestPasswordResetCallback = createAuthEndpoint(\"/reset-password/:token\", {\n\tmethod: \"GET\",\n\toperationId: \"forgetPasswordCallback\",\n\tquery: z.object({ callbackURL: z.string().meta({ description: \"The URL to redirect the user to reset their password\" }) }),\n\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\tmetadata: { openapi: {\n\t\toperationId: \"resetPasswordCallback\",\n\t\tdescription: \"Redirects the user to the callback URL with the token\",\n\t\tparameters: [{\n\t\t\tname: \"token\",\n\t\t\tin: \"path\",\n\t\t\trequired: true,\n\t\t\tdescription: \"The token to reset the password\",\n\t\t\tschema: { type: \"string\" }\n\t\t}, {\n\t\t\tname: \"callbackURL\",\n\t\t\tin: \"query\",\n\t\t\trequired: true,\n\t\t\tdescription: \"The URL to redirect the user to reset their password\",\n\t\t\tschema: { type: \"string\" }\n\t\t}],\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { token: { type: \"string\" } }\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst { token } = ctx.params;\n\tconst { callbackURL } = ctx.query;\n\tif (!token || !callbackURL) throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: \"INVALID_TOKEN\" }));\n\tconst verification = await ctx.context.internalAdapter.findVerificationValue(`reset-password:${token}`);\n\tif (!verification || verification.expiresAt < /* @__PURE__ */ new Date()) throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: \"INVALID_TOKEN\" }));\n\tthrow ctx.redirect(redirectCallback(ctx.context, callbackURL, { token }));\n});\nconst resetPassword = createAuthEndpoint(\"/reset-password\", {\n\tmethod: \"POST\",\n\toperationId: \"resetPassword\",\n\tquery: z.object({ token: z.string().optional() }).optional(),\n\tbody: z.object({\n\t\tnewPassword: z.string().meta({ description: \"The new password to set\" }),\n\t\ttoken: z.string().meta({ description: \"The token to reset the password\" }).optional()\n\t}),\n\tmetadata: { openapi: {\n\t\toperationId: \"resetPassword\",\n\t\tdescription: \"Reset the password for a user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst token = ctx.body.token || ctx.query?.token;\n\tif (!token) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_TOKEN });\n\tconst { newPassword } = ctx.body;\n\tconst minLength = ctx.context.password?.config.minPasswordLength;\n\tconst maxLength = ctx.context.password?.config.maxPasswordLength;\n\tif (newPassword.length < minLength) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });\n\tif (newPassword.length > maxLength) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });\n\tconst id = `reset-password:${token}`;\n\tconst verification = await ctx.context.internalAdapter.findVerificationValue(id);\n\tif (!verification || verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_TOKEN });\n\tconst userId = verification.value;\n\tconst hashedPassword = await ctx.context.password.hash(newPassword);\n\tif (!(await ctx.context.internalAdapter.findAccounts(userId)).find((ac) => ac.providerId === \"credential\")) await ctx.context.internalAdapter.createAccount({\n\t\tuserId,\n\t\tproviderId: \"credential\",\n\t\tpassword: hashedPassword,\n\t\taccountId: userId\n\t});\n\telse await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);\n\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\tif (ctx.context.options.emailAndPassword?.onPasswordReset) {\n\t\tconst user = await ctx.context.internalAdapter.findUserById(userId);\n\t\tif (user) await ctx.context.options.emailAndPassword.onPasswordReset({ user }, ctx.request);\n\t}\n\tif (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) await ctx.context.internalAdapter.deleteSessions(userId);\n\treturn ctx.json({ status: true });\n});\n\n//#endregion\n//#region src/api/routes/sign-in.ts\nconst socialSignInBodySchema = z.object({\n\tcallbackURL: z.string().meta({ description: \"Callback URL to redirect to after the user has signed in\" }).optional(),\n\tnewUserCallbackURL: z.string().optional(),\n\terrorCallbackURL: z.string().meta({ description: \"Callback URL to redirect to if an error happens\" }).optional(),\n\tprovider: SocialProviderListEnum,\n\tdisableRedirect: z.boolean().meta({ description: \"Disable automatic redirection to the provider. Useful for handling the redirection yourself\" }).optional(),\n\tidToken: z.optional(z.object({\n\t\ttoken: z.string().meta({ description: \"ID token from the provider\" }),\n\t\tnonce: z.string().meta({ description: \"Nonce used to generate the token\" }).optional(),\n\t\taccessToken: z.string().meta({ description: \"Access token from the provider\" }).optional(),\n\t\trefreshToken: z.string().meta({ description: \"Refresh token from the provider\" }).optional(),\n\t\texpiresAt: z.number().meta({ description: \"Expiry date of the token\" }).optional()\n\t})),\n\tscopes: z.array(z.string()).meta({ description: \"Array of scopes to request from the provider. This will override the default scopes passed.\" }).optional(),\n\trequestSignUp: z.boolean().meta({ description: \"Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider\" }).optional(),\n\tloginHint: z.string().meta({ description: \"The login hint to use for the authorization code request\" }).optional(),\n\tadditionalData: z.record(z.string(), z.any()).optional().meta({ description: \"Additional data to be passed through the OAuth flow\" })\n});\nconst signInSocial = () => createAuthEndpoint(\"/sign-in/social\", {\n\tmethod: \"POST\",\n\toperationId: \"socialSignIn\",\n\tbody: socialSignInBodySchema,\n\tmetadata: {\n\t\t$Infer: {\n\t\t\tbody: {},\n\t\t\treturned: {}\n\t\t},\n\t\topenapi: {\n\t\t\tdescription: \"Sign in with a social provider\",\n\t\t\toperationId: \"socialSignIn\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success - Returns either session details or redirect URL\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tdescription: \"Session response when idToken is provided\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\ttoken: { type: \"string\" },\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\turl: { type: \"string\" },\n\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tenum: [false]\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"redirect\",\n\t\t\t\t\t\t\"token\",\n\t\t\t\t\t\t\"user\"\n\t\t\t\t\t]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t}\n\t}\n}, async (c) => {\n\tconst provider = c.context.socialProviders.find((p) => p.id === c.body.provider);\n\tif (!provider) {\n\t\tc.context.logger.error(\"Provider not found. Make sure to add the provider in your auth config\", { provider: c.body.provider });\n\t\tthrow new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });\n\t}\n\tif (c.body.idToken) {\n\t\tif (!provider.verifyIdToken) {\n\t\t\tc.context.logger.error(\"Provider does not support id token verification\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED });\n\t\t}\n\t\tconst { token, nonce } = c.body.idToken;\n\t\tif (!await provider.verifyIdToken(token, nonce)) {\n\t\t\tc.context.logger.error(\"Invalid id token\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.INVALID_TOKEN });\n\t\t}\n\t\tconst userInfo = await provider.getUserInfo({\n\t\t\tidToken: token,\n\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\trefreshToken: c.body.idToken.refreshToken\n\t\t});\n\t\tif (!userInfo || !userInfo?.user) {\n\t\t\tc.context.logger.error(\"Failed to get user info\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });\n\t\t}\n\t\tif (!userInfo.user.email) {\n\t\t\tc.context.logger.error(\"User email not found\", { provider: c.body.provider });\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND });\n\t\t}\n\t\tconst data = await handleOAuthUserInfo(c, {\n\t\t\tuserInfo: {\n\t\t\t\t...userInfo.user,\n\t\t\t\temail: userInfo.user.email,\n\t\t\t\tid: String(userInfo.user.id),\n\t\t\t\tname: userInfo.user.name || \"\",\n\t\t\t\timage: userInfo.user.image,\n\t\t\t\temailVerified: userInfo.user.emailVerified || false\n\t\t\t},\n\t\t\taccount: {\n\t\t\t\tproviderId: provider.id,\n\t\t\t\taccountId: String(userInfo.user.id),\n\t\t\t\taccessToken: c.body.idToken.accessToken\n\t\t\t},\n\t\t\tcallbackURL: c.body.callbackURL,\n\t\t\tdisableSignUp: provider.disableImplicitSignUp && !c.body.requestSignUp || provider.disableSignUp\n\t\t});\n\t\tif (data.error) throw new APIError(\"UNAUTHORIZED\", { message: data.error });\n\t\tawait setSessionCookie(c, data.data);\n\t\treturn c.json({\n\t\t\tredirect: false,\n\t\t\ttoken: data.data.session.token,\n\t\t\turl: void 0,\n\t\t\tuser: parseUserOutput(c.context.options, data.data.user)\n\t\t});\n\t}\n\tconst { codeVerifier, state } = await generateState(c, void 0, c.body.additionalData);\n\tconst url = await provider.createAuthorizationURL({\n\t\tstate,\n\t\tcodeVerifier,\n\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\tscopes: c.body.scopes,\n\t\tloginHint: c.body.loginHint\n\t});\n\treturn c.json({\n\t\turl: url.toString(),\n\t\tredirect: !c.body.disableRedirect\n\t});\n});\nconst signInEmail = () => createAuthEndpoint(\"/sign-in/email\", {\n\tmethod: \"POST\",\n\toperationId: \"signInEmail\",\n\tbody: z.object({\n\t\temail: z.string().meta({ description: \"Email of the user\" }),\n\t\tpassword: z.string().meta({ description: \"Password of the user\" }),\n\t\tcallbackURL: z.string().meta({ description: \"Callback URL to use as a redirect for email verification\" }).optional(),\n\t\trememberMe: z.boolean().meta({ description: \"If this is false, the session will not be remembered. Default is `true`.\" }).default(true).optional()\n\t}),\n\tmetadata: {\n\t\t$Infer: {\n\t\t\tbody: {},\n\t\t\treturned: {}\n\t\t},\n\t\topenapi: {\n\t\t\toperationId: \"signInEmail\",\n\t\t\tdescription: \"Sign in with email and password\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success - Returns either session details or redirect URL\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tdescription: \"Session response when idToken is provided\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tenum: [false]\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"Session token\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"redirect\",\n\t\t\t\t\t\t\"token\",\n\t\t\t\t\t\t\"user\"\n\t\t\t\t\t]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t}\n\t}\n}, async (ctx) => {\n\tif (!ctx.context.options?.emailAndPassword?.enabled) {\n\t\tctx.context.logger.error(\"Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Email and password is not enabled\" });\n\t}\n\tconst { email, password } = ctx.body;\n\tif (!z.email().safeParse(email).success) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });\n\tif (!user) {\n\t\tawait ctx.context.password.hash(password);\n\t\tctx.context.logger.error(\"User not found\", { email });\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });\n\t}\n\tconst credentialAccount = user.accounts.find((a) => a.providerId === \"credential\");\n\tif (!credentialAccount) {\n\t\tawait ctx.context.password.hash(password);\n\t\tctx.context.logger.error(\"Credential account not found\", { email });\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });\n\t}\n\tconst currentPassword = credentialAccount?.password;\n\tif (!currentPassword) {\n\t\tawait ctx.context.password.hash(password);\n\t\tctx.context.logger.error(\"Password not found\", { email });\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });\n\t}\n\tif (!await ctx.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword\n\t})) {\n\t\tctx.context.logger.error(\"Invalid password\");\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });\n\t}\n\tif (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.user.emailVerified) {\n\t\tif (!ctx.context.options?.emailVerification?.sendVerificationEmail) throw new APIError(\"FORBIDDEN\", { message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED });\n\t\tif (ctx.context.options?.emailVerification?.sendOnSignIn) {\n\t\t\tconst token = await createEmailVerificationToken(ctx.context.secret, user.user.email, void 0, ctx.context.options.emailVerification?.expiresIn);\n\t\t\tconst callbackURL = ctx.body.callbackURL ? encodeURIComponent(ctx.body.callbackURL) : encodeURIComponent(\"/\");\n\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\tawait ctx.context.options.emailVerification.sendVerificationEmail({\n\t\t\t\tuser: user.user,\n\t\t\t\turl,\n\t\t\t\ttoken\n\t\t\t}, ctx.request);\n\t\t}\n\t\tthrow new APIError(\"FORBIDDEN\", { message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED });\n\t}\n\tconst session = await ctx.context.internalAdapter.createSession(user.user.id, ctx.body.rememberMe === false);\n\tif (!session) {\n\t\tctx.context.logger.error(\"Failed to create session\");\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });\n\t}\n\tawait setSessionCookie(ctx, {\n\t\tsession,\n\t\tuser: user.user\n\t}, ctx.body.rememberMe === false);\n\treturn ctx.json({\n\t\tredirect: !!ctx.body.callbackURL,\n\t\ttoken: session.token,\n\t\turl: ctx.body.callbackURL,\n\t\tuser: parseUserOutput(ctx.context.options, user.user)\n\t});\n});\n\n//#endregion\n//#region src/api/routes/sign-out.ts\nconst signOut = createAuthEndpoint(\"/sign-out\", {\n\tmethod: \"POST\",\n\toperationId: \"signOut\",\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\toperationId: \"signOut\",\n\t\tdescription: \"Sign out the current user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { success: { type: \"boolean\" } }\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);\n\tif (sessionCookieToken) try {\n\t\tawait ctx.context.internalAdapter.deleteSession(sessionCookieToken);\n\t} catch (e) {\n\t\tctx.context.logger.error(\"Failed to delete session from database\", e);\n\t}\n\tdeleteSessionCookie(ctx);\n\treturn ctx.json({ success: true });\n});\n\n//#endregion\n//#region src/api/routes/sign-up.ts\nconst signUpEmail = () => createAuthEndpoint(\"/sign-up/email\", {\n\tmethod: \"POST\",\n\toperationId: \"signUpWithEmailAndPassword\",\n\tbody: z.record(z.string(), z.any()),\n\tmetadata: {\n\t\t$Infer: {\n\t\t\tbody: {},\n\t\t\treturned: {}\n\t\t},\n\t\topenapi: {\n\t\t\toperationId: \"signUpWithEmailAndPassword\",\n\t\t\tdescription: \"Sign up a user using email and password\",\n\t\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tname: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The name of the user\"\n\t\t\t\t\t},\n\t\t\t\t\temail: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The email of the user\"\n\t\t\t\t\t},\n\t\t\t\t\tpassword: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The password of the user\"\n\t\t\t\t\t},\n\t\t\t\t\timage: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The profile image URL of the user\"\n\t\t\t\t\t},\n\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The URL to use for email verification callback\"\n\t\t\t\t\t},\n\t\t\t\t\trememberMe: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"If this is false, the session will not be remembered. Default is `true`.\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\n\t\t\t\t\t\"name\",\n\t\t\t\t\t\"email\",\n\t\t\t\t\t\"password\"\n\t\t\t\t]\n\t\t\t} } } },\n\t\t\tresponses: {\n\t\t\t\t\"200\": {\n\t\t\t\t\tdescription: \"Successfully created user\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"Authentication token for the session\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The unique identifier of the user\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The email address of the user\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email has been verified\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was created\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was last updated\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\t\"emailVerified\",\n\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\"user\"]\n\t\t\t\t\t} } }\n\t\t\t\t},\n\t\t\t\t\"422\": {\n\t\t\t\t\tdescription: \"Unprocessable Entity. User already exists or failed to create user.\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t\t\t} } }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}, async (ctx) => {\n\treturn runWithTransaction(ctx.context.adapter, async () => {\n\t\tif (!ctx.context.options.emailAndPassword?.enabled || ctx.context.options.emailAndPassword?.disableSignUp) throw new APIError(\"BAD_REQUEST\", { message: \"Email and password sign up is not enabled\" });\n\t\tconst body = ctx.body;\n\t\tconst { name, email, password, image, callbackURL, rememberMe, ...rest } = body;\n\t\tif (!z.email().safeParse(email).success) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\tif (password.length < minPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });\n\t\t}\n\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\t\tif (password.length > maxPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });\n\t\t}\n\t\tif ((await ctx.context.internalAdapter.findUserByEmail(email))?.user) {\n\t\t\tctx.context.logger.info(`Sign-up attempt for existing email: ${email}`);\n\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", { message: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });\n\t\t}\n\t\t/**\n\t\t* Hash the password\n\t\t*\n\t\t* This is done prior to creating the user\n\t\t* to ensure that any plugin that\n\t\t* may break the hashing should break\n\t\t* before the user is created.\n\t\t*/\n\t\tconst hash = await ctx.context.password.hash(password);\n\t\tlet createdUser;\n\t\ttry {\n\t\t\tconst data = parseUserInput(ctx.context.options, rest, \"create\");\n\t\t\tcreatedUser = await ctx.context.internalAdapter.createUser({\n\t\t\t\temail: email.toLowerCase(),\n\t\t\t\tname,\n\t\t\t\timage,\n\t\t\t\t...data,\n\t\t\t\temailVerified: false\n\t\t\t});\n\t\t\tif (!createdUser) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });\n\t\t} catch (e) {\n\t\t\tif (isDevelopment()) ctx.context.logger.error(\"Failed to create user\", e);\n\t\t\tif (e instanceof APIError) throw e;\n\t\t\tctx.context.logger?.error(\"Failed to create user\", e);\n\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\tdetails: e\n\t\t\t});\n\t\t}\n\t\tif (!createdUser) throw new APIError(\"UNPROCESSABLE_ENTITY\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });\n\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\tuserId: createdUser.id,\n\t\t\tproviderId: \"credential\",\n\t\t\taccountId: createdUser.id,\n\t\t\tpassword: hash\n\t\t});\n\t\tif (ctx.context.options.emailVerification?.sendOnSignUp || ctx.context.options.emailAndPassword.requireEmailVerification) {\n\t\t\tconst token = await createEmailVerificationToken(ctx.context.secret, createdUser.email, void 0, ctx.context.options.emailVerification?.expiresIn);\n\t\t\tconst callbackURL$1 = body.callbackURL ? encodeURIComponent(body.callbackURL) : encodeURIComponent(\"/\");\n\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL$1}`;\n\t\t\tconst args = ctx.request ? [{\n\t\t\t\tuser: createdUser,\n\t\t\t\turl,\n\t\t\t\ttoken\n\t\t\t}, ctx.request] : [{\n\t\t\t\tuser: createdUser,\n\t\t\t\turl,\n\t\t\t\ttoken\n\t\t\t}];\n\t\t\tawait ctx.context.options.emailVerification?.sendVerificationEmail?.(...args);\n\t\t}\n\t\tif (ctx.context.options.emailAndPassword.autoSignIn === false || ctx.context.options.emailAndPassword.requireEmailVerification) return ctx.json({\n\t\t\ttoken: null,\n\t\t\tuser: parseUserOutput(ctx.context.options, createdUser)\n\t\t});\n\t\tconst session = await ctx.context.internalAdapter.createSession(createdUser.id, rememberMe === false);\n\t\tif (!session) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });\n\t\tawait setSessionCookie(ctx, {\n\t\t\tsession,\n\t\t\tuser: createdUser\n\t\t}, rememberMe === false);\n\t\treturn ctx.json({\n\t\t\ttoken: session.token,\n\t\t\tuser: parseUserOutput(ctx.context.options, createdUser)\n\t\t});\n\t});\n});\n\n//#endregion\n//#region src/api/routes/update-user.ts\nconst updateUser = () => createAuthEndpoint(\"/update-user\", {\n\tmethod: \"POST\",\n\toperationId: \"updateUser\",\n\tbody: z.record(z.string().meta({ description: \"Field name must be a string\" }), z.any()),\n\tuse: [sessionMiddleware],\n\tmetadata: {\n\t\t$Infer: { body: {} },\n\t\topenapi: {\n\t\t\toperationId: \"updateUser\",\n\t\t\tdescription: \"Update the current user\",\n\t\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tname: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The name of the user\"\n\t\t\t\t\t},\n\t\t\t\t\timage: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The image of the user\",\n\t\t\t\t\t\tnullable: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} } } },\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { user: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t$ref: \"#/components/schemas/User\"\n\t\t\t\t\t} }\n\t\t\t\t} } }\n\t\t\t} }\n\t\t}\n\t}\n}, async (ctx) => {\n\tconst body = ctx.body;\n\tif (body.email) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.EMAIL_CAN_NOT_BE_UPDATED });\n\tconst { name, image, ...rest } = body;\n\tconst session = ctx.context.session;\n\tconst additionalFields = parseUserInput(ctx.context.options, rest, \"update\");\n\tif (image === void 0 && name === void 0 && Object.keys(additionalFields).length === 0) throw new APIError(\"BAD_REQUEST\", { message: \"No fields to update\" });\n\tconst user = await ctx.context.internalAdapter.updateUser(session.user.id, {\n\t\tname,\n\t\timage,\n\t\t...additionalFields\n\t});\n\t/**\n\t* Update the session cookie with the new user data\n\t*/\n\tawait setSessionCookie(ctx, {\n\t\tsession: session.session,\n\t\tuser\n\t});\n\treturn ctx.json({ status: true });\n});\nconst changePassword = createAuthEndpoint(\"/change-password\", {\n\tmethod: \"POST\",\n\toperationId: \"changePassword\",\n\tbody: z.object({\n\t\tnewPassword: z.string().meta({ description: \"The new password to set\" }),\n\t\tcurrentPassword: z.string().meta({ description: \"The current password is required\" }),\n\t\trevokeOtherSessions: z.boolean().meta({ description: \"Must be a boolean value\" }).optional()\n\t}),\n\tuse: [sensitiveSessionMiddleware],\n\tmetadata: { openapi: {\n\t\toperationId: \"changePassword\",\n\t\tdescription: \"Change the password of the user\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Password successfully changed\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\ttoken: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\tdescription: \"New session token if other sessions were revoked\"\n\t\t\t\t\t},\n\t\t\t\t\tuser: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"The unique identifier of the user\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\tdescription: \"The email address of the user\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"The name of the user\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\tdescription: \"Whether the email has been verified\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"When the user was created\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"When the user was last updated\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\"emailVerified\",\n\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\"user\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst { newPassword, currentPassword, revokeOtherSessions: revokeOtherSessions$1 } = ctx.body;\n\tconst session = ctx.context.session;\n\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\tif (newPassword.length < minPasswordLength) {\n\t\tctx.context.logger.error(\"Password is too short\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });\n\t}\n\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\tif (newPassword.length > maxPasswordLength) {\n\t\tctx.context.logger.error(\"Password is too long\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });\n\t}\n\tconst account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === \"credential\" && account$1.password);\n\tif (!account || !account.password) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND });\n\tconst passwordHash = await ctx.context.password.hash(newPassword);\n\tif (!await ctx.context.password.verify({\n\t\thash: account.password,\n\t\tpassword: currentPassword\n\t})) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_PASSWORD });\n\tawait ctx.context.internalAdapter.updateAccount(account.id, { password: passwordHash });\n\tlet token = null;\n\tif (revokeOtherSessions$1) {\n\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\tconst newSession = await ctx.context.internalAdapter.createSession(session.user.id);\n\t\tif (!newSession) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });\n\t\tawait setSessionCookie(ctx, {\n\t\t\tsession: newSession,\n\t\t\tuser: session.user\n\t\t});\n\t\ttoken = newSession.token;\n\t}\n\treturn ctx.json({\n\t\ttoken,\n\t\tuser: {\n\t\t\tid: session.user.id,\n\t\t\temail: session.user.email,\n\t\t\tname: session.user.name,\n\t\t\timage: session.user.image,\n\t\t\temailVerified: session.user.emailVerified,\n\t\t\tcreatedAt: session.user.createdAt,\n\t\t\tupdatedAt: session.user.updatedAt\n\t\t}\n\t});\n});\nconst setPassword = createAuthEndpoint(\"/set-password\", {\n\tmethod: \"POST\",\n\tbody: z.object({ newPassword: z.string().meta({ description: \"The new password to set is required\" }) }),\n\tmetadata: { SERVER_ONLY: true },\n\tuse: [sensitiveSessionMiddleware]\n}, async (ctx) => {\n\tconst { newPassword } = ctx.body;\n\tconst session = ctx.context.session;\n\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\tif (newPassword.length < minPasswordLength) {\n\t\tctx.context.logger.error(\"Password is too short\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });\n\t}\n\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\tif (newPassword.length > maxPasswordLength) {\n\t\tctx.context.logger.error(\"Password is too long\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });\n\t}\n\tconst account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === \"credential\" && account$1.password);\n\tconst passwordHash = await ctx.context.password.hash(newPassword);\n\tif (!account) {\n\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\tuserId: session.user.id,\n\t\t\tproviderId: \"credential\",\n\t\t\taccountId: session.user.id,\n\t\t\tpassword: passwordHash\n\t\t});\n\t\treturn ctx.json({ status: true });\n\t}\n\tthrow new APIError(\"BAD_REQUEST\", { message: \"user already has a password\" });\n});\nconst deleteUser = createAuthEndpoint(\"/delete-user\", {\n\tmethod: \"POST\",\n\tuse: [sensitiveSessionMiddleware],\n\tbody: z.object({\n\t\tcallbackURL: z.string().meta({ description: \"The callback URL to redirect to after the user is deleted\" }).optional(),\n\t\tpassword: z.string().meta({ description: \"The password of the user is required to delete the user\" }).optional(),\n\t\ttoken: z.string().meta({ description: \"The token to delete the user is required\" }).optional()\n\t}),\n\tmetadata: { openapi: {\n\t\toperationId: \"deleteUser\",\n\t\tdescription: \"Delete the user\",\n\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\ttype: \"object\",\n\t\t\tproperties: {\n\t\t\t\tcallbackURL: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The callback URL to redirect to after the user is deleted\"\n\t\t\t\t},\n\t\t\t\tpassword: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The user's password. Required if session is not fresh\"\n\t\t\t\t},\n\t\t\t\ttoken: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The deletion verification token\"\n\t\t\t\t}\n\t\t\t}\n\t\t} } } },\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"User deletion processed successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tsuccess: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the operation was successful\"\n\t\t\t\t\t},\n\t\t\t\t\tmessage: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tenum: [\"User deleted\", \"Verification email sent\"],\n\t\t\t\t\t\tdescription: \"Status message of the deletion process\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\"success\", \"message\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tif (!ctx.context.options.user?.deleteUser?.enabled) {\n\t\tctx.context.logger.error(\"Delete user is disabled. Enable it in the options\");\n\t\tthrow new APIError(\"NOT_FOUND\");\n\t}\n\tconst session = ctx.context.session;\n\tif (ctx.body.password) {\n\t\tconst account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === \"credential\" && account$1.password);\n\t\tif (!account || !account.password) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND });\n\t\tif (!await ctx.context.password.verify({\n\t\t\thash: account.password,\n\t\t\tpassword: ctx.body.password\n\t\t})) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_PASSWORD });\n\t}\n\tif (ctx.body.token) {\n\t\tawait deleteUserCallback({\n\t\t\t...ctx,\n\t\t\tquery: { token: ctx.body.token }\n\t\t});\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: \"User deleted\"\n\t\t});\n\t}\n\tif (ctx.context.options.user.deleteUser?.sendDeleteAccountVerification) {\n\t\tconst token = generateRandomString(32, \"0-9\", \"a-z\");\n\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\tvalue: session.user.id,\n\t\t\tidentifier: `delete-account-${token}`,\n\t\t\texpiresAt: new Date(Date.now() + (ctx.context.options.user.deleteUser?.deleteTokenExpiresIn || 3600 * 24) * 1e3)\n\t\t});\n\t\tconst url = `${ctx.context.baseURL}/delete-user/callback?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\tawait ctx.context.options.user.deleteUser.sendDeleteAccountVerification({\n\t\t\tuser: session.user,\n\t\t\turl,\n\t\t\ttoken\n\t\t}, ctx.request);\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Verification email sent\"\n\t\t});\n\t}\n\tif (!ctx.body.password && ctx.context.sessionConfig.freshAge !== 0) {\n\t\tconst currentAge = new Date(session.session.createdAt).getTime();\n\t\tconst freshAge = ctx.context.sessionConfig.freshAge * 1e3;\n\t\tif (Date.now() - currentAge > freshAge * 1e3) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.SESSION_EXPIRED });\n\t}\n\tconst beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;\n\tif (beforeDelete) await beforeDelete(session.user, ctx.request);\n\tawait ctx.context.internalAdapter.deleteUser(session.user.id);\n\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\tdeleteSessionCookie(ctx);\n\tconst afterDelete = ctx.context.options.user.deleteUser?.afterDelete;\n\tif (afterDelete) await afterDelete(session.user, ctx.request);\n\treturn ctx.json({\n\t\tsuccess: true,\n\t\tmessage: \"User deleted\"\n\t});\n});\nconst deleteUserCallback = createAuthEndpoint(\"/delete-user/callback\", {\n\tmethod: \"GET\",\n\tquery: z.object({\n\t\ttoken: z.string().meta({ description: \"The token to verify the deletion request\" }),\n\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after deletion\" }).optional()\n\t}),\n\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\tmetadata: { openapi: {\n\t\tdescription: \"Callback to complete user deletion with verification token\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"User successfully deleted\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tsuccess: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the deletion was successful\"\n\t\t\t\t\t},\n\t\t\t\t\tmessage: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tenum: [\"User deleted\"],\n\t\t\t\t\t\tdescription: \"Confirmation message\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\"success\", \"message\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tif (!ctx.context.options.user?.deleteUser?.enabled) {\n\t\tctx.context.logger.error(\"Delete user is disabled. Enable it in the options\");\n\t\tthrow new APIError(\"NOT_FOUND\");\n\t}\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) throw new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });\n\tconst token = await ctx.context.internalAdapter.findVerificationValue(`delete-account-${ctx.query.token}`);\n\tif (!token || token.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.INVALID_TOKEN });\n\tif (token.value !== session.user.id) throw new APIError(\"NOT_FOUND\", { message: BASE_ERROR_CODES.INVALID_TOKEN });\n\tconst beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;\n\tif (beforeDelete) await beforeDelete(session.user, ctx.request);\n\tawait ctx.context.internalAdapter.deleteUser(session.user.id);\n\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\tawait ctx.context.internalAdapter.deleteAccounts(session.user.id);\n\tawait ctx.context.internalAdapter.deleteVerificationValue(token.id);\n\tdeleteSessionCookie(ctx);\n\tconst afterDelete = ctx.context.options.user.deleteUser?.afterDelete;\n\tif (afterDelete) await afterDelete(session.user, ctx.request);\n\tif (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL || \"/\");\n\treturn ctx.json({\n\t\tsuccess: true,\n\t\tmessage: \"User deleted\"\n\t});\n});\nconst changeEmail = createAuthEndpoint(\"/change-email\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tnewEmail: z.email().meta({ description: \"The new email address to set must be a valid email address\" }),\n\t\tcallbackURL: z.string().meta({ description: \"The URL to redirect to after email verification\" }).optional()\n\t}),\n\tuse: [sensitiveSessionMiddleware],\n\tmetadata: { openapi: {\n\t\toperationId: \"changeEmail\",\n\t\tresponses: {\n\t\t\t\"200\": {\n\t\t\t\tdescription: \"Email change request processed successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Indicates if the request was successful\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tenum: [\"Email updated\", \"Verification email sent\"],\n\t\t\t\t\t\t\tdescription: \"Status message of the email change process\",\n\t\t\t\t\t\t\tnullable: true\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\"status\"]\n\t\t\t\t} } }\n\t\t\t},\n\t\t\t\"422\": {\n\t\t\t\tdescription: \"Unprocessable Entity. Email already exists\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t\t} } }\n\t\t\t}\n\t\t}\n\t} }\n}, async (ctx) => {\n\tif (!ctx.context.options.user?.changeEmail?.enabled) {\n\t\tctx.context.logger.error(\"Change email is disabled.\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Change email is disabled\" });\n\t}\n\tconst newEmail = ctx.body.newEmail.toLowerCase();\n\tif (newEmail === ctx.context.session.user.email) {\n\t\tctx.context.logger.error(\"Email is the same\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Email is the same\" });\n\t}\n\tif (await ctx.context.internalAdapter.findUserByEmail(newEmail)) {\n\t\tctx.context.logger.error(\"Email already exists\");\n\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", { message: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });\n\t}\n\t/**\n\t* If the email is not verified, we can update the email if the option is enabled\n\t*/\n\tif (ctx.context.session.user.emailVerified !== true && ctx.context.options.user.changeEmail.updateEmailWithoutVerification) {\n\t\tawait ctx.context.internalAdapter.updateUserByEmail(ctx.context.session.user.email, { email: newEmail });\n\t\tawait setSessionCookie(ctx, {\n\t\t\tsession: ctx.context.session.session,\n\t\t\tuser: {\n\t\t\t\t...ctx.context.session.user,\n\t\t\t\temail: newEmail\n\t\t\t}\n\t\t});\n\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\tconst token$1 = await createEmailVerificationToken(ctx.context.secret, newEmail, void 0, ctx.context.options.emailVerification?.expiresIn);\n\t\t\tconst url$1 = `${ctx.context.baseURL}/verify-email?token=${token$1}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\t\tawait ctx.context.options.emailVerification.sendVerificationEmail({\n\t\t\t\tuser: {\n\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\temail: newEmail\n\t\t\t\t},\n\t\t\t\turl: url$1,\n\t\t\t\ttoken: token$1\n\t\t\t}, ctx.request);\n\t\t}\n\t\treturn ctx.json({ status: true });\n\t}\n\tif (ctx.context.session.user.emailVerified && (ctx.context.options.user.changeEmail.sendChangeEmailConfirmation || ctx.context.options.user.changeEmail.sendChangeEmailVerification)) {\n\t\tconst token$1 = await createEmailVerificationToken(ctx.context.secret, ctx.context.session.user.email, newEmail, ctx.context.options.emailVerification?.expiresIn, { requestType: \"change-email-confirmation\" });\n\t\tconst url$1 = `${ctx.context.baseURL}/verify-email?token=${token$1}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\tconst sendFn = ctx.context.options.user.changeEmail.sendChangeEmailConfirmation || ctx.context.options.user.changeEmail.sendChangeEmailVerification;\n\t\tif (sendFn) await sendFn({\n\t\t\tuser: ctx.context.session.user,\n\t\t\tnewEmail,\n\t\t\turl: url$1,\n\t\t\ttoken: token$1\n\t\t}, ctx.request);\n\t\treturn ctx.json({ status: true });\n\t}\n\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Verification email isn't enabled\" });\n\t}\n\tconst token = await createEmailVerificationToken(ctx.context.secret, ctx.context.session.user.email, newEmail, ctx.context.options.emailVerification?.expiresIn, { requestType: \"change-email-verification\" });\n\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\tawait ctx.context.options.emailVerification.sendVerificationEmail({\n\t\tuser: {\n\t\t\t...ctx.context.session.user,\n\t\t\temail: newEmail\n\t\t},\n\t\turl,\n\t\ttoken\n\t}, ctx.request);\n\treturn ctx.json({ status: true });\n});\n\n//#endregion\n//#region src/api/to-auth-endpoints.ts\nconst defuReplaceArrays = createDefu((obj, key, value) => {\n\tif (Array.isArray(obj[key]) && Array.isArray(value)) {\n\t\tobj[key] = value;\n\t\treturn true;\n\t}\n});\nfunction toAuthEndpoints(endpoints, ctx) {\n\tconst api = {};\n\tfor (const [key, endpoint] of Object.entries(endpoints)) {\n\t\tapi[key] = async (context) => {\n\t\t\tconst run = async () => {\n\t\t\t\tconst authContext = await ctx;\n\t\t\t\tlet internalContext = {\n\t\t\t\t\t...context,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\t...authContext,\n\t\t\t\t\t\treturned: void 0,\n\t\t\t\t\t\tresponseHeaders: void 0,\n\t\t\t\t\t\tsession: null\n\t\t\t\t\t},\n\t\t\t\t\tpath: endpoint.path,\n\t\t\t\t\theaders: context?.headers ? new Headers(context?.headers) : void 0\n\t\t\t\t};\n\t\t\t\treturn runWithEndpointContext(internalContext, async () => {\n\t\t\t\t\tconst { beforeHooks, afterHooks } = getHooks(authContext);\n\t\t\t\t\tconst before = await runBeforeHooks(internalContext, beforeHooks);\n\t\t\t\t\t/**\n\t\t\t\t\t* If `before.context` is returned, it should\n\t\t\t\t\t* get merged with the original context\n\t\t\t\t\t*/\n\t\t\t\t\tif (\"context\" in before && before.context && typeof before.context === \"object\") {\n\t\t\t\t\t\tconst { headers, ...rest } = before.context;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t* Headers should be merged differently\n\t\t\t\t\t\t* so the hook doesn't override the whole\n\t\t\t\t\t\t* header\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (headers) headers.forEach((value, key$1) => {\n\t\t\t\t\t\t\tinternalContext.headers.set(key$1, value);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinternalContext = defuReplaceArrays(rest, internalContext);\n\t\t\t\t\t} else if (before) return context?.asResponse ? toResponse(before, { headers: context?.headers }) : context?.returnHeaders ? {\n\t\t\t\t\t\theaders: context?.headers,\n\t\t\t\t\t\tresponse: before\n\t\t\t\t\t} : before;\n\t\t\t\t\tinternalContext.asResponse = false;\n\t\t\t\t\tinternalContext.returnHeaders = true;\n\t\t\t\t\tinternalContext.returnStatus = true;\n\t\t\t\t\tconst result = await runWithEndpointContext(internalContext, () => endpoint(internalContext)).catch((e) => {\n\t\t\t\t\t\tif (e instanceof APIError)\n /**\n\t\t\t\t\t\t* API Errors from response are caught\n\t\t\t\t\t\t* and returned to hooks\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tresponse: e,\n\t\t\t\t\t\t\tstatus: e.statusCode,\n\t\t\t\t\t\t\theaders: e.headers ? new Headers(e.headers) : null\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t\tif (result && result instanceof Response) return result;\n\t\t\t\t\tinternalContext.context.returned = result.response;\n\t\t\t\t\tinternalContext.context.responseHeaders = result.headers;\n\t\t\t\t\tconst after = await runAfterHooks(internalContext, afterHooks);\n\t\t\t\t\tif (after.response) result.response = after.response;\n\t\t\t\t\tif (result.response instanceof APIError && shouldPublishLog(authContext.logger.level, \"debug\")) result.response.stack = result.response.errorStack;\n\t\t\t\t\tif (result.response instanceof APIError && !context?.asResponse) throw result.response;\n\t\t\t\t\treturn context?.asResponse ? toResponse(result.response, {\n\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\tstatus: result.status\n\t\t\t\t\t}) : context?.returnHeaders ? context?.returnStatus ? {\n\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\tresponse: result.response,\n\t\t\t\t\t\tstatus: result.status\n\t\t\t\t\t} : {\n\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\tresponse: result.response\n\t\t\t\t\t} : context?.returnStatus ? {\n\t\t\t\t\t\tresponse: result.response,\n\t\t\t\t\t\tstatus: result.status\n\t\t\t\t\t} : result.response;\n\t\t\t\t});\n\t\t\t};\n\t\t\tif (await hasRequestState()) return run();\n\t\t\telse return runWithRequestState(/* @__PURE__ */ new WeakMap(), run);\n\t\t};\n\t\tapi[key].path = endpoint.path;\n\t\tapi[key].options = endpoint.options;\n\t}\n\treturn api;\n}\nasync function runBeforeHooks(context, hooks) {\n\tlet modifiedContext = {};\n\tfor (const hook of hooks) if (hook.matcher(context)) {\n\t\tconst result = await hook.handler({\n\t\t\t...context,\n\t\t\treturnHeaders: false\n\t\t}).catch((e) => {\n\t\t\tif (e instanceof APIError && shouldPublishLog(context.context.logger.level, \"debug\")) e.stack = e.errorStack;\n\t\t\tthrow e;\n\t\t});\n\t\tif (result && typeof result === \"object\") {\n\t\t\tif (\"context\" in result && typeof result.context === \"object\") {\n\t\t\t\tconst { headers, ...rest } = result.context;\n\t\t\t\tif (headers instanceof Headers) if (modifiedContext.headers) headers.forEach((value, key) => {\n\t\t\t\t\tmodifiedContext.headers?.set(key, value);\n\t\t\t\t});\n\t\t\t\telse modifiedContext.headers = headers;\n\t\t\t\tmodifiedContext = defuReplaceArrays(rest, modifiedContext);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn { context: modifiedContext };\n}\nasync function runAfterHooks(context, hooks) {\n\tfor (const hook of hooks) if (hook.matcher(context)) {\n\t\tconst result = await hook.handler(context).catch((e) => {\n\t\t\tif (e instanceof APIError) {\n\t\t\t\tif (shouldPublishLog(context.context.logger.level, \"debug\")) e.stack = e.errorStack;\n\t\t\t\treturn {\n\t\t\t\t\tresponse: e,\n\t\t\t\t\theaders: e.headers ? new Headers(e.headers) : null\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow e;\n\t\t});\n\t\tif (result.headers) result.headers.forEach((value, key) => {\n\t\t\tif (!context.context.responseHeaders) context.context.responseHeaders = new Headers({ [key]: value });\n\t\t\telse if (key.toLowerCase() === \"set-cookie\") context.context.responseHeaders.append(key, value);\n\t\t\telse context.context.responseHeaders.set(key, value);\n\t\t});\n\t\tif (result.response) context.context.returned = result.response;\n\t}\n\treturn {\n\t\tresponse: context.context.returned,\n\t\theaders: context.context.responseHeaders\n\t};\n}\nfunction getHooks(authContext) {\n\tconst plugins = authContext.options.plugins || [];\n\tconst beforeHooks = [];\n\tconst afterHooks = [];\n\tif (authContext.options.hooks?.before) beforeHooks.push({\n\t\tmatcher: () => true,\n\t\thandler: authContext.options.hooks.before\n\t});\n\tif (authContext.options.hooks?.after) afterHooks.push({\n\t\tmatcher: () => true,\n\t\thandler: authContext.options.hooks.after\n\t});\n\tconst pluginBeforeHooks = plugins.map((plugin) => {\n\t\tif (plugin.hooks?.before) return plugin.hooks.before;\n\t}).filter((plugin) => plugin !== void 0).flat();\n\tconst pluginAfterHooks = plugins.map((plugin) => {\n\t\tif (plugin.hooks?.after) return plugin.hooks.after;\n\t}).filter((plugin) => plugin !== void 0).flat();\n\t/**\n\t* Add plugin added hooks at last\n\t*/\n\tif (pluginBeforeHooks.length) beforeHooks.push(...pluginBeforeHooks);\n\tif (pluginAfterHooks.length) afterHooks.push(...pluginAfterHooks);\n\treturn {\n\t\tbeforeHooks,\n\t\tafterHooks\n\t};\n}\n\n//#endregion\n//#region src/api/index.ts\nfunction checkEndpointConflicts(options, logger$1) {\n\tconst endpointRegistry = /* @__PURE__ */ new Map();\n\toptions.plugins?.forEach((plugin) => {\n\t\tif (plugin.endpoints) {\n\t\t\tfor (const [key, endpoint] of Object.entries(plugin.endpoints)) if (endpoint && \"path\" in endpoint) {\n\t\t\t\tconst path = endpoint.path;\n\t\t\t\tlet methods = [];\n\t\t\t\tif (endpoint.options && \"method\" in endpoint.options) {\n\t\t\t\t\tif (Array.isArray(endpoint.options.method)) methods = endpoint.options.method;\n\t\t\t\t\telse if (typeof endpoint.options.method === \"string\") methods = [endpoint.options.method];\n\t\t\t\t}\n\t\t\t\tif (methods.length === 0) methods = [\"*\"];\n\t\t\t\tif (!endpointRegistry.has(path)) endpointRegistry.set(path, []);\n\t\t\t\tendpointRegistry.get(path).push({\n\t\t\t\t\tpluginId: plugin.id,\n\t\t\t\t\tendpointKey: key,\n\t\t\t\t\tmethods\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\tconst conflicts = [];\n\tfor (const [path, entries] of endpointRegistry.entries()) if (entries.length > 1) {\n\t\tconst methodMap = /* @__PURE__ */ new Map();\n\t\tlet hasConflict = false;\n\t\tfor (const entry of entries) for (const method of entry.methods) {\n\t\t\tif (!methodMap.has(method)) methodMap.set(method, []);\n\t\t\tmethodMap.get(method).push(entry.pluginId);\n\t\t\tif (methodMap.get(method).length > 1) hasConflict = true;\n\t\t\tif (method === \"*\" && entries.length > 1) hasConflict = true;\n\t\t\telse if (method !== \"*\" && methodMap.has(\"*\")) hasConflict = true;\n\t\t}\n\t\tif (hasConflict) {\n\t\t\tconst uniquePlugins = [...new Set(entries.map((e) => e.pluginId))];\n\t\t\tconst conflictingMethods = [];\n\t\t\tfor (const [method, plugins] of methodMap.entries()) if (plugins.length > 1 || method === \"*\" && entries.length > 1 || method !== \"*\" && methodMap.has(\"*\")) conflictingMethods.push(method);\n\t\t\tconflicts.push({\n\t\t\t\tpath,\n\t\t\t\tplugins: uniquePlugins,\n\t\t\t\tconflictingMethods\n\t\t\t});\n\t\t}\n\t}\n\tif (conflicts.length > 0) {\n\t\tconst conflictMessages = conflicts.map((conflict) => `  - \"${conflict.path}\" [${conflict.conflictingMethods.join(\", \")}] used by plugins: ${conflict.plugins.join(\", \")}`).join(\"\\n\");\n\t\tlogger$1.error(`Endpoint path conflicts detected! Multiple plugins are trying to use the same endpoint paths with conflicting HTTP methods:\n${conflictMessages}\n\nTo resolve this, you can:\n\t1. Use only one of the conflicting plugins\n\t2. Configure the plugins to use different paths (if supported)\n\t3. Ensure plugins use different HTTP methods for the same path\n`);\n\t}\n}\nfunction getEndpoints(ctx, options) {\n\tconst pluginEndpoints = options.plugins?.reduce((acc, plugin) => {\n\t\treturn {\n\t\t\t...acc,\n\t\t\t...plugin.endpoints\n\t\t};\n\t}, {}) ?? {};\n\tconst middlewares = options.plugins?.map((plugin) => plugin.middlewares?.map((m) => {\n\t\tconst middleware = (async (context) => {\n\t\t\tconst authContext = await ctx;\n\t\t\treturn m.middleware({\n\t\t\t\t...context,\n\t\t\t\tcontext: {\n\t\t\t\t\t...authContext,\n\t\t\t\t\t...context.context\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tmiddleware.options = m.middleware.options;\n\t\treturn {\n\t\t\tpath: m.path,\n\t\t\tmiddleware\n\t\t};\n\t})).filter((plugin) => plugin !== void 0).flat() || [];\n\treturn {\n\t\tapi: toAuthEndpoints({\n\t\t\tsignInSocial: signInSocial(),\n\t\t\tcallbackOAuth,\n\t\t\tgetSession: getSession(),\n\t\t\tsignOut,\n\t\t\tsignUpEmail: signUpEmail(),\n\t\t\tsignInEmail: signInEmail(),\n\t\t\tresetPassword,\n\t\t\tverifyEmail,\n\t\t\tsendVerificationEmail,\n\t\t\tchangeEmail,\n\t\t\tchangePassword,\n\t\t\tsetPassword,\n\t\t\tupdateUser: updateUser(),\n\t\t\tdeleteUser,\n\t\t\trequestPasswordReset,\n\t\t\trequestPasswordResetCallback,\n\t\t\tlistSessions: listSessions(),\n\t\t\trevokeSession,\n\t\t\trevokeSessions,\n\t\t\trevokeOtherSessions,\n\t\t\tlinkSocialAccount,\n\t\t\tlistUserAccounts,\n\t\t\tdeleteUserCallback,\n\t\t\tunlinkAccount,\n\t\t\trefreshToken,\n\t\t\tgetAccessToken,\n\t\t\taccountInfo,\n\t\t\t...pluginEndpoints,\n\t\t\tok,\n\t\t\terror\n\t\t}, ctx),\n\t\tmiddlewares\n\t};\n}\nconst router = (ctx, options) => {\n\tconst { api, middlewares } = getEndpoints(ctx, options);\n\tconst basePath = new URL(ctx.baseURL).pathname;\n\treturn createRouter(api, {\n\t\trouterContext: ctx,\n\t\topenapi: { disabled: true },\n\t\tbasePath,\n\t\trouterMiddleware: [{\n\t\t\tpath: \"/**\",\n\t\t\tmiddleware: originCheckMiddleware\n\t\t}, ...middlewares],\n\t\tallowedMediaTypes: [\"application/json\"],\n\t\tasync onRequest(req) {\n\t\t\tconst disabledPaths = ctx.options.disabledPaths || [];\n\t\t\tconst path = new URL(req.url).pathname.replace(basePath, \"\");\n\t\t\tif (disabledPaths.includes(path)) return new Response(\"Not Found\", { status: 404 });\n\t\t\tfor (const plugin of ctx.options.plugins || []) if (plugin.onRequest) {\n\t\t\t\tconst response = await plugin.onRequest(req, ctx);\n\t\t\t\tif (response && \"response\" in response) return response.response;\n\t\t\t\tif (response && \"request\" in response) {\n\t\t\t\t\tconst rateLimitResponse$1 = await onRequestRateLimit(response.request, ctx);\n\t\t\t\t\tif (rateLimitResponse$1) return rateLimitResponse$1;\n\t\t\t\t\treturn response.request;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn onRequestRateLimit(req, ctx);\n\t\t},\n\t\tasync onResponse(res) {\n\t\t\tfor (const plugin of ctx.options.plugins || []) if (plugin.onResponse) {\n\t\t\t\tconst response = await plugin.onResponse(res, ctx);\n\t\t\t\tif (response) return response.response;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\tonError(e) {\n\t\t\tif (e instanceof APIError && e.status === \"FOUND\") return;\n\t\t\tif (options.onAPIError?.throw) throw e;\n\t\t\tif (options.onAPIError?.onError) {\n\t\t\t\toptions.onAPIError.onError(e, ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst optLogLevel = options.logger?.level;\n\t\t\tconst log = optLogLevel === \"error\" || optLogLevel === \"warn\" || optLogLevel === \"debug\" ? logger : void 0;\n\t\t\tif (options.logger?.disabled !== true) {\n\t\t\t\tif (e && typeof e === \"object\" && \"message\" in e && typeof e.message === \"string\") {\n\t\t\t\t\tif (e.message.includes(\"no column\") || e.message.includes(\"column\") || e.message.includes(\"relation\") || e.message.includes(\"table\") || e.message.includes(\"does not exist\")) {\n\t\t\t\t\t\tctx.logger?.error(e.message);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\tif (e.status === \"INTERNAL_SERVER_ERROR\") ctx.logger.error(e.status, e);\n\t\t\t\t\tlog?.error(e.message);\n\t\t\t\t} else ctx.logger?.error(e && typeof e === \"object\" && \"name\" in e ? e.name : \"\", e);\n\t\t\t}\n\t\t}\n\t});\n};\n\n//#endregion\nexport { getAccessToken as A, createEmailVerificationToken as C, callbackOAuth as D, verifyEmail as E, decryptOAuthToken as F, setTokenUtil as I, originCheck as L, listUserAccounts as M, refreshToken as N, handleOAuthUserInfo as O, unlinkAccount as P, originCheckMiddleware as R, error as S, sendVerificationEmailFn as T, signInSocial as _, getEndpoints as a, resetPassword as b, changeEmail as c, deleteUserCallback as d, setPassword as f, signInEmail as g, signOut as h, createAuthMiddleware$1 as i, linkSocialAccount as j, accountInfo as k, changePassword as l, signUpEmail as m, checkEndpointConflicts as n, optionsMiddleware as o, updateUser as p, createAuthEndpoint$1 as r, router as s, APIError$1 as t, deleteUser as u, requestPasswordReset as v, sendVerificationEmail as w, ok as x, requestPasswordResetCallback as y };","import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from \"./crypto-CFUhAR9W.mjs\";\nimport { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as APIError$1 } from \"./api-CkmycQ2x.mjs\";\nimport { l as parseSetCookieHeader } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx, u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { n as verifyJWT, r as getJwtToken } from \"./jwt-Ar1sciI2.mjs\";\nimport { getCurrentAuthContext } from \"@better-auth/core/context\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { SignJWT, jwtVerify } from \"jose\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\nimport { base64, base64Url } from \"@better-auth/utils/base64\";\n\n//#region src/plugins/oidc-provider/error.ts\nvar OIDCProviderError = class extends APIError {};\nvar InvalidRequest = class extends OIDCProviderError {\n\tconstructor(error_description, error_detail) {\n\t\tsuper(\"BAD_REQUEST\", {\n\t\t\tmessage: \"invalid_request\",\n\t\t\terror_description,\n\t\t\terror_detail\n\t\t});\n\t}\n};\n\n//#endregion\n//#region src/plugins/oidc-provider/utils/prompt.ts\n/**\n* Parse space-separated prompt string into a set of prompts\n*\n* @param prompt\n*/\nfunction parsePrompt(prompt) {\n\tconst prompts = prompt.split(\" \").map((p) => p.trim());\n\tconst set = /* @__PURE__ */ new Set();\n\tfor (const p of prompts) if (p === \"login\" || p === \"consent\" || p === \"select_account\" || p === \"none\") set.add(p);\n\tif (set.has(\"none\") && set.size > 1) throw new InvalidRequest(\"prompt none must only be used alone\");\n\treturn new Set(set);\n}\n\n//#endregion\n//#region src/plugins/oidc-provider/authorize.ts\nfunction formatErrorURL(url, error, description) {\n\treturn `${url.includes(\"?\") ? \"&\" : \"?\"}error=${error}&error_description=${description}`;\n}\nfunction getErrorURL(ctx, error, description) {\n\treturn formatErrorURL(ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`, error, description);\n}\nasync function authorize(ctx, options) {\n\tconst handleRedirect = (url) => {\n\t\tif (ctx.request?.headers.get(\"sec-fetch-mode\") === \"cors\") return ctx.json({\n\t\t\tredirect: true,\n\t\t\turl\n\t\t});\n\t\telse throw ctx.redirect(url);\n\t};\n\tconst opts = {\n\t\tcodeExpiresIn: 600,\n\t\tdefaultScope: \"openid\",\n\t\t...options,\n\t\tscopes: [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\",\n\t\t\t...options?.scopes || []\n\t\t]\n\t};\n\tif (!ctx.request) throw new APIError(\"UNAUTHORIZED\", {\n\t\terror_description: \"request not found\",\n\t\terror: \"invalid_request\"\n\t});\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) {\n\t\tconst query$1 = ctx.query;\n\t\tif (parsePrompt(query$1.prompt ?? \"\").has(\"none\") && query$1.redirect_uri) return handleRedirect(formatErrorURL(query$1.redirect_uri, \"login_required\", \"Authentication required but prompt is none\"));\n\t\t/**\n\t\t* If the user is not logged in, we need to redirect them to the\n\t\t* login page.\n\t\t*/\n\t\tawait ctx.setSignedCookie(\"oidc_login_prompt\", JSON.stringify(ctx.query), ctx.context.secret, {\n\t\t\tmaxAge: 600,\n\t\t\tpath: \"/\",\n\t\t\tsameSite: \"lax\"\n\t\t});\n\t\tconst queryFromURL = ctx.request.url?.split(\"?\")[1];\n\t\treturn handleRedirect(`${options.loginPage}?${queryFromURL}`);\n\t}\n\tconst query = ctx.query;\n\tif (!query.client_id) {\n\t\tconst errorURL = getErrorURL(ctx, \"invalid_client\", \"client_id is required\");\n\t\tthrow ctx.redirect(errorURL);\n\t}\n\tif (!query.response_type) {\n\t\tconst errorURL = getErrorURL(ctx, \"invalid_request\", \"response_type is required\");\n\t\tthrow ctx.redirect(errorURL);\n\t}\n\tconst client = await getClient(ctx.query.client_id, options.trustedClients || []);\n\tif (!client) {\n\t\tconst errorURL = getErrorURL(ctx, \"invalid_client\", \"client_id is required\");\n\t\tthrow ctx.redirect(errorURL);\n\t}\n\tconst redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);\n\tif (!redirectURI || !query.redirect_uri)\n /**\n\t* show UI error here warning the user that the redirect URI is invalid\n\t*/\n\tthrow new APIError(\"BAD_REQUEST\", { message: \"Invalid redirect URI\" });\n\tif (client.disabled) {\n\t\tconst errorURL = getErrorURL(ctx, \"client_disabled\", \"client is disabled\");\n\t\tthrow ctx.redirect(errorURL);\n\t}\n\tif (query.response_type !== \"code\") {\n\t\tconst errorURL = getErrorURL(ctx, \"unsupported_response_type\", \"unsupported response type\");\n\t\tthrow ctx.redirect(errorURL);\n\t}\n\tconst requestScope = query.scope?.split(\" \").filter((s) => s) || opts.defaultScope.split(\" \");\n\tconst invalidScopes = requestScope.filter((scope) => {\n\t\treturn !opts.scopes.includes(scope);\n\t});\n\tif (invalidScopes.length) return handleRedirect(formatErrorURL(query.redirect_uri, \"invalid_scope\", `The following scopes are invalid: ${invalidScopes.join(\", \")}`));\n\tif ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) return handleRedirect(formatErrorURL(query.redirect_uri, \"invalid_request\", \"pkce is required\"));\n\tif (!query.code_challenge_method) query.code_challenge_method = \"plain\";\n\tif (![\"s256\", options.allowPlainCodeChallengeMethod ? \"plain\" : \"s256\"].includes(query.code_challenge_method?.toLowerCase() || \"\")) return handleRedirect(formatErrorURL(query.redirect_uri, \"invalid_request\", \"invalid code_challenge method\"));\n\tconst code = generateRandomString(32, \"a-z\", \"A-Z\", \"0-9\");\n\tconst codeExpiresInMs = opts.codeExpiresIn * 1e3;\n\tconst expiresAt = new Date(Date.now() + codeExpiresInMs);\n\tconst skipConsentForTrustedClient = client.skipConsent;\n\tconst hasAlreadyConsented = await ctx.context.adapter.findOne({\n\t\tmodel: \"oauthConsent\",\n\t\twhere: [{\n\t\t\tfield: \"clientId\",\n\t\t\tvalue: client.clientId\n\t\t}, {\n\t\t\tfield: \"userId\",\n\t\t\tvalue: session.user.id\n\t\t}]\n\t}).then((res) => {\n\t\tif (!res?.consentGiven) return false;\n\t\tconst consentedScopes = res.scopes ? res.scopes.split(\" \") : [];\n\t\treturn requestScope.every((scope) => consentedScopes.includes(scope));\n\t});\n\tconst promptSet = parsePrompt(query.prompt ?? \"\");\n\tif (promptSet.has(\"none\")) {\n\t\tif (!skipConsentForTrustedClient && !hasAlreadyConsented) return handleRedirect(formatErrorURL(query.redirect_uri, \"consent_required\", \"Consent required but prompt is none\"));\n\t}\n\tlet requireLogin = promptSet.has(\"login\");\n\tif (query.max_age !== void 0) {\n\t\tconst maxAge = Number(query.max_age);\n\t\tif (Number.isInteger(maxAge) && maxAge >= 0) {\n\t\t\tif ((Date.now() - new Date(session.session.createdAt).getTime()) / 1e3 > maxAge) requireLogin = true;\n\t\t}\n\t}\n\tconst requireConsent = !skipConsentForTrustedClient && (!hasAlreadyConsented || promptSet.has(\"consent\"));\n\ttry {\n\t\t/**\n\t\t* Save the code in the database\n\t\t*/\n\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\tvalue: JSON.stringify({\n\t\t\t\tclientId: client.clientId,\n\t\t\t\tredirectURI: query.redirect_uri,\n\t\t\t\tscope: requestScope,\n\t\t\t\tuserId: session.user.id,\n\t\t\t\tauthTime: new Date(session.session.createdAt).getTime(),\n\t\t\t\trequireConsent,\n\t\t\t\tstate: requireConsent ? query.state : null,\n\t\t\t\tcodeChallenge: query.code_challenge,\n\t\t\t\tcodeChallengeMethod: query.code_challenge_method,\n\t\t\t\tnonce: query.nonce\n\t\t\t}),\n\t\t\tidentifier: code,\n\t\t\texpiresAt\n\t\t});\n\t} catch (e) {\n\t\treturn handleRedirect(formatErrorURL(query.redirect_uri, \"server_error\", \"An error occurred while processing the request\"));\n\t}\n\tif (requireLogin) {\n\t\tawait ctx.setSignedCookie(\"oidc_login_prompt\", JSON.stringify(ctx.query), ctx.context.secret, {\n\t\t\tmaxAge: 600,\n\t\t\tpath: \"/\",\n\t\t\tsameSite: \"lax\"\n\t\t});\n\t\tawait ctx.setSignedCookie(\"oidc_consent_prompt\", code, ctx.context.secret, {\n\t\t\tmaxAge: 600,\n\t\t\tpath: \"/\",\n\t\t\tsameSite: \"lax\"\n\t\t});\n\t\treturn handleRedirect(`${options.loginPage}?${new URLSearchParams({\n\t\t\tclient_id: client.clientId,\n\t\t\tcode,\n\t\t\tstate: query.state\n\t\t}).toString()}`);\n\t}\n\tif (!requireConsent) {\n\t\tconst redirectURIWithCode = new URL(redirectURI);\n\t\tredirectURIWithCode.searchParams.set(\"code\", code);\n\t\tredirectURIWithCode.searchParams.set(\"state\", ctx.query.state);\n\t\treturn handleRedirect(redirectURIWithCode.toString());\n\t}\n\tif (options?.consentPage) {\n\t\tawait ctx.setSignedCookie(\"oidc_consent_prompt\", code, ctx.context.secret, {\n\t\t\tmaxAge: 600,\n\t\t\tpath: \"/\",\n\t\t\tsameSite: \"lax\"\n\t\t});\n\t\tconst urlParams = new URLSearchParams();\n\t\turlParams.set(\"consent_code\", code);\n\t\turlParams.set(\"client_id\", client.clientId);\n\t\turlParams.set(\"scope\", requestScope.join(\" \"));\n\t\treturn handleRedirect(`${options.consentPage}?${urlParams.toString()}`);\n\t}\n\tconst htmlFn = options?.getConsentHTML;\n\tif (!htmlFn) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"No consent page provided\" });\n\treturn new Response(htmlFn({\n\t\tscopes: requestScope,\n\t\tclientMetadata: client.metadata,\n\t\tclientIcon: client?.icon,\n\t\tclientId: client.clientId,\n\t\tclientName: client.name,\n\t\tcode\n\t}), { headers: { \"content-type\": \"text/html\" } });\n}\n\n//#endregion\n//#region src/plugins/oidc-provider/schema.ts\nconst oAuthApplicationSchema = z.object({\n\tclientId: z.string(),\n\tclientSecret: z.string().optional(),\n\ttype: z.enum([\n\t\t\"web\",\n\t\t\"native\",\n\t\t\"user-agent-based\",\n\t\t\"public\"\n\t]),\n\tname: z.string(),\n\ticon: z.string().optional(),\n\tmetadata: z.string().optional(),\n\tdisabled: z.boolean().optional().default(false),\n\tredirectUrls: z.string(),\n\tuserId: z.string().optional(),\n\tcreatedAt: z.date(),\n\tupdatedAt: z.date()\n});\nconst schema = {\n\toauthApplication: {\n\t\tmodelName: \"oauthApplication\",\n\t\tfields: {\n\t\t\tname: { type: \"string\" },\n\t\t\ticon: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: false\n\t\t\t},\n\t\t\tmetadata: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: false\n\t\t\t},\n\t\t\tclientId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tunique: true\n\t\t\t},\n\t\t\tclientSecret: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: false\n\t\t\t},\n\t\t\tredirectUrls: { type: \"string\" },\n\t\t\ttype: { type: \"string\" },\n\t\t\tdisabled: {\n\t\t\t\ttype: \"boolean\",\n\t\t\t\trequired: false,\n\t\t\t\tdefaultValue: false\n\t\t\t},\n\t\t\tuserId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: false,\n\t\t\t\treferences: {\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tonDelete: \"cascade\"\n\t\t\t\t},\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\tcreatedAt: { type: \"date\" },\n\t\t\tupdatedAt: { type: \"date\" }\n\t\t}\n\t},\n\toauthAccessToken: {\n\t\tmodelName: \"oauthAccessToken\",\n\t\tfields: {\n\t\t\taccessToken: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tunique: true\n\t\t\t},\n\t\t\trefreshToken: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tunique: true\n\t\t\t},\n\t\t\taccessTokenExpiresAt: { type: \"date\" },\n\t\t\trefreshTokenExpiresAt: { type: \"date\" },\n\t\t\tclientId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\treferences: {\n\t\t\t\t\tmodel: \"oauthApplication\",\n\t\t\t\t\tfield: \"clientId\",\n\t\t\t\t\tonDelete: \"cascade\"\n\t\t\t\t},\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\tuserId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: false,\n\t\t\t\treferences: {\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tonDelete: \"cascade\"\n\t\t\t\t},\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\tscopes: { type: \"string\" },\n\t\t\tcreatedAt: { type: \"date\" },\n\t\t\tupdatedAt: { type: \"date\" }\n\t\t}\n\t},\n\toauthConsent: {\n\t\tmodelName: \"oauthConsent\",\n\t\tfields: {\n\t\t\tclientId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\treferences: {\n\t\t\t\t\tmodel: \"oauthApplication\",\n\t\t\t\t\tfield: \"clientId\",\n\t\t\t\t\tonDelete: \"cascade\"\n\t\t\t\t},\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\tuserId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\treferences: {\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tonDelete: \"cascade\"\n\t\t\t\t},\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\tscopes: { type: \"string\" },\n\t\t\tcreatedAt: { type: \"date\" },\n\t\t\tupdatedAt: { type: \"date\" },\n\t\t\tconsentGiven: { type: \"boolean\" }\n\t\t}\n\t}\n};\n\n//#endregion\n//#region src/plugins/oidc-provider/utils.ts\n/**\n* Default client secret hasher using SHA-256\n*/\nconst defaultClientSecretHasher = async (clientSecret) => {\n\tconst hash = await createHash(\"SHA-256\").digest(new TextEncoder().encode(clientSecret));\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n};\n\n//#endregion\n//#region src/plugins/oidc-provider/index.ts\nconst getJwtPlugin = (ctx) => {\n\treturn ctx.context.options.plugins?.find((plugin) => plugin.id === \"jwt\");\n};\n/**\n* Get a client by ID, checking trusted clients first, then database\n*/\nasync function getClient(clientId, trustedClients = []) {\n\tconst { context: { adapter } } = await getCurrentAuthContext();\n\tconst trustedClient = trustedClients.find((client) => client.clientId === clientId);\n\tif (trustedClient) return trustedClient;\n\treturn adapter.findOne({\n\t\tmodel: \"oauthApplication\",\n\t\twhere: [{\n\t\t\tfield: \"clientId\",\n\t\t\tvalue: clientId\n\t\t}]\n\t}).then((res) => {\n\t\tif (!res) return null;\n\t\treturn {\n\t\t\tclientId: res.clientId,\n\t\t\tclientSecret: res.clientSecret,\n\t\t\ttype: res.type,\n\t\t\tname: res.name,\n\t\t\ticon: res.icon,\n\t\t\tdisabled: res.disabled,\n\t\t\tredirectUrls: (res.redirectUrls ?? \"\").split(\",\"),\n\t\t\tmetadata: res.metadata ? JSON.parse(res.metadata) : {}\n\t\t};\n\t});\n}\nconst getMetadata = (ctx, options) => {\n\tconst jwtPlugin = getJwtPlugin(ctx);\n\tconst issuer = jwtPlugin && jwtPlugin.options?.jwt && jwtPlugin.options.jwt.issuer ? jwtPlugin.options.jwt.issuer : ctx.context.options.baseURL;\n\tconst baseURL = ctx.context.baseURL;\n\tconst supportedAlgs = options?.useJWTPlugin ? [\n\t\t\"RS256\",\n\t\t\"EdDSA\",\n\t\t\"none\"\n\t] : [\"HS256\", \"none\"];\n\treturn {\n\t\tissuer,\n\t\tauthorization_endpoint: `${baseURL}/oauth2/authorize`,\n\t\ttoken_endpoint: `${baseURL}/oauth2/token`,\n\t\tuserinfo_endpoint: `${baseURL}/oauth2/userinfo`,\n\t\tjwks_uri: `${baseURL}/jwks`,\n\t\tregistration_endpoint: `${baseURL}/oauth2/register`,\n\t\tend_session_endpoint: `${baseURL}/oauth2/endsession`,\n\t\tscopes_supported: [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\"\n\t\t],\n\t\tresponse_types_supported: [\"code\"],\n\t\tresponse_modes_supported: [\"query\"],\n\t\tgrant_types_supported: [\"authorization_code\", \"refresh_token\"],\n\t\tacr_values_supported: [\"urn:mace:incommon:iap:silver\", \"urn:mace:incommon:iap:bronze\"],\n\t\tsubject_types_supported: [\"public\"],\n\t\tid_token_signing_alg_values_supported: supportedAlgs,\n\t\ttoken_endpoint_auth_methods_supported: [\n\t\t\t\"client_secret_basic\",\n\t\t\t\"client_secret_post\",\n\t\t\t\"none\"\n\t\t],\n\t\tcode_challenge_methods_supported: [\"S256\"],\n\t\tclaims_supported: [\n\t\t\t\"sub\",\n\t\t\t\"iss\",\n\t\t\t\"aud\",\n\t\t\t\"exp\",\n\t\t\t\"nbf\",\n\t\t\t\"iat\",\n\t\t\t\"jti\",\n\t\t\t\"email\",\n\t\t\t\"email_verified\",\n\t\t\t\"name\"\n\t\t],\n\t\t...options?.metadata\n\t};\n};\n/**\n* OpenID Connect (OIDC) plugin for Better Auth. This plugin implements the\n* authorization code flow and the token exchange flow. It also implements the\n* userinfo endpoint.\n*\n* @param options - The options for the OIDC plugin.\n* @returns A Better Auth plugin.\n*/\nconst oidcProvider = (options) => {\n\tconst modelName = {\n\t\toauthClient: \"oauthApplication\",\n\t\toauthAccessToken: \"oauthAccessToken\",\n\t\toauthConsent: \"oauthConsent\"\n\t};\n\tconst opts = {\n\t\tcodeExpiresIn: 600,\n\t\tdefaultScope: \"openid\",\n\t\taccessTokenExpiresIn: 3600,\n\t\trefreshTokenExpiresIn: 604800,\n\t\tallowPlainCodeChallengeMethod: true,\n\t\tstoreClientSecret: \"plain\",\n\t\t...options,\n\t\tscopes: [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\",\n\t\t\t...options?.scopes || []\n\t\t]\n\t};\n\tconst trustedClients = options.trustedClients || [];\n\t/**\n\t* Store client secret according to the configured storage method\n\t*/\n\tasync function storeClientSecret(ctx, clientSecret) {\n\t\tif (opts.storeClientSecret === \"encrypted\") return await symmetricEncrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: clientSecret\n\t\t});\n\t\tif (opts.storeClientSecret === \"hashed\") return await defaultClientSecretHasher(clientSecret);\n\t\tif (typeof opts.storeClientSecret === \"object\" && \"hash\" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret);\n\t\tif (typeof opts.storeClientSecret === \"object\" && \"encrypt\" in opts.storeClientSecret) return await opts.storeClientSecret.encrypt(clientSecret);\n\t\treturn clientSecret;\n\t}\n\t/**\n\t* Verify stored client secret against provided client secret\n\t*/\n\tasync function verifyStoredClientSecret(ctx, storedClientSecret, clientSecret) {\n\t\tif (opts.storeClientSecret === \"encrypted\") return await symmetricDecrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: storedClientSecret\n\t\t}) === clientSecret;\n\t\tif (opts.storeClientSecret === \"hashed\") return await defaultClientSecretHasher(clientSecret) === storedClientSecret;\n\t\tif (typeof opts.storeClientSecret === \"object\" && \"hash\" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret) === storedClientSecret;\n\t\tif (typeof opts.storeClientSecret === \"object\" && \"decrypt\" in opts.storeClientSecret) return await opts.storeClientSecret.decrypt(storedClientSecret) === clientSecret;\n\t\treturn clientSecret === storedClientSecret;\n\t}\n\treturn {\n\t\tid: \"oidc\",\n\t\thooks: { after: [{\n\t\t\tmatcher() {\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst loginPromptCookie = await ctx.getSignedCookie(\"oidc_login_prompt\", ctx.context.secret);\n\t\t\t\tconst cookieName = ctx.context.authCookies.sessionToken.name;\n\t\t\t\tconst parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get(\"set-cookie\") || \"\");\n\t\t\t\tconst hasSessionToken = parsedSetCookieHeader.has(cookieName);\n\t\t\t\tif (!loginPromptCookie || !hasSessionToken) return;\n\t\t\t\tctx.setCookie(\"oidc_login_prompt\", \"\", { maxAge: 0 });\n\t\t\t\tconst sessionToken = (parsedSetCookieHeader.get(cookieName)?.value)?.split(\".\")[0];\n\t\t\t\tif (!sessionToken) return;\n\t\t\t\tconst session = await ctx.context.internalAdapter.findSession(sessionToken) || ctx.context.newSession;\n\t\t\t\tif (!session) return;\n\t\t\t\tctx.query = JSON.parse(loginPromptCookie);\n\t\t\t\tconst promptSet = parsePrompt(String(ctx.query?.prompt));\n\t\t\t\tif (promptSet.has(\"login\")) {\n\t\t\t\t\tconst newPromptSet = new Set(promptSet);\n\t\t\t\t\tnewPromptSet.delete(\"login\");\n\t\t\t\t\tctx.query = {\n\t\t\t\t\t\t...ctx.query,\n\t\t\t\t\t\tprompt: Array.from(newPromptSet).join(\" \")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tctx.context.session = session;\n\t\t\t\treturn await authorize(ctx, opts);\n\t\t\t})\n\t\t}] },\n\t\tendpoints: {\n\t\t\tgetOpenIdConfig: createAuthEndpoint(\"/.well-known/openid-configuration\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\toperationId: \"getOpenIdConfig\",\n\t\t\t\tmetadata: { isAction: false }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst metadata = getMetadata(ctx, options);\n\t\t\t\treturn ctx.json(metadata);\n\t\t\t}),\n\t\t\toAuth2authorize: createAuthEndpoint(\"/oauth2/authorize\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\toperationId: \"oauth2Authorize\",\n\t\t\t\tquery: z.record(z.string(), z.any()),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Authorize an OAuth2 request\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Authorization response generated successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tdescription: \"Authorization response, contents depend on the authorize function implementation\"\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\treturn authorize(ctx, opts);\n\t\t\t}),\n\t\t\toAuthConsent: createAuthEndpoint(\"/oauth2/consent\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\toperationId: \"oauth2Consent\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\taccept: z.boolean(),\n\t\t\t\t\tconsent_code: z.string().optional().nullish()\n\t\t\t\t}),\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Handle OAuth2 consent. Supports both URL parameter-based flows (consent_code in body) and cookie-based flows (signed cookie).\",\n\t\t\t\t\trequestBody: {\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\taccept: {\n\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\tdescription: \"Whether the user accepts or denies the consent request\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tconsent_code: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"The consent code from the authorization request. Optional if using cookie-based flow.\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"accept\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t},\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Consent processed successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { redirectURI: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\tdescription: \"The URI to redirect to, either with an authorization code or an error\"\n\t\t\t\t\t\t\t} },\n\t\t\t\t\t\t\trequired: [\"redirectURI\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tlet consentCode = ctx.body.consent_code || null;\n\t\t\t\tif (!consentCode) {\n\t\t\t\t\tconst cookieValue = await ctx.getSignedCookie(\"oidc_consent_prompt\", ctx.context.secret);\n\t\t\t\t\tif (cookieValue) consentCode = cookieValue;\n\t\t\t\t}\n\t\t\t\tif (!consentCode) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"consent_code is required (either in body or cookie)\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst verification = await ctx.context.internalAdapter.findVerificationValue(consentCode);\n\t\t\t\tif (!verification) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"Invalid code\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"Code expired\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tctx.setCookie(\"oidc_consent_prompt\", \"\", { maxAge: 0 });\n\t\t\t\tconst value = JSON.parse(verification.value);\n\t\t\t\tif (!value.requireConsent) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"Consent not required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (!ctx.body.accept) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\t\t\t\t\treturn ctx.json({ redirectURI: `${value.redirectURI}?error=access_denied&error_description=User denied access` });\n\t\t\t\t}\n\t\t\t\tconst code = generateRandomString(32, \"a-z\", \"A-Z\", \"0-9\");\n\t\t\t\tconst codeExpiresInMs = opts.codeExpiresIn * 1e3;\n\t\t\t\tconst expiresAt = new Date(Date.now() + codeExpiresInMs);\n\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(verification.id, {\n\t\t\t\t\tvalue: JSON.stringify({\n\t\t\t\t\t\t...value,\n\t\t\t\t\t\trequireConsent: false\n\t\t\t\t\t}),\n\t\t\t\t\tidentifier: code,\n\t\t\t\t\texpiresAt\n\t\t\t\t});\n\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\tmodel: modelName.oauthConsent,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tclientId: value.clientId,\n\t\t\t\t\t\tuserId: value.userId,\n\t\t\t\t\t\tscopes: value.scope.join(\" \"),\n\t\t\t\t\t\tconsentGiven: true,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst redirectURI = new URL(value.redirectURI);\n\t\t\t\tredirectURI.searchParams.set(\"code\", code);\n\t\t\t\tif (value.state) redirectURI.searchParams.set(\"state\", value.state);\n\t\t\t\treturn ctx.json({ redirectURI: redirectURI.toString() });\n\t\t\t}),\n\t\t\toAuth2token: createAuthEndpoint(\"/oauth2/token\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\toperationId: \"oauth2Token\",\n\t\t\t\tbody: z.record(z.any(), z.any()),\n\t\t\t\tmetadata: {\n\t\t\t\t\tisAction: false,\n\t\t\t\t\tallowedMediaTypes: [\"application/x-www-form-urlencoded\", \"application/json\"]\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tlet { body } = ctx;\n\t\t\t\tif (!body) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"request body not found\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (body instanceof FormData) body = Object.fromEntries(body.entries());\n\t\t\t\tif (!(body instanceof Object)) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"request body is not an object\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tlet { client_id, client_secret } = body;\n\t\t\t\tconst authorization = ctx.request?.headers.get(\"authorization\") || null;\n\t\t\t\tif (authorization && !client_id && !client_secret && authorization.startsWith(\"Basic \")) try {\n\t\t\t\t\tconst encoded = authorization.replace(\"Basic \", \"\");\n\t\t\t\t\tconst decoded = new TextDecoder().decode(base64.decode(encoded));\n\t\t\t\t\tif (!decoded.includes(\":\")) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid authorization header format\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tconst [id, secret] = decoded.split(\":\");\n\t\t\t\t\tif (!id || !secret) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid authorization header format\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tclient_id = id;\n\t\t\t\t\tclient_secret = secret;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid authorization header format\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst now = Date.now();\n\t\t\t\tconst iat = Math.floor(now / 1e3);\n\t\t\t\tconst exp = iat + (opts.accessTokenExpiresIn ?? 3600);\n\t\t\t\tconst accessTokenExpiresAt = /* @__PURE__ */ new Date(exp * 1e3);\n\t\t\t\tconst refreshTokenExpiresAt = /* @__PURE__ */ new Date((iat + (opts.refreshTokenExpiresIn ?? 604800)) * 1e3);\n\t\t\t\tconst { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;\n\t\t\t\tif (grant_type === \"refresh_token\") {\n\t\t\t\t\tif (!refresh_token) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror_description: \"refresh_token is required\",\n\t\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t\t});\n\t\t\t\t\tconst token = await ctx.context.adapter.findOne({\n\t\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"refreshToken\",\n\t\t\t\t\t\t\tvalue: refresh_token.toString()\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (!token) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid refresh token\",\n\t\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t\t});\n\t\t\t\t\tif (token.clientId !== client_id?.toString()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid client_id\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tif (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"refresh token expired\",\n\t\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t\t});\n\t\t\t\t\tconst accessToken$1 = generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\t\tconst newRefreshToken = generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\taccessToken: accessToken$1,\n\t\t\t\t\t\t\trefreshToken: newRefreshToken,\n\t\t\t\t\t\t\taccessTokenExpiresAt,\n\t\t\t\t\t\t\trefreshTokenExpiresAt,\n\t\t\t\t\t\t\tclientId: client_id.toString(),\n\t\t\t\t\t\t\tuserId: token.userId,\n\t\t\t\t\t\t\tscopes: token.scopes,\n\t\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(iat * 1e3),\n\t\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(iat * 1e3)\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\taccess_token: accessToken$1,\n\t\t\t\t\t\ttoken_type: \"Bearer\",\n\t\t\t\t\t\texpires_in: opts.accessTokenExpiresIn,\n\t\t\t\t\t\trefresh_token: newRefreshToken,\n\t\t\t\t\t\tscope: token.scopes\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!code) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"code is required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (options.requirePKCE && !code_verifier) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"code verifier is missing\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\t/**\n\t\t\t\t* We need to check if the code is valid before we can proceed\n\t\t\t\t* with the rest of the request.\n\t\t\t\t*/\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());\n\t\t\t\tif (!verificationValue) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid code\",\n\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t});\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"code expired\",\n\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t});\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tif (!client_id) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"client_id is required\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (!grant_type) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"grant_type is required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (grant_type !== \"authorization_code\") throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"grant_type must be 'authorization_code'\",\n\t\t\t\t\terror: \"unsupported_grant_type\"\n\t\t\t\t});\n\t\t\t\tif (!redirect_uri) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"redirect_uri is required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst client = await getClient(client_id.toString(), trustedClients);\n\t\t\t\tif (!client) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid client_id\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (client.disabled) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"client is disabled\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tconst value = JSON.parse(verificationValue.value);\n\t\t\t\tif (value.clientId !== client_id.toString()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid client_id\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (value.redirectURI !== redirect_uri.toString()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid redirect_uri\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (value.codeChallenge && !code_verifier) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"code verifier is missing\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (client.type === \"public\") {\n\t\t\t\t\tif (!code_verifier) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror_description: \"code verifier is required for public clients\",\n\t\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!client.clientSecret || !client_secret) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"client_secret is required for confidential clients\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tif (!await verifyStoredClientSecret(ctx, client.clientSecret, client_secret.toString())) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid client_secret\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif ((value.codeChallengeMethod === \"plain\" ? code_verifier : await createHash(\"SHA-256\", \"base64urlnopad\").digest(code_verifier)) !== value.codeChallenge) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"code verification failed\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst requestedScopes = value.scope;\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tconst accessToken = generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst refreshToken = generateRandomString(32, \"A-Z\", \"a-z\");\n\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\taccessToken,\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\taccessTokenExpiresAt,\n\t\t\t\t\t\trefreshTokenExpiresAt,\n\t\t\t\t\t\tclientId: client_id.toString(),\n\t\t\t\t\t\tuserId: value.userId,\n\t\t\t\t\t\tscopes: requestedScopes.join(\" \"),\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(iat * 1e3),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(iat * 1e3)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(value.userId);\n\t\t\t\tif (!user) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"user not found\",\n\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t});\n\t\t\t\tconst profile = {\n\t\t\t\t\tgiven_name: user.name.split(\" \")[0],\n\t\t\t\t\tfamily_name: user.name.split(\" \")[1],\n\t\t\t\t\tname: user.name,\n\t\t\t\t\tprofile: user.image,\n\t\t\t\t\tupdated_at: new Date(user.updatedAt).toISOString()\n\t\t\t\t};\n\t\t\t\tconst email = {\n\t\t\t\t\temail: user.email,\n\t\t\t\t\temail_verified: user.emailVerified\n\t\t\t\t};\n\t\t\t\tconst userClaims = {\n\t\t\t\t\t...requestedScopes.includes(\"profile\") ? profile : {},\n\t\t\t\t\t...requestedScopes.includes(\"email\") ? email : {}\n\t\t\t\t};\n\t\t\t\tconst additionalUserClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};\n\t\t\t\tconst payload = {\n\t\t\t\t\tsub: user.id,\n\t\t\t\t\taud: client_id.toString(),\n\t\t\t\t\tiat,\n\t\t\t\t\tauth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,\n\t\t\t\t\tnonce: value.nonce,\n\t\t\t\t\tacr: \"urn:mace:incommon:iap:silver\",\n\t\t\t\t\t...userClaims,\n\t\t\t\t\t...additionalUserClaims\n\t\t\t\t};\n\t\t\t\tconst expirationTime = Math.floor(Date.now() / 1e3) + opts.accessTokenExpiresIn;\n\t\t\t\tlet idToken;\n\t\t\t\tif (options.useJWTPlugin) {\n\t\t\t\t\tconst jwtPlugin = getJwtPlugin(ctx);\n\t\t\t\t\tif (!jwtPlugin) {\n\t\t\t\t\t\tctx.context.logger.error(\"OIDC: `useJWTPlugin` is enabled but the JWT plugin is not available. Make sure you have the JWT Plugin in your plugins array or set `useJWTPlugin` to false.\");\n\t\t\t\t\t\tthrow new APIError$1(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\t\terror_description: \"JWT plugin is not enabled\",\n\t\t\t\t\t\t\terror: \"internal_server_error\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tidToken = await getJwtToken({\n\t\t\t\t\t\t...ctx,\n\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\t...ctx.context,\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\tid: generateRandomString(32, \"a-z\", \"A-Z\"),\n\t\t\t\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(iat * 1e3),\n\t\t\t\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(iat * 1e3),\n\t\t\t\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\t\t\t\texpiresAt: accessTokenExpiresAt,\n\t\t\t\t\t\t\t\t\ttoken: accessToken,\n\t\t\t\t\t\t\t\t\tipAddress: ctx.request?.headers.get(\"x-forwarded-for\")\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\t...jwtPlugin.options,\n\t\t\t\t\t\tjwt: {\n\t\t\t\t\t\t\t...jwtPlugin.options?.jwt,\n\t\t\t\t\t\t\tgetSubject: () => user.id,\n\t\t\t\t\t\t\taudience: client_id.toString(),\n\t\t\t\t\t\t\tissuer: jwtPlugin.options?.jwt?.issuer ?? ctx.context.options.baseURL,\n\t\t\t\t\t\t\texpirationTime,\n\t\t\t\t\t\t\tdefinePayload: () => payload\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else idToken = await new SignJWT(payload).setProtectedHeader({ alg: \"HS256\" }).setIssuedAt(iat).setExpirationTime(accessTokenExpiresAt).sign(new TextEncoder().encode(client.clientSecret));\n\t\t\t\treturn ctx.json({\n\t\t\t\t\taccess_token: accessToken,\n\t\t\t\t\ttoken_type: \"Bearer\",\n\t\t\t\t\texpires_in: opts.accessTokenExpiresIn,\n\t\t\t\t\trefresh_token: requestedScopes.includes(\"offline_access\") ? refreshToken : void 0,\n\t\t\t\t\tscope: requestedScopes.join(\" \"),\n\t\t\t\t\tid_token: requestedScopes.includes(\"openid\") ? idToken : void 0\n\t\t\t\t}, { headers: {\n\t\t\t\t\t\"Cache-Control\": \"no-store\",\n\t\t\t\t\tPragma: \"no-cache\"\n\t\t\t\t} });\n\t\t\t}),\n\t\t\toAuth2userInfo: createAuthEndpoint(\"/oauth2/userinfo\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\toperationId: \"oauth2Userinfo\",\n\t\t\t\tmetadata: {\n\t\t\t\t\tisAction: false,\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\tdescription: \"Get OAuth2 user information\",\n\t\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\t\tdescription: \"User information retrieved successfully\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tsub: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Subject identifier (user ID)\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"User's email address, included if 'email' scope is granted\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"User's full name, included if 'profile' scope is granted\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpicture: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"User's profile picture URL, included if 'profile' scope is granted\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgiven_name: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"User's given name, included if 'profile' scope is granted\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfamily_name: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"User's family name, included if 'profile' scope is granted\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\temail_verified: {\n\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email is verified, included if 'email' scope is granted\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"sub\"]\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!ctx.request) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"request not found\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst authorization = ctx.request.headers.get(\"authorization\");\n\t\t\t\tif (!authorization) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"authorization header not found\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst token = authorization.replace(\"Bearer \", \"\");\n\t\t\t\tconst accessToken = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"accessToken\",\n\t\t\t\t\t\tvalue: token\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!accessToken) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid access token\",\n\t\t\t\t\terror: \"invalid_token\"\n\t\t\t\t});\n\t\t\t\tif (accessToken.accessTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"The Access Token expired\",\n\t\t\t\t\terror: \"invalid_token\"\n\t\t\t\t});\n\t\t\t\tconst client = await getClient(accessToken.clientId, trustedClients);\n\t\t\t\tif (!client) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"client not found\",\n\t\t\t\t\terror: \"invalid_token\"\n\t\t\t\t});\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(accessToken.userId);\n\t\t\t\tif (!user) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"user not found\",\n\t\t\t\t\terror: \"invalid_token\"\n\t\t\t\t});\n\t\t\t\tconst requestedScopes = accessToken.scopes.split(\" \");\n\t\t\t\tconst baseUserClaims = {\n\t\t\t\t\tsub: user.id,\n\t\t\t\t\temail: requestedScopes.includes(\"email\") ? user.email : void 0,\n\t\t\t\t\tname: requestedScopes.includes(\"profile\") ? user.name : void 0,\n\t\t\t\t\tpicture: requestedScopes.includes(\"profile\") ? user.image : void 0,\n\t\t\t\t\tgiven_name: requestedScopes.includes(\"profile\") ? user.name.split(\" \")[0] : void 0,\n\t\t\t\t\tfamily_name: requestedScopes.includes(\"profile\") ? user.name.split(\" \")[1] : void 0,\n\t\t\t\t\temail_verified: requestedScopes.includes(\"email\") ? user.emailVerified : void 0\n\t\t\t\t};\n\t\t\t\tconst userClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : baseUserClaims;\n\t\t\t\treturn ctx.json({\n\t\t\t\t\t...baseUserClaims,\n\t\t\t\t\t...userClaims\n\t\t\t\t});\n\t\t\t}),\n\t\t\tregisterOAuthApplication: createAuthEndpoint(\"/oauth2/register\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tredirect_uris: z.array(z.string()).meta({ description: \"A list of redirect URIs. Eg: [\\\"https://client.example.com/callback\\\"]\" }),\n\t\t\t\t\ttoken_endpoint_auth_method: z.enum([\n\t\t\t\t\t\t\"none\",\n\t\t\t\t\t\t\"client_secret_basic\",\n\t\t\t\t\t\t\"client_secret_post\"\n\t\t\t\t\t]).meta({ description: \"The authentication method for the token endpoint. Eg: \\\"client_secret_basic\\\"\" }).default(\"client_secret_basic\").optional(),\n\t\t\t\t\tgrant_types: z.array(z.enum([\n\t\t\t\t\t\t\"authorization_code\",\n\t\t\t\t\t\t\"implicit\",\n\t\t\t\t\t\t\"password\",\n\t\t\t\t\t\t\"client_credentials\",\n\t\t\t\t\t\t\"refresh_token\",\n\t\t\t\t\t\t\"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n\t\t\t\t\t\t\"urn:ietf:params:oauth:grant-type:saml2-bearer\"\n\t\t\t\t\t])).meta({ description: \"The grant types supported by the application. Eg: [\\\"authorization_code\\\"]\" }).default([\"authorization_code\"]).optional(),\n\t\t\t\t\tresponse_types: z.array(z.enum([\"code\", \"token\"])).meta({ description: \"The response types supported by the application. Eg: [\\\"code\\\"]\" }).default([\"code\"]).optional(),\n\t\t\t\t\tclient_name: z.string().meta({ description: \"The name of the application. Eg: \\\"My App\\\"\" }).optional(),\n\t\t\t\t\tclient_uri: z.string().meta({ description: \"The URI of the application. Eg: \\\"https://client.example.com\\\"\" }).optional(),\n\t\t\t\t\tlogo_uri: z.string().meta({ description: \"The URI of the application logo. Eg: \\\"https://client.example.com/logo.png\\\"\" }).optional(),\n\t\t\t\t\tscope: z.string().meta({ description: \"The scopes supported by the application. Separated by spaces. Eg: \\\"profile email\\\"\" }).optional(),\n\t\t\t\t\tcontacts: z.array(z.string()).meta({ description: \"The contact information for the application. Eg: [\\\"admin@example.com\\\"]\" }).optional(),\n\t\t\t\t\ttos_uri: z.string().meta({ description: \"The URI of the application terms of service. Eg: \\\"https://client.example.com/tos\\\"\" }).optional(),\n\t\t\t\t\tpolicy_uri: z.string().meta({ description: \"The URI of the application privacy policy. Eg: \\\"https://client.example.com/policy\\\"\" }).optional(),\n\t\t\t\t\tjwks_uri: z.string().meta({ description: \"The URI of the application JWKS. Eg: \\\"https://client.example.com/jwks\\\"\" }).optional(),\n\t\t\t\t\tjwks: z.record(z.any(), z.any()).meta({ description: \"The JWKS of the application. Eg: {\\\"keys\\\": [{\\\"kty\\\": \\\"RSA\\\", \\\"alg\\\": \\\"RS256\\\", \\\"use\\\": \\\"sig\\\", \\\"n\\\": \\\"...\\\", \\\"e\\\": \\\"...\\\"}]}\" }).optional(),\n\t\t\t\t\tmetadata: z.record(z.any(), z.any()).meta({ description: \"The metadata of the application. Eg: {\\\"key\\\": \\\"value\\\"}\" }).optional(),\n\t\t\t\t\tsoftware_id: z.string().meta({ description: \"The software ID of the application. Eg: \\\"my-software\\\"\" }).optional(),\n\t\t\t\t\tsoftware_version: z.string().meta({ description: \"The software version of the application. Eg: \\\"1.0.0\\\"\" }).optional(),\n\t\t\t\t\tsoftware_statement: z.string().meta({ description: \"The software statement of the application.\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Register an OAuth2 application\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"OAuth2 application registered successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Name of the OAuth2 application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ticon: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"Icon URL for the application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"Additional metadata for the application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tclientId: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier for the client\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tclientSecret: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Secret key for the client\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tredirectURLs: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"uri\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdescription: \"List of allowed redirect URLs\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Type of the client\",\n\t\t\t\t\t\t\t\t\tenum: [\"web\"]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tauthenticationScheme: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Authentication scheme used by the client\",\n\t\t\t\t\t\t\t\t\tenum: [\"client_secret\"]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tdisabled: {\n\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\tdescription: \"Whether the client is disabled\",\n\t\t\t\t\t\t\t\t\tenum: [false]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"ID of the user who registered the client, null if registered anonymously\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\tdescription: \"Creation timestamp\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\tdescription: \"Last update timestamp\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\"clientId\",\n\t\t\t\t\t\t\t\t\"clientSecret\",\n\t\t\t\t\t\t\t\t\"redirectURLs\",\n\t\t\t\t\t\t\t\t\"type\",\n\t\t\t\t\t\t\t\t\"authenticationScheme\",\n\t\t\t\t\t\t\t\t\"disabled\",\n\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst body = ctx.body;\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tif (!session && !options.allowDynamicClientRegistration) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror: \"invalid_token\",\n\t\t\t\t\terror_description: \"Authentication required for client registration\"\n\t\t\t\t});\n\t\t\t\tif ((!body.grant_types || body.grant_types.includes(\"authorization_code\") || body.grant_types.includes(\"implicit\")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_redirect_uri\",\n\t\t\t\t\terror_description: \"Redirect URIs are required for authorization_code and implicit grant types\"\n\t\t\t\t});\n\t\t\t\tif (body.grant_types && body.response_types) {\n\t\t\t\t\tif (body.grant_types.includes(\"authorization_code\") && !body.response_types.includes(\"code\")) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client_metadata\",\n\t\t\t\t\t\terror_description: \"When 'authorization_code' grant type is used, 'code' response type must be included\"\n\t\t\t\t\t});\n\t\t\t\t\tif (body.grant_types.includes(\"implicit\") && !body.response_types.includes(\"token\")) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client_metadata\",\n\t\t\t\t\t\terror_description: \"When 'implicit' grant type is used, 'token' response type must be included\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst clientId = options.generateClientId?.() || generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst clientSecret = options.generateClientSecret?.() || generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst storedClientSecret = await storeClientSecret(ctx, clientSecret);\n\t\t\t\tconst client = await ctx.context.adapter.create({\n\t\t\t\t\tmodel: modelName.oauthClient,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: body.client_name,\n\t\t\t\t\t\ticon: body.logo_uri,\n\t\t\t\t\t\tmetadata: body.metadata ? JSON.stringify(body.metadata) : null,\n\t\t\t\t\t\tclientId,\n\t\t\t\t\t\tclientSecret: storedClientSecret,\n\t\t\t\t\t\tredirectUrls: body.redirect_uris.join(\",\"),\n\t\t\t\t\t\ttype: \"web\",\n\t\t\t\t\t\tauthenticationScheme: body.token_endpoint_auth_method || \"client_secret_basic\",\n\t\t\t\t\t\tdisabled: false,\n\t\t\t\t\t\tuserId: session?.session.userId,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tclient_id: clientId,\n\t\t\t\t\t...client.type !== \"public\" ? {\n\t\t\t\t\t\tclient_secret: clientSecret,\n\t\t\t\t\t\tclient_secret_expires_at: 0\n\t\t\t\t\t} : {},\n\t\t\t\t\tclient_id_issued_at: Math.floor(Date.now() / 1e3),\n\t\t\t\t\tclient_secret_expires_at: 0,\n\t\t\t\t\tredirect_uris: body.redirect_uris,\n\t\t\t\t\ttoken_endpoint_auth_method: body.token_endpoint_auth_method || \"client_secret_basic\",\n\t\t\t\t\tgrant_types: body.grant_types || [\"authorization_code\"],\n\t\t\t\t\tresponse_types: body.response_types || [\"code\"],\n\t\t\t\t\tclient_name: body.client_name,\n\t\t\t\t\tclient_uri: body.client_uri,\n\t\t\t\t\tlogo_uri: body.logo_uri,\n\t\t\t\t\tscope: body.scope,\n\t\t\t\t\tcontacts: body.contacts,\n\t\t\t\t\ttos_uri: body.tos_uri,\n\t\t\t\t\tpolicy_uri: body.policy_uri,\n\t\t\t\t\tjwks_uri: body.jwks_uri,\n\t\t\t\t\tjwks: body.jwks,\n\t\t\t\t\tsoftware_id: body.software_id,\n\t\t\t\t\tsoftware_version: body.software_version,\n\t\t\t\t\tsoftware_statement: body.software_statement,\n\t\t\t\t\tmetadata: body.metadata\n\t\t\t\t}, {\n\t\t\t\t\tstatus: 201,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Cache-Control\": \"no-store\",\n\t\t\t\t\t\tPragma: \"no-cache\"\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tgetOAuthClient: createAuthEndpoint(\"/oauth2/client/:id\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Get OAuth2 client details\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"OAuth2 client retrieved successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tclientId: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier for the client\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Name of the OAuth2 application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ticon: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"Icon URL for the application\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"clientId\", \"name\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst client = await getClient(ctx.params.id, trustedClients);\n\t\t\t\tif (!client) throw new APIError$1(\"NOT_FOUND\", {\n\t\t\t\t\terror_description: \"client not found\",\n\t\t\t\t\terror: \"not_found\"\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tclientId: client.clientId,\n\t\t\t\t\tname: client.name,\n\t\t\t\t\ticon: client.icon || null\n\t\t\t\t});\n\t\t\t}),\n\t\t\tendSession: createAuthEndpoint(\"/oauth2/endsession\", {\n\t\t\t\tmethod: [\"GET\", \"POST\"],\n\t\t\t\toperationId: \"oauth2EndSession\",\n\t\t\t\tquery: z.object({\n\t\t\t\t\tid_token_hint: z.string().optional(),\n\t\t\t\t\tlogout_hint: z.string().optional(),\n\t\t\t\t\tclient_id: z.string().optional(),\n\t\t\t\t\tpost_logout_redirect_uri: z.string().optional(),\n\t\t\t\t\tstate: z.string().optional(),\n\t\t\t\t\tui_locales: z.string().optional()\n\t\t\t\t}).optional(),\n\t\t\t\tmetadata: {\n\t\t\t\t\tisAction: false,\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\tdescription: \"RP-Initiated Logout endpoint. Logs out the end-user and optionally redirects to a post-logout URI.\",\n\t\t\t\t\t\tparameters: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"id_token_hint\",\n\t\t\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\t\t\tdescription: \"Previously issued ID Token passed as a hint about the End-User's current authenticated session\",\n\t\t\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\t\t\tschema: { type: \"string\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"logout_hint\",\n\t\t\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\t\t\tdescription: \"Hint to the Authorization Server about the End-User that is logging out\",\n\t\t\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\t\t\tschema: { type: \"string\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"client_id\",\n\t\t\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\t\t\tdescription: \"OAuth 2.0 Client Identifier. Required if post_logout_redirect_uri is used without id_token_hint\",\n\t\t\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\t\t\tschema: { type: \"string\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"post_logout_redirect_uri\",\n\t\t\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\t\t\tdescription: \"URL to which the RP is requesting that the End-User's User Agent be redirected after a logout has been performed\",\n\t\t\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tformat: \"uri\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"state\",\n\t\t\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\t\t\tdescription: \"Opaque value used by the RP to maintain state between the logout request and the callback\",\n\t\t\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\t\t\tschema: { type: \"string\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"ui_locales\",\n\t\t\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\t\t\tdescription: \"End-User's preferred languages and scripts for the user interface\",\n\t\t\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\t\t\tschema: { type: \"string\" }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\t\"302\": { description: \"Redirect to post_logout_redirect_uri or logout confirmation page\" },\n\t\t\t\t\t\t\t\"200\": { description: \"Logout completed successfully\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { id_token_hint, logout_hint, client_id, post_logout_redirect_uri, state, ui_locales } = ctx.query || {};\n\t\t\t\tlet validatedClientId = null;\n\t\t\t\tlet validatedUserId = null;\n\t\t\t\tif (id_token_hint) try {\n\t\t\t\t\tconst jwtPlugin = getJwtPlugin(ctx);\n\t\t\t\t\tif (jwtPlugin && jwtPlugin.options && options?.useJWTPlugin) {\n\t\t\t\t\t\tconst verified = await verifyJWT(id_token_hint, jwtPlugin.options);\n\t\t\t\t\t\tif (verified) {\n\t\t\t\t\t\t\tvalidatedUserId = verified.sub;\n\t\t\t\t\t\t\tvalidatedClientId = verified.aud ? typeof verified.aud === \"string\" ? verified.aud : verified.aud[0] : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (client_id) {\n\t\t\t\t\t\tconst client = await getClient(client_id, trustedClients);\n\t\t\t\t\t\tif (client && client.clientSecret) try {\n\t\t\t\t\t\t\tconst { payload } = await jwtVerify(id_token_hint, new TextEncoder().encode(client.clientSecret));\n\t\t\t\t\t\t\tvalidatedUserId = payload.sub;\n\t\t\t\t\t\t\tvalidatedClientId = payload.aud;\n\t\t\t\t\t\t} catch (error) {}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tctx.context.logger.debug(\"Invalid id_token_hint provided to end_session endpoint\");\n\t\t\t\t}\n\t\t\t\tif (client_id) {\n\t\t\t\t\tif (!await getClient(client_id, trustedClients)) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client\",\n\t\t\t\t\t\terror_description: \"Invalid client_id\"\n\t\t\t\t\t});\n\t\t\t\t\tif (validatedClientId && validatedClientId !== client_id) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\t\terror_description: \"client_id does not match the ID Token's audience\"\n\t\t\t\t\t});\n\t\t\t\t\tvalidatedClientId = client_id;\n\t\t\t\t}\n\t\t\t\tif (post_logout_redirect_uri) {\n\t\t\t\t\tif (!validatedClientId) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\t\terror_description: \"client_id is required when using post_logout_redirect_uri without a valid id_token_hint\"\n\t\t\t\t\t});\n\t\t\t\t\tconst client = await getClient(validatedClientId, trustedClients);\n\t\t\t\t\tif (!client) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client\",\n\t\t\t\t\t\terror_description: \"Invalid client\"\n\t\t\t\t\t});\n\t\t\t\t\tif (!client.redirectUrls.some((registeredUri) => post_logout_redirect_uri === registeredUri)) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\t\terror_description: \"post_logout_redirect_uri is not registered for this client\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tif (validatedUserId || session) {\n\t\t\t\t\tconst userId = validatedUserId || session?.user.id;\n\t\t\t\t\tif (userId) await ctx.context.adapter.deleteMany({\n\t\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\tvalue: userId\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (session) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteSession(session.session.token);\n\t\t\t\t\tctx.setSignedCookie(ctx.context.authCookies.sessionToken.name, \"\", ctx.context.secret, { maxAge: 0 });\n\t\t\t\t}\n\t\t\t\tif (post_logout_redirect_uri) try {\n\t\t\t\t\tconst redirectUrl = new URL(post_logout_redirect_uri);\n\t\t\t\t\tif (state) redirectUrl.searchParams.set(\"state\", state);\n\t\t\t\t\treturn ctx.redirect(redirectUrl.toString());\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_request\",\n\t\t\t\t\t\terror_description: \"Invalid post_logout_redirect_uri format\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmessage: \"Logout successful\"\n\t\t\t\t});\n\t\t\t})\n\t\t},\n\t\tschema: mergeSchema(schema, options?.schema),\n\t\tget options() {\n\t\t\treturn opts;\n\t\t}\n\t};\n};\n\n//#endregion\nexport { parsePrompt as a, schema as i, getMetadata as n, oidcProvider as r, getClient as t };","import { a as getAuthTables } from \"./get-model-name-D4DUV7S2.mjs\";\nimport { a as createInternalAdapter } from \"./get-migration-Bf0TuCzm.mjs\";\nimport { t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport { a as verifyPassword, i as hashPassword } from \"./crypto-CFUhAR9W.mjs\";\nimport { r as getOrigin, t as getBaseURL } from \"./url-CB8xCwz-.mjs\";\nimport { a as getEndpoints, n as checkEndpointConflicts, s as router } from \"./api-CkmycQ2x.mjs\";\nimport { i as getCookies, t as createCookieGetter } from \"./cookies-D72PbWdz.mjs\";\nimport { t as checkPassword } from \"./password-BFQK0cLg.mjs\";\nimport { runWithAdapter } from \"@better-auth/core/context\";\nimport { createLogger, env, isProduction, isTest } from \"@better-auth/core/env\";\nimport { BASE_ERROR_CODES, BetterAuthError } from \"@better-auth/core/error\";\nimport { socialProviders } from \"@better-auth/core/social-providers\";\nimport { createTelemetry } from \"@better-auth/telemetry\";\nimport defu$1, { defu } from \"defu\";\n\n//#region src/utils/constants.ts\nconst DEFAULT_SECRET = \"better-auth-secret-12345678901234567890\";\n\n//#endregion\n//#region src/utils/is-promise.ts\nfunction isPromise(obj) {\n\treturn !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof obj.then === \"function\";\n}\n\n//#endregion\n//#region src/context/helpers.ts\nasync function runPluginInit(ctx) {\n\tlet options = ctx.options;\n\tconst plugins = options.plugins || [];\n\tlet context = ctx;\n\tconst dbHooks = [];\n\tfor (const plugin of plugins) if (plugin.init) {\n\t\tlet initPromise = plugin.init(context);\n\t\tlet result;\n\t\tif (isPromise(initPromise)) result = await initPromise;\n\t\telse result = initPromise;\n\t\tif (typeof result === \"object\") {\n\t\t\tif (result.options) {\n\t\t\t\tconst { databaseHooks, ...restOpts } = result.options;\n\t\t\t\tif (databaseHooks) dbHooks.push(databaseHooks);\n\t\t\t\toptions = defu(options, restOpts);\n\t\t\t}\n\t\t\tif (result.context) context = {\n\t\t\t\t...context,\n\t\t\t\t...result.context\n\t\t\t};\n\t\t}\n\t}\n\tdbHooks.push(options.databaseHooks);\n\tcontext.internalAdapter = createInternalAdapter(context.adapter, {\n\t\toptions,\n\t\tlogger: context.logger,\n\t\thooks: dbHooks.filter((u) => u !== void 0),\n\t\tgenerateId: context.generateId\n\t});\n\tcontext.options = options;\n\treturn { context };\n}\nfunction getInternalPlugins(options) {\n\tconst plugins = [];\n\tif (options.advanced?.crossSubDomainCookies?.enabled) {}\n\treturn plugins;\n}\nfunction getTrustedOrigins(options) {\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath);\n\tif (!baseURL) return [];\n\tconst trustedOrigins = [new URL(baseURL).origin];\n\tif (options.trustedOrigins && Array.isArray(options.trustedOrigins)) trustedOrigins.push(...options.trustedOrigins);\n\tconst envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;\n\tif (envTrustedOrigins) trustedOrigins.push(...envTrustedOrigins.split(\",\"));\n\tif (trustedOrigins.filter((x) => !x).length) throw new BetterAuthError(\"A provided trusted origin is invalid, make sure your trusted origins list is properly defined.\");\n\treturn trustedOrigins;\n}\n\n//#endregion\n//#region src/context/create-context.ts\n/**\n* Estimates the entropy of a string in bits.\n* This is a simple approximation that helps detect low-entropy secrets.\n*/\nfunction estimateEntropy(str) {\n\tconst unique = new Set(str).size;\n\tif (unique === 0) return 0;\n\treturn Math.log2(Math.pow(unique, str.length));\n}\n/**\n* Validates that the secret meets minimum security requirements.\n* Throws BetterAuthError if the secret is invalid.\n* Skips validation for DEFAULT_SECRET in test environments only.\n* Only throws for DEFAULT_SECRET in production environment.\n*/\nfunction validateSecret(secret, logger$1) {\n\tconst isDefaultSecret = secret === DEFAULT_SECRET;\n\tif (isTest()) return;\n\tif (isDefaultSecret && isProduction) throw new BetterAuthError(\"You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.\");\n\tif (!secret) throw new BetterAuthError(\"BETTER_AUTH_SECRET is missing. Set it in your environment or pass `secret` to betterAuth({ secret }).\");\n\tif (secret.length < 32) throw new BetterAuthError(`Invalid BETTER_AUTH_SECRET: must be at least 32 characters long for adequate security. Generate one with \\`npx @better-auth/cli secret\\` or \\`openssl rand -base64 32\\`.`);\n\tif (estimateEntropy(secret) < 120) logger$1.warn(\"[better-auth] Warning: your BETTER_AUTH_SECRET appears low-entropy. Use a randomly generated secret for production.\");\n}\nasync function createAuthContext(adapter, options, getDatabaseType) {\n\tif (!options.database) options = defu$1(options, {\n\t\tsession: { cookieCache: {\n\t\t\tenabled: true,\n\t\t\tstrategy: \"jwe\",\n\t\t\trefreshCache: true\n\t\t} },\n\t\taccount: {\n\t\t\tstoreStateStrategy: \"cookie\",\n\t\t\tstoreAccountCookie: true\n\t\t}\n\t});\n\tconst plugins = options.plugins || [];\n\tconst internalPlugins = getInternalPlugins(options);\n\tconst logger$1 = createLogger(options.logger);\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath);\n\tconst secret = options.secret || env.BETTER_AUTH_SECRET || env.AUTH_SECRET || DEFAULT_SECRET;\n\tvalidateSecret(secret, logger$1);\n\toptions = {\n\t\t...options,\n\t\tsecret,\n\t\tbaseURL: baseURL ? new URL(baseURL).origin : \"\",\n\t\tbasePath: options.basePath || \"/api/auth\",\n\t\tplugins: plugins.concat(internalPlugins)\n\t};\n\tcheckEndpointConflicts(options, logger$1);\n\tconst cookies = getCookies(options);\n\tconst tables = getAuthTables(options);\n\tconst providers = Object.entries(options.socialProviders || {}).map(([key, config]) => {\n\t\tif (config == null) return null;\n\t\tif (config.enabled === false) return null;\n\t\tif (!config.clientId) logger$1.warn(`Social provider ${key} is missing clientId or clientSecret`);\n\t\tconst provider = socialProviders[key](config);\n\t\tprovider.disableImplicitSignUp = config.disableImplicitSignUp;\n\t\treturn provider;\n\t}).filter((x) => x !== null);\n\tconst generateIdFunc = ({ model, size }) => {\n\t\tif (typeof options.advanced?.generateId === \"function\") return options.advanced.generateId({\n\t\t\tmodel,\n\t\t\tsize\n\t\t});\n\t\tif (typeof options?.advanced?.database?.generateId === \"function\") return options.advanced.database.generateId({\n\t\t\tmodel,\n\t\t\tsize\n\t\t});\n\t\treturn generateId(size);\n\t};\n\tconst { publish } = await createTelemetry(options, {\n\t\tadapter: adapter.id,\n\t\tdatabase: typeof options.database === \"function\" ? \"adapter\" : getDatabaseType(options.database)\n\t});\n\tconst initOrPromise = runPluginInit({\n\t\tappName: options.appName || \"Better Auth\",\n\t\tsocialProviders: providers,\n\t\toptions,\n\t\toauthConfig: {\n\t\t\tstoreStateStrategy: options.account?.storeStateStrategy || \"database\",\n\t\t\tskipStateCookieCheck: !!options.account?.skipStateCookieCheck\n\t\t},\n\t\ttables,\n\t\ttrustedOrigins: getTrustedOrigins(options),\n\t\tbaseURL: baseURL || \"\",\n\t\tsessionConfig: {\n\t\t\tupdateAge: options.session?.updateAge !== void 0 ? options.session.updateAge : 1440 * 60,\n\t\t\texpiresIn: options.session?.expiresIn || 3600 * 24 * 7,\n\t\t\tfreshAge: options.session?.freshAge === void 0 ? 3600 * 24 : options.session.freshAge,\n\t\t\tcookieRefreshCache: (() => {\n\t\t\t\tconst refreshCache = options.session?.cookieCache?.refreshCache;\n\t\t\t\tconst maxAge = options.session?.cookieCache?.maxAge || 300;\n\t\t\t\tif (refreshCache === false || refreshCache === void 0) return false;\n\t\t\t\tif (refreshCache === true) return {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tupdateAge: Math.floor(maxAge * .2)\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tupdateAge: refreshCache.updateAge !== void 0 ? refreshCache.updateAge : Math.floor(maxAge * .2)\n\t\t\t\t};\n\t\t\t})()\n\t\t},\n\t\tsecret,\n\t\trateLimit: {\n\t\t\t...options.rateLimit,\n\t\t\tenabled: options.rateLimit?.enabled ?? isProduction,\n\t\t\twindow: options.rateLimit?.window || 10,\n\t\t\tmax: options.rateLimit?.max || 100,\n\t\t\tstorage: options.rateLimit?.storage || (options.secondaryStorage ? \"secondary-storage\" : \"memory\")\n\t\t},\n\t\tauthCookies: cookies,\n\t\tlogger: logger$1,\n\t\tgenerateId: generateIdFunc,\n\t\tsession: null,\n\t\tsecondaryStorage: options.secondaryStorage,\n\t\tpassword: {\n\t\t\thash: options.emailAndPassword?.password?.hash || hashPassword,\n\t\t\tverify: options.emailAndPassword?.password?.verify || verifyPassword,\n\t\t\tconfig: {\n\t\t\t\tminPasswordLength: options.emailAndPassword?.minPasswordLength || 8,\n\t\t\t\tmaxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128\n\t\t\t},\n\t\t\tcheckPassword\n\t\t},\n\t\tsetNewSession(session) {\n\t\t\tthis.newSession = session;\n\t\t},\n\t\tnewSession: null,\n\t\tadapter,\n\t\tinternalAdapter: createInternalAdapter(adapter, {\n\t\t\toptions,\n\t\t\tlogger: logger$1,\n\t\t\thooks: options.databaseHooks ? [options.databaseHooks] : [],\n\t\t\tgenerateId: generateIdFunc\n\t\t}),\n\t\tcreateAuthCookie: createCookieGetter(options),\n\t\tasync runMigrations() {\n\t\t\tthrow new BetterAuthError(\"runMigrations will be set by the specific init implementation\");\n\t\t},\n\t\tpublishTelemetry: publish,\n\t\tskipCSRFCheck: !!options.advanced?.disableCSRFCheck,\n\t\tskipOriginCheck: options.advanced?.disableOriginCheck !== void 0 ? options.advanced.disableOriginCheck : isTest() ? true : false\n\t});\n\tlet context;\n\tif (isPromise(initOrPromise)) ({context} = await initOrPromise);\n\telse ({context} = initOrPromise);\n\treturn context;\n}\n\n//#endregion\n//#region src/auth/base.ts\nconst createBetterAuth = (options, initFn) => {\n\tconst authContext = initFn(options);\n\tconst { api } = getEndpoints(authContext, options);\n\treturn {\n\t\thandler: async (request) => {\n\t\t\tconst ctx = await authContext;\n\t\t\tconst basePath = ctx.options.basePath || \"/api/auth\";\n\t\t\tif (!ctx.options.baseURL) {\n\t\t\t\tconst baseURL = getBaseURL(void 0, basePath, request, void 0, ctx.options.advanced?.trustedProxyHeaders);\n\t\t\t\tif (baseURL) {\n\t\t\t\t\tctx.baseURL = baseURL;\n\t\t\t\t\tctx.options.baseURL = getOrigin(ctx.baseURL) || void 0;\n\t\t\t\t} else throw new BetterAuthError(\"Could not get base URL from request. Please provide a valid base URL.\");\n\t\t\t}\n\t\t\tctx.trustedOrigins = [...options.trustedOrigins ? Array.isArray(options.trustedOrigins) ? options.trustedOrigins : await options.trustedOrigins(request) : [], ctx.options.baseURL];\n\t\t\tconst { handler } = router(ctx, options);\n\t\t\treturn runWithAdapter(ctx.adapter, () => handler(request));\n\t\t},\n\t\tapi,\n\t\toptions,\n\t\t$context: authContext,\n\t\t$ERROR_CODES: {\n\t\t\t...options.plugins?.reduce((acc, plugin) => {\n\t\t\t\tif (plugin.$ERROR_CODES) return {\n\t\t\t\t\t...acc,\n\t\t\t\t\t...plugin.$ERROR_CODES\n\t\t\t\t};\n\t\t\t\treturn acc;\n\t\t\t}, {}),\n\t\t\t...BASE_ERROR_CODES\n\t\t}\n\t};\n};\n\n//#endregion\nexport { createAuthContext as n, createBetterAuth as t };","import { i as toZodSchema } from \"./get-migration-Bf0TuCzm.mjs\";\nimport { t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport { u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as APIError$1 } from \"./api-CkmycQ2x.mjs\";\nimport { c as setSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { a as requestOnlySessionMiddleware, r as getSessionFromCtx, u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { n as parser_default } from \"./parser-pHp5yoAv.mjs\";\nimport { r as defaultRoles } from \"./access-vPNO48H4.mjs\";\nimport { n as hasPermissionFn, t as cacheAllRoles } from \"./permission-JwliMugl.mjs\";\nimport { getCurrentAdapter } from \"@better-auth/core/context\";\nimport { BASE_ERROR_CODES, BetterAuthError } from \"@better-auth/core/error\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\n\n//#region src/utils/shim.ts\nconst shimContext = (originalObject, newContext) => {\n\tconst shimmedObj = {};\n\tfor (const [key, value] of Object.entries(originalObject)) {\n\t\tshimmedObj[key] = (ctx) => {\n\t\t\treturn value({\n\t\t\t\t...ctx,\n\t\t\t\tcontext: {\n\t\t\t\t\t...newContext,\n\t\t\t\t\t...ctx.context\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tshimmedObj[key].path = value.path;\n\t\tshimmedObj[key].method = value.method;\n\t\tshimmedObj[key].options = value.options;\n\t\tshimmedObj[key].headers = value.headers;\n\t}\n\treturn shimmedObj;\n};\n\n//#endregion\n//#region src/plugins/organization/adapter.ts\nconst getOrgAdapter = (context, options) => {\n\tconst baseAdapter = context.adapter;\n\treturn {\n\t\tfindOrganizationBySlug: async (slug) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"organization\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"slug\",\n\t\t\t\t\tvalue: slug\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tcreateOrganization: async (data) => {\n\t\t\tconst organization$1 = await (await getCurrentAdapter(baseAdapter)).create({\n\t\t\t\tmodel: \"organization\",\n\t\t\t\tdata: {\n\t\t\t\t\t...data.organization,\n\t\t\t\t\tmetadata: data.organization.metadata ? JSON.stringify(data.organization.metadata) : void 0\n\t\t\t\t},\n\t\t\t\tforceAllowId: true\n\t\t\t});\n\t\t\treturn {\n\t\t\t\t...organization$1,\n\t\t\t\tmetadata: organization$1.metadata && typeof organization$1.metadata === \"string\" ? JSON.parse(organization$1.metadata) : void 0\n\t\t\t};\n\t\t},\n\t\tfindMemberByEmail: async (data) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tconst user = await adapter.findOne({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"email\",\n\t\t\t\t\tvalue: data.email.toLowerCase()\n\t\t\t\t}]\n\t\t\t});\n\t\t\tif (!user) return null;\n\t\t\tconst member = await adapter.findOne({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: user.id\n\t\t\t\t}]\n\t\t\t});\n\t\t\tif (!member) return null;\n\t\t\treturn {\n\t\t\t\t...member,\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.image\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tlistMembers: async (data) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tconst members = await Promise.all([adapter.findMany({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}, ...data.filter?.field ? [{\n\t\t\t\t\tfield: data.filter?.field,\n\t\t\t\t\tvalue: data.filter?.value\n\t\t\t\t}] : []],\n\t\t\t\tlimit: data.limit || options?.membershipLimit || 100,\n\t\t\t\toffset: data.offset || 0,\n\t\t\t\tsortBy: data.sortBy ? {\n\t\t\t\t\tfield: data.sortBy,\n\t\t\t\t\tdirection: data.sortOrder || \"asc\"\n\t\t\t\t} : void 0\n\t\t\t}), adapter.count({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}, ...data.filter?.field ? [{\n\t\t\t\t\tfield: data.filter?.field,\n\t\t\t\t\tvalue: data.filter?.value\n\t\t\t\t}] : []]\n\t\t\t})]);\n\t\t\tconst users = await adapter.findMany({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: members[0].map((member) => member.userId),\n\t\t\t\t\toperator: \"in\"\n\t\t\t\t}]\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tmembers: members[0].map((member) => {\n\t\t\t\t\tconst user = users.find((user$1) => user$1.id === member.userId);\n\t\t\t\t\tif (!user) throw new BetterAuthError(\"Unexpected error: User not found for member\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...member,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\t\timage: user.image\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\ttotal: members[1]\n\t\t\t};\n\t\t},\n\t\tfindMemberByOrgId: async (data) => {\n\t\t\tconst result = await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: data.userId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}],\n\t\t\t\tjoin: { user: true }\n\t\t\t});\n\t\t\tif (!result || !result.user) return null;\n\t\t\tconst { user, ...member } = result;\n\t\t\treturn {\n\t\t\t\t...member,\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.image\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tfindMemberById: async (memberId) => {\n\t\t\tconst result = await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: memberId\n\t\t\t\t}],\n\t\t\t\tjoin: { user: true }\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { user, ...member } = result;\n\t\t\treturn {\n\t\t\t\t...member,\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.image\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tcreateMember: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).create({\n\t\t\t\tmodel: \"member\",\n\t\t\t\tdata: {\n\t\t\t\t\t...data,\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tupdateMember: async (memberId, role) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).update({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: memberId\n\t\t\t\t}],\n\t\t\t\tupdate: { role }\n\t\t\t});\n\t\t},\n\t\tdeleteMember: async ({ memberId, organizationId, userId: _userId }) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tlet userId;\n\t\t\tif (!_userId) {\n\t\t\t\tconst member$1 = await adapter.findOne({\n\t\t\t\t\tmodel: \"member\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: memberId\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!member$1) throw new BetterAuthError(\"Member not found\");\n\t\t\t\tuserId = member$1.userId;\n\t\t\t} else userId = _userId;\n\t\t\tconst member = await adapter.delete({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: memberId\n\t\t\t\t}]\n\t\t\t});\n\t\t\tif (options?.teams?.enabled) {\n\t\t\t\tconst teams = await adapter.findMany({\n\t\t\t\t\tmodel: \"team\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\t\tvalue: organizationId\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tawait Promise.all(teams.map((team) => adapter.deleteMany({\n\t\t\t\t\tmodel: \"teamMember\",\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\t\tvalue: team.id\n\t\t\t\t\t}, {\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId\n\t\t\t\t\t}]\n\t\t\t\t})));\n\t\t\t}\n\t\t\treturn member;\n\t\t},\n\t\tupdateOrganization: async (organizationId, data) => {\n\t\t\tconst organization$1 = await (await getCurrentAdapter(baseAdapter)).update({\n\t\t\t\tmodel: \"organization\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}],\n\t\t\t\tupdate: {\n\t\t\t\t\t...data,\n\t\t\t\t\tmetadata: typeof data.metadata === \"object\" ? JSON.stringify(data.metadata) : data.metadata\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!organization$1) return null;\n\t\t\treturn {\n\t\t\t\t...organization$1,\n\t\t\t\tmetadata: organization$1.metadata ? parser_default(organization$1.metadata) : void 0\n\t\t\t};\n\t\t},\n\t\tdeleteOrganization: async (organizationId) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tawait adapter.deleteMany({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t\tawait adapter.deleteMany({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t\tawait adapter.delete({\n\t\t\t\tmodel: \"organization\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t\treturn organizationId;\n\t\t},\n\t\tsetActiveOrganization: async (sessionToken, organizationId, ctx) => {\n\t\t\treturn await context.internalAdapter.updateSession(sessionToken, { activeOrganizationId: organizationId });\n\t\t},\n\t\tfindOrganizationById: async (organizationId) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"organization\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tcheckMembership: async ({ userId, organizationId }) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindFullOrganization: async ({ organizationId, isSlug, includeTeams, membersLimit }) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tconst result = await adapter.findOne({\n\t\t\t\tmodel: \"organization\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: isSlug ? \"slug\" : \"id\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}],\n\t\t\t\tjoin: {\n\t\t\t\t\tinvitation: true,\n\t\t\t\t\tmember: membersLimit ? { limit: membersLimit } : true,\n\t\t\t\t\t...includeTeams ? { team: true } : {}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { invitation: invitations, member: members, team: teams, ...org } = result;\n\t\t\tconst userIds = members.map((member) => member.userId);\n\t\t\tconst users = userIds.length > 0 ? await adapter.findMany({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: userIds,\n\t\t\t\t\toperator: \"in\"\n\t\t\t\t}],\n\t\t\t\tlimit: options?.membershipLimit || 100\n\t\t\t}) : [];\n\t\t\tconst userMap = new Map(users.map((user) => [user.id, user]));\n\t\t\tconst membersWithUsers = members.map((member) => {\n\t\t\t\tconst user = userMap.get(member.userId);\n\t\t\t\tif (!user) throw new BetterAuthError(\"Unexpected error: User not found for member\");\n\t\t\t\treturn {\n\t\t\t\t\t...member,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\timage: user.image\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\treturn {\n\t\t\t\t...org,\n\t\t\t\tinvitations,\n\t\t\t\tmembers: membersWithUsers,\n\t\t\t\tteams\n\t\t\t};\n\t\t},\n\t\tlistOrganizations: async (userId) => {\n\t\t\tconst result = await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId\n\t\t\t\t}],\n\t\t\t\tjoin: { organization: true }\n\t\t\t});\n\t\t\tif (!result || result.length === 0) return [];\n\t\t\treturn result.map((member) => member.organization);\n\t\t},\n\t\tcreateTeam: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).create({\n\t\t\t\tmodel: \"team\",\n\t\t\t\tdata\n\t\t\t});\n\t\t},\n\t\tfindTeamById: async ({ teamId, organizationId, includeTeamMembers }) => {\n\t\t\tconst result = await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"team\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: teamId\n\t\t\t\t}, ...organizationId ? [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}] : []],\n\t\t\t\tjoin: { ...includeTeamMembers ? { teamMember: true } : {} }\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { teamMember, ...team } = result;\n\t\t\treturn {\n\t\t\t\t...team,\n\t\t\t\t...includeTeamMembers ? { members: teamMember } : {}\n\t\t\t};\n\t\t},\n\t\tupdateTeam: async (teamId, data) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tif (\"id\" in data) data.id = void 0;\n\t\t\treturn await adapter.update({\n\t\t\t\tmodel: \"team\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: teamId\n\t\t\t\t}],\n\t\t\t\tupdate: { ...data }\n\t\t\t});\n\t\t},\n\t\tdeleteTeam: async (teamId) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tawait adapter.deleteMany({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: teamId\n\t\t\t\t}]\n\t\t\t});\n\t\t\treturn await adapter.delete({\n\t\t\t\tmodel: \"team\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: teamId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tlistTeams: async (organizationId) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"team\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tcreateTeamInvitation: async ({ email, role, teamId, organizationId, inviterId, expiresIn = 1e3 * 60 * 60 * 48 }) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tconst expiresAt = getDate(expiresIn);\n\t\t\treturn await adapter.create({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\tdata: {\n\t\t\t\t\temail,\n\t\t\t\t\trole,\n\t\t\t\t\torganizationId,\n\t\t\t\t\tteamId,\n\t\t\t\t\tinviterId,\n\t\t\t\t\tstatus: \"pending\",\n\t\t\t\t\texpiresAt\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tsetActiveTeam: async (sessionToken, teamId, ctx) => {\n\t\t\treturn await context.internalAdapter.updateSession(sessionToken, { activeTeamId: teamId });\n\t\t},\n\t\tlistTeamMembers: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: data.teamId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tcountTeamMembers: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).count({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: data.teamId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tcountMembers: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).count({\n\t\t\t\tmodel: \"member\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tlistTeamsByUser: async (data) => {\n\t\t\treturn (await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: data.userId\n\t\t\t\t}],\n\t\t\t\tjoin: { team: true }\n\t\t\t})).map((result) => result.team);\n\t\t},\n\t\tfindTeamMember: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: data.teamId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: data.userId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindOrCreateTeamMember: async (data) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tconst member = await adapter.findOne({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: data.teamId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: data.userId\n\t\t\t\t}]\n\t\t\t});\n\t\t\tif (member) return member;\n\t\t\treturn await adapter.create({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\tdata: {\n\t\t\t\t\tteamId: data.teamId,\n\t\t\t\t\tuserId: data.userId,\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tremoveTeamMember: async (data) => {\n\t\t\tawait (await getCurrentAdapter(baseAdapter)).deleteMany({\n\t\t\t\tmodel: \"teamMember\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: data.teamId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: data.userId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindInvitationsByTeamId: async (teamId) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"teamId\",\n\t\t\t\t\tvalue: teamId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tlistUserInvitations: async (email) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"email\",\n\t\t\t\t\tvalue: email.toLowerCase()\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tcreateInvitation: async ({ invitation, user }) => {\n\t\t\tconst adapter = await getCurrentAdapter(baseAdapter);\n\t\t\tconst expiresAt = getDate(options?.invitationExpiresIn || 3600 * 48, \"sec\");\n\t\t\treturn await adapter.create({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\tdata: {\n\t\t\t\t\tstatus: \"pending\",\n\t\t\t\t\texpiresAt,\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\tinviterId: user.id,\n\t\t\t\t\t...invitation,\n\t\t\t\t\tteamId: invitation.teamIds.length > 0 ? invitation.teamIds.join(\",\") : null\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfindInvitationById: async (id) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findOne({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: id\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tfindPendingInvitation: async (data) => {\n\t\t\treturn (await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\tvalue: data.email.toLowerCase()\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"status\",\n\t\t\t\t\t\tvalue: \"pending\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t})).filter((invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date());\n\t\t},\n\t\tfindPendingInvitations: async (data) => {\n\t\t\treturn (await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}, {\n\t\t\t\t\tfield: \"status\",\n\t\t\t\t\tvalue: \"pending\"\n\t\t\t\t}]\n\t\t\t})).filter((invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date());\n\t\t},\n\t\tlistInvitations: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).findMany({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"organizationId\",\n\t\t\t\t\tvalue: data.organizationId\n\t\t\t\t}]\n\t\t\t});\n\t\t},\n\t\tupdateInvitation: async (data) => {\n\t\t\treturn await (await getCurrentAdapter(baseAdapter)).update({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: data.invitationId\n\t\t\t\t}],\n\t\t\t\tupdate: { status: data.status }\n\t\t\t});\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/plugins/organization/call.ts\nconst orgMiddleware = createAuthMiddleware(async () => {\n\treturn {};\n});\n/**\n* The middleware forces the endpoint to require a valid session by utilizing the `sessionMiddleware`.\n* It also appends additional types to the session type regarding organizations.\n*/\nconst orgSessionMiddleware = createAuthMiddleware({ use: [sessionMiddleware] }, async (ctx) => {\n\treturn { session: ctx.context.session };\n});\n\n//#endregion\n//#region src/plugins/organization/error-codes.ts\nconst ORGANIZATION_ERROR_CODES = defineErrorCodes({\n\tYOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION: \"You are not allowed to create a new organization\",\n\tYOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS: \"You have reached the maximum number of organizations\",\n\tORGANIZATION_ALREADY_EXISTS: \"Organization already exists\",\n\tORGANIZATION_SLUG_ALREADY_TAKEN: \"Organization slug already taken\",\n\tORGANIZATION_NOT_FOUND: \"Organization not found\",\n\tUSER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION: \"User is not a member of the organization\",\n\tYOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION: \"You are not allowed to update this organization\",\n\tYOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION: \"You are not allowed to delete this organization\",\n\tNO_ACTIVE_ORGANIZATION: \"No active organization\",\n\tUSER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION: \"User is already a member of this organization\",\n\tMEMBER_NOT_FOUND: \"Member not found\",\n\tROLE_NOT_FOUND: \"Role not found\",\n\tYOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM: \"You are not allowed to create a new team\",\n\tTEAM_ALREADY_EXISTS: \"Team already exists\",\n\tTEAM_NOT_FOUND: \"Team not found\",\n\tYOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER: \"You cannot leave the organization as the only owner\",\n\tYOU_CANNOT_LEAVE_THE_ORGANIZATION_WITHOUT_AN_OWNER: \"You cannot leave the organization without an owner\",\n\tYOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER: \"You are not allowed to delete this member\",\n\tYOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION: \"You are not allowed to invite users to this organization\",\n\tUSER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION: \"User is already invited to this organization\",\n\tINVITATION_NOT_FOUND: \"Invitation not found\",\n\tYOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION: \"You are not the recipient of the invitation\",\n\tEMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION: \"Email verification required before accepting or rejecting invitation\",\n\tYOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION: \"You are not allowed to cancel this invitation\",\n\tINVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION: \"Inviter is no longer a member of the organization\",\n\tYOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE: \"You are not allowed to invite a user with this role\",\n\tFAILED_TO_RETRIEVE_INVITATION: \"Failed to retrieve invitation\",\n\tYOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS: \"You have reached the maximum number of teams\",\n\tUNABLE_TO_REMOVE_LAST_TEAM: \"Unable to remove last team\",\n\tYOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER: \"You are not allowed to update this member\",\n\tORGANIZATION_MEMBERSHIP_LIMIT_REACHED: \"Organization membership limit reached\",\n\tYOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION: \"You are not allowed to create teams in this organization\",\n\tYOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION: \"You are not allowed to delete teams in this organization\",\n\tYOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM: \"You are not allowed to update this team\",\n\tYOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM: \"You are not allowed to delete this team\",\n\tINVITATION_LIMIT_REACHED: \"Invitation limit reached\",\n\tTEAM_MEMBER_LIMIT_REACHED: \"Team member limit reached\",\n\tUSER_IS_NOT_A_MEMBER_OF_THE_TEAM: \"User is not a member of the team\",\n\tYOU_CAN_NOT_ACCESS_THE_MEMBERS_OF_THIS_TEAM: \"You are not allowed to list the members of this team\",\n\tYOU_DO_NOT_HAVE_AN_ACTIVE_TEAM: \"You do not have an active team\",\n\tYOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM_MEMBER: \"You are not allowed to create a new member\",\n\tYOU_ARE_NOT_ALLOWED_TO_REMOVE_A_TEAM_MEMBER: \"You are not allowed to remove a team member\",\n\tYOU_ARE_NOT_ALLOWED_TO_ACCESS_THIS_ORGANIZATION: \"You are not allowed to access this organization as an owner\",\n\tYOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION: \"You are not a member of this organization\",\n\tMISSING_AC_INSTANCE: \"Dynamic Access Control requires a pre-defined ac instance on the server auth plugin. Read server logs for more information\",\n\tYOU_MUST_BE_IN_AN_ORGANIZATION_TO_CREATE_A_ROLE: \"You must be in an organization to create a role\",\n\tYOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE: \"You are not allowed to create a role\",\n\tYOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE: \"You are not allowed to update a role\",\n\tYOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE: \"You are not allowed to delete a role\",\n\tYOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE: \"You are not allowed to read a role\",\n\tYOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE: \"You are not allowed to list a role\",\n\tYOU_ARE_NOT_ALLOWED_TO_GET_A_ROLE: \"You are not allowed to get a role\",\n\tTOO_MANY_ROLES: \"This organization has too many roles\",\n\tINVALID_RESOURCE: \"The provided permission includes an invalid resource\",\n\tROLE_NAME_IS_ALREADY_TAKEN: \"That role name is already taken\",\n\tCANNOT_DELETE_A_PRE_DEFINED_ROLE: \"Cannot delete a pre-defined role\"\n});\n\n//#endregion\n//#region src/plugins/organization/has-permission.ts\nconst hasPermission = async (input, ctx) => {\n\tlet acRoles = { ...input.options.roles || defaultRoles };\n\tif (ctx && input.organizationId && input.options.dynamicAccessControl?.enabled && input.options.ac && !input.useMemoryCache) {\n\t\tconst roles = await ctx.context.adapter.findMany({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: input.organizationId\n\t\t\t}]\n\t\t});\n\t\tfor (const { role, permission: permissionsString } of roles) {\n\t\t\tif (role in acRoles) continue;\n\t\t\tconst result = z.record(z.string(), z.array(z.string())).safeParse(JSON.parse(permissionsString));\n\t\t\tif (!result.success) {\n\t\t\t\tctx.context.logger.error(\"[hasPermission] Invalid permissions for role \" + role, { permissions: JSON.parse(permissionsString) });\n\t\t\t\tthrow new APIError$1(\"INTERNAL_SERVER_ERROR\", { message: \"Invalid permissions for role \" + role });\n\t\t\t}\n\t\t\tacRoles[role] = input.options.ac.newRole(result.data);\n\t\t}\n\t}\n\tif (input.useMemoryCache) acRoles = cacheAllRoles.get(input.organizationId) || acRoles;\n\tcacheAllRoles.set(input.organizationId, acRoles);\n\treturn hasPermissionFn(input, acRoles);\n};\n\n//#endregion\n//#region src/plugins/organization/routes/crud-access-control.ts\nconst normalizeRoleName = (role) => role.toLowerCase();\nconst DEFAULT_MAXIMUM_ROLES_PER_ORGANIZATION = Number.POSITIVE_INFINITY;\nconst getAdditionalFields = (options, shouldBePartial = false) => {\n\tlet additionalFields = options?.schema?.organizationRole?.additionalFields || {};\n\tif (shouldBePartial) for (const key in additionalFields) additionalFields[key].required = false;\n\treturn {\n\t\tadditionalFieldsSchema: toZodSchema({\n\t\t\tfields: additionalFields,\n\t\t\tisClientSide: true\n\t\t}),\n\t\t$AdditionalFields: {},\n\t\t$ReturnAdditionalFields: {}\n\t};\n};\nconst createOrgRole = (options) => {\n\tconst { additionalFieldsSchema, $AdditionalFields, $ReturnAdditionalFields } = getAdditionalFields(options, false);\n\treturn createAuthEndpoint(\"/organization/create-role\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\torganizationId: z.string().optional().meta({ description: \"The id of the organization to create the role in. If not provided, the user's active organization will be used.\" }),\n\t\t\trole: z.string().meta({ description: \"The name of the role to create\" }),\n\t\t\tpermission: z.record(z.string(), z.array(z.string())).meta({ description: \"The permission to assign to the role\" }),\n\t\t\tadditionalFields: z.object({ ...additionalFieldsSchema.shape }).optional()\n\t\t}),\n\t\tmetadata: { $Infer: { body: {} } },\n\t\trequireHeaders: true,\n\t\tuse: [orgSessionMiddleware]\n\t}, async (ctx) => {\n\t\tconst { session, user } = ctx.context.session;\n\t\tlet roleName = ctx.body.role;\n\t\tconst permission = ctx.body.permission;\n\t\tconst additionalFields = ctx.body.additionalFields;\n\t\tconst ac = options.ac;\n\t\tif (!ac) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The organization plugin is missing a pre-defined ac instance.`, `\\nPlease refer to the documentation here: https://better-auth.com/docs/plugins/organization#dynamic-access-control`);\n\t\t\tthrow new APIError$1(\"NOT_IMPLEMENTED\", { message: ORGANIZATION_ERROR_CODES.MISSING_AC_INSTANCE });\n\t\t}\n\t\tconst organizationId = ctx.body.organizationId ?? session.activeOrganizationId;\n\t\tif (!organizationId) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to create a role. Either set an active org id, or pass an organizationId in the request body.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_MUST_BE_IN_AN_ORGANIZATION_TO_CREATE_A_ROLE });\n\t\t}\n\t\troleName = normalizeRoleName(roleName);\n\t\tawait checkIfRoleNameIsTakenByPreDefinedRole({\n\t\t\trole: roleName,\n\t\t\torganizationId,\n\t\t\toptions,\n\t\t\tctx\n\t\t});\n\t\tconst member = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, {\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: user.id,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\tif (!member) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to create a role.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\t}\n\t\tif (!await hasPermission({\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\tpermissions: { ac: [\"create\"] },\n\t\t\trole: member.role\n\t\t}, ctx)) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to create a role. If this is unexpected, please make sure the role associated to that member has the \"ac\" resource with the \"create\" permission.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId,\n\t\t\t\trole: member.role\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE });\n\t\t}\n\t\tconst maximumRolesPerOrganization = typeof options.dynamicAccessControl?.maximumRolesPerOrganization === \"function\" ? await options.dynamicAccessControl.maximumRolesPerOrganization(organizationId) : options.dynamicAccessControl?.maximumRolesPerOrganization ?? DEFAULT_MAXIMUM_ROLES_PER_ORGANIZATION;\n\t\tconst rolesInDB = await ctx.context.adapter.count({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\tif (rolesInDB >= maximumRolesPerOrganization) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] Failed to create a new role, the organization has too many roles. Maximum allowed roles is ${maximumRolesPerOrganization}.`, {\n\t\t\t\torganizationId,\n\t\t\t\tmaximumRolesPerOrganization,\n\t\t\t\trolesInDB\n\t\t\t});\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TOO_MANY_ROLES });\n\t\t}\n\t\tawait checkForInvalidResources({\n\t\t\tac,\n\t\t\tctx,\n\t\t\tpermission\n\t\t});\n\t\tawait checkIfMemberHasPermission({\n\t\t\tctx,\n\t\t\tmember,\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\tpermissionRequired: permission,\n\t\t\tuser,\n\t\t\taction: \"create\"\n\t\t});\n\t\tawait checkIfRoleNameIsTakenByRoleInDB({\n\t\t\tctx,\n\t\t\torganizationId,\n\t\t\trole: roleName\n\t\t});\n\t\tconst newRole = ac.newRole(permission);\n\t\tconst data = {\n\t\t\t...await ctx.context.adapter.create({\n\t\t\t\tmodel: \"organizationRole\",\n\t\t\t\tdata: {\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\torganizationId,\n\t\t\t\t\tpermission: JSON.stringify(permission),\n\t\t\t\t\trole: roleName,\n\t\t\t\t\t...additionalFields\n\t\t\t\t}\n\t\t\t}),\n\t\t\tpermission\n\t\t};\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\troleData: data,\n\t\t\tstatements: newRole.statements\n\t\t});\n\t});\n};\nconst deleteOrgRole = (options) => {\n\treturn createAuthEndpoint(\"/organization/delete-role\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({ organizationId: z.string().optional().meta({ description: \"The id of the organization to create the role in. If not provided, the user's active organization will be used.\" }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: \"The name of the role to delete\" }) }), z.object({ roleId: z.string().nonempty().meta({ description: \"The id of the role to delete\" }) })])),\n\t\trequireHeaders: true,\n\t\tuse: [orgSessionMiddleware],\n\t\tmetadata: { $Infer: { body: {} } }\n\t}, async (ctx) => {\n\t\tconst { session, user } = ctx.context.session;\n\t\tconst organizationId = ctx.body.organizationId ?? session.activeOrganizationId;\n\t\tif (!organizationId) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to delete a role. Either set an active org id, or pass an organizationId in the request body.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\t\t}\n\t\tconst member = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, {\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: user.id,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\tif (!member) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to delete a role.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\t}\n\t\tif (!await hasPermission({\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\tpermissions: { ac: [\"delete\"] },\n\t\t\trole: member.role\n\t\t}, ctx)) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to delete a role. If this is unexpected, please make sure the role associated to that member has the \"ac\" resource with the \"delete\" permission.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId,\n\t\t\t\trole: member.role\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE });\n\t\t}\n\t\tif (ctx.body.roleName) {\n\t\t\tconst roleName = ctx.body.roleName;\n\t\t\tconst defaultRoles$2 = options.roles ? Object.keys(options.roles) : [\n\t\t\t\t\"owner\",\n\t\t\t\t\"admin\",\n\t\t\t\t\"member\"\n\t\t\t];\n\t\t\tif (defaultRoles$2.includes(roleName)) {\n\t\t\t\tctx.context.logger.error(`[Dynamic Access Control] Cannot delete a pre-defined role.`, {\n\t\t\t\t\troleName,\n\t\t\t\t\torganizationId,\n\t\t\t\t\tdefaultRoles: defaultRoles$2\n\t\t\t\t});\n\t\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.CANNOT_DELETE_A_PRE_DEFINED_ROLE });\n\t\t\t}\n\t\t}\n\t\tlet condition;\n\t\tif (ctx.body.roleName) condition = {\n\t\t\tfield: \"role\",\n\t\t\tvalue: ctx.body.roleName,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t};\n\t\telse if (ctx.body.roleId) condition = {\n\t\t\tfield: \"id\",\n\t\t\tvalue: ctx.body.roleId,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t};\n\t\telse {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request body.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });\n\t\t}\n\t\tconst existingRoleInDB = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, condition]\n\t\t});\n\t\tif (!existingRoleInDB) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {\n\t\t\t\t...\"roleName\" in ctx.body ? { roleName: ctx.body.roleName } : { roleId: ctx.body.roleId },\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });\n\t\t}\n\t\texistingRoleInDB.permission = JSON.parse(existingRoleInDB.permission);\n\t\tawait ctx.context.adapter.delete({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, condition]\n\t\t});\n\t\treturn ctx.json({ success: true });\n\t});\n};\nconst listOrgRoles = (options) => {\n\tconst { $ReturnAdditionalFields } = getAdditionalFields(options, false);\n\treturn createAuthEndpoint(\"/organization/list-roles\", {\n\t\tmethod: \"GET\",\n\t\trequireHeaders: true,\n\t\tuse: [orgSessionMiddleware],\n\t\tquery: z.object({ organizationId: z.string().optional().meta({ description: \"The id of the organization to list roles for. If not provided, the user's active organization will be used.\" }) }).optional()\n\t}, async (ctx) => {\n\t\tconst { session, user } = ctx.context.session;\n\t\tconst organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;\n\t\tif (!organizationId) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to list roles. Either set an active org id, or pass an organizationId in the request query.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\t\t}\n\t\tconst member = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, {\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: user.id,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\tif (!member) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to list roles.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\t}\n\t\tif (!await hasPermission({\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\tpermissions: { ac: [\"read\"] },\n\t\t\trole: member.role\n\t\t}, ctx)) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to list roles.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId,\n\t\t\t\trole: member.role\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE });\n\t\t}\n\t\tlet roles = await ctx.context.adapter.findMany({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\troles = roles.map((x) => ({\n\t\t\t...x,\n\t\t\tpermission: JSON.parse(x.permission)\n\t\t}));\n\t\treturn ctx.json(roles);\n\t});\n};\nconst getOrgRole = (options) => {\n\tconst { $ReturnAdditionalFields } = getAdditionalFields(options, false);\n\treturn createAuthEndpoint(\"/organization/get-role\", {\n\t\tmethod: \"GET\",\n\t\trequireHeaders: true,\n\t\tuse: [orgSessionMiddleware],\n\t\tquery: z.object({ organizationId: z.string().optional().meta({ description: \"The id of the organization to read a role for. If not provided, the user's active organization will be used.\" }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: \"The name of the role to read\" }) }), z.object({ roleId: z.string().nonempty().meta({ description: \"The id of the role to read\" }) })])).optional(),\n\t\tmetadata: { $Infer: { query: {} } }\n\t}, async (ctx) => {\n\t\tconst { session, user } = ctx.context.session;\n\t\tconst organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;\n\t\tif (!organizationId) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to read a role. Either set an active org id, or pass an organizationId in the request query.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\t\t}\n\t\tconst member = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, {\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: user.id,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\tif (!member) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to read a role.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\t}\n\t\tif (!await hasPermission({\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\tpermissions: { ac: [\"read\"] },\n\t\t\trole: member.role\n\t\t}, ctx)) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to read a role.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId,\n\t\t\t\trole: member.role\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE });\n\t\t}\n\t\tlet condition;\n\t\tif (ctx.query.roleName) condition = {\n\t\t\tfield: \"role\",\n\t\t\tvalue: ctx.query.roleName,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t};\n\t\telse if (ctx.query.roleId) condition = {\n\t\t\tfield: \"id\",\n\t\t\tvalue: ctx.query.roleId,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t};\n\t\telse {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request query.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });\n\t\t}\n\t\tlet role = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, condition]\n\t\t});\n\t\tif (!role) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {\n\t\t\t\t...\"roleName\" in ctx.query ? { roleName: ctx.query.roleName } : { roleId: ctx.query.roleId },\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });\n\t\t}\n\t\trole.permission = JSON.parse(role.permission);\n\t\treturn ctx.json(role);\n\t});\n};\nconst updateOrgRole = (options) => {\n\tconst { additionalFieldsSchema, $AdditionalFields, $ReturnAdditionalFields } = getAdditionalFields(options, true);\n\treturn createAuthEndpoint(\"/organization/update-role\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\torganizationId: z.string().optional().meta({ description: \"The id of the organization to update the role in. If not provided, the user's active organization will be used.\" }),\n\t\t\tdata: z.object({\n\t\t\t\tpermission: z.record(z.string(), z.array(z.string())).optional().meta({ description: \"The permission to update the role with\" }),\n\t\t\t\troleName: z.string().optional().meta({ description: \"The name of the role to update\" }),\n\t\t\t\t...additionalFieldsSchema.shape\n\t\t\t})\n\t\t}).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: \"The name of the role to update\" }) }), z.object({ roleId: z.string().nonempty().meta({ description: \"The id of the role to update\" }) })])),\n\t\tmetadata: { $Infer: { body: {} } },\n\t\trequireHeaders: true,\n\t\tuse: [orgSessionMiddleware]\n\t}, async (ctx) => {\n\t\tconst { session, user } = ctx.context.session;\n\t\tconst ac = options.ac;\n\t\tif (!ac) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The organization plugin is missing a pre-defined ac instance.`, `\\nPlease refer to the documentation here: https://better-auth.com/docs/plugins/organization#dynamic-access-control`);\n\t\t\tthrow new APIError$1(\"NOT_IMPLEMENTED\", { message: ORGANIZATION_ERROR_CODES.MISSING_AC_INSTANCE });\n\t\t}\n\t\tconst organizationId = ctx.body.organizationId ?? session.activeOrganizationId;\n\t\tif (!organizationId) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to update a role. Either set an active org id, or pass an organizationId in the request body.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\t\t}\n\t\tconst member = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, {\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: user.id,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}]\n\t\t});\n\t\tif (!member) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to update a role.`, {\n\t\t\t\tuserId: user.id,\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\t}\n\t\tif (!await hasPermission({\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\trole: member.role,\n\t\t\tpermissions: { ac: [\"update\"] }\n\t\t}, ctx)) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to update a role.`);\n\t\t\tthrow new APIError$1(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE });\n\t\t}\n\t\tlet condition;\n\t\tif (ctx.body.roleName) condition = {\n\t\t\tfield: \"role\",\n\t\t\tvalue: ctx.body.roleName,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t};\n\t\telse if (ctx.body.roleId) condition = {\n\t\t\tfield: \"id\",\n\t\t\tvalue: ctx.body.roleId,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t};\n\t\telse {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request body.`);\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });\n\t\t}\n\t\tlet role = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, condition]\n\t\t});\n\t\tif (!role) {\n\t\t\tctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {\n\t\t\t\t...\"roleName\" in ctx.body ? { roleName: ctx.body.roleName } : { roleId: ctx.body.roleId },\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });\n\t\t}\n\t\trole.permission = role.permission ? JSON.parse(role.permission) : void 0;\n\t\tconst { permission: _, roleName: __, ...additionalFields } = ctx.body.data;\n\t\tlet updateData = { ...additionalFields };\n\t\tif (ctx.body.data.permission) {\n\t\t\tlet newPermission = ctx.body.data.permission;\n\t\t\tawait checkForInvalidResources({\n\t\t\t\tac,\n\t\t\t\tctx,\n\t\t\t\tpermission: newPermission\n\t\t\t});\n\t\t\tawait checkIfMemberHasPermission({\n\t\t\t\tctx,\n\t\t\t\tmember,\n\t\t\t\toptions,\n\t\t\t\torganizationId,\n\t\t\t\tpermissionRequired: newPermission,\n\t\t\t\tuser,\n\t\t\t\taction: \"update\"\n\t\t\t});\n\t\t\tupdateData.permission = newPermission;\n\t\t}\n\t\tif (ctx.body.data.roleName) {\n\t\t\tlet newRoleName = ctx.body.data.roleName;\n\t\t\tnewRoleName = normalizeRoleName(newRoleName);\n\t\t\tawait checkIfRoleNameIsTakenByPreDefinedRole({\n\t\t\t\trole: newRoleName,\n\t\t\t\torganizationId,\n\t\t\t\toptions,\n\t\t\t\tctx\n\t\t\t});\n\t\t\tawait checkIfRoleNameIsTakenByRoleInDB({\n\t\t\t\trole: newRoleName,\n\t\t\t\torganizationId,\n\t\t\t\tctx\n\t\t\t});\n\t\t\tupdateData.role = newRoleName;\n\t\t}\n\t\tconst update = {\n\t\t\t...updateData,\n\t\t\t...updateData.permission ? { permission: JSON.stringify(updateData.permission) } : {}\n\t\t};\n\t\tawait ctx.context.adapter.update({\n\t\t\tmodel: \"organizationRole\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tconnector: \"AND\"\n\t\t\t}, condition],\n\t\t\tupdate\n\t\t});\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\troleData: {\n\t\t\t\t...role,\n\t\t\t\t...update,\n\t\t\t\tpermission: updateData.permission || role.permission || null\n\t\t\t}\n\t\t});\n\t});\n};\nasync function checkForInvalidResources({ ac, ctx, permission }) {\n\tconst validResources = Object.keys(ac.statements);\n\tconst providedResources = Object.keys(permission);\n\tif (providedResources.some((r) => !validResources.includes(r))) {\n\t\tctx.context.logger.error(`[Dynamic Access Control] The provided permission includes an invalid resource.`, {\n\t\t\tprovidedResources,\n\t\t\tvalidResources\n\t\t});\n\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.INVALID_RESOURCE });\n\t}\n}\nasync function checkIfMemberHasPermission({ ctx, permissionRequired: permission, options, organizationId, member, user, action }) {\n\tconst hasNecessaryPermissions = [];\n\tconst permissionEntries = Object.entries(permission);\n\tfor await (const [resource, permissions] of permissionEntries) for await (const perm of permissions) hasNecessaryPermissions.push({\n\t\tresource: { [resource]: [perm] },\n\t\thasPermission: await hasPermission({\n\t\t\toptions,\n\t\t\torganizationId,\n\t\t\tpermissions: { [resource]: [perm] },\n\t\t\tuseMemoryCache: true,\n\t\t\trole: member.role\n\t\t}, ctx)\n\t});\n\tconst missingPermissions = hasNecessaryPermissions.filter((x) => x.hasPermission === false).map((x) => {\n\t\tconst key = Object.keys(x.resource)[0];\n\t\treturn `${key}:${x.resource[key][0]}`;\n\t});\n\tif (missingPermissions.length > 0) {\n\t\tctx.context.logger.error(`[Dynamic Access Control] The user is missing permissions necessary to ${action} a role with those set of permissions.\\n`, {\n\t\t\tuserId: user.id,\n\t\t\torganizationId,\n\t\t\trole: member.role,\n\t\t\tmissingPermissions\n\t\t});\n\t\tlet errorMessage;\n\t\tif (action === \"create\") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE;\n\t\telse if (action === \"update\") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE;\n\t\telse if (action === \"delete\") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE;\n\t\telse if (action === \"read\") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE;\n\t\telse if (action === \"list\") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE;\n\t\telse errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_A_ROLE;\n\t\tthrow new APIError$1(\"FORBIDDEN\", {\n\t\t\tmessage: errorMessage,\n\t\t\tmissingPermissions\n\t\t});\n\t}\n}\nasync function checkIfRoleNameIsTakenByPreDefinedRole({ options, organizationId, role, ctx }) {\n\tconst defaultRoles$2 = options.roles ? Object.keys(options.roles) : [\n\t\t\"owner\",\n\t\t\"admin\",\n\t\t\"member\"\n\t];\n\tif (defaultRoles$2.includes(role)) {\n\t\tctx.context.logger.error(`[Dynamic Access Control] The role name \"${role}\" is already taken by a pre-defined role.`, {\n\t\t\trole,\n\t\t\torganizationId,\n\t\t\tdefaultRoles: defaultRoles$2\n\t\t});\n\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NAME_IS_ALREADY_TAKEN });\n\t}\n}\nasync function checkIfRoleNameIsTakenByRoleInDB({ organizationId, role, ctx }) {\n\tif (await ctx.context.adapter.findOne({\n\t\tmodel: \"organizationRole\",\n\t\twhere: [{\n\t\t\tfield: \"organizationId\",\n\t\t\tvalue: organizationId,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t}, {\n\t\t\tfield: \"role\",\n\t\t\tvalue: role,\n\t\t\toperator: \"eq\",\n\t\t\tconnector: \"AND\"\n\t\t}]\n\t})) {\n\t\tctx.context.logger.error(`[Dynamic Access Control] The role name \"${role}\" is already taken by a role in the database.`, {\n\t\t\trole,\n\t\t\torganizationId\n\t\t});\n\t\tthrow new APIError$1(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ROLE_NAME_IS_ALREADY_TAKEN });\n\t}\n}\n\n//#endregion\n//#region src/plugins/organization/routes/crud-invites.ts\nconst createInvitation = (option) => {\n\tconst additionalFieldsSchema = toZodSchema({\n\t\tfields: option?.schema?.invitation?.additionalFields || {},\n\t\tisClientSide: true\n\t});\n\tconst baseSchema = z.object({\n\t\temail: z.string().meta({ description: \"The email address of the user to invite\" }),\n\t\trole: z.union([z.string().meta({ description: \"The role to assign to the user\" }), z.array(z.string().meta({ description: \"The roles to assign to the user\" }))]).meta({ description: \"The role(s) to assign to the user. It can be `admin`, `member`, owner. Eg: \\\"member\\\"\" }),\n\t\torganizationId: z.string().meta({ description: \"The organization ID to invite the user to\" }).optional(),\n\t\tresend: z.boolean().meta({ description: \"Resend the invitation email, if the user is already invited. Eg: true\" }).optional(),\n\t\tteamId: z.union([z.string().meta({ description: \"The team ID to invite the user to\" }).optional(), z.array(z.string()).meta({ description: \"The team IDs to invite the user to\" }).optional()])\n\t});\n\treturn createAuthEndpoint(\"/organization/invite-member\", {\n\t\tmethod: \"POST\",\n\t\trequireHeaders: true,\n\t\tuse: [orgMiddleware, orgSessionMiddleware],\n\t\tbody: z.object({\n\t\t\t...baseSchema.shape,\n\t\t\t...additionalFieldsSchema.shape\n\t\t}),\n\t\tmetadata: {\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\toperationId: \"createOrganizationInvitation\",\n\t\t\t\tdescription: \"Create an invitation to an organization\",\n\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\t\t\temail: { type: \"string\" },\n\t\t\t\t\t\t\trole: { type: \"string\" },\n\t\t\t\t\t\t\torganizationId: { type: \"string\" },\n\t\t\t\t\t\t\tinviterId: { type: \"string\" },\n\t\t\t\t\t\t\tstatus: { type: \"string\" },\n\t\t\t\t\t\t\texpiresAt: { type: \"string\" },\n\t\t\t\t\t\t\tcreatedAt: { type: \"string\" }\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\"role\",\n\t\t\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\t\t\"inviterId\",\n\t\t\t\t\t\t\t\"status\",\n\t\t\t\t\t\t\t\"expiresAt\",\n\t\t\t\t\t\t\t\"createdAt\"\n\t\t\t\t\t\t]\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst session = ctx.context.session;\n\t\tconst organizationId = ctx.body.organizationId || session.session.activeOrganizationId;\n\t\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tconst email = ctx.body.email.toLowerCase();\n\t\tif (!z.email().safeParse(email).success) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_EMAIL });\n\t\tconst adapter = getOrgAdapter(ctx.context, option);\n\t\tconst member = await adapter.findMemberByOrgId({\n\t\t\tuserId: session.user.id,\n\t\t\torganizationId\n\t\t});\n\t\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\t\tif (!await hasPermission({\n\t\t\trole: member.role,\n\t\t\toptions: ctx.context.orgOptions,\n\t\t\tpermissions: { invitation: [\"create\"] },\n\t\t\torganizationId\n\t\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION });\n\t\tconst creatorRole = ctx.context.orgOptions.creatorRole || \"owner\";\n\t\tconst roles = parseRoles(ctx.body.role);\n\t\tif (member.role !== creatorRole && roles.split(\",\").includes(creatorRole)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE });\n\t\tif (await adapter.findMemberByEmail({\n\t\t\temail,\n\t\t\torganizationId\n\t\t})) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\tconst alreadyInvited = await adapter.findPendingInvitation({\n\t\t\temail,\n\t\t\torganizationId\n\t\t});\n\t\tif (alreadyInvited.length && !ctx.body.resend) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION });\n\t\tconst organization$1 = await adapter.findOrganizationById(organizationId);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tif (alreadyInvited.length && ctx.body.resend) {\n\t\t\tconst existingInvitation = alreadyInvited[0];\n\t\t\tconst newExpiresAt = getDate(ctx.context.orgOptions.invitationExpiresIn || 3600 * 48, \"sec\");\n\t\t\tawait ctx.context.adapter.update({\n\t\t\t\tmodel: \"invitation\",\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: existingInvitation.id\n\t\t\t\t}],\n\t\t\t\tupdate: { expiresAt: newExpiresAt }\n\t\t\t});\n\t\t\tconst updatedInvitation = {\n\t\t\t\t...existingInvitation,\n\t\t\t\texpiresAt: newExpiresAt\n\t\t\t};\n\t\t\tawait ctx.context.orgOptions.sendInvitationEmail?.({\n\t\t\t\tid: updatedInvitation.id,\n\t\t\t\trole: updatedInvitation.role,\n\t\t\t\temail: updatedInvitation.email.toLowerCase(),\n\t\t\t\torganization: organization$1,\n\t\t\t\tinviter: {\n\t\t\t\t\t...member,\n\t\t\t\t\tuser: session.user\n\t\t\t\t},\n\t\t\t\tinvitation: updatedInvitation\n\t\t\t}, ctx.request);\n\t\t\treturn ctx.json(updatedInvitation);\n\t\t}\n\t\tif (alreadyInvited.length && ctx.context.orgOptions.cancelPendingInvitationsOnReInvite) await adapter.updateInvitation({\n\t\t\tinvitationId: alreadyInvited[0].id,\n\t\t\tstatus: \"canceled\"\n\t\t});\n\t\tconst invitationLimit = typeof ctx.context.orgOptions.invitationLimit === \"function\" ? await ctx.context.orgOptions.invitationLimit({\n\t\t\tuser: session.user,\n\t\t\torganization: organization$1,\n\t\t\tmember\n\t\t}, ctx.context) : ctx.context.orgOptions.invitationLimit ?? 100;\n\t\tif ((await adapter.findPendingInvitations({ organizationId })).length >= invitationLimit) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.INVITATION_LIMIT_REACHED });\n\t\tif (ctx.context.orgOptions.teams && ctx.context.orgOptions.teams.enabled && typeof ctx.context.orgOptions.teams.maximumMembersPerTeam !== \"undefined\" && \"teamId\" in ctx.body && ctx.body.teamId) {\n\t\t\tconst teamIds$1 = typeof ctx.body.teamId === \"string\" ? [ctx.body.teamId] : ctx.body.teamId;\n\t\t\tfor (const teamId of teamIds$1) {\n\t\t\t\tconst team = await adapter.findTeamById({\n\t\t\t\t\tteamId,\n\t\t\t\t\torganizationId,\n\t\t\t\t\tincludeTeamMembers: true\n\t\t\t\t});\n\t\t\t\tif (!team) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\t\t\t\tconst maximumMembersPerTeam = typeof ctx.context.orgOptions.teams.maximumMembersPerTeam === \"function\" ? await ctx.context.orgOptions.teams.maximumMembersPerTeam({\n\t\t\t\t\tteamId,\n\t\t\t\t\tsession,\n\t\t\t\t\torganizationId\n\t\t\t\t}) : ctx.context.orgOptions.teams.maximumMembersPerTeam;\n\t\t\t\tif (team.members.length >= maximumMembersPerTeam) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.TEAM_MEMBER_LIMIT_REACHED });\n\t\t\t}\n\t\t}\n\t\tconst teamIds = \"teamId\" in ctx.body ? typeof ctx.body.teamId === \"string\" ? [ctx.body.teamId] : ctx.body.teamId ?? [] : [];\n\t\tconst { email: _, role: __, organizationId: ___, resend: ____, ...additionalFields } = ctx.body;\n\t\tlet invitationData = {\n\t\t\trole: roles,\n\t\t\temail,\n\t\t\torganizationId,\n\t\t\tteamIds,\n\t\t\t...additionalFields ? additionalFields : {}\n\t\t};\n\t\tif (option?.organizationHooks?.beforeCreateInvitation) {\n\t\t\tconst response = await option?.organizationHooks.beforeCreateInvitation({\n\t\t\t\tinvitation: {\n\t\t\t\t\t...invitationData,\n\t\t\t\t\tinviterId: session.user.id,\n\t\t\t\t\tteamId: teamIds.length > 0 ? teamIds[0] : void 0\n\t\t\t\t},\n\t\t\t\tinviter: session.user,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) invitationData = {\n\t\t\t\t...invitationData,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tconst invitation = await adapter.createInvitation({\n\t\t\tinvitation: invitationData,\n\t\t\tuser: session.user\n\t\t});\n\t\tawait ctx.context.orgOptions.sendInvitationEmail?.({\n\t\t\tid: invitation.id,\n\t\t\trole: invitation.role,\n\t\t\temail: invitation.email.toLowerCase(),\n\t\t\torganization: organization$1,\n\t\t\tinviter: {\n\t\t\t\t...member,\n\t\t\t\tuser: session.user\n\t\t\t},\n\t\t\tinvitation\n\t\t}, ctx.request);\n\t\tif (option?.organizationHooks?.afterCreateInvitation) await option?.organizationHooks.afterCreateInvitation({\n\t\t\tinvitation,\n\t\t\tinviter: session.user,\n\t\t\torganization: organization$1\n\t\t});\n\t\treturn ctx.json(invitation);\n\t});\n};\nconst acceptInvitation = (options) => createAuthEndpoint(\"/organization/accept-invitation\", {\n\tmethod: \"POST\",\n\tbody: z.object({ invitationId: z.string().meta({ description: \"The ID of the invitation to accept\" }) }),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Accept an invitation to an organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tinvitation: { type: \"object\" },\n\t\t\t\t\tmember: { type: \"object\" }\n\t\t\t\t}\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tconst invitation = await adapter.findInvitationById(ctx.body.invitationId);\n\tif (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== \"pending\") throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND });\n\tif (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });\n\tif (ctx.context.orgOptions.requireEmailVerificationOnInvitation && !session.user.emailVerified) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION });\n\tconst membershipLimit = ctx.context.orgOptions?.membershipLimit || 100;\n\tif (await adapter.countMembers({ organizationId: invitation.organizationId }) >= membershipLimit) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_MEMBERSHIP_LIMIT_REACHED });\n\tconst organization$1 = await adapter.findOrganizationById(invitation.organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tif (options?.organizationHooks?.beforeAcceptInvitation) await options?.organizationHooks.beforeAcceptInvitation({\n\t\tinvitation,\n\t\tuser: session.user,\n\t\torganization: organization$1\n\t});\n\tconst acceptedI = await adapter.updateInvitation({\n\t\tinvitationId: ctx.body.invitationId,\n\t\tstatus: \"accepted\"\n\t});\n\tif (!acceptedI) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.FAILED_TO_RETRIEVE_INVITATION });\n\tif (ctx.context.orgOptions.teams && ctx.context.orgOptions.teams.enabled && \"teamId\" in acceptedI && acceptedI.teamId) {\n\t\tconst teamIds = acceptedI.teamId.split(\",\");\n\t\tconst onlyOne = teamIds.length === 1;\n\t\tfor (const teamId of teamIds) {\n\t\t\tawait adapter.findOrCreateTeamMember({\n\t\t\t\tteamId,\n\t\t\t\tuserId: session.user.id\n\t\t\t});\n\t\t\tif (typeof ctx.context.orgOptions.teams.maximumMembersPerTeam !== \"undefined\") {\n\t\t\t\tif (await adapter.countTeamMembers({ teamId }) >= (typeof ctx.context.orgOptions.teams.maximumMembersPerTeam === \"function\" ? await ctx.context.orgOptions.teams.maximumMembersPerTeam({\n\t\t\t\t\tteamId,\n\t\t\t\t\tsession,\n\t\t\t\t\torganizationId: invitation.organizationId\n\t\t\t\t}) : ctx.context.orgOptions.teams.maximumMembersPerTeam)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.TEAM_MEMBER_LIMIT_REACHED });\n\t\t\t}\n\t\t}\n\t\tif (onlyOne) {\n\t\t\tconst teamId = teamIds[0];\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: await adapter.setActiveTeam(session.session.token, teamId, ctx),\n\t\t\t\tuser: session.user\n\t\t\t});\n\t\t}\n\t}\n\tconst member = await adapter.createMember({\n\t\torganizationId: invitation.organizationId,\n\t\tuserId: session.user.id,\n\t\trole: invitation.role,\n\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t});\n\tawait adapter.setActiveOrganization(session.session.token, invitation.organizationId, ctx);\n\tif (!acceptedI) return ctx.json(null, {\n\t\tstatus: 400,\n\t\tbody: { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND }\n\t});\n\tif (options?.organizationHooks?.afterAcceptInvitation) await options?.organizationHooks.afterAcceptInvitation({\n\t\tinvitation: acceptedI,\n\t\tmember,\n\t\tuser: session.user,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json({\n\t\tinvitation: acceptedI,\n\t\tmember\n\t});\n});\nconst rejectInvitation = (options) => createAuthEndpoint(\"/organization/reject-invitation\", {\n\tmethod: \"POST\",\n\tbody: z.object({ invitationId: z.string().meta({ description: \"The ID of the invitation to reject\" }) }),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Reject an invitation to an organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tinvitation: { type: \"object\" },\n\t\t\t\t\tmember: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tnullable: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);\n\tconst invitation = await adapter.findInvitationById(ctx.body.invitationId);\n\tif (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== \"pending\") throw new APIError(\"BAD_REQUEST\", { message: \"Invitation not found!\" });\n\tif (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });\n\tif (ctx.context.orgOptions.requireEmailVerificationOnInvitation && !session.user.emailVerified) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION });\n\tconst organization$1 = await adapter.findOrganizationById(invitation.organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tif (options?.organizationHooks?.beforeRejectInvitation) await options?.organizationHooks.beforeRejectInvitation({\n\t\tinvitation,\n\t\tuser: session.user,\n\t\torganization: organization$1\n\t});\n\tconst rejectedI = await adapter.updateInvitation({\n\t\tinvitationId: ctx.body.invitationId,\n\t\tstatus: \"rejected\"\n\t});\n\tif (options?.organizationHooks?.afterRejectInvitation) await options?.organizationHooks.afterRejectInvitation({\n\t\tinvitation: rejectedI || invitation,\n\t\tuser: session.user,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json({\n\t\tinvitation: rejectedI,\n\t\tmember: null\n\t});\n});\nconst cancelInvitation = (options) => createAuthEndpoint(\"/organization/cancel-invitation\", {\n\tmethod: \"POST\",\n\tbody: z.object({ invitationId: z.string().meta({ description: \"The ID of the invitation to cancel\" }) }),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\topenapi: {\n\t\toperationId: \"cancelOrganizationInvitation\",\n\t\tdescription: \"Cancel an invitation to an organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { invitation: { type: \"object\" } }\n\t\t\t} } }\n\t\t} }\n\t}\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tconst invitation = await adapter.findInvitationById(ctx.body.invitationId);\n\tif (!invitation) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND });\n\tconst member = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId: invitation.organizationId\n\t});\n\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tif (!await hasPermission({\n\t\trole: member.role,\n\t\toptions: ctx.context.orgOptions,\n\t\tpermissions: { invitation: [\"cancel\"] },\n\t\torganizationId: invitation.organizationId\n\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION });\n\tconst organization$1 = await adapter.findOrganizationById(invitation.organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tif (options?.organizationHooks?.beforeCancelInvitation) await options?.organizationHooks.beforeCancelInvitation({\n\t\tinvitation,\n\t\tcancelledBy: session.user,\n\t\torganization: organization$1\n\t});\n\tconst canceledI = await adapter.updateInvitation({\n\t\tinvitationId: ctx.body.invitationId,\n\t\tstatus: \"canceled\"\n\t});\n\tif (options?.organizationHooks?.afterCancelInvitation) await options?.organizationHooks.afterCancelInvitation({\n\t\tinvitation: canceledI || invitation,\n\t\tcancelledBy: session.user,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json(canceledI);\n});\nconst getInvitation = (options) => createAuthEndpoint(\"/organization/get-invitation\", {\n\tmethod: \"GET\",\n\tuse: [orgMiddleware],\n\trequireHeaders: true,\n\tquery: z.object({ id: z.string().meta({ description: \"The ID of the invitation to get\" }) }),\n\tmetadata: { openapi: {\n\t\tdescription: \"Get an invitation by ID\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\temail: { type: \"string\" },\n\t\t\t\t\trole: { type: \"string\" },\n\t\t\t\t\torganizationId: { type: \"string\" },\n\t\t\t\t\tinviterId: { type: \"string\" },\n\t\t\t\t\tstatus: { type: \"string\" },\n\t\t\t\t\texpiresAt: { type: \"string\" },\n\t\t\t\t\torganizationName: { type: \"string\" },\n\t\t\t\t\torganizationSlug: { type: \"string\" },\n\t\t\t\t\tinviterEmail: { type: \"string\" }\n\t\t\t\t},\n\t\t\t\trequired: [\n\t\t\t\t\t\"id\",\n\t\t\t\t\t\"email\",\n\t\t\t\t\t\"role\",\n\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\"inviterId\",\n\t\t\t\t\t\"status\",\n\t\t\t\t\t\"expiresAt\",\n\t\t\t\t\t\"organizationName\",\n\t\t\t\t\t\"organizationSlug\",\n\t\t\t\t\t\"inviterEmail\"\n\t\t\t\t]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) throw new APIError(\"UNAUTHORIZED\", { message: \"Not authenticated\" });\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tconst invitation = await adapter.findInvitationById(ctx.query.id);\n\tif (!invitation || invitation.status !== \"pending\" || invitation.expiresAt < /* @__PURE__ */ new Date()) throw new APIError(\"BAD_REQUEST\", { message: \"Invitation not found!\" });\n\tif (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });\n\tconst organization$1 = await adapter.findOrganizationById(invitation.organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tconst member = await adapter.findMemberByOrgId({\n\t\tuserId: invitation.inviterId,\n\t\torganizationId: invitation.organizationId\n\t});\n\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.INVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION });\n\treturn ctx.json({\n\t\t...invitation,\n\t\torganizationName: organization$1.name,\n\t\torganizationSlug: organization$1.slug,\n\t\tinviterEmail: member.user.email\n\t});\n});\nconst listInvitations = (options) => createAuthEndpoint(\"/organization/list-invitations\", {\n\tmethod: \"GET\",\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\tquery: z.object({ organizationId: z.string().meta({ description: \"The ID of the organization to list invitations for\" }).optional() }).optional()\n}, async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) throw new APIError(\"UNAUTHORIZED\", { message: \"Not authenticated\" });\n\tconst orgId = ctx.query?.organizationId || session.session.activeOrganizationId;\n\tif (!orgId) throw new APIError(\"BAD_REQUEST\", { message: \"Organization ID is required\" });\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tif (!await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId: orgId\n\t})) throw new APIError(\"FORBIDDEN\", { message: \"You are not a member of this organization\" });\n\tconst invitations = await adapter.listInvitations({ organizationId: orgId });\n\treturn ctx.json(invitations);\n});\n/**\n* List all invitations a user has received\n*/\nconst listUserInvitations = (options) => createAuthEndpoint(\"/organization/list-user-invitations\", {\n\tmethod: \"GET\",\n\tuse: [orgMiddleware],\n\tquery: z.object({ email: z.string().meta({ description: \"The email of the user to list invitations for. This only works for server side API calls.\" }).optional() }).optional()\n}, async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (ctx.request && ctx.query?.email) throw new APIError(\"BAD_REQUEST\", { message: \"User email cannot be passed for client side API calls.\" });\n\tconst userEmail = session?.user.email || ctx.query?.email;\n\tif (!userEmail) throw new APIError(\"BAD_REQUEST\", { message: \"Missing session headers, or email query parameter.\" });\n\tconst invitations = await getOrgAdapter(ctx.context, options).listUserInvitations(userEmail);\n\treturn ctx.json(invitations);\n});\n\n//#endregion\n//#region src/plugins/organization/routes/crud-members.ts\nconst addMember = (option) => {\n\tconst additionalFieldsSchema = toZodSchema({\n\t\tfields: option?.schema?.member?.additionalFields || {},\n\t\tisClientSide: true\n\t});\n\tconst baseSchema = z.object({\n\t\tuserId: z.coerce.string().meta({ description: \"The user Id which represents the user to be added as a member. If `null` is provided, then it's expected to provide session headers. Eg: \\\"user-id\\\"\" }),\n\t\trole: z.union([z.string(), z.array(z.string())]).meta({ description: \"The role(s) to assign to the new member. Eg: [\\\"admin\\\", \\\"sale\\\"]\" }),\n\t\torganizationId: z.string().meta({ description: \"An optional organization ID to pass. If not provided, will default to the user's active organization. Eg: \\\"org-id\\\"\" }).optional(),\n\t\tteamId: z.string().meta({ description: \"An optional team ID to add the member to. Eg: \\\"team-id\\\"\" }).optional()\n\t});\n\treturn createAuthEndpoint(\"/organization/add-member\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t...baseSchema.shape,\n\t\t\t...additionalFieldsSchema.shape\n\t\t}),\n\t\tuse: [orgMiddleware],\n\t\tmetadata: {\n\t\t\tSERVER_ONLY: true,\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\toperationId: \"addOrganizationMember\",\n\t\t\t\tdescription: \"Add a member to an organization\"\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst session = ctx.body.userId ? await getSessionFromCtx(ctx).catch((e) => null) : null;\n\t\tconst orgId = ctx.body.organizationId || session?.session.activeOrganizationId;\n\t\tif (!orgId) return ctx.json(null, {\n\t\t\tstatus: 400,\n\t\t\tbody: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }\n\t\t});\n\t\tconst teamId = \"teamId\" in ctx.body ? ctx.body.teamId : void 0;\n\t\tif (teamId && !ctx.context.orgOptions.teams?.enabled) {\n\t\t\tctx.context.logger.error(\"Teams are not enabled\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"Teams are not enabled\" });\n\t\t}\n\t\tconst adapter = getOrgAdapter(ctx.context, option);\n\t\tconst user = await ctx.context.internalAdapter.findUserById(ctx.body.userId);\n\t\tif (!user) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.USER_NOT_FOUND });\n\t\tif (await adapter.findMemberByEmail({\n\t\t\temail: user.email,\n\t\t\torganizationId: orgId\n\t\t})) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION });\n\t\tif (teamId) {\n\t\t\tconst team = await adapter.findTeamById({\n\t\t\t\tteamId,\n\t\t\t\torganizationId: orgId\n\t\t\t});\n\t\t\tif (!team || team.organizationId !== orgId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\t\t}\n\t\tconst membershipLimit = ctx.context.orgOptions?.membershipLimit || 100;\n\t\tif (await adapter.countMembers({ organizationId: orgId }) >= membershipLimit) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_MEMBERSHIP_LIMIT_REACHED });\n\t\tconst { role: _, userId: __, organizationId: ___, ...additionalFields } = ctx.body;\n\t\tconst organization$1 = await adapter.findOrganizationById(orgId);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tlet memberData = {\n\t\t\torganizationId: orgId,\n\t\t\tuserId: user.id,\n\t\t\trole: parseRoles(ctx.body.role),\n\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t...additionalFields ? additionalFields : {}\n\t\t};\n\t\tif (option?.organizationHooks?.beforeAddMember) {\n\t\t\tconst response = await option?.organizationHooks.beforeAddMember({\n\t\t\t\tmember: {\n\t\t\t\t\tuserId: user.id,\n\t\t\t\t\torganizationId: orgId,\n\t\t\t\t\trole: parseRoles(ctx.body.role),\n\t\t\t\t\t...additionalFields\n\t\t\t\t},\n\t\t\t\tuser,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) memberData = {\n\t\t\t\t...memberData,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tconst createdMember = await adapter.createMember(memberData);\n\t\tif (teamId) await adapter.findOrCreateTeamMember({\n\t\t\tuserId: user.id,\n\t\t\tteamId\n\t\t});\n\t\tif (option?.organizationHooks?.afterAddMember) await option?.organizationHooks.afterAddMember({\n\t\t\tmember: createdMember,\n\t\t\tuser,\n\t\t\torganization: organization$1\n\t\t});\n\t\treturn ctx.json(createdMember);\n\t});\n};\nconst removeMember = (options) => createAuthEndpoint(\"/organization/remove-member\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tmemberIdOrEmail: z.string().meta({ description: \"The ID or email of the member to remove\" }),\n\t\torganizationId: z.string().meta({ description: \"The ID of the organization to remove the member from. If not provided, the active organization will be used. Eg: \\\"org-id\\\"\" }).optional()\n\t}),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Remove a member from an organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { member: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\t\tuserId: { type: \"string\" },\n\t\t\t\t\t\torganizationId: { type: \"string\" },\n\t\t\t\t\t\trole: { type: \"string\" }\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\t\"role\"\n\t\t\t\t\t]\n\t\t\t\t} },\n\t\t\t\trequired: [\"member\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst organizationId = ctx.body.organizationId || session.session.activeOrganizationId;\n\tif (!organizationId) return ctx.json(null, {\n\t\tstatus: 400,\n\t\tbody: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }\n\t});\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tconst member = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId\n\t});\n\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tlet toBeRemovedMember = null;\n\tif (ctx.body.memberIdOrEmail.includes(\"@\")) toBeRemovedMember = await adapter.findMemberByEmail({\n\t\temail: ctx.body.memberIdOrEmail,\n\t\torganizationId\n\t});\n\telse {\n\t\tconst result = await adapter.findMemberById(ctx.body.memberIdOrEmail);\n\t\tif (!result) toBeRemovedMember = null;\n\t\telse {\n\t\t\tconst { user: _user, ...member$1 } = result;\n\t\t\ttoBeRemovedMember = member$1;\n\t\t}\n\t}\n\tif (!toBeRemovedMember) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tconst roles = toBeRemovedMember.role.split(\",\");\n\tconst creatorRole = ctx.context.orgOptions?.creatorRole || \"owner\";\n\tif (roles.includes(creatorRole)) {\n\t\tif (member.role !== creatorRole) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });\n\t\tconst { members } = await adapter.listMembers({ organizationId });\n\t\tif (members.filter((member$1) => {\n\t\t\treturn member$1.role.split(\",\").includes(creatorRole);\n\t\t}).length <= 1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });\n\t}\n\tif (!await hasPermission({\n\t\trole: member.role,\n\t\toptions: ctx.context.orgOptions,\n\t\tpermissions: { member: [\"delete\"] },\n\t\torganizationId\n\t}, ctx)) throw new APIError(\"UNAUTHORIZED\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER });\n\tif (toBeRemovedMember?.organizationId !== organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tconst organization$1 = await adapter.findOrganizationById(organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tconst userBeingRemoved = await ctx.context.internalAdapter.findUserById(toBeRemovedMember.userId);\n\tif (!userBeingRemoved) throw new APIError(\"BAD_REQUEST\", { message: \"User not found\" });\n\tif (options?.organizationHooks?.beforeRemoveMember) await options?.organizationHooks.beforeRemoveMember({\n\t\tmember: toBeRemovedMember,\n\t\tuser: userBeingRemoved,\n\t\torganization: organization$1\n\t});\n\tawait adapter.deleteMember({\n\t\tmemberId: toBeRemovedMember.id,\n\t\torganizationId,\n\t\tuserId: toBeRemovedMember.userId\n\t});\n\tif (session.user.id === toBeRemovedMember.userId && session.session.activeOrganizationId === toBeRemovedMember.organizationId) await adapter.setActiveOrganization(session.session.token, null, ctx);\n\tif (options?.organizationHooks?.afterRemoveMember) await options?.organizationHooks.afterRemoveMember({\n\t\tmember: toBeRemovedMember,\n\t\tuser: userBeingRemoved,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json({ member: toBeRemovedMember });\n});\nconst updateMemberRole = (option) => createAuthEndpoint(\"/organization/update-member-role\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\trole: z.union([z.string(), z.array(z.string())]).meta({ description: \"The new role to be applied. This can be a string or array of strings representing the roles. Eg: [\\\"admin\\\", \\\"sale\\\"]\" }),\n\t\tmemberId: z.string().meta({ description: \"The member id to apply the role update to. Eg: \\\"member-id\\\"\" }),\n\t\torganizationId: z.string().meta({ description: \"An optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization. Eg: \\\"organization-id\\\"\" }).optional()\n\t}),\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\trequireHeaders: true,\n\tmetadata: {\n\t\t$Infer: { body: {} },\n\t\topenapi: {\n\t\t\toperationId: \"updateOrganizationMemberRole\",\n\t\t\tdescription: \"Update the role of a member in an organization\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { member: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\t\t\tuserId: { type: \"string\" },\n\t\t\t\t\t\t\torganizationId: { type: \"string\" },\n\t\t\t\t\t\t\trole: { type: \"string\" }\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\t\t\"role\"\n\t\t\t\t\t\t]\n\t\t\t\t\t} },\n\t\t\t\t\trequired: [\"member\"]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t}\n\t}\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tif (!ctx.body.role) throw new APIError(\"BAD_REQUEST\");\n\tconst organizationId = ctx.body.organizationId || session.session.activeOrganizationId;\n\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\tconst adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);\n\tconst roleToSet = Array.isArray(ctx.body.role) ? ctx.body.role : ctx.body.role ? [ctx.body.role] : [];\n\tconst member = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId\n\t});\n\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tconst toBeUpdatedMember = member.id !== ctx.body.memberId ? await adapter.findMemberById(ctx.body.memberId) : member;\n\tif (!toBeUpdatedMember) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tif (!(toBeUpdatedMember.organizationId === organizationId)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });\n\tconst creatorRole = ctx.context.orgOptions?.creatorRole || \"owner\";\n\tconst updatingMemberRoles = member.role.split(\",\");\n\tconst isUpdatingCreator = toBeUpdatedMember.role.split(\",\").includes(creatorRole);\n\tconst updaterIsCreator = updatingMemberRoles.includes(creatorRole);\n\tconst isSettingCreatorRole = roleToSet.includes(creatorRole);\n\tconst memberIsUpdatingThemselves = member.id === toBeUpdatedMember.id;\n\tif (isUpdatingCreator && !updaterIsCreator || isSettingCreatorRole && !updaterIsCreator) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });\n\tif (updaterIsCreator && memberIsUpdatingThemselves) {\n\t\tif ((await ctx.context.adapter.findMany({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: organizationId\n\t\t\t}]\n\t\t})).filter((member$1) => {\n\t\t\treturn member$1.role.split(\",\").includes(creatorRole);\n\t\t}).length <= 1 && !isSettingCreatorRole) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_WITHOUT_AN_OWNER });\n\t}\n\tif (!await hasPermission({\n\t\trole: member.role,\n\t\toptions: ctx.context.orgOptions,\n\t\tpermissions: { member: [\"update\"] },\n\t\tallowCreatorAllPermissions: true,\n\t\torganizationId\n\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });\n\tconst organization$1 = await adapter.findOrganizationById(organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tconst userBeingUpdated = await ctx.context.internalAdapter.findUserById(toBeUpdatedMember.userId);\n\tif (!userBeingUpdated) throw new APIError(\"BAD_REQUEST\", { message: \"User not found\" });\n\tconst previousRole = toBeUpdatedMember.role;\n\tconst newRole = parseRoles(ctx.body.role);\n\tif (option?.organizationHooks?.beforeUpdateMemberRole) {\n\t\tconst response = await option?.organizationHooks.beforeUpdateMemberRole({\n\t\t\tmember: toBeUpdatedMember,\n\t\t\tnewRole,\n\t\t\tuser: userBeingUpdated,\n\t\t\torganization: organization$1\n\t\t});\n\t\tif (response && typeof response === \"object\" && \"data\" in response) {\n\t\t\tconst updatedMember$1 = await adapter.updateMember(ctx.body.memberId, response.data.role || newRole);\n\t\t\tif (!updatedMember$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\t\t\tif (option?.organizationHooks?.afterUpdateMemberRole) await option?.organizationHooks.afterUpdateMemberRole({\n\t\t\t\tmember: updatedMember$1,\n\t\t\t\tpreviousRole,\n\t\t\t\tuser: userBeingUpdated,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t\treturn ctx.json(updatedMember$1);\n\t\t}\n\t}\n\tconst updatedMember = await adapter.updateMember(ctx.body.memberId, newRole);\n\tif (!updatedMember) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tif (option?.organizationHooks?.afterUpdateMemberRole) await option?.organizationHooks.afterUpdateMemberRole({\n\t\tmember: updatedMember,\n\t\tpreviousRole,\n\t\tuser: userBeingUpdated,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json(updatedMember);\n});\nconst getActiveMember = (options) => createAuthEndpoint(\"/organization/get-active-member\", {\n\tmethod: \"GET\",\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\tdescription: \"Get the member details of the active organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tid: { type: \"string\" },\n\t\t\t\t\tuserId: { type: \"string\" },\n\t\t\t\t\torganizationId: { type: \"string\" },\n\t\t\t\t\trole: { type: \"string\" }\n\t\t\t\t},\n\t\t\t\trequired: [\n\t\t\t\t\t\"id\",\n\t\t\t\t\t\"userId\",\n\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\"role\"\n\t\t\t\t]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst organizationId = session.session.activeOrganizationId;\n\tif (!organizationId) return ctx.json(null, {\n\t\tstatus: 400,\n\t\tbody: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }\n\t});\n\tconst member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId\n\t});\n\tif (!member) return ctx.json(null, {\n\t\tstatus: 400,\n\t\tbody: { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND }\n\t});\n\treturn ctx.json(member);\n});\nconst leaveOrganization = (options) => createAuthEndpoint(\"/organization/leave\", {\n\tmethod: \"POST\",\n\tbody: z.object({ organizationId: z.string().meta({ description: \"The organization Id for the member to leave. Eg: \\\"organization-id\\\"\" }) }),\n\trequireHeaders: true,\n\tuse: [sessionMiddleware, orgMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tconst member = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId: ctx.body.organizationId\n\t});\n\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });\n\tconst creatorRole = ctx.context.orgOptions?.creatorRole || \"owner\";\n\tif (member.role.split(\",\").includes(creatorRole)) {\n\t\tif ((await ctx.context.adapter.findMany({\n\t\t\tmodel: \"member\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"organizationId\",\n\t\t\t\tvalue: ctx.body.organizationId\n\t\t\t}]\n\t\t})).filter((member$1) => member$1.role.split(\",\").includes(creatorRole)).length <= 1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });\n\t}\n\tawait adapter.deleteMember({\n\t\tmemberId: member.id,\n\t\torganizationId: ctx.body.organizationId,\n\t\tuserId: session.user.id\n\t});\n\tif (session.session.activeOrganizationId === ctx.body.organizationId) await adapter.setActiveOrganization(session.session.token, null, ctx);\n\treturn ctx.json(member);\n});\nconst listMembers = (options) => createAuthEndpoint(\"/organization/list-members\", {\n\tmethod: \"GET\",\n\tquery: z.object({\n\t\tlimit: z.string().meta({ description: \"The number of users to return\" }).or(z.number()).optional(),\n\t\toffset: z.string().meta({ description: \"The offset to start from\" }).or(z.number()).optional(),\n\t\tsortBy: z.string().meta({ description: \"The field to sort by\" }).optional(),\n\t\tsortDirection: z.enum([\"asc\", \"desc\"]).meta({ description: \"The direction to sort by\" }).optional(),\n\t\tfilterField: z.string().meta({ description: \"The field to filter by\" }).optional(),\n\t\tfilterValue: z.string().meta({ description: \"The value to filter by\" }).or(z.number()).or(z.boolean()).optional(),\n\t\tfilterOperator: z.enum([\n\t\t\t\"eq\",\n\t\t\t\"ne\",\n\t\t\t\"lt\",\n\t\t\t\"lte\",\n\t\t\t\"gt\",\n\t\t\t\"gte\",\n\t\t\t\"contains\"\n\t\t]).meta({ description: \"The operator to use for the filter\" }).optional(),\n\t\torganizationId: z.string().meta({ description: \"The organization ID to list members for. If not provided, will default to the user's active organization. Eg: \\\"organization-id\\\"\" }).optional(),\n\t\torganizationSlug: z.string().meta({ description: \"The organization slug to list members for. If not provided, will default to the user's active organization. Eg: \\\"organization-slug\\\"\" }).optional()\n\t}).optional(),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tlet organizationId = ctx.query?.organizationId || session.session.activeOrganizationId;\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tif (ctx.query?.organizationSlug) {\n\t\tconst organization$1 = await adapter.findOrganizationBySlug(ctx.query?.organizationSlug);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\torganizationId = organization$1.id;\n\t}\n\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\tif (!await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId\n\t})) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\tconst { members, total } = await adapter.listMembers({\n\t\torganizationId,\n\t\tlimit: ctx.query?.limit ? Number(ctx.query.limit) : void 0,\n\t\toffset: ctx.query?.offset ? Number(ctx.query.offset) : void 0,\n\t\tsortBy: ctx.query?.sortBy,\n\t\tsortOrder: ctx.query?.sortDirection,\n\t\tfilter: ctx.query?.filterField ? {\n\t\t\tfield: ctx.query?.filterField,\n\t\t\toperator: ctx.query.filterOperator,\n\t\t\tvalue: ctx.query.filterValue\n\t\t} : void 0\n\t});\n\treturn ctx.json({\n\t\tmembers,\n\t\ttotal\n\t});\n});\nconst getActiveMemberRole = (options) => createAuthEndpoint(\"/organization/get-active-member-role\", {\n\tmethod: \"GET\",\n\tquery: z.object({\n\t\tuserId: z.string().meta({ description: \"The user ID to get the role for. If not provided, will default to the current user's\" }).optional(),\n\t\torganizationId: z.string().meta({ description: \"The organization ID to list members for. If not provided, will default to the user's active organization. Eg: \\\"organization-id\\\"\" }).optional(),\n\t\torganizationSlug: z.string().meta({ description: \"The organization slug to list members for. If not provided, will default to the user's active organization. Eg: \\\"organization-slug\\\"\" }).optional()\n\t}).optional(),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tlet organizationId = ctx.query?.organizationId || session.session.activeOrganizationId;\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tif (ctx.query?.organizationSlug) {\n\t\tconst organization$1 = await adapter.findOrganizationBySlug(ctx.query?.organizationSlug);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\torganizationId = organization$1.id;\n\t}\n\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\tconst isMember = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId\n\t});\n\tif (!isMember) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\tif (!ctx.query?.userId) return ctx.json({ role: isMember.role });\n\tconst userIdToGetRole = ctx.query?.userId;\n\tconst member = await adapter.findMemberByOrgId({\n\t\tuserId: userIdToGetRole,\n\t\torganizationId\n\t});\n\tif (!member) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });\n\treturn ctx.json({ role: member?.role });\n});\n\n//#endregion\n//#region src/plugins/organization/routes/crud-org.ts\nconst createOrganization = (options) => {\n\tconst additionalFieldsSchema = toZodSchema({\n\t\tfields: options?.schema?.organization?.additionalFields || {},\n\t\tisClientSide: true\n\t});\n\tconst baseSchema = z.object({\n\t\tname: z.string().min(1).meta({ description: \"The name of the organization\" }),\n\t\tslug: z.string().min(1).meta({ description: \"The slug of the organization\" }),\n\t\tuserId: z.coerce.string().meta({ description: \"The user id of the organization creator. If not provided, the current user will be used. Should only be used by admins or when called by the server. server-only. Eg: \\\"user-id\\\"\" }).optional(),\n\t\tlogo: z.string().meta({ description: \"The logo of the organization\" }).optional(),\n\t\tmetadata: z.record(z.string(), z.any()).meta({ description: \"The metadata of the organization\" }).optional(),\n\t\tkeepCurrentActiveOrganization: z.boolean().meta({ description: \"Whether to keep the current active organization active after creating a new one. Eg: true\" }).optional()\n\t});\n\treturn createAuthEndpoint(\"/organization/create\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t...baseSchema.shape,\n\t\t\t...additionalFieldsSchema.shape\n\t\t}),\n\t\tuse: [orgMiddleware],\n\t\tmetadata: {\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Create an organization\",\n\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tdescription: \"The organization that was created\",\n\t\t\t\t\t\t$ref: \"#/components/schemas/Organization\"\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session && (ctx.request || ctx.headers)) throw new APIError(\"UNAUTHORIZED\");\n\t\tlet user = session?.user || null;\n\t\tif (!user) {\n\t\t\tif (!ctx.body.userId) throw new APIError(\"UNAUTHORIZED\");\n\t\t\tuser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);\n\t\t}\n\t\tif (!user) return ctx.json(null, { status: 401 });\n\t\tconst options$1 = ctx.context.orgOptions;\n\t\tif (!(typeof options$1?.allowUserToCreateOrganization === \"function\" ? await options$1.allowUserToCreateOrganization(user) : options$1?.allowUserToCreateOrganization === void 0 ? true : options$1.allowUserToCreateOrganization)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION });\n\t\tconst adapter = getOrgAdapter(ctx.context, options$1);\n\t\tconst userOrganizations = await adapter.listOrganizations(user.id);\n\t\tif (typeof options$1.organizationLimit === \"number\" ? userOrganizations.length >= options$1.organizationLimit : typeof options$1.organizationLimit === \"function\" ? await options$1.organizationLimit(user) : false) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS });\n\t\tif (await adapter.findOrganizationBySlug(ctx.body.slug)) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_ALREADY_EXISTS });\n\t\tlet { keepCurrentActiveOrganization: _, userId: __, ...orgData } = ctx.body;\n\t\tif (options$1.organizationCreation?.beforeCreate) {\n\t\t\tconst response = await options$1.organizationCreation.beforeCreate({\n\t\t\t\torganization: {\n\t\t\t\t\t...orgData,\n\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t},\n\t\t\t\tuser\n\t\t\t}, ctx.request);\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) orgData = {\n\t\t\t\t...ctx.body,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tif (options$1?.organizationHooks?.beforeCreateOrganization) {\n\t\t\tconst response = await options$1?.organizationHooks.beforeCreateOrganization({\n\t\t\t\torganization: orgData,\n\t\t\t\tuser\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) orgData = {\n\t\t\t\t...ctx.body,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tconst organization$1 = await adapter.createOrganization({ organization: {\n\t\t\t...orgData,\n\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t} });\n\t\tlet member;\n\t\tlet teamMember = null;\n\t\tlet data = {\n\t\t\tuserId: user.id,\n\t\t\torganizationId: organization$1.id,\n\t\t\trole: ctx.context.orgOptions.creatorRole || \"owner\"\n\t\t};\n\t\tif (options$1?.organizationHooks?.beforeAddMember) {\n\t\t\tconst response = await options$1?.organizationHooks.beforeAddMember({\n\t\t\t\tmember: {\n\t\t\t\t\tuserId: user.id,\n\t\t\t\t\torganizationId: organization$1.id,\n\t\t\t\t\trole: ctx.context.orgOptions.creatorRole || \"owner\"\n\t\t\t\t},\n\t\t\t\tuser,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) data = {\n\t\t\t\t...data,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tmember = await adapter.createMember(data);\n\t\tif (options$1?.organizationHooks?.afterAddMember) await options$1?.organizationHooks.afterAddMember({\n\t\t\tmember,\n\t\t\tuser,\n\t\t\torganization: organization$1\n\t\t});\n\t\tif (options$1?.teams?.enabled && options$1.teams.defaultTeam?.enabled !== false) {\n\t\t\tlet teamData = {\n\t\t\t\torganizationId: organization$1.id,\n\t\t\t\tname: `${organization$1.name}`,\n\t\t\t\tcreatedAt: /* @__PURE__ */ new Date()\n\t\t\t};\n\t\t\tif (options$1?.organizationHooks?.beforeCreateTeam) {\n\t\t\t\tconst response = await options$1?.organizationHooks.beforeCreateTeam({\n\t\t\t\t\tteam: {\n\t\t\t\t\t\torganizationId: organization$1.id,\n\t\t\t\t\t\tname: `${organization$1.name}`\n\t\t\t\t\t},\n\t\t\t\t\tuser,\n\t\t\t\t\torganization: organization$1\n\t\t\t\t});\n\t\t\t\tif (response && typeof response === \"object\" && \"data\" in response) teamData = {\n\t\t\t\t\t...teamData,\n\t\t\t\t\t...response.data\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst defaultTeam = await options$1.teams.defaultTeam?.customCreateDefaultTeam?.(organization$1, ctx) || await adapter.createTeam(teamData);\n\t\t\tteamMember = await adapter.findOrCreateTeamMember({\n\t\t\t\tteamId: defaultTeam.id,\n\t\t\t\tuserId: user.id\n\t\t\t});\n\t\t\tif (options$1?.organizationHooks?.afterCreateTeam) await options$1?.organizationHooks.afterCreateTeam({\n\t\t\t\tteam: defaultTeam,\n\t\t\t\tuser,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t}\n\t\tif (options$1.organizationCreation?.afterCreate) await options$1.organizationCreation.afterCreate({\n\t\t\torganization: organization$1,\n\t\t\tuser,\n\t\t\tmember\n\t\t}, ctx.request);\n\t\tif (options$1?.organizationHooks?.afterCreateOrganization) await options$1?.organizationHooks.afterCreateOrganization({\n\t\t\torganization: organization$1,\n\t\t\tuser,\n\t\t\tmember\n\t\t});\n\t\tif (ctx.context.session && !ctx.body.keepCurrentActiveOrganization) await adapter.setActiveOrganization(ctx.context.session.session.token, organization$1.id, ctx);\n\t\tif (teamMember && ctx.context.session && !ctx.body.keepCurrentActiveOrganization) await adapter.setActiveTeam(ctx.context.session.session.token, teamMember.teamId, ctx);\n\t\treturn ctx.json({\n\t\t\t...organization$1,\n\t\t\tmetadata: organization$1.metadata && typeof organization$1.metadata === \"string\" ? JSON.parse(organization$1.metadata) : organization$1.metadata,\n\t\t\tmembers: [member]\n\t\t});\n\t});\n};\nconst checkOrganizationSlug = (options) => createAuthEndpoint(\"/organization/check-slug\", {\n\tmethod: \"POST\",\n\tbody: z.object({ slug: z.string().meta({ description: \"The organization slug to check. Eg: \\\"my-org\\\"\" }) }),\n\tuse: [requestOnlySessionMiddleware, orgMiddleware]\n}, async (ctx) => {\n\tif (!await getOrgAdapter(ctx.context, options).findOrganizationBySlug(ctx.body.slug)) return ctx.json({ status: true });\n\tthrow new APIError(\"BAD_REQUEST\", { message: \"slug is taken\" });\n});\nconst updateOrganization = (options) => {\n\tconst additionalFieldsSchema = toZodSchema({\n\t\tfields: options?.schema?.organization?.additionalFields || {},\n\t\tisClientSide: true\n\t});\n\treturn createAuthEndpoint(\"/organization/update\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tdata: z.object({\n\t\t\t\t...additionalFieldsSchema.shape,\n\t\t\t\tname: z.string().min(1).meta({ description: \"The name of the organization\" }).optional(),\n\t\t\t\tslug: z.string().min(1).meta({ description: \"The slug of the organization\" }).optional(),\n\t\t\t\tlogo: z.string().meta({ description: \"The logo of the organization\" }).optional(),\n\t\t\t\tmetadata: z.record(z.string(), z.any()).meta({ description: \"The metadata of the organization\" }).optional()\n\t\t\t}).partial(),\n\t\t\torganizationId: z.string().meta({ description: \"The organization ID. Eg: \\\"org-id\\\"\" }).optional()\n\t\t}),\n\t\trequireHeaders: true,\n\t\tuse: [orgMiddleware],\n\t\tmetadata: {\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Update an organization\",\n\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tdescription: \"The updated organization\",\n\t\t\t\t\t\t$ref: \"#/components/schemas/Organization\"\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst session = await ctx.context.getSession(ctx);\n\t\tif (!session) throw new APIError(\"UNAUTHORIZED\", { message: \"User not found\" });\n\t\tconst organizationId = ctx.body.organizationId || session.session.activeOrganizationId;\n\t\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tconst adapter = getOrgAdapter(ctx.context, options);\n\t\tconst member = await adapter.findMemberByOrgId({\n\t\t\tuserId: session.user.id,\n\t\t\torganizationId\n\t\t});\n\t\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\t\tif (!await hasPermission({\n\t\t\tpermissions: { organization: [\"update\"] },\n\t\t\trole: member.role,\n\t\t\toptions: ctx.context.orgOptions,\n\t\t\torganizationId\n\t\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION });\n\t\tif (typeof ctx.body.data.slug === \"string\") {\n\t\t\tconst existingOrganization = await adapter.findOrganizationBySlug(ctx.body.data.slug);\n\t\t\tif (existingOrganization && existingOrganization.id !== organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_SLUG_ALREADY_TAKEN });\n\t\t}\n\t\tif (options?.organizationHooks?.beforeUpdateOrganization) {\n\t\t\tconst response = await options.organizationHooks.beforeUpdateOrganization({\n\t\t\t\torganization: ctx.body.data,\n\t\t\t\tuser: session.user,\n\t\t\t\tmember\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) ctx.body.data = {\n\t\t\t\t...ctx.body.data,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tconst updatedOrg = await adapter.updateOrganization(organizationId, ctx.body.data);\n\t\tif (options?.organizationHooks?.afterUpdateOrganization) await options.organizationHooks.afterUpdateOrganization({\n\t\t\torganization: updatedOrg,\n\t\t\tuser: session.user,\n\t\t\tmember\n\t\t});\n\t\treturn ctx.json(updatedOrg);\n\t});\n};\nconst deleteOrganization = (options) => {\n\treturn createAuthEndpoint(\"/organization/delete\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({ organizationId: z.string().meta({ description: \"The organization id to delete\" }) }),\n\t\trequireHeaders: true,\n\t\tuse: [orgMiddleware],\n\t\tmetadata: { openapi: {\n\t\t\tdescription: \"Delete an organization\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The organization id that was deleted\"\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tif (ctx.context.orgOptions.organizationDeletion?.disabled || ctx.context.orgOptions.disableOrganizationDeletion) {\n\t\t\tif (ctx.context.orgOptions.organizationDeletion?.disabled) ctx.context.logger.info(\"`organizationDeletion.disabled` is deprecated. Use `disableOrganizationDeletion` instead\");\n\t\t\tthrow new APIError(\"NOT_FOUND\", { message: \"Organization deletion is disabled\" });\n\t\t}\n\t\tconst session = await ctx.context.getSession(ctx);\n\t\tif (!session) throw new APIError(\"UNAUTHORIZED\", { status: 401 });\n\t\tconst organizationId = ctx.body.organizationId;\n\t\tif (!organizationId) return ctx.json(null, {\n\t\t\tstatus: 400,\n\t\t\tbody: { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND }\n\t\t});\n\t\tconst adapter = getOrgAdapter(ctx.context, options);\n\t\tconst member = await adapter.findMemberByOrgId({\n\t\t\tuserId: session.user.id,\n\t\t\torganizationId\n\t\t});\n\t\tif (!member) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\t\tif (!await hasPermission({\n\t\t\trole: member.role,\n\t\t\tpermissions: { organization: [\"delete\"] },\n\t\t\torganizationId,\n\t\t\toptions: ctx.context.orgOptions\n\t\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION });\n\t\tif (organizationId === session.session.activeOrganizationId)\n /**\n\t\t* If the organization is deleted, we set the active organization to null\n\t\t*/\n\t\tawait adapter.setActiveOrganization(session.session.token, null, ctx);\n\t\tconst org = await adapter.findOrganizationById(organizationId);\n\t\tif (!org) throw new APIError(\"BAD_REQUEST\");\n\t\tif (options?.organizationHooks?.beforeDeleteOrganization) await options.organizationHooks.beforeDeleteOrganization({\n\t\t\torganization: org,\n\t\t\tuser: session.user\n\t\t});\n\t\tawait adapter.deleteOrganization(organizationId);\n\t\tif (options?.organizationHooks?.afterDeleteOrganization) await options.organizationHooks.afterDeleteOrganization({\n\t\t\torganization: org,\n\t\t\tuser: session.user\n\t\t});\n\t\treturn ctx.json(org);\n\t});\n};\nconst getFullOrganization = (options) => createAuthEndpoint(\"/organization/get-full-organization\", {\n\tmethod: \"GET\",\n\tquery: z.optional(z.object({\n\t\torganizationId: z.string().meta({ description: \"The organization id to get\" }).optional(),\n\t\torganizationSlug: z.string().meta({ description: \"The organization slug to get\" }).optional(),\n\t\tmembersLimit: z.number().or(z.string().transform((val) => parseInt(val))).meta({ description: \"The limit of members to get. By default, it uses the membershipLimit option which defaults to 100.\" }).optional()\n\t})),\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\tmetadata: { openapi: {\n\t\toperationId: \"getOrganization\",\n\t\tdescription: \"Get the full organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tdescription: \"The organization\",\n\t\t\t\t$ref: \"#/components/schemas/Organization\"\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst organizationId = ctx.query?.organizationSlug || ctx.query?.organizationId || session.session.activeOrganizationId;\n\tif (!organizationId) return ctx.json(null, { status: 200 });\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tconst organization$1 = await adapter.findFullOrganization({\n\t\torganizationId,\n\t\tisSlug: !!ctx.query?.organizationSlug,\n\t\tincludeTeams: ctx.context.orgOptions.teams?.enabled,\n\t\tmembersLimit: ctx.query?.membersLimit\n\t});\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tif (!await adapter.checkMembership({\n\t\tuserId: session.user.id,\n\t\torganizationId: organization$1.id\n\t})) {\n\t\tawait adapter.setActiveOrganization(session.session.token, null, ctx);\n\t\tthrow new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\t}\n\treturn ctx.json(organization$1);\n});\nconst setActiveOrganization = (options) => {\n\treturn createAuthEndpoint(\"/organization/set-active\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\torganizationId: z.string().meta({ description: \"The organization id to set as active. It can be null to unset the active organization. Eg: \\\"org-id\\\"\" }).nullable().optional(),\n\t\t\torganizationSlug: z.string().meta({ description: \"The organization slug to set as active. It can be null to unset the active organization if organizationId is not provided. Eg: \\\"org-slug\\\"\" }).optional()\n\t\t}),\n\t\tuse: [orgSessionMiddleware, orgMiddleware],\n\t\trequireHeaders: true,\n\t\tmetadata: { openapi: {\n\t\t\toperationId: \"setActiveOrganization\",\n\t\t\tdescription: \"Set the active organization\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"Success\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tdescription: \"The organization\",\n\t\t\t\t\t$ref: \"#/components/schemas/Organization\"\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst adapter = getOrgAdapter(ctx.context, options);\n\t\tconst session = ctx.context.session;\n\t\tlet organizationId = ctx.body.organizationId;\n\t\tlet organizationSlug = ctx.body.organizationSlug;\n\t\tif (organizationId === null) {\n\t\t\tif (!session.session.activeOrganizationId) return ctx.json(null);\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: await adapter.setActiveOrganization(session.session.token, null, ctx),\n\t\t\t\tuser: session.user\n\t\t\t});\n\t\t\treturn ctx.json(null);\n\t\t}\n\t\tif (!organizationId && !organizationSlug) {\n\t\t\tconst sessionOrgId = session.session.activeOrganizationId;\n\t\t\tif (!sessionOrgId) return ctx.json(null);\n\t\t\torganizationId = sessionOrgId;\n\t\t}\n\t\tif (organizationSlug && !organizationId) {\n\t\t\tconst organization$2 = await adapter.findOrganizationBySlug(organizationSlug);\n\t\t\tif (!organization$2) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\t\torganizationId = organization$2.id;\n\t\t}\n\t\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tif (!await adapter.checkMembership({\n\t\t\tuserId: session.user.id,\n\t\t\torganizationId\n\t\t})) {\n\t\t\tawait adapter.setActiveOrganization(session.session.token, null, ctx);\n\t\t\tthrow new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\t\t}\n\t\tlet organization$1 = await adapter.findOrganizationById(organizationId);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tawait setSessionCookie(ctx, {\n\t\t\tsession: await adapter.setActiveOrganization(session.session.token, organization$1.id, ctx),\n\t\t\tuser: session.user\n\t\t});\n\t\treturn ctx.json(organization$1);\n\t});\n};\nconst listOrganizations = (options) => createAuthEndpoint(\"/organization/list\", {\n\tmethod: \"GET\",\n\tuse: [orgMiddleware, orgSessionMiddleware],\n\trequireHeaders: true,\n\tmetadata: { openapi: {\n\t\tdescription: \"List all organizations\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: { $ref: \"#/components/schemas/Organization\" }\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst organizations = await getOrgAdapter(ctx.context, options).listOrganizations(ctx.context.session.user.id);\n\treturn ctx.json(organizations);\n});\n\n//#endregion\n//#region src/plugins/organization/schema.ts\nconst roleSchema = z.string();\nconst invitationStatus = z.enum([\n\t\"pending\",\n\t\"accepted\",\n\t\"rejected\",\n\t\"canceled\"\n]).default(\"pending\");\nconst organizationSchema = z.object({\n\tid: z.string().default(generateId),\n\tname: z.string(),\n\tslug: z.string(),\n\tlogo: z.string().nullish().optional(),\n\tmetadata: z.record(z.string(), z.unknown()).or(z.string().transform((v) => JSON.parse(v))).optional(),\n\tcreatedAt: z.date()\n});\nconst memberSchema = z.object({\n\tid: z.string().default(generateId),\n\torganizationId: z.string(),\n\tuserId: z.coerce.string(),\n\trole: roleSchema,\n\tcreatedAt: z.date().default(() => /* @__PURE__ */ new Date())\n});\nconst invitationSchema = z.object({\n\tid: z.string().default(generateId),\n\torganizationId: z.string(),\n\temail: z.string(),\n\trole: roleSchema,\n\tstatus: invitationStatus,\n\tteamId: z.string().nullish(),\n\tinviterId: z.string(),\n\texpiresAt: z.date(),\n\tcreatedAt: z.date().default(() => /* @__PURE__ */ new Date())\n});\nconst teamSchema = z.object({\n\tid: z.string().default(generateId),\n\tname: z.string().min(1),\n\torganizationId: z.string(),\n\tcreatedAt: z.date(),\n\tupdatedAt: z.date().optional()\n});\nconst teamMemberSchema = z.object({\n\tid: z.string().default(generateId),\n\tteamId: z.string(),\n\tuserId: z.string(),\n\tcreatedAt: z.date().default(() => /* @__PURE__ */ new Date())\n});\nconst organizationRoleSchema = z.object({\n\tid: z.string().default(generateId),\n\torganizationId: z.string(),\n\trole: z.string(),\n\tpermission: z.record(z.string(), z.array(z.string())),\n\tcreatedAt: z.date().default(() => /* @__PURE__ */ new Date()),\n\tupdatedAt: z.date().optional()\n});\nconst defaultRoles$1 = [\n\t\"admin\",\n\t\"member\",\n\t\"owner\"\n];\nconst defaultRolesSchema = z.union([z.enum(defaultRoles$1), z.array(z.enum(defaultRoles$1))]);\n\n//#endregion\n//#region src/plugins/organization/routes/crud-team.ts\nconst createTeam = (options) => {\n\tconst additionalFieldsSchema = toZodSchema({\n\t\tfields: options?.schema?.team?.additionalFields ?? {},\n\t\tisClientSide: true\n\t});\n\tconst baseSchema = z.object({\n\t\tname: z.string().meta({ description: \"The name of the team. Eg: \\\"my-team\\\"\" }),\n\t\torganizationId: z.string().meta({ description: \"The organization ID which the team will be created in. Defaults to the active organization. Eg: \\\"organization-id\\\"\" }).optional()\n\t});\n\treturn createAuthEndpoint(\"/organization/create-team\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t...baseSchema.shape,\n\t\t\t...additionalFieldsSchema.shape\n\t\t}),\n\t\tuse: [orgMiddleware],\n\t\tmetadata: {\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Create a new team within an organization\",\n\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\tdescription: \"Team created successfully\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"Unique identifier of the created team\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"Name of the team\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\torganizationId: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"ID of the organization the team belongs to\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"Timestamp when the team was created\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"Timestamp when the team was last updated\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t]\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tconst organizationId = ctx.body.organizationId || session?.session.activeOrganizationId;\n\t\tif (!session && (ctx.request || ctx.headers)) throw new APIError(\"UNAUTHORIZED\");\n\t\tif (!organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\t\tconst adapter = getOrgAdapter(ctx.context, options);\n\t\tif (session) {\n\t\t\tconst member = await adapter.findMemberByOrgId({\n\t\t\t\tuserId: session.user.id,\n\t\t\t\torganizationId\n\t\t\t});\n\t\t\tif (!member) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION });\n\t\t\tif (!await hasPermission({\n\t\t\t\trole: member.role,\n\t\t\t\toptions: ctx.context.orgOptions,\n\t\t\t\tpermissions: { team: [\"create\"] },\n\t\t\t\torganizationId\n\t\t\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION });\n\t\t}\n\t\tconst existingTeams = await adapter.listTeams(organizationId);\n\t\tconst maximum = typeof ctx.context.orgOptions.teams?.maximumTeams === \"function\" ? await ctx.context.orgOptions.teams?.maximumTeams({\n\t\t\torganizationId,\n\t\t\tsession\n\t\t}, ctx) : ctx.context.orgOptions.teams?.maximumTeams;\n\t\tif (maximum ? existingTeams.length >= maximum : false) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS });\n\t\tconst { name, organizationId: _, ...additionalFields } = ctx.body;\n\t\tconst organization$1 = await adapter.findOrganizationById(organizationId);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tlet teamData = {\n\t\t\tname,\n\t\t\torganizationId,\n\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t...additionalFields\n\t\t};\n\t\tif (options?.organizationHooks?.beforeCreateTeam) {\n\t\t\tconst response = await options?.organizationHooks.beforeCreateTeam({\n\t\t\t\tteam: {\n\t\t\t\t\tname,\n\t\t\t\t\torganizationId,\n\t\t\t\t\t...additionalFields\n\t\t\t\t},\n\t\t\t\tuser: session?.user,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) teamData = {\n\t\t\t\t...teamData,\n\t\t\t\t...response.data\n\t\t\t};\n\t\t}\n\t\tconst createdTeam = await adapter.createTeam(teamData);\n\t\tif (options?.organizationHooks?.afterCreateTeam) await options?.organizationHooks.afterCreateTeam({\n\t\t\tteam: createdTeam,\n\t\t\tuser: session?.user,\n\t\t\torganization: organization$1\n\t\t});\n\t\treturn ctx.json(createdTeam);\n\t});\n};\nconst removeTeam = (options) => createAuthEndpoint(\"/organization/remove-team\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tteamId: z.string().meta({ description: `The team ID of the team to remove. Eg: \"team-id\"` }),\n\t\torganizationId: z.string().meta({ description: `The organization ID which the team falls under. If not provided, it will default to the user's active organization. Eg: \"organization-id\"` }).optional()\n\t}),\n\tuse: [orgMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Remove a team from an organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Team removed successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"Confirmation message indicating successful removal\",\n\t\t\t\t\tenum: [\"Team removed successfully.\"]\n\t\t\t\t} },\n\t\t\t\trequired: [\"message\"]\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tconst organizationId = ctx.body.organizationId || session?.session.activeOrganizationId;\n\tif (!organizationId) return ctx.json(null, {\n\t\tstatus: 400,\n\t\tbody: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }\n\t});\n\tif (!session && (ctx.request || ctx.headers)) throw new APIError(\"UNAUTHORIZED\");\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tif (session) {\n\t\tconst member = await adapter.findMemberByOrgId({\n\t\t\tuserId: session.user.id,\n\t\t\torganizationId\n\t\t});\n\t\tif (!member || session.session?.activeTeamId === ctx.body.teamId) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM });\n\t\tif (!await hasPermission({\n\t\t\trole: member.role,\n\t\t\toptions: ctx.context.orgOptions,\n\t\t\tpermissions: { team: [\"delete\"] },\n\t\t\torganizationId\n\t\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION });\n\t}\n\tconst team = await adapter.findTeamById({\n\t\tteamId: ctx.body.teamId,\n\t\torganizationId\n\t});\n\tif (!team || team.organizationId !== organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\tif (!ctx.context.orgOptions.teams?.allowRemovingAllTeams) {\n\t\tif ((await adapter.listTeams(organizationId)).length <= 1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.UNABLE_TO_REMOVE_LAST_TEAM });\n\t}\n\tconst organization$1 = await adapter.findOrganizationById(organizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tif (options?.organizationHooks?.beforeDeleteTeam) await options?.organizationHooks.beforeDeleteTeam({\n\t\tteam,\n\t\tuser: session?.user,\n\t\torganization: organization$1\n\t});\n\tawait adapter.deleteTeam(team.id);\n\tif (options?.organizationHooks?.afterDeleteTeam) await options?.organizationHooks.afterDeleteTeam({\n\t\tteam,\n\t\tuser: session?.user,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json({ message: \"Team removed successfully.\" });\n});\nconst updateTeam = (options) => {\n\tconst additionalFieldsSchema = toZodSchema({\n\t\tfields: options?.schema?.team?.additionalFields ?? {},\n\t\tisClientSide: true\n\t});\n\treturn createAuthEndpoint(\"/organization/update-team\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tteamId: z.string().meta({ description: `The ID of the team to be updated. Eg: \"team-id\"` }),\n\t\t\tdata: z.object({\n\t\t\t\t...teamSchema.shape,\n\t\t\t\t...additionalFieldsSchema.shape\n\t\t\t}).partial()\n\t\t}),\n\t\trequireHeaders: true,\n\t\tuse: [orgMiddleware, orgSessionMiddleware],\n\t\tmetadata: {\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Update an existing team in an organization\",\n\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\tdescription: \"Team updated successfully\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"Unique identifier of the updated team\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"Updated name of the team\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\torganizationId: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"ID of the organization the team belongs to\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"Timestamp when the team was created\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"Timestamp when the team was last updated\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t]\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst session = ctx.context.session;\n\t\tconst organizationId = ctx.body.data.organizationId || session.session.activeOrganizationId;\n\t\tif (!organizationId) return ctx.json(null, {\n\t\t\tstatus: 400,\n\t\t\tbody: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }\n\t\t});\n\t\tconst adapter = getOrgAdapter(ctx.context, options);\n\t\tconst member = await adapter.findMemberByOrgId({\n\t\t\tuserId: session.user.id,\n\t\t\torganizationId\n\t\t});\n\t\tif (!member) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM });\n\t\tif (!await hasPermission({\n\t\t\trole: member.role,\n\t\t\toptions: ctx.context.orgOptions,\n\t\t\tpermissions: { team: [\"update\"] },\n\t\t\torganizationId\n\t\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM });\n\t\tconst team = await adapter.findTeamById({\n\t\t\tteamId: ctx.body.teamId,\n\t\t\torganizationId\n\t\t});\n\t\tif (!team || team.organizationId !== organizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\t\tconst { name, organizationId: __, ...additionalFields } = ctx.body.data;\n\t\tconst organization$1 = await adapter.findOrganizationById(organizationId);\n\t\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\t\tconst updates = {\n\t\t\tname,\n\t\t\t...additionalFields\n\t\t};\n\t\tif (options?.organizationHooks?.beforeUpdateTeam) {\n\t\t\tconst response = await options?.organizationHooks.beforeUpdateTeam({\n\t\t\t\tteam,\n\t\t\t\tupdates,\n\t\t\t\tuser: session.user,\n\t\t\t\torganization: organization$1\n\t\t\t});\n\t\t\tif (response && typeof response === \"object\" && \"data\" in response) {\n\t\t\t\tconst modifiedUpdates = response.data;\n\t\t\t\tconst updatedTeam$1 = await adapter.updateTeam(team.id, modifiedUpdates);\n\t\t\t\tif (options?.organizationHooks?.afterUpdateTeam) await options?.organizationHooks.afterUpdateTeam({\n\t\t\t\t\tteam: updatedTeam$1,\n\t\t\t\t\tuser: session.user,\n\t\t\t\t\torganization: organization$1\n\t\t\t\t});\n\t\t\t\treturn ctx.json(updatedTeam$1);\n\t\t\t}\n\t\t}\n\t\tconst updatedTeam = await adapter.updateTeam(team.id, updates);\n\t\tif (options?.organizationHooks?.afterUpdateTeam) await options?.organizationHooks.afterUpdateTeam({\n\t\t\tteam: updatedTeam,\n\t\t\tuser: session.user,\n\t\t\torganization: organization$1\n\t\t});\n\t\treturn ctx.json(updatedTeam);\n\t});\n};\nconst listOrganizationTeams = (options) => createAuthEndpoint(\"/organization/list-teams\", {\n\tmethod: \"GET\",\n\tquery: z.optional(z.object({ organizationId: z.string().meta({ description: `The organization ID which the teams are under to list. Defaults to the users active organization. Eg: \"organization-id\"` }).optional() })),\n\tmetadata: { openapi: {\n\t\tdescription: \"List all teams in an organization\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Teams retrieved successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"Unique identifier of the team\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"Name of the team\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\torganizationId: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"ID of the organization the team belongs to\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"Timestamp when the team was created\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"Timestamp when the team was last updated\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\"organizationId\",\n\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tdescription: \"Array of team objects within the organization\"\n\t\t\t} } }\n\t\t} }\n\t} },\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst organizationId = ctx.query?.organizationId || session?.session.activeOrganizationId;\n\tif (!organizationId) throw ctx.error(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\tconst adapter = getOrgAdapter(ctx.context, options);\n\tif (!await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId: organizationId || \"\"\n\t})) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_ACCESS_THIS_ORGANIZATION });\n\tconst teams = await adapter.listTeams(organizationId);\n\treturn ctx.json(teams);\n});\nconst setActiveTeam = (options) => createAuthEndpoint(\"/organization/set-active-team\", {\n\tmethod: \"POST\",\n\tbody: z.object({ teamId: z.string().meta({ description: \"The team id to set as active. It can be null to unset the active team\" }).nullable().optional() }),\n\trequireHeaders: true,\n\tuse: [orgSessionMiddleware, orgMiddleware],\n\tmetadata: { openapi: {\n\t\tdescription: \"Set the active team\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Success\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tdescription: \"The team\",\n\t\t\t\t$ref: \"#/components/schemas/Team\"\n\t\t\t} } }\n\t\t} }\n\t} }\n}, async (ctx) => {\n\tconst adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);\n\tconst session = ctx.context.session;\n\tif (ctx.body.teamId === null) {\n\t\tif (!session.session.activeTeamId) return ctx.json(null);\n\t\tawait setSessionCookie(ctx, {\n\t\t\tsession: await adapter.setActiveTeam(session.session.token, null, ctx),\n\t\t\tuser: session.user\n\t\t});\n\t\treturn ctx.json(null);\n\t}\n\tlet teamId;\n\tif (!ctx.body.teamId) {\n\t\tconst sessionTeamId = session.session.activeTeamId;\n\t\tif (!sessionTeamId) return ctx.json(null);\n\t\telse teamId = sessionTeamId;\n\t} else teamId = ctx.body.teamId;\n\tconst team = await adapter.findTeamById({ teamId });\n\tif (!team) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\tif (!await adapter.findTeamMember({\n\t\tteamId,\n\t\tuserId: session.user.id\n\t})) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });\n\tawait setSessionCookie(ctx, {\n\t\tsession: await adapter.setActiveTeam(session.session.token, team.id, ctx),\n\t\tuser: session.user\n\t});\n\treturn ctx.json(team);\n});\nconst listUserTeams = (options) => createAuthEndpoint(\"/organization/list-user-teams\", {\n\tmethod: \"GET\",\n\tmetadata: { openapi: {\n\t\tdescription: \"List all teams that the current user is a part of.\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Teams retrieved successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tdescription: \"The team\",\n\t\t\t\t\t$ref: \"#/components/schemas/Team\"\n\t\t\t\t},\n\t\t\t\tdescription: \"Array of team objects within the organization\"\n\t\t\t} } }\n\t\t} }\n\t} },\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst teams = await getOrgAdapter(ctx.context, ctx.context.orgOptions).listTeamsByUser({ userId: session.user.id });\n\treturn ctx.json(teams);\n});\nconst listTeamMembers = (options) => createAuthEndpoint(\"/organization/list-team-members\", {\n\tmethod: \"GET\",\n\tquery: z.optional(z.object({ teamId: z.string().optional().meta({ description: \"The team whose members we should return. If this is not provided the members of the current active team get returned.\" }) })),\n\tmetadata: { openapi: {\n\t\tdescription: \"List the members of the given team.\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Teams retrieved successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tdescription: \"The team member\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"Unique identifier of the team member\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"The user ID of the team member\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tteamId: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"The team ID of the team the team member is in\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"Timestamp when the team member was created\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\"teamId\",\n\t\t\t\t\t\t\"createdAt\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tdescription: \"Array of team member objects within the team\"\n\t\t\t} } }\n\t\t} }\n\t} },\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);\n\tlet teamId = ctx.query?.teamId || session?.session.activeTeamId;\n\tif (!teamId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.YOU_DO_NOT_HAVE_AN_ACTIVE_TEAM });\n\tif (!await adapter.findTeamMember({\n\t\tuserId: session.user.id,\n\t\tteamId\n\t})) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });\n\tconst members = await adapter.listTeamMembers({ teamId });\n\treturn ctx.json(members);\n});\nconst addTeamMember = (options) => createAuthEndpoint(\"/organization/add-team-member\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tteamId: z.string().meta({ description: \"The team the user should be a member of.\" }),\n\t\tuserId: z.coerce.string().meta({ description: \"The user Id which represents the user to be added as a member.\" })\n\t}),\n\tmetadata: { openapi: {\n\t\tdescription: \"The newly created member\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Team member created successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tdescription: \"The team member\",\n\t\t\t\tproperties: {\n\t\t\t\t\tid: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"Unique identifier of the team member\"\n\t\t\t\t\t},\n\t\t\t\t\tuserId: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The user ID of the team member\"\n\t\t\t\t\t},\n\t\t\t\t\tteamId: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: \"The team ID of the team the team member is in\"\n\t\t\t\t\t},\n\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\tdescription: \"Timestamp when the team member was created\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trequired: [\n\t\t\t\t\t\"id\",\n\t\t\t\t\t\"userId\",\n\t\t\t\t\t\"teamId\",\n\t\t\t\t\t\"createdAt\"\n\t\t\t\t]\n\t\t\t} } }\n\t\t} }\n\t} },\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);\n\tif (!session.session.activeOrganizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\tconst currentMember = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId: session.session.activeOrganizationId\n\t});\n\tif (!currentMember) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\tif (!await hasPermission({\n\t\trole: currentMember.role,\n\t\toptions: ctx.context.orgOptions,\n\t\tpermissions: { member: [\"update\"] },\n\t\torganizationId: session.session.activeOrganizationId\n\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM_MEMBER });\n\tif (!await adapter.findMemberByOrgId({\n\t\tuserId: ctx.body.userId,\n\t\torganizationId: session.session.activeOrganizationId\n\t})) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\tconst team = await adapter.findTeamById({\n\t\tteamId: ctx.body.teamId,\n\t\torganizationId: session.session.activeOrganizationId\n\t});\n\tif (!team) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\tconst organization$1 = await adapter.findOrganizationById(session.session.activeOrganizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tconst userBeingAdded = await ctx.context.internalAdapter.findUserById(ctx.body.userId);\n\tif (!userBeingAdded) throw new APIError(\"BAD_REQUEST\", { message: \"User not found\" });\n\tif (options?.organizationHooks?.beforeAddTeamMember) {\n\t\tconst response = await options?.organizationHooks.beforeAddTeamMember({\n\t\t\tteamMember: {\n\t\t\t\tteamId: ctx.body.teamId,\n\t\t\t\tuserId: ctx.body.userId\n\t\t\t},\n\t\t\tteam,\n\t\t\tuser: userBeingAdded,\n\t\t\torganization: organization$1\n\t\t});\n\t\tif (response && typeof response === \"object\" && \"data\" in response) {}\n\t}\n\tconst teamMember = await adapter.findOrCreateTeamMember({\n\t\tteamId: ctx.body.teamId,\n\t\tuserId: ctx.body.userId\n\t});\n\tif (options?.organizationHooks?.afterAddTeamMember) await options?.organizationHooks.afterAddTeamMember({\n\t\tteamMember,\n\t\tteam,\n\t\tuser: userBeingAdded,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json(teamMember);\n});\nconst removeTeamMember = (options) => createAuthEndpoint(\"/organization/remove-team-member\", {\n\tmethod: \"POST\",\n\tbody: z.object({\n\t\tteamId: z.string().meta({ description: \"The team the user should be removed from.\" }),\n\t\tuserId: z.coerce.string().meta({ description: \"The user which should be removed from the team.\" })\n\t}),\n\tmetadata: { openapi: {\n\t\tdescription: \"Remove a member from a team\",\n\t\tresponses: { \"200\": {\n\t\t\tdescription: \"Team member removed successfully\",\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"Confirmation message indicating successful removal\",\n\t\t\t\t\tenum: [\"Team member removed successfully.\"]\n\t\t\t\t} },\n\t\t\t\trequired: [\"message\"]\n\t\t\t} } }\n\t\t} }\n\t} },\n\trequireHeaders: true,\n\tuse: [orgMiddleware, orgSessionMiddleware]\n}, async (ctx) => {\n\tconst session = ctx.context.session;\n\tconst adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);\n\tif (!session.session.activeOrganizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\tconst currentMember = await adapter.findMemberByOrgId({\n\t\tuserId: session.user.id,\n\t\torganizationId: session.session.activeOrganizationId\n\t});\n\tif (!currentMember) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\tif (!await hasPermission({\n\t\trole: currentMember.role,\n\t\toptions: ctx.context.orgOptions,\n\t\tpermissions: { member: [\"delete\"] },\n\t\torganizationId: session.session.activeOrganizationId\n\t}, ctx)) throw new APIError(\"FORBIDDEN\", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REMOVE_A_TEAM_MEMBER });\n\tif (!await adapter.findMemberByOrgId({\n\t\tuserId: ctx.body.userId,\n\t\torganizationId: session.session.activeOrganizationId\n\t})) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\tconst team = await adapter.findTeamById({\n\t\tteamId: ctx.body.teamId,\n\t\torganizationId: session.session.activeOrganizationId\n\t});\n\tif (!team) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });\n\tconst organization$1 = await adapter.findOrganizationById(session.session.activeOrganizationId);\n\tif (!organization$1) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });\n\tconst userBeingRemoved = await ctx.context.internalAdapter.findUserById(ctx.body.userId);\n\tif (!userBeingRemoved) throw new APIError(\"BAD_REQUEST\", { message: \"User not found\" });\n\tconst teamMember = await adapter.findTeamMember({\n\t\tteamId: ctx.body.teamId,\n\t\tuserId: ctx.body.userId\n\t});\n\tif (!teamMember) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });\n\tif (options?.organizationHooks?.beforeRemoveTeamMember) await options?.organizationHooks.beforeRemoveTeamMember({\n\t\tteamMember,\n\t\tteam,\n\t\tuser: userBeingRemoved,\n\t\torganization: organization$1\n\t});\n\tawait adapter.removeTeamMember({\n\t\tteamId: ctx.body.teamId,\n\t\tuserId: ctx.body.userId\n\t});\n\tif (options?.organizationHooks?.afterRemoveTeamMember) await options?.organizationHooks.afterRemoveTeamMember({\n\t\tteamMember,\n\t\tteam,\n\t\tuser: userBeingRemoved,\n\t\torganization: organization$1\n\t});\n\treturn ctx.json({ message: \"Team member removed successfully.\" });\n});\n\n//#endregion\n//#region src/plugins/organization/organization.ts\nfunction parseRoles(roles) {\n\treturn Array.isArray(roles) ? roles.join(\",\") : roles;\n}\nconst createHasPermission = (options) => {\n\treturn createAuthEndpoint(\"/organization/has-permission\", {\n\t\tmethod: \"POST\",\n\t\trequireHeaders: true,\n\t\tbody: z.object({ organizationId: z.string().optional() }).and(z.union([z.object({\n\t\t\tpermission: z.record(z.string(), z.array(z.string())),\n\t\t\tpermissions: z.undefined()\n\t\t}), z.object({\n\t\t\tpermission: z.undefined(),\n\t\t\tpermissions: z.record(z.string(), z.array(z.string()))\n\t\t})])),\n\t\tuse: [orgSessionMiddleware],\n\t\tmetadata: {\n\t\t\t$Infer: { body: {} },\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Check if the user has permission\",\n\t\t\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tpermission: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tdescription: \"The permission to check\",\n\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tdescription: \"The permission to check\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\"permissions\"]\n\t\t\t\t} } } },\n\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\terror: { type: \"string\" },\n\t\t\t\t\t\t\tsuccess: { type: \"boolean\" }\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\"success\"]\n\t\t\t\t\t} } }\n\t\t\t\t} }\n\t\t\t}\n\t\t}\n\t}, async (ctx) => {\n\t\tconst activeOrganizationId = ctx.body.organizationId || ctx.context.session.session.activeOrganizationId;\n\t\tif (!activeOrganizationId) throw new APIError(\"BAD_REQUEST\", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });\n\t\tconst member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({\n\t\t\tuserId: ctx.context.session.user.id,\n\t\t\torganizationId: activeOrganizationId\n\t\t});\n\t\tif (!member) throw new APIError(\"UNAUTHORIZED\", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });\n\t\tconst result = await hasPermission({\n\t\t\trole: member.role,\n\t\t\toptions: options || {},\n\t\t\tpermissions: ctx.body.permissions ?? ctx.body.permission,\n\t\t\torganizationId: activeOrganizationId\n\t\t}, ctx);\n\t\treturn ctx.json({\n\t\t\terror: null,\n\t\t\tsuccess: result\n\t\t});\n\t});\n};\nfunction organization(options) {\n\tlet endpoints = {\n\t\tcreateOrganization: createOrganization(options),\n\t\tupdateOrganization: updateOrganization(options),\n\t\tdeleteOrganization: deleteOrganization(options),\n\t\tsetActiveOrganization: setActiveOrganization(options),\n\t\tgetFullOrganization: getFullOrganization(options),\n\t\tlistOrganizations: listOrganizations(options),\n\t\tcreateInvitation: createInvitation(options),\n\t\tcancelInvitation: cancelInvitation(options),\n\t\tacceptInvitation: acceptInvitation(options),\n\t\tgetInvitation: getInvitation(options),\n\t\trejectInvitation: rejectInvitation(options),\n\t\tlistInvitations: listInvitations(options),\n\t\tgetActiveMember: getActiveMember(options),\n\t\tcheckOrganizationSlug: checkOrganizationSlug(options),\n\t\taddMember: addMember(options),\n\t\tremoveMember: removeMember(options),\n\t\tupdateMemberRole: updateMemberRole(options),\n\t\tleaveOrganization: leaveOrganization(options),\n\t\tlistUserInvitations: listUserInvitations(options),\n\t\tlistMembers: listMembers(options),\n\t\tgetActiveMemberRole: getActiveMemberRole(options)\n\t};\n\tconst teamSupport = options?.teams?.enabled;\n\tconst teamEndpoints = {\n\t\tcreateTeam: createTeam(options),\n\t\tlistOrganizationTeams: listOrganizationTeams(options),\n\t\tremoveTeam: removeTeam(options),\n\t\tupdateTeam: updateTeam(options),\n\t\tsetActiveTeam: setActiveTeam(options),\n\t\tlistUserTeams: listUserTeams(options),\n\t\tlistTeamMembers: listTeamMembers(options),\n\t\taddTeamMember: addTeamMember(options),\n\t\tremoveTeamMember: removeTeamMember(options)\n\t};\n\tif (teamSupport) endpoints = {\n\t\t...endpoints,\n\t\t...teamEndpoints\n\t};\n\tconst dynamicAccessControlEndpoints = {\n\t\tcreateOrgRole: createOrgRole(options),\n\t\tdeleteOrgRole: deleteOrgRole(options),\n\t\tlistOrgRoles: listOrgRoles(options),\n\t\tgetOrgRole: getOrgRole(options),\n\t\tupdateOrgRole: updateOrgRole(options)\n\t};\n\tif (options?.dynamicAccessControl?.enabled) endpoints = {\n\t\t...endpoints,\n\t\t...dynamicAccessControlEndpoints\n\t};\n\tconst roles = {\n\t\t...defaultRoles,\n\t\t...options?.roles\n\t};\n\tconst teamSchema$1 = teamSupport ? {\n\t\tteam: {\n\t\t\tmodelName: options?.schema?.team?.modelName,\n\t\t\tfields: {\n\t\t\t\tname: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.team?.fields?.name\n\t\t\t\t},\n\t\t\t\torganizationId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"organization\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldName: options?.schema?.team?.fields?.organizationId,\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.team?.fields?.createdAt\n\t\t\t\t},\n\t\t\t\tupdatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options?.schema?.team?.fields?.updatedAt,\n\t\t\t\t\tonUpdate: () => /* @__PURE__ */ new Date()\n\t\t\t\t},\n\t\t\t\t...options?.schema?.team?.additionalFields || {}\n\t\t\t}\n\t\t},\n\t\tteamMember: {\n\t\t\tmodelName: options?.schema?.teamMember?.modelName,\n\t\t\tfields: {\n\t\t\t\tteamId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"team\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldName: options?.schema?.teamMember?.fields?.teamId,\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\tuserId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldName: options?.schema?.teamMember?.fields?.userId,\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options?.schema?.teamMember?.fields?.createdAt\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} : {};\n\tconst organizationRoleSchema$1 = options?.dynamicAccessControl?.enabled ? { organizationRole: {\n\t\tfields: {\n\t\t\torganizationId: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: true,\n\t\t\t\treferences: {\n\t\t\t\t\tmodel: \"organization\",\n\t\t\t\t\tfield: \"id\"\n\t\t\t\t},\n\t\t\t\tfieldName: options?.schema?.organizationRole?.fields?.organizationId,\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\trole: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: true,\n\t\t\t\tfieldName: options?.schema?.organizationRole?.fields?.role,\n\t\t\t\tindex: true\n\t\t\t},\n\t\t\tpermission: {\n\t\t\t\ttype: \"string\",\n\t\t\t\trequired: true,\n\t\t\t\tfieldName: options?.schema?.organizationRole?.fields?.permission\n\t\t\t},\n\t\t\tcreatedAt: {\n\t\t\t\ttype: \"date\",\n\t\t\t\trequired: true,\n\t\t\t\tdefaultValue: () => /* @__PURE__ */ new Date(),\n\t\t\t\tfieldName: options?.schema?.organizationRole?.fields?.createdAt\n\t\t\t},\n\t\t\tupdatedAt: {\n\t\t\t\ttype: \"date\",\n\t\t\t\trequired: false,\n\t\t\t\tfieldName: options?.schema?.organizationRole?.fields?.updatedAt,\n\t\t\t\tonUpdate: () => /* @__PURE__ */ new Date()\n\t\t\t},\n\t\t\t...options?.schema?.organizationRole?.additionalFields || {}\n\t\t},\n\t\tmodelName: options?.schema?.organizationRole?.modelName\n\t} } : {};\n\tconst schema = {\n\t\torganization: {\n\t\t\tmodelName: options?.schema?.organization?.modelName,\n\t\t\tfields: {\n\t\t\t\tname: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tfieldName: options?.schema?.organization?.fields?.name\n\t\t\t\t},\n\t\t\t\tslug: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tunique: true,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tfieldName: options?.schema?.organization?.fields?.slug\n\t\t\t\t},\n\t\t\t\tlogo: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options?.schema?.organization?.fields?.logo\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.organization?.fields?.createdAt\n\t\t\t\t},\n\t\t\t\tmetadata: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options?.schema?.organization?.fields?.metadata\n\t\t\t\t},\n\t\t\t\t...options?.schema?.organization?.additionalFields || {}\n\t\t\t}\n\t\t},\n\t\t...organizationRoleSchema$1,\n\t\t...teamSchema$1,\n\t\tmember: {\n\t\t\tmodelName: options?.schema?.member?.modelName,\n\t\t\tfields: {\n\t\t\t\torganizationId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"organization\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldName: options?.schema?.member?.fields?.organizationId,\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\tuserId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.member?.fields?.userId,\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\trole: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tdefaultValue: \"member\",\n\t\t\t\t\tfieldName: options?.schema?.member?.fields?.role\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.member?.fields?.createdAt\n\t\t\t\t},\n\t\t\t\t...options?.schema?.member?.additionalFields || {}\n\t\t\t}\n\t\t},\n\t\tinvitation: {\n\t\t\tmodelName: options?.schema?.invitation?.modelName,\n\t\t\tfields: {\n\t\t\t\torganizationId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"organization\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.organizationId,\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\temail: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.email,\n\t\t\t\t\tindex: true\n\t\t\t\t},\n\t\t\t\trole: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.role\n\t\t\t\t},\n\t\t\t\t...teamSupport ? { teamId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.teamId\n\t\t\t\t} } : {},\n\t\t\t\tstatus: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tsortable: true,\n\t\t\t\t\tdefaultValue: \"pending\",\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.status\n\t\t\t\t},\n\t\t\t\texpiresAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.expiresAt\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.createdAt,\n\t\t\t\t\tdefaultValue: () => /* @__PURE__ */ new Date()\n\t\t\t\t},\n\t\t\t\tinviterId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\tfield: \"id\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldName: options?.schema?.invitation?.fields?.inviterId,\n\t\t\t\t\trequired: true\n\t\t\t\t},\n\t\t\t\t...options?.schema?.invitation?.additionalFields || {}\n\t\t\t}\n\t\t}\n\t};\n\treturn {\n\t\tid: \"organization\",\n\t\tendpoints: {\n\t\t\t...shimContext(endpoints, {\n\t\t\t\torgOptions: options || {},\n\t\t\t\troles,\n\t\t\t\tgetSession: async (context) => {\n\t\t\t\t\treturn await getSessionFromCtx(context);\n\t\t\t\t}\n\t\t\t}),\n\t\t\thasPermission: createHasPermission(options)\n\t\t},\n\t\tschema: {\n\t\t\t...schema,\n\t\t\tsession: { fields: {\n\t\t\t\tactiveOrganizationId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options?.schema?.session?.fields?.activeOrganizationId\n\t\t\t\t},\n\t\t\t\t...teamSupport ? { activeTeamId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options?.schema?.session?.fields?.activeTeamId\n\t\t\t\t} } : {}\n\t\t\t} }\n\t\t},\n\t\t$Infer: {\n\t\t\tOrganization: {},\n\t\t\tInvitation: {},\n\t\t\tMember: {},\n\t\t\tTeam: teamSupport ? {} : {},\n\t\t\tTeamMember: teamSupport ? {} : {},\n\t\t\tActiveOrganization: {}\n\t\t},\n\t\t$ERROR_CODES: ORGANIZATION_ERROR_CODES,\n\t\toptions\n\t};\n}\n\n//#endregion\nexport { parseRoles as n, organization as t };","import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt, u as constantTimeEqual } from \"./crypto-CFUhAR9W.mjs\";\nimport { t as mergeSchema } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as safeJSONParse } from \"./json-CnHxKYpj.mjs\";\nimport { c as setSessionCookie, n as deleteSessionCookie } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx, u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { n as validatePassword } from \"./password-BFQK0cLg.mjs\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { createAuthEndpoint, createAuthMiddleware } from \"@better-auth/core/api\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport { createOTP } from \"@better-auth/utils/otp\";\n\n//#region src/plugins/two-factor/error-code.ts\nconst TWO_FACTOR_ERROR_CODES = defineErrorCodes({\n\tOTP_NOT_ENABLED: \"OTP not enabled\",\n\tOTP_HAS_EXPIRED: \"OTP has expired\",\n\tTOTP_NOT_ENABLED: \"TOTP not enabled\",\n\tTWO_FACTOR_NOT_ENABLED: \"Two factor isn't enabled\",\n\tBACKUP_CODES_NOT_ENABLED: \"Backup codes aren't enabled\",\n\tINVALID_BACKUP_CODE: \"Invalid backup code\",\n\tINVALID_CODE: \"Invalid code\",\n\tTOO_MANY_ATTEMPTS_REQUEST_NEW_CODE: \"Too many attempts. Please request a new code.\",\n\tINVALID_TWO_FACTOR_COOKIE: \"Invalid two factor cookie\"\n});\n\n//#endregion\n//#region src/plugins/two-factor/constant.ts\nconst TWO_FACTOR_COOKIE_NAME = \"two_factor\";\nconst TRUST_DEVICE_COOKIE_NAME = \"trust_device\";\nconst TRUST_DEVICE_COOKIE_MAX_AGE = 720 * 60 * 60;\n\n//#endregion\n//#region src/plugins/two-factor/verify-two-factor.ts\nasync function verifyTwoFactor(ctx) {\n\tconst invalid = (errorKey) => {\n\t\tthrow new APIError(\"UNAUTHORIZED\", { message: TWO_FACTOR_ERROR_CODES[errorKey] });\n\t};\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) {\n\t\tconst cookieName = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME);\n\t\tconst twoFactorCookie = await ctx.getSignedCookie(cookieName.name, ctx.context.secret);\n\t\tif (!twoFactorCookie) throw new APIError(\"UNAUTHORIZED\", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });\n\t\tconst verificationToken = await ctx.context.internalAdapter.findVerificationValue(twoFactorCookie);\n\t\tif (!verificationToken) throw new APIError(\"UNAUTHORIZED\", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });\n\t\tconst user = await ctx.context.internalAdapter.findUserById(verificationToken.value);\n\t\tif (!user) throw new APIError(\"UNAUTHORIZED\", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });\n\t\tconst dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);\n\t\treturn {\n\t\t\tvalid: async (ctx$1) => {\n\t\t\t\tconst session$1 = await ctx$1.context.internalAdapter.createSession(verificationToken.value, !!dontRememberMe);\n\t\t\t\tif (!session$1) throw new APIError(\"INTERNAL_SERVER_ERROR\", { message: \"failed to create session\" });\n\t\t\t\tawait setSessionCookie(ctx$1, {\n\t\t\t\t\tsession: session$1,\n\t\t\t\t\tuser\n\t\t\t\t});\n\t\t\t\tif (ctx$1.body.trustDevice) {\n\t\t\t\t\tconst trustDeviceCookie = ctx$1.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });\n\t\t\t\t\t/**\n\t\t\t\t\t* create a token that will be used to\n\t\t\t\t\t* verify the device\n\t\t\t\t\t*/\n\t\t\t\t\tconst token = await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(ctx$1.context.secret, `${user.id}!${session$1.token}`);\n\t\t\t\t\tawait ctx$1.setSignedCookie(trustDeviceCookie.name, `${token}!${session$1.token}`, ctx$1.context.secret, trustDeviceCookie.attributes);\n\t\t\t\t\tctx$1.setCookie(ctx$1.context.authCookies.dontRememberToken.name, \"\", { maxAge: 0 });\n\t\t\t\t\tctx$1.setCookie(cookieName.name, \"\", { maxAge: 0 });\n\t\t\t\t}\n\t\t\t\treturn ctx$1.json({\n\t\t\t\t\ttoken: session$1.token,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.id,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\temailVerified: user.emailVerified,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\tcreatedAt: user.createdAt,\n\t\t\t\t\t\tupdatedAt: user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tinvalid,\n\t\t\tsession: {\n\t\t\t\tsession: null,\n\t\t\t\tuser\n\t\t\t},\n\t\t\tkey: twoFactorCookie\n\t\t};\n\t}\n\treturn {\n\t\tvalid: async (ctx$1) => {\n\t\t\treturn ctx$1.json({\n\t\t\t\ttoken: session.session.token,\n\t\t\t\tuser: {\n\t\t\t\t\tid: session.user.id,\n\t\t\t\t\temail: session.user.email,\n\t\t\t\t\temailVerified: session.user.emailVerified,\n\t\t\t\t\tname: session.user.name,\n\t\t\t\t\timage: session.user.image,\n\t\t\t\t\tcreatedAt: session.user.createdAt,\n\t\t\t\t\tupdatedAt: session.user.updatedAt\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tinvalid,\n\t\tsession,\n\t\tkey: `${session.user.id}!${session.session.id}`\n\t};\n}\n\n//#endregion\n//#region src/plugins/two-factor/backup-codes/index.ts\nfunction generateBackupCodesFn(options) {\n\treturn Array.from({ length: options?.amount ?? 10 }).fill(null).map(() => generateRandomString(options?.length ?? 10, \"a-z\", \"0-9\", \"A-Z\")).map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);\n}\nasync function generateBackupCodes(secret, options) {\n\tconst backupCodes = options?.customBackupCodesGenerate ? options.customBackupCodesGenerate() : generateBackupCodesFn(options);\n\tif (options?.storeBackupCodes === \"encrypted\") return {\n\t\tbackupCodes,\n\t\tencryptedBackupCodes: await symmetricEncrypt({\n\t\t\tdata: JSON.stringify(backupCodes),\n\t\t\tkey: secret\n\t\t})\n\t};\n\tif (typeof options?.storeBackupCodes === \"object\" && \"encrypt\" in options?.storeBackupCodes) return {\n\t\tbackupCodes,\n\t\tencryptedBackupCodes: await options?.storeBackupCodes.encrypt(JSON.stringify(backupCodes))\n\t};\n\treturn {\n\t\tbackupCodes,\n\t\tencryptedBackupCodes: JSON.stringify(backupCodes)\n\t};\n}\nasync function verifyBackupCode(data, key, options) {\n\tconst codes = await getBackupCodes(data.backupCodes, key, options);\n\tif (!codes) return {\n\t\tstatus: false,\n\t\tupdated: null\n\t};\n\treturn {\n\t\tstatus: codes.includes(data.code),\n\t\tupdated: codes.filter((code) => code !== data.code)\n\t};\n}\nasync function getBackupCodes(backupCodes, key, options) {\n\tif (options?.storeBackupCodes === \"encrypted\") return safeJSONParse(await symmetricDecrypt({\n\t\tkey,\n\t\tdata: backupCodes\n\t}));\n\tif (typeof options?.storeBackupCodes === \"object\" && \"decrypt\" in options?.storeBackupCodes) return safeJSONParse(await options?.storeBackupCodes.decrypt(backupCodes));\n\treturn safeJSONParse(backupCodes);\n}\nconst backupCode2fa = (opts) => {\n\tconst twoFactorTable = \"twoFactor\";\n\treturn {\n\t\tid: \"backup_code\",\n\t\tendpoints: {\n\t\t\tverifyBackupCode: createAuthEndpoint(\"/two-factor/verify-backup-code\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tcode: z.string().meta({ description: `A backup code to verify. Eg: \"123456\"` }),\n\t\t\t\t\tdisableSession: z.boolean().meta({ description: \"If true, the session cookie will not be set.\" }).optional(),\n\t\t\t\t\ttrustDevice: z.boolean().meta({ description: \"If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Verify a backup code for two-factor authentication\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Backup code verified successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier of the user\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's email address\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email is verified\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's profile image URL\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\ttwoFactorEnabled: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether two-factor authentication is enabled for the user\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the user was created\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the user was last updated\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\"twoFactorEnabled\",\n\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tdescription: \"The authenticated user object with two-factor details\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Session token\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"ID of the user associated with the session\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the session was created\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the session expires\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\"token\",\n\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\"expiresAt\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tdescription: \"The current session object, included unless disableSession is true\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"user\", \"session\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { session, valid } = await verifyTwoFactor(ctx);\n\t\t\t\tconst user = session.user;\n\t\t\t\tconst twoFactor$1 = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: twoFactorTable,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: user.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!twoFactor$1) throw new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.BACKUP_CODES_NOT_ENABLED });\n\t\t\t\tconst validate = await verifyBackupCode({\n\t\t\t\t\tbackupCodes: twoFactor$1.backupCodes,\n\t\t\t\t\tcode: ctx.body.code\n\t\t\t\t}, ctx.context.secret, opts);\n\t\t\t\tif (!validate.status) throw new APIError(\"UNAUTHORIZED\", { message: TWO_FACTOR_ERROR_CODES.INVALID_BACKUP_CODE });\n\t\t\t\tconst updatedBackupCodes = await symmetricEncrypt({\n\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\tdata: JSON.stringify(validate.updated)\n\t\t\t\t});\n\t\t\t\tif (!await ctx.context.adapter.updateMany({\n\t\t\t\t\tmodel: twoFactorTable,\n\t\t\t\t\tupdate: { backupCodes: updatedBackupCodes },\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: user.id\n\t\t\t\t\t}, {\n\t\t\t\t\t\tfield: \"backupCodes\",\n\t\t\t\t\t\tvalue: twoFactor$1.backupCodes\n\t\t\t\t\t}]\n\t\t\t\t})) throw new APIError(\"CONFLICT\", { message: \"Failed to verify backup code. Please try again.\" });\n\t\t\t\tif (!ctx.body.disableSession) return valid(ctx);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.session?.token,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: session.user?.id,\n\t\t\t\t\t\temail: session.user.email,\n\t\t\t\t\t\temailVerified: session.user.emailVerified,\n\t\t\t\t\t\tname: session.user.name,\n\t\t\t\t\t\timage: session.user.image,\n\t\t\t\t\t\tcreatedAt: session.user.createdAt,\n\t\t\t\t\t\tupdatedAt: session.user.updatedAt\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tgenerateBackupCodes: createAuthEndpoint(\"/two-factor/generate-backup-codes\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ password: z.string().meta({ description: \"The users password.\" }) }),\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Generate new backup codes for two-factor authentication\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Backup codes generated successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the backup codes were generated successfully\",\n\t\t\t\t\t\t\t\t\tenum: [true]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbackupCodes: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: { type: \"string\" },\n\t\t\t\t\t\t\t\t\tdescription: \"Array of generated backup codes in plain text\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"status\", \"backupCodes\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst user = ctx.context.session.user;\n\t\t\t\tif (!user.twoFactorEnabled) throw new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.TWO_FACTOR_NOT_ENABLED });\n\t\t\t\tawait ctx.context.password.checkPassword(user.id, ctx);\n\t\t\t\tconst backupCodes = await generateBackupCodes(ctx.context.secret, opts);\n\t\t\t\tawait ctx.context.adapter.updateMany({\n\t\t\t\t\tmodel: twoFactorTable,\n\t\t\t\t\tupdate: { backupCodes: backupCodes.encryptedBackupCodes },\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: ctx.context.session.user.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tstatus: true,\n\t\t\t\t\tbackupCodes: backupCodes.backupCodes\n\t\t\t\t});\n\t\t\t}),\n\t\t\tviewBackupCodes: createAuthEndpoint(\"/two-factor/view-backup-codes\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ userId: z.coerce.string().meta({ description: `The user ID to view all backup codes. Eg: \"user-id\"` }) }),\n\t\t\t\tmetadata: { SERVER_ONLY: true }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst twoFactor$1 = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: twoFactorTable,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: ctx.body.userId\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!twoFactor$1) throw new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.BACKUP_CODES_NOT_ENABLED });\n\t\t\t\tconst decryptedBackupCodes = await getBackupCodes(twoFactor$1.backupCodes, ctx.context.secret, opts);\n\t\t\t\tif (!decryptedBackupCodes) throw new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.INVALID_BACKUP_CODE });\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tstatus: true,\n\t\t\t\t\tbackupCodes: decryptedBackupCodes\n\t\t\t\t});\n\t\t\t})\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/plugins/two-factor/utils.ts\nconst defaultKeyHasher = async (token) => {\n\tconst hash = await createHash(\"SHA-256\").digest(new TextEncoder().encode(token));\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n};\n\n//#endregion\n//#region src/plugins/two-factor/otp/index.ts\n/**\n* The otp adapter is created from the totp adapter.\n*/\nconst otp2fa = (options) => {\n\tconst opts = {\n\t\tstoreOTP: \"plain\",\n\t\tdigits: 6,\n\t\t...options,\n\t\tperiod: (options?.period || 3) * 60 * 1e3\n\t};\n\tasync function storeOTP(ctx, otp) {\n\t\tif (opts.storeOTP === \"hashed\") return await defaultKeyHasher(otp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"hash\" in opts.storeOTP) return await opts.storeOTP.hash(otp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"encrypt\" in opts.storeOTP) return await opts.storeOTP.encrypt(otp);\n\t\tif (opts.storeOTP === \"encrypted\") return await symmetricEncrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: otp\n\t\t});\n\t\treturn otp;\n\t}\n\tasync function decryptOTP(ctx, otp) {\n\t\tif (opts.storeOTP === \"hashed\") return await defaultKeyHasher(otp);\n\t\tif (opts.storeOTP === \"encrypted\") return await symmetricDecrypt({\n\t\t\tkey: ctx.context.secret,\n\t\t\tdata: otp\n\t\t});\n\t\tif (typeof opts.storeOTP === \"object\" && \"encrypt\" in opts.storeOTP) return await opts.storeOTP.decrypt(otp);\n\t\tif (typeof opts.storeOTP === \"object\" && \"hash\" in opts.storeOTP) return await opts.storeOTP.hash(otp);\n\t\treturn otp;\n\t}\n\treturn {\n\t\tid: \"otp\",\n\t\tendpoints: {\n\t\t\tsendTwoFactorOTP: createAuthEndpoint(\"/two-factor/send-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ trustDevice: z.boolean().optional().meta({ description: \"If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true\" }) }).optional(),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Send two factor OTP\",\n\t\t\t\t\tdescription: \"Send two factor OTP to the user\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (!options || !options.sendOTP) {\n\t\t\t\t\tctx.context.logger.error(\"send otp isn't configured. Please configure the send otp function on otp options.\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"otp isn't configured\" });\n\t\t\t\t}\n\t\t\t\tconst { session, key } = await verifyTwoFactor(ctx);\n\t\t\t\tconst code = generateRandomString(opts.digits, \"0-9\");\n\t\t\t\tconst hashedCode = await storeOTP(ctx, code);\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: `${hashedCode}:0`,\n\t\t\t\t\tidentifier: `2fa-otp-${key}`,\n\t\t\t\t\texpiresAt: new Date(Date.now() + opts.period)\n\t\t\t\t});\n\t\t\t\tawait options.sendOTP({\n\t\t\t\t\tuser: session.user,\n\t\t\t\t\totp: code\n\t\t\t\t}, ctx);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t}),\n\t\t\tverifyTwoFactorOTP: createAuthEndpoint(\"/two-factor/verify-otp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tcode: z.string().meta({ description: \"The otp code to verify. Eg: \\\"012345\\\"\" }),\n\t\t\t\t\ttrustDevice: z.boolean().optional().meta({ description: \"If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true\" })\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Verify two factor OTP\",\n\t\t\t\t\tdescription: \"Verify two factor OTP\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Two-factor OTP verified successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Session token for the authenticated session\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier of the user\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's email address\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email is verified\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"User's profile image URL\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the user was created\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Timestamp when the user was last updated\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tdescription: \"The authenticated user object\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\"token\", \"user\"]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst { session, key, valid, invalid } = await verifyTwoFactor(ctx);\n\t\t\t\tconst toCheckOtp = await ctx.context.internalAdapter.findVerificationValue(`2fa-otp-${key}`);\n\t\t\t\tconst [otp, counter] = toCheckOtp?.value?.split(\":\") ?? [];\n\t\t\t\tconst decryptedOtp = await decryptOTP(ctx, otp);\n\t\t\t\tif (!toCheckOtp || toCheckOtp.expiresAt < /* @__PURE__ */ new Date()) {\n\t\t\t\t\tif (toCheckOtp) await ctx.context.internalAdapter.deleteVerificationValue(toCheckOtp.id);\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.OTP_HAS_EXPIRED });\n\t\t\t\t}\n\t\t\t\tconst allowedAttempts = options?.allowedAttempts || 5;\n\t\t\t\tif (parseInt(counter) >= allowedAttempts) {\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(toCheckOtp.id);\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.TOO_MANY_ATTEMPTS_REQUEST_NEW_CODE });\n\t\t\t\t}\n\t\t\t\tif (constantTimeEqual(new TextEncoder().encode(decryptedOtp), new TextEncoder().encode(ctx.body.code))) {\n\t\t\t\t\tif (!session.user.twoFactorEnabled) {\n\t\t\t\t\t\tif (!session.session) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });\n\t\t\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(session.user.id, { twoFactorEnabled: true });\n\t\t\t\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(session.user.id, false, session.session);\n\t\t\t\t\t\tawait ctx.context.internalAdapter.deleteSession(session.session.token);\n\t\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\t\tsession: newSession,\n\t\t\t\t\t\t\tuser: updatedUser\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\ttoken: newSession.token,\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\tid: updatedUser.id,\n\t\t\t\t\t\t\t\temail: updatedUser.email,\n\t\t\t\t\t\t\t\temailVerified: updatedUser.emailVerified,\n\t\t\t\t\t\t\t\tname: updatedUser.name,\n\t\t\t\t\t\t\t\timage: updatedUser.image,\n\t\t\t\t\t\t\t\tcreatedAt: updatedUser.createdAt,\n\t\t\t\t\t\t\t\tupdatedAt: updatedUser.updatedAt\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn valid(ctx);\n\t\t\t\t} else {\n\t\t\t\t\tawait ctx.context.internalAdapter.updateVerificationValue(toCheckOtp.id, { value: `${otp}:${(parseInt(counter, 10) || 0) + 1}` });\n\t\t\t\t\treturn invalid(\"INVALID_CODE\");\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/plugins/two-factor/schema.ts\nconst schema = {\n\tuser: { fields: { twoFactorEnabled: {\n\t\ttype: \"boolean\",\n\t\trequired: false,\n\t\tdefaultValue: false,\n\t\tinput: false\n\t} } },\n\ttwoFactor: { fields: {\n\t\tsecret: {\n\t\t\ttype: \"string\",\n\t\t\trequired: true,\n\t\t\treturned: false,\n\t\t\tindex: true\n\t\t},\n\t\tbackupCodes: {\n\t\t\ttype: \"string\",\n\t\t\trequired: true,\n\t\t\treturned: false\n\t\t},\n\t\tuserId: {\n\t\t\ttype: \"string\",\n\t\t\trequired: true,\n\t\t\treturned: false,\n\t\t\treferences: {\n\t\t\t\tmodel: \"user\",\n\t\t\t\tfield: \"id\"\n\t\t\t},\n\t\t\tindex: true\n\t\t}\n\t} }\n};\n\n//#endregion\n//#region src/plugins/two-factor/totp/index.ts\nconst totp2fa = (options) => {\n\tconst opts = {\n\t\t...options,\n\t\tdigits: options?.digits || 6,\n\t\tperiod: options?.period || 30\n\t};\n\tconst twoFactorTable = \"twoFactor\";\n\treturn {\n\t\tid: \"totp\",\n\t\tendpoints: {\n\t\t\tgenerateTOTP: createAuthEndpoint(\"/totp/generate\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ secret: z.string().meta({ description: \"The secret to generate the TOTP code\" }) }),\n\t\t\t\tmetadata: {\n\t\t\t\t\topenapi: {\n\t\t\t\t\t\tsummary: \"Generate TOTP code\",\n\t\t\t\t\t\tdescription: \"Use this endpoint to generate a TOTP code\",\n\t\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: { code: { type: \"string\" } }\n\t\t\t\t\t\t\t} } }\n\t\t\t\t\t\t} }\n\t\t\t\t\t},\n\t\t\t\t\tSERVER_ONLY: true\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (options?.disable) {\n\t\t\t\t\tctx.context.logger.error(\"totp isn't configured. please pass totp option on two factor plugin to enable totp\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"totp isn't configured\" });\n\t\t\t\t}\n\t\t\t\treturn { code: await createOTP(ctx.body.secret, {\n\t\t\t\t\tperiod: opts.period,\n\t\t\t\t\tdigits: opts.digits\n\t\t\t\t}).totp() };\n\t\t\t}),\n\t\t\tgetTOTPURI: createAuthEndpoint(\"/two-factor/get-totp-uri\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tbody: z.object({ password: z.string().meta({ description: \"User password\" }) }),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Get TOTP URI\",\n\t\t\t\t\tdescription: \"Use this endpoint to get the TOTP URI\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { totpURI: { type: \"string\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (options?.disable) {\n\t\t\t\t\tctx.context.logger.error(\"totp isn't configured. please pass totp option on two factor plugin to enable totp\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"totp isn't configured\" });\n\t\t\t\t}\n\t\t\t\tconst user = ctx.context.session.user;\n\t\t\t\tconst twoFactor$1 = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: twoFactorTable,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: user.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!twoFactor$1) throw new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.TOTP_NOT_ENABLED });\n\t\t\t\tconst secret = await symmetricDecrypt({\n\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\tdata: twoFactor$1.secret\n\t\t\t\t});\n\t\t\t\tawait ctx.context.password.checkPassword(user.id, ctx);\n\t\t\t\treturn { totpURI: createOTP(secret, {\n\t\t\t\t\tdigits: opts.digits,\n\t\t\t\t\tperiod: opts.period\n\t\t\t\t}).url(options?.issuer || ctx.context.appName, user.email) };\n\t\t\t}),\n\t\t\tverifyTOTP: createAuthEndpoint(\"/two-factor/verify-totp\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tcode: z.string().meta({ description: \"The otp code to verify. Eg: \\\"012345\\\"\" }),\n\t\t\t\t\ttrustDevice: z.boolean().meta({ description: \"If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true\" }).optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Verify two factor TOTP\",\n\t\t\t\t\tdescription: \"Verify two factor TOTP\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tif (options?.disable) {\n\t\t\t\t\tctx.context.logger.error(\"totp isn't configured. please pass totp option on two factor plugin to enable totp\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", { message: \"totp isn't configured\" });\n\t\t\t\t}\n\t\t\t\tconst { session, valid, invalid } = await verifyTwoFactor(ctx);\n\t\t\t\tconst user = session.user;\n\t\t\t\tconst twoFactor$1 = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: twoFactorTable,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: user.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!twoFactor$1) throw new APIError(\"BAD_REQUEST\", { message: TWO_FACTOR_ERROR_CODES.TOTP_NOT_ENABLED });\n\t\t\t\tif (!await createOTP(await symmetricDecrypt({\n\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\tdata: twoFactor$1.secret\n\t\t\t\t}), {\n\t\t\t\t\tperiod: opts.period,\n\t\t\t\t\tdigits: opts.digits\n\t\t\t\t}).verify(ctx.body.code)) return invalid(\"INVALID_CODE\");\n\t\t\t\tif (!user.twoFactorEnabled) {\n\t\t\t\t\tif (!session.session) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });\n\t\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: true });\n\t\t\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(user.id, false, session.session).catch((e) => {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteSession(session.session.token);\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: newSession,\n\t\t\t\t\t\tuser: updatedUser\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn valid(ctx);\n\t\t\t})\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/plugins/two-factor/index.ts\nconst twoFactor = (options) => {\n\tconst opts = { twoFactorTable: \"twoFactor\" };\n\tconst backupCodeOptions = {\n\t\tstoreBackupCodes: \"encrypted\",\n\t\t...options?.backupCodeOptions\n\t};\n\tconst totp = totp2fa(options?.totpOptions);\n\tconst backupCode = backupCode2fa(backupCodeOptions);\n\tconst otp = otp2fa(options?.otpOptions);\n\treturn {\n\t\tid: \"two-factor\",\n\t\tendpoints: {\n\t\t\t...totp.endpoints,\n\t\t\t...otp.endpoints,\n\t\t\t...backupCode.endpoints,\n\t\t\tenableTwoFactor: createAuthEndpoint(\"/two-factor/enable\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tpassword: z.string().meta({ description: \"User password\" }),\n\t\t\t\t\tissuer: z.string().meta({ description: \"Custom issuer for the TOTP URI\" }).optional()\n\t\t\t\t}),\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Enable two factor authentication\",\n\t\t\t\t\tdescription: \"Use this endpoint to enable two factor authentication. This will generate a TOTP URI and backup codes. Once the user verifies the TOTP URI, the two factor authentication will be enabled.\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\ttotpURI: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"TOTP URI\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbackupCodes: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: { type: \"string\" },\n\t\t\t\t\t\t\t\t\tdescription: \"Backup codes\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst user = ctx.context.session.user;\n\t\t\t\tconst { password, issuer } = ctx.body;\n\t\t\t\tif (!await validatePassword(ctx, {\n\t\t\t\t\tpassword,\n\t\t\t\t\tuserId: user.id\n\t\t\t\t})) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_PASSWORD });\n\t\t\t\tconst secret = generateRandomString(32);\n\t\t\t\tconst encryptedSecret = await symmetricEncrypt({\n\t\t\t\t\tkey: ctx.context.secret,\n\t\t\t\t\tdata: secret\n\t\t\t\t});\n\t\t\t\tconst backupCodes = await generateBackupCodes(ctx.context.secret, backupCodeOptions);\n\t\t\t\tif (options?.skipVerificationOnEnable) {\n\t\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: true });\n\t\t\t\t\t/**\n\t\t\t\t\t* Update the session cookie with the new user data\n\t\t\t\t\t*/\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: await ctx.context.internalAdapter.createSession(updatedUser.id, false, ctx.context.session.session),\n\t\t\t\t\t\tuser: updatedUser\n\t\t\t\t\t});\n\t\t\t\t\tawait ctx.context.internalAdapter.deleteSession(ctx.context.session.session.token);\n\t\t\t\t}\n\t\t\t\tawait ctx.context.adapter.deleteMany({\n\t\t\t\t\tmodel: opts.twoFactorTable,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: user.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\tmodel: opts.twoFactorTable,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tsecret: encryptedSecret,\n\t\t\t\t\t\tbackupCodes: backupCodes.encryptedBackupCodes,\n\t\t\t\t\t\tuserId: user.id\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst totpURI = createOTP(secret, {\n\t\t\t\t\tdigits: options?.totpOptions?.digits || 6,\n\t\t\t\t\tperiod: options?.totpOptions?.period\n\t\t\t\t}).url(issuer || options?.issuer || ctx.context.appName, user.email);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttotpURI,\n\t\t\t\t\tbackupCodes: backupCodes.backupCodes\n\t\t\t\t});\n\t\t\t}),\n\t\t\tdisableTwoFactor: createAuthEndpoint(\"/two-factor/disable\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({ password: z.string().meta({ description: \"User password\" }) }),\n\t\t\t\tuse: [sessionMiddleware],\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tsummary: \"Disable two factor authentication\",\n\t\t\t\t\tdescription: \"Use this endpoint to disable two factor authentication.\",\n\t\t\t\t\tresponses: { 200: {\n\t\t\t\t\t\tdescription: \"Successful response\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: { status: { type: \"boolean\" } }\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst user = ctx.context.session.user;\n\t\t\t\tconst { password } = ctx.body;\n\t\t\t\tif (!await validatePassword(ctx, {\n\t\t\t\t\tpassword,\n\t\t\t\t\tuserId: user.id\n\t\t\t\t})) throw new APIError(\"BAD_REQUEST\", { message: BASE_ERROR_CODES.INVALID_PASSWORD });\n\t\t\t\tconst updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: false });\n\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\tmodel: opts.twoFactorTable,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: updatedUser.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\t/**\n\t\t\t\t* Update the session cookie with the new user data\n\t\t\t\t*/\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession: await ctx.context.internalAdapter.createSession(updatedUser.id, false, ctx.context.session.session),\n\t\t\t\t\tuser: updatedUser\n\t\t\t\t});\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(ctx.context.session.session.token);\n\t\t\t\treturn ctx.json({ status: true });\n\t\t\t})\n\t\t},\n\t\toptions,\n\t\thooks: { after: [{\n\t\t\tmatcher(context) {\n\t\t\t\treturn context.path === \"/sign-in/email\" || context.path === \"/sign-in/username\" || context.path === \"/sign-in/phone-number\";\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst data = ctx.context.newSession;\n\t\t\t\tif (!data) return;\n\t\t\t\tif (!data?.user.twoFactorEnabled) return;\n\t\t\t\tconst trustDeviceCookieAttrs = ctx.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });\n\t\t\t\tconst trustDeviceCookie = await ctx.getSignedCookie(trustDeviceCookieAttrs.name, ctx.context.secret);\n\t\t\t\tif (trustDeviceCookie) {\n\t\t\t\t\tconst [token, sessionToken] = trustDeviceCookie.split(\"!\");\n\t\t\t\t\tif (token === await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(ctx.context.secret, `${data.user.id}!${sessionToken}`)) {\n\t\t\t\t\t\tconst newTrustDeviceCookie = ctx.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });\n\t\t\t\t\t\tconst newToken = await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(ctx.context.secret, `${data.user.id}!${data.session.token}`);\n\t\t\t\t\t\tawait ctx.setSignedCookie(newTrustDeviceCookie.name, `${newToken}!${data.session.token}`, ctx.context.secret, trustDeviceCookieAttrs.attributes);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t* remove the session cookie. It's set by the sign in credential\n\t\t\t\t*/\n\t\t\t\tdeleteSessionCookie(ctx, true);\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(data.session.token);\n\t\t\t\tconst maxAge = (options?.otpOptions?.period ?? 3) * 60;\n\t\t\t\tconst twoFactorCookie = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME, { maxAge });\n\t\t\t\tconst identifier = `2fa-${generateRandomString(20)}`;\n\t\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\t\tvalue: data.user.id,\n\t\t\t\t\tidentifier,\n\t\t\t\t\texpiresAt: new Date(Date.now() + maxAge * 1e3)\n\t\t\t\t});\n\t\t\t\tawait ctx.setSignedCookie(twoFactorCookie.name, identifier, ctx.context.secret, twoFactorCookie.attributes);\n\t\t\t\treturn ctx.json({ twoFactorRedirect: true });\n\t\t\t})\n\t\t}] },\n\t\tschema: mergeSchema(schema, options?.schema),\n\t\trateLimit: [{\n\t\t\tpathMatcher(path) {\n\t\t\t\treturn path.startsWith(\"/two-factor/\");\n\t\t\t},\n\t\t\twindow: 10,\n\t\t\tmax: 3\n\t\t}],\n\t\t$ERROR_CODES: TWO_FACTOR_ERROR_CODES\n\t};\n};\n\n//#endregion\nexport { TWO_FACTOR_ERROR_CODES as n, twoFactor as t };","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher,\n  oidNist,\n  swap32IfBE,\n  u32,\n  type CHash, type CHashXOF,\n  type Hash,\n  type HashInfo,\n  type HashXOF\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = []; // no pure annotation: var is always used\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak implements Hash<Keccak>, HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen, 'outputLen');\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst genKeccak = (suffix: number, blockLen: number, outputLen: number, info: HashInfo = {}) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen), info);\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ genKeccak(\n  0x06,\n  144,\n  28,\n  /* @__PURE__ */ oidNist(0x07)\n);\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ genKeccak(\n  0x06,\n  136,\n  32,\n  /* @__PURE__ */ oidNist(0x08)\n);\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ genKeccak(\n  0x06,\n  104,\n  48,\n  /* @__PURE__ */ oidNist(0x09)\n);\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ genKeccak(\n  0x06,\n  72,\n  64,\n  /* @__PURE__ */ oidNist(0x0a)\n);\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ genKeccak(0x01, 144, 28);\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ genKeccak(0x01, 136, 32);\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ genKeccak(0x01, 104, 48);\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ genKeccak(0x01, 72, 64);\n\n/** Options for SHAKE XOF. */\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number, info: HashInfo = {}) =>\n  createHasher<Keccak, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true),\n    info\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXOF<Keccak, ShakeOpts> =\n  /* @__PURE__ */\n  genShake(0x1f, 168, 16, /* @__PURE__ */ oidNist(0x0b));\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXOF<Keccak, ShakeOpts> =\n  /* @__PURE__ */\n  genShake(0x1f, 136, 32, /* @__PURE__ */ oidNist(0x0c));\n\n/** SHAKE128 XOF with 256-bit output (NIST version). */\nexport const shake128_32: CHashXOF<Keccak, ShakeOpts> =\n  /* @__PURE__ */\n  genShake(0x1f, 168, 32, /* @__PURE__ */ oidNist(0x0b));\n/** SHAKE256 XOF with 512-bit output (NIST version). */\nexport const shake256_64: CHashXOF<Keccak, ShakeOpts> =\n  /* @__PURE__ */\n  genShake(0x1f, 136, 64, /* @__PURE__ */ oidNist(0x0c));\n","import { n as HIDE_METADATA, t as generateId } from \"./utils-db7gNqd-.mjs\";\nimport { r as generateRandomString } from \"./crypto-CFUhAR9W.mjs\";\nimport { t as mergeSchema, u as getDate } from \"./schema-Bb7wzeK_.mjs\";\nimport { t as getIp } from \"./get-request-ip-D6st-mto.mjs\";\nimport { t as safeJSONParse } from \"./json-CnHxKYpj.mjs\";\nimport { t as getBaseURL } from \"./url-CB8xCwz-.mjs\";\nimport { t as APIError$1 } from \"./api-CkmycQ2x.mjs\";\nimport { l as parseSetCookieHeader } from \"./cookies-D72PbWdz.mjs\";\nimport { r as getSessionFromCtx, u as sessionMiddleware } from \"./session-AaRl3_x-.mjs\";\nimport { n as parser_default } from \"./parser-pHp5yoAv.mjs\";\nimport { n as role } from \"./access-Dx8TLKnw.mjs\";\nimport { a as parsePrompt, i as schema, r as oidcProvider } from \"./oidc-provider-B9SsN23J.mjs\";\nimport { isProduction, logger } from \"@better-auth/core/env\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { SignJWT } from \"jose\";\nimport { createAuthEndpoint, createAuthEndpoint as createAuthEndpoint$1, createAuthMiddleware, createAuthMiddleware as createAuthMiddleware$1, optionsMiddleware } from \"@better-auth/core/api\";\nimport { base64, base64Url } from \"@better-auth/utils/base64\";\nimport { getWebcryptoSubtle } from \"@better-auth/utils\";\n\n//#region src/plugins/api-key/adapter.ts\n/**\n* Generate storage key for API key by hashed key\n*/\nfunction getStorageKeyByHashedKey(hashedKey) {\n\treturn `api-key:${hashedKey}`;\n}\n/**\n* Generate storage key for API key by ID\n*/\nfunction getStorageKeyById(id) {\n\treturn `api-key:by-id:${id}`;\n}\n/**\n* Generate storage key for user's API key list\n*/\nfunction getStorageKeyByUserId(userId) {\n\treturn `api-key:by-user:${userId}`;\n}\n/**\n* Serialize API key for storage\n*/\nfunction serializeApiKey(apiKey$1) {\n\treturn JSON.stringify({\n\t\t...apiKey$1,\n\t\tcreatedAt: apiKey$1.createdAt.toISOString(),\n\t\tupdatedAt: apiKey$1.updatedAt.toISOString(),\n\t\texpiresAt: apiKey$1.expiresAt?.toISOString() ?? null,\n\t\tlastRefillAt: apiKey$1.lastRefillAt?.toISOString() ?? null,\n\t\tlastRequest: apiKey$1.lastRequest?.toISOString() ?? null\n\t});\n}\n/**\n* Deserialize API key from storage\n*/\nfunction deserializeApiKey(data) {\n\tif (!data || typeof data !== \"string\") return null;\n\ttry {\n\t\tconst parsed = JSON.parse(data);\n\t\treturn {\n\t\t\t...parsed,\n\t\t\tcreatedAt: new Date(parsed.createdAt),\n\t\t\tupdatedAt: new Date(parsed.updatedAt),\n\t\t\texpiresAt: parsed.expiresAt ? new Date(parsed.expiresAt) : null,\n\t\t\tlastRefillAt: parsed.lastRefillAt ? new Date(parsed.lastRefillAt) : null,\n\t\t\tlastRequest: parsed.lastRequest ? new Date(parsed.lastRequest) : null\n\t\t};\n\t} catch {\n\t\treturn null;\n\t}\n}\n/**\n* Get the storage instance to use (custom methods take precedence)\n*/\nfunction getStorageInstance(ctx, opts) {\n\tif (opts.customStorage) return opts.customStorage;\n\treturn ctx.context.secondaryStorage || null;\n}\n/**\n* Calculate TTL in seconds for an API key\n*/\nfunction calculateTTL(apiKey$1) {\n\tif (apiKey$1.expiresAt) {\n\t\tconst now = Date.now();\n\t\tconst expiresAt = new Date(apiKey$1.expiresAt).getTime();\n\t\tconst ttlSeconds = Math.floor((expiresAt - now) / 1e3);\n\t\tif (ttlSeconds > 0) return ttlSeconds;\n\t}\n}\n/**\n* Get API key from secondary storage by hashed key\n*/\nasync function getApiKeyFromStorage(ctx, hashedKey, storage) {\n\tconst key = getStorageKeyByHashedKey(hashedKey);\n\treturn deserializeApiKey(await storage.get(key));\n}\n/**\n* Get API key from secondary storage by ID\n*/\nasync function getApiKeyByIdFromStorage(ctx, id, storage) {\n\tconst key = getStorageKeyById(id);\n\treturn deserializeApiKey(await storage.get(key));\n}\n/**\n* Store API key in secondary storage\n*/\nasync function setApiKeyInStorage(ctx, apiKey$1, storage, ttl) {\n\tconst serialized = serializeApiKey(apiKey$1);\n\tconst hashedKey = apiKey$1.key;\n\tconst id = apiKey$1.id;\n\tawait storage.set(getStorageKeyByHashedKey(hashedKey), serialized, ttl);\n\tawait storage.set(getStorageKeyById(id), serialized, ttl);\n\tconst userKey = getStorageKeyByUserId(apiKey$1.userId);\n\tconst userListData = await storage.get(userKey);\n\tlet userIds = [];\n\tif (userListData && typeof userListData === \"string\") try {\n\t\tuserIds = JSON.parse(userListData);\n\t} catch {\n\t\tuserIds = [];\n\t}\n\telse if (Array.isArray(userListData)) userIds = userListData;\n\tif (!userIds.includes(id)) {\n\t\tuserIds.push(id);\n\t\tawait storage.set(userKey, JSON.stringify(userIds));\n\t}\n}\n/**\n* Delete API key from secondary storage\n*/\nasync function deleteApiKeyFromStorage(ctx, apiKey$1, storage) {\n\tconst hashedKey = apiKey$1.key;\n\tconst id = apiKey$1.id;\n\tconst userId = apiKey$1.userId;\n\tawait storage.delete(getStorageKeyByHashedKey(hashedKey));\n\tawait storage.delete(getStorageKeyById(id));\n\tconst userKey = getStorageKeyByUserId(userId);\n\tconst userListData = await storage.get(userKey);\n\tlet userIds = [];\n\tif (userListData && typeof userListData === \"string\") try {\n\t\tuserIds = JSON.parse(userListData);\n\t} catch {\n\t\tuserIds = [];\n\t}\n\telse if (Array.isArray(userListData)) userIds = userListData;\n\tconst filteredIds = userIds.filter((keyId) => keyId !== id);\n\tif (filteredIds.length === 0) await storage.delete(userKey);\n\telse await storage.set(userKey, JSON.stringify(filteredIds));\n}\n/**\n* Unified getter for API keys with support for all storage modes\n*/\nasync function getApiKey$1(ctx, hashedKey, opts) {\n\tconst storage = getStorageInstance(ctx, opts);\n\tif (opts.storage === \"database\") return await ctx.context.adapter.findOne({\n\t\tmodel: \"apikey\",\n\t\twhere: [{\n\t\t\tfield: \"key\",\n\t\t\tvalue: hashedKey\n\t\t}]\n\t});\n\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\tif (storage) {\n\t\t\tconst cached = await getApiKeyFromStorage(ctx, hashedKey, storage);\n\t\t\tif (cached) return cached;\n\t\t}\n\t\tconst dbKey = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"key\",\n\t\t\t\tvalue: hashedKey\n\t\t\t}]\n\t\t});\n\t\tif (dbKey && storage) await setApiKeyInStorage(ctx, dbKey, storage, calculateTTL(dbKey));\n\t\treturn dbKey;\n\t}\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) return null;\n\t\treturn await getApiKeyFromStorage(ctx, hashedKey, storage);\n\t}\n\treturn await ctx.context.adapter.findOne({\n\t\tmodel: \"apikey\",\n\t\twhere: [{\n\t\t\tfield: \"key\",\n\t\t\tvalue: hashedKey\n\t\t}]\n\t});\n}\n/**\n* Unified getter for API keys by ID\n*/\nasync function getApiKeyById(ctx, id, opts) {\n\tconst storage = getStorageInstance(ctx, opts);\n\tif (opts.storage === \"database\") return await ctx.context.adapter.findOne({\n\t\tmodel: \"apikey\",\n\t\twhere: [{\n\t\t\tfield: \"id\",\n\t\t\tvalue: id\n\t\t}]\n\t});\n\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\tif (storage) {\n\t\t\tconst cached = await getApiKeyByIdFromStorage(ctx, id, storage);\n\t\t\tif (cached) return cached;\n\t\t}\n\t\tconst dbKey = await ctx.context.adapter.findOne({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: id\n\t\t\t}]\n\t\t});\n\t\tif (dbKey && storage) await setApiKeyInStorage(ctx, dbKey, storage, calculateTTL(dbKey));\n\t\treturn dbKey;\n\t}\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) return null;\n\t\treturn await getApiKeyByIdFromStorage(ctx, id, storage);\n\t}\n\treturn await ctx.context.adapter.findOne({\n\t\tmodel: \"apikey\",\n\t\twhere: [{\n\t\t\tfield: \"id\",\n\t\t\tvalue: id\n\t\t}]\n\t});\n}\n/**\n* Unified setter for API keys with support for all storage modes\n*/\nasync function setApiKey(ctx, apiKey$1, opts) {\n\tconst storage = getStorageInstance(ctx, opts);\n\tconst ttl = calculateTTL(apiKey$1);\n\tif (opts.storage === \"database\") return;\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) throw new Error(\"Secondary storage is required when storage mode is 'secondary-storage'\");\n\t\tawait setApiKeyInStorage(ctx, apiKey$1, storage, ttl);\n\t\treturn;\n\t}\n}\n/**\n* Unified deleter for API keys with support for all storage modes\n*/\nasync function deleteApiKey$1(ctx, apiKey$1, opts) {\n\tconst storage = getStorageInstance(ctx, opts);\n\tif (opts.storage === \"database\") return;\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) throw new Error(\"Secondary storage is required when storage mode is 'secondary-storage'\");\n\t\tawait deleteApiKeyFromStorage(ctx, apiKey$1, storage);\n\t\treturn;\n\t}\n}\n/**\n* List API keys for a user with support for all storage modes\n*/\nasync function listApiKeys$1(ctx, userId, opts) {\n\tconst storage = getStorageInstance(ctx, opts);\n\tif (opts.storage === \"database\") return await ctx.context.adapter.findMany({\n\t\tmodel: \"apikey\",\n\t\twhere: [{\n\t\t\tfield: \"userId\",\n\t\t\tvalue: userId\n\t\t}]\n\t});\n\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\tconst userKey = getStorageKeyByUserId(userId);\n\t\tif (storage) {\n\t\t\tconst userListData = await storage.get(userKey);\n\t\t\tlet userIds = [];\n\t\t\tif (userListData && typeof userListData === \"string\") try {\n\t\t\t\tuserIds = JSON.parse(userListData);\n\t\t\t} catch {\n\t\t\t\tuserIds = [];\n\t\t\t}\n\t\t\telse if (Array.isArray(userListData)) userIds = userListData;\n\t\t\tif (userIds.length > 0) {\n\t\t\t\tconst apiKeys = [];\n\t\t\t\tfor (const id of userIds) {\n\t\t\t\t\tconst apiKey$1 = await getApiKeyByIdFromStorage(ctx, id, storage);\n\t\t\t\t\tif (apiKey$1) apiKeys.push(apiKey$1);\n\t\t\t\t}\n\t\t\t\treturn apiKeys;\n\t\t\t}\n\t\t}\n\t\tconst dbKeys = await ctx.context.adapter.findMany({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [{\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: userId\n\t\t\t}]\n\t\t});\n\t\tif (storage && dbKeys.length > 0) {\n\t\t\tconst userIds = [];\n\t\t\tfor (const apiKey$1 of dbKeys) {\n\t\t\t\tawait setApiKeyInStorage(ctx, apiKey$1, storage, calculateTTL(apiKey$1));\n\t\t\t\tuserIds.push(apiKey$1.id);\n\t\t\t}\n\t\t\tawait storage.set(userKey, JSON.stringify(userIds));\n\t\t}\n\t\treturn dbKeys;\n\t}\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) return [];\n\t\tconst userKey = getStorageKeyByUserId(userId);\n\t\tconst userListData = await storage.get(userKey);\n\t\tlet userIds = [];\n\t\tif (userListData && typeof userListData === \"string\") try {\n\t\t\tuserIds = JSON.parse(userListData);\n\t\t} catch {\n\t\t\treturn [];\n\t\t}\n\t\telse if (Array.isArray(userListData)) userIds = userListData;\n\t\telse return [];\n\t\tconst apiKeys = [];\n\t\tfor (const id of userIds) {\n\t\t\tconst apiKey$1 = await getApiKeyByIdFromStorage(ctx, id, storage);\n\t\t\tif (apiKey$1) apiKeys.push(apiKey$1);\n\t\t}\n\t\treturn apiKeys;\n\t}\n\treturn await ctx.context.adapter.findMany({\n\t\tmodel: \"apikey\",\n\t\twhere: [{\n\t\t\tfield: \"userId\",\n\t\t\tvalue: userId\n\t\t}]\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/create-api-key.ts\nfunction createApiKey({ keyGenerator, opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/create\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tname: z.string().meta({ description: \"Name of the Api Key\" }).optional(),\n\t\t\texpiresIn: z.number().meta({ description: \"Expiration time of the Api Key in seconds\" }).min(1).optional().nullable().default(null),\n\t\t\tuserId: z.coerce.string().meta({ description: \"User Id of the user that the Api Key belongs to. server-only. Eg: \\\"user-id\\\"\" }).optional(),\n\t\t\tprefix: z.string().meta({ description: \"Prefix of the Api Key\" }).regex(/^[a-zA-Z0-9_-]+$/, { message: \"Invalid prefix format, must be alphanumeric and contain only underscores and hyphens.\" }).optional(),\n\t\t\tremaining: z.number().meta({ description: \"Remaining number of requests. Server side only\" }).min(0).optional().nullable().default(null),\n\t\t\tmetadata: z.any().optional(),\n\t\t\trefillAmount: z.number().meta({ description: \"Amount to refill the remaining count of the Api Key. server-only. Eg: 100\" }).min(1).optional(),\n\t\t\trefillInterval: z.number().meta({ description: \"Interval to refill the Api Key in milliseconds. server-only. Eg: 1000\" }).optional(),\n\t\t\trateLimitTimeWindow: z.number().meta({ description: \"The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 1000\" }).optional(),\n\t\t\trateLimitMax: z.number().meta({ description: \"Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100\" }).optional(),\n\t\t\trateLimitEnabled: z.boolean().meta({ description: \"Whether the key has rate limiting enabled. server-only. Eg: true\" }).optional(),\n\t\t\tpermissions: z.record(z.string(), z.array(z.string())).meta({ description: \"Permissions of the Api Key.\" }).optional()\n\t\t}),\n\t\tmetadata: { openapi: {\n\t\t\tdescription: \"Create a new API key for a user\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"API key created successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"Unique identifier of the API key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"Creation timestamp\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"Last update timestamp\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Name of the API key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Prefix of the API key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Starting characters of the key (if configured)\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkey: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"The full API key (only returned on creation)\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Whether the key is enabled\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Expiration timestamp\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"ID of the user owning the key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Last refill timestamp\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Last request timestamp\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tdescription: \"Metadata associated with the key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Maximum requests in time window\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Rate limit time window in milliseconds\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Remaining requests\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Amount to refill\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Refill interval in milliseconds\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Whether rate limiting is enabled\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tdescription: \"Current request count in window\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tadditionalProperties: {\n\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\titems: { type: \"string\" }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdescription: \"Permissions associated with the key\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\"key\",\n\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\"requestCount\"\n\t\t\t\t\t]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst { name, expiresIn, prefix, remaining, metadata, refillAmount, refillInterval, permissions, rateLimitMax, rateLimitTimeWindow, rateLimitEnabled } = ctx.body;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tconst authRequired = ctx.request || ctx.headers;\n\t\tconst user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };\n\t\tif (!user?.id) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.UNAUTHORIZED_SESSION });\n\t\tif (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.UNAUTHORIZED_SESSION });\n\t\tif (authRequired) {\n\t\t\tif (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || permissions !== void 0 || remaining !== null) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });\n\t\t}\n\t\tif (metadata) {\n\t\t\tif (opts.enableMetadata === false) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.METADATA_DISABLED });\n\t\t\tif (typeof metadata !== \"object\") throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_METADATA_TYPE });\n\t\t}\n\t\tif (refillAmount && !refillInterval) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });\n\t\tif (refillInterval && !refillAmount) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });\n\t\tif (expiresIn) {\n\t\t\tif (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });\n\t\t\tconst expiresIn_in_days = expiresIn / (3600 * 24);\n\t\t\tif (opts.keyExpiration.minExpiresIn > expiresIn_in_days) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });\n\t\t\telse if (opts.keyExpiration.maxExpiresIn < expiresIn_in_days) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });\n\t\t}\n\t\tif (prefix) {\n\t\t\tif (prefix.length < opts.minimumPrefixLength) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });\n\t\t\tif (prefix.length > opts.maximumPrefixLength) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });\n\t\t}\n\t\tif (name) {\n\t\t\tif (name.length < opts.minimumNameLength) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_NAME_LENGTH });\n\t\t\tif (name.length > opts.maximumNameLength) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_NAME_LENGTH });\n\t\t} else if (opts.requireName) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.NAME_REQUIRED });\n\t\tdeleteAllExpiredApiKeys$1(ctx.context);\n\t\tconst key = await keyGenerator({\n\t\t\tlength: opts.defaultKeyLength,\n\t\t\tprefix: prefix || opts.defaultPrefix\n\t\t});\n\t\tconst hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);\n\t\tlet start = null;\n\t\tif (opts.startingCharactersConfig.shouldStore) start = key.substring(0, opts.startingCharactersConfig.charactersLength);\n\t\tconst defaultPermissions = opts.permissions?.defaultPermissions ? typeof opts.permissions.defaultPermissions === \"function\" ? await opts.permissions.defaultPermissions(user.id, ctx) : opts.permissions.defaultPermissions : void 0;\n\t\tconst permissionsToApply = permissions ? JSON.stringify(permissions) : defaultPermissions ? JSON.stringify(defaultPermissions) : void 0;\n\t\tlet data = {\n\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\tname: name ?? null,\n\t\t\tprefix: prefix ?? opts.defaultPrefix ?? null,\n\t\t\tstart,\n\t\t\tkey: hashed,\n\t\t\tenabled: true,\n\t\t\texpiresAt: expiresIn ? getDate(expiresIn, \"sec\") : opts.keyExpiration.defaultExpiresIn ? getDate(opts.keyExpiration.defaultExpiresIn, \"sec\") : null,\n\t\t\tuserId: user.id,\n\t\t\tlastRefillAt: null,\n\t\t\tlastRequest: null,\n\t\t\tmetadata: null,\n\t\t\trateLimitMax: rateLimitMax ?? opts.rateLimit.maxRequests ?? null,\n\t\t\trateLimitTimeWindow: rateLimitTimeWindow ?? opts.rateLimit.timeWindow ?? null,\n\t\t\tremaining: remaining === null ? remaining : remaining ?? refillAmount ?? null,\n\t\t\trefillAmount: refillAmount ?? null,\n\t\t\trefillInterval: refillInterval ?? null,\n\t\t\trateLimitEnabled: rateLimitEnabled === void 0 ? opts.rateLimit.enabled ?? true : rateLimitEnabled,\n\t\t\trequestCount: 0,\n\t\t\tpermissions: permissionsToApply\n\t\t};\n\t\tif (metadata) data.metadata = schema$1.apikey.fields.metadata.transform.input(metadata);\n\t\tlet apiKey$1;\n\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\tapiKey$1 = await ctx.context.adapter.create({\n\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\tdata\n\t\t\t});\n\t\t\tawait setApiKey(ctx, apiKey$1, opts);\n\t\t} else if (opts.storage === \"secondary-storage\") {\n\t\t\tconst id = ctx.context.generateId({ model: API_KEY_TABLE_NAME }) ?? generateId();\n\t\t\tapiKey$1 = {\n\t\t\t\t...data,\n\t\t\t\tid\n\t\t\t};\n\t\t\tawait setApiKey(ctx, apiKey$1, opts);\n\t\t} else apiKey$1 = await ctx.context.adapter.create({\n\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\tdata\n\t\t});\n\t\treturn ctx.json({\n\t\t\t...apiKey$1,\n\t\t\tkey,\n\t\t\tmetadata: metadata ?? null,\n\t\t\tpermissions: apiKey$1.permissions ? safeJSONParse(apiKey$1.permissions) : null\n\t\t});\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/delete-all-expired-api-keys.ts\nfunction deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/delete-all-expired-api-keys\", {\n\t\tmethod: \"POST\",\n\t\tmetadata: { SERVER_ONLY: true }\n\t}, async (ctx) => {\n\t\ttry {\n\t\t\tawait deleteAllExpiredApiKeys$1(ctx.context, true);\n\t\t} catch (error) {\n\t\t\tctx.context.logger.error(\"[API KEY PLUGIN] Failed to delete expired API keys:\", error);\n\t\t\treturn ctx.json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror\n\t\t\t});\n\t\t}\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\terror: null\n\t\t});\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/delete-api-key.ts\nfunction deleteApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/delete\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({ keyId: z.string().meta({ description: \"The id of the Api Key\" }) }),\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: { openapi: {\n\t\t\tdescription: \"Delete an existing API key\",\n\t\t\trequestBody: { content: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { keyId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tdescription: \"The id of the API key to delete\"\n\t\t\t\t} },\n\t\t\t\trequired: [\"keyId\"]\n\t\t\t} } } },\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"API key deleted successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: { success: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: \"Indicates if the API key was successfully deleted\"\n\t\t\t\t\t} },\n\t\t\t\t\trequired: [\"success\"]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst { keyId } = ctx.body;\n\t\tconst session = ctx.context.session;\n\t\tif (session.user.banned === true) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.USER_BANNED });\n\t\tlet apiKey$1 = null;\n\t\tapiKey$1 = await getApiKeyById(ctx, keyId, opts);\n\t\tif (!apiKey$1 || apiKey$1.userId !== session.user.id) throw new APIError$1(\"NOT_FOUND\", { message: ERROR_CODES.KEY_NOT_FOUND });\n\t\ttry {\n\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\tawait deleteApiKey$1(ctx, apiKey$1, opts);\n\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else if (opts.storage === \"database\") await ctx.context.adapter.delete({\n\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t}]\n\t\t\t});\n\t\t\telse await deleteApiKey$1(ctx, apiKey$1, opts);\n\t\t} catch (error) {\n\t\t\tthrow new APIError$1(\"INTERNAL_SERVER_ERROR\", { message: error?.message });\n\t\t}\n\t\tdeleteAllExpiredApiKeys$1(ctx.context);\n\t\treturn ctx.json({ success: true });\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/get-api-key.ts\nfunction getApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/get\", {\n\t\tmethod: \"GET\",\n\t\tquery: z.object({ id: z.string().meta({ description: \"The id of the Api Key\" }) }),\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: { openapi: {\n\t\t\tdescription: \"Retrieve an existing API key by ID\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"API key retrieved successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"ID\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The name of the key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The API Key prefix. Stored as plain text.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"The owner of the user id\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The amount to refill\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The last refill date\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Sets if key is enabled or disabled\",\n\t\t\t\t\t\t\tdefault: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Whether the key has rate limiting enabled\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The duration in milliseconds\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Maximum amount of requests allowed within a window\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tdescription: \"The number of requests made within the rate limit time window\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Remaining requests (every time api key is used this should updated and should be updated on refill as well)\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"When last request occurred\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Expiry date of a key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"created at\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"updated at\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tdescription: \"Extra metadata about the apiKey\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Permissions for the api key (stored as JSON string)\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst { id } = ctx.query;\n\t\tconst session = ctx.context.session;\n\t\tlet apiKey$1 = null;\n\t\tapiKey$1 = await getApiKeyById(ctx, id, opts);\n\t\tif (apiKey$1 && apiKey$1.userId !== session.user.id) apiKey$1 = null;\n\t\tif (!apiKey$1) throw new APIError$1(\"NOT_FOUND\", { message: ERROR_CODES.KEY_NOT_FOUND });\n\t\tdeleteAllExpiredApiKeys$1(ctx.context);\n\t\tapiKey$1.metadata = schema$1.apikey.fields.metadata.transform.output(apiKey$1.metadata);\n\t\tconst { key, ...returningApiKey } = apiKey$1;\n\t\treturn ctx.json({\n\t\t\t...returningApiKey,\n\t\t\tpermissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null\n\t\t});\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/list-api-keys.ts\nfunction listApiKeys({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/list\", {\n\t\tmethod: \"GET\",\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: { openapi: {\n\t\t\tdescription: \"List all API keys for the authenticated user\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"API keys retrieved successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"array\",\n\t\t\t\t\titems: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"ID\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The name of the key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key.\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The API Key prefix. Stored as plain text.\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tdescription: \"The owner of the user id\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The amount to refill\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The last refill date\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\tdescription: \"Sets if key is enabled or disabled\",\n\t\t\t\t\t\t\t\tdefault: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\tdescription: \"Whether the key has rate limiting enabled\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"The duration in milliseconds\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"Maximum amount of requests allowed within a window\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\tdescription: \"The number of requests made within the rate limit time window\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"Remaining requests (every time api key is used this should updated and should be updated on refill as well)\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"When last request occurred\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"Expiry date of a key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"created at\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\tdescription: \"updated at\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\tdescription: \"Extra metadata about the apiKey\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\tdescription: \"Permissions for the api key (stored as JSON string)\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst session = ctx.context.session;\n\t\tlet apiKeys;\n\t\tapiKeys = await listApiKeys$1(ctx, session.user.id, opts);\n\t\tdeleteAllExpiredApiKeys$1(ctx.context);\n\t\tapiKeys = apiKeys.map((apiKey$1) => {\n\t\t\treturn {\n\t\t\t\t...apiKey$1,\n\t\t\t\tmetadata: schema$1.apikey.fields.metadata.transform.output(apiKey$1.metadata)\n\t\t\t};\n\t\t});\n\t\tlet returningApiKey = apiKeys.map((x) => {\n\t\t\tconst { key, ...returningApiKey$1 } = x;\n\t\t\treturn {\n\t\t\t\t...returningApiKey$1,\n\t\t\t\tpermissions: returningApiKey$1.permissions ? safeJSONParse(returningApiKey$1.permissions) : null\n\t\t\t};\n\t\t});\n\t\treturn ctx.json(returningApiKey);\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/update-api-key.ts\nfunction updateApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/update\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tkeyId: z.string().meta({ description: \"The id of the Api Key\" }),\n\t\t\tuserId: z.coerce.string().meta({ description: \"The id of the user which the api key belongs to. server-only. Eg: \\\"some-user-id\\\"\" }).optional(),\n\t\t\tname: z.string().meta({ description: \"The name of the key\" }).optional(),\n\t\t\tenabled: z.boolean().meta({ description: \"Whether the Api Key is enabled or not\" }).optional(),\n\t\t\tremaining: z.number().meta({ description: \"The number of remaining requests\" }).min(1).optional(),\n\t\t\trefillAmount: z.number().meta({ description: \"The refill amount\" }).optional(),\n\t\t\trefillInterval: z.number().meta({ description: \"The refill interval\" }).optional(),\n\t\t\tmetadata: z.any().optional(),\n\t\t\texpiresIn: z.number().meta({ description: \"Expiration time of the Api Key in seconds\" }).min(1).optional().nullable(),\n\t\t\trateLimitEnabled: z.boolean().meta({ description: \"Whether the key has rate limiting enabled.\" }).optional(),\n\t\t\trateLimitTimeWindow: z.number().meta({ description: \"The duration in milliseconds where each request is counted. server-only. Eg: 1000\" }).optional(),\n\t\t\trateLimitMax: z.number().meta({ description: \"Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100\" }).optional(),\n\t\t\tpermissions: z.record(z.string(), z.array(z.string())).meta({ description: \"Update the permissions on the API Key. server-only.\" }).optional().nullable()\n\t\t}),\n\t\tmetadata: { openapi: {\n\t\t\tdescription: \"Update an existing API key by ID\",\n\t\t\tresponses: { \"200\": {\n\t\t\t\tdescription: \"API key updated successfully\",\n\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"ID\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The name of the key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The API Key prefix. Stored as plain text.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tdescription: \"The owner of the user id\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The amount to refill\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The last refill date\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Sets if key is enabled or disabled\",\n\t\t\t\t\t\t\tdefault: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\tdescription: \"Whether the key has rate limiting enabled\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"The duration in milliseconds\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Maximum amount of requests allowed within a window\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tdescription: \"The number of requests made within the rate limit time window\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Remaining requests (every time api key is used this should updated and should be updated on refill as well)\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"When last request occurred\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Expiry date of a key\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"created at\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\tdescription: \"updated at\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tdescription: \"Extra metadata about the apiKey\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\tdescription: \"Permissions for the api key (stored as JSON string)\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequired: [\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t]\n\t\t\t\t} } }\n\t\t\t} }\n\t\t} }\n\t}, async (ctx) => {\n\t\tconst { keyId, expiresIn, enabled, metadata, refillAmount, refillInterval, remaining, name, permissions, rateLimitEnabled, rateLimitTimeWindow, rateLimitMax } = ctx.body;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tconst authRequired = ctx.request || ctx.headers;\n\t\tconst user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };\n\t\tif (!user?.id) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.UNAUTHORIZED_SESSION });\n\t\tif (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.UNAUTHORIZED_SESSION });\n\t\tif (authRequired) {\n\t\t\tif (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || remaining !== void 0 || permissions !== void 0) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });\n\t\t}\n\t\tlet apiKey$1 = null;\n\t\tapiKey$1 = await getApiKeyById(ctx, keyId, opts);\n\t\tif (apiKey$1 && apiKey$1.userId !== user.id) apiKey$1 = null;\n\t\tif (!apiKey$1) throw new APIError$1(\"NOT_FOUND\", { message: ERROR_CODES.KEY_NOT_FOUND });\n\t\tlet newValues = {};\n\t\tif (name !== void 0) {\n\t\t\tif (name.length < opts.minimumNameLength) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_NAME_LENGTH });\n\t\t\telse if (name.length > opts.maximumNameLength) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_NAME_LENGTH });\n\t\t\tnewValues.name = name;\n\t\t}\n\t\tif (enabled !== void 0) newValues.enabled = enabled;\n\t\tif (expiresIn !== void 0) {\n\t\t\tif (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });\n\t\t\tif (expiresIn !== null) {\n\t\t\t\tconst expiresIn_in_days = expiresIn / (3600 * 24);\n\t\t\t\tif (expiresIn_in_days < opts.keyExpiration.minExpiresIn) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });\n\t\t\t\telse if (expiresIn_in_days > opts.keyExpiration.maxExpiresIn) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });\n\t\t\t}\n\t\t\tnewValues.expiresAt = expiresIn ? getDate(expiresIn, \"sec\") : null;\n\t\t}\n\t\tif (metadata !== void 0) {\n\t\t\tif (typeof metadata !== \"object\") throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_METADATA_TYPE });\n\t\t\tnewValues.metadata = schema$1.apikey.fields.metadata.transform.input(metadata);\n\t\t}\n\t\tif (remaining !== void 0) newValues.remaining = remaining;\n\t\tif (refillAmount !== void 0 || refillInterval !== void 0) {\n\t\t\tif (refillAmount !== void 0 && refillInterval === void 0) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });\n\t\t\telse if (refillInterval !== void 0 && refillAmount === void 0) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });\n\t\t\tnewValues.refillAmount = refillAmount;\n\t\t\tnewValues.refillInterval = refillInterval;\n\t\t}\n\t\tif (rateLimitEnabled !== void 0) newValues.rateLimitEnabled = rateLimitEnabled;\n\t\tif (rateLimitTimeWindow !== void 0) newValues.rateLimitTimeWindow = rateLimitTimeWindow;\n\t\tif (rateLimitMax !== void 0) newValues.rateLimitMax = rateLimitMax;\n\t\tif (permissions !== void 0) newValues.permissions = JSON.stringify(permissions);\n\t\tif (Object.keys(newValues).length === 0) throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.NO_VALUES_TO_UPDATE });\n\t\tlet newApiKey = apiKey$1;\n\t\ttry {\n\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\tconst dbUpdated = await ctx.context.adapter.update({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t\t}],\n\t\t\t\t\tupdate: newValues\n\t\t\t\t});\n\t\t\t\tif (dbUpdated) {\n\t\t\t\t\tawait setApiKey(ctx, dbUpdated, opts);\n\t\t\t\t\tnewApiKey = dbUpdated;\n\t\t\t\t}\n\t\t\t} else if (opts.storage === \"database\") {\n\t\t\t\tconst result = await ctx.context.adapter.update({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t\t}],\n\t\t\t\t\tupdate: newValues\n\t\t\t\t});\n\t\t\t\tif (result) newApiKey = result;\n\t\t\t} else {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...apiKey$1,\n\t\t\t\t\t...newValues,\n\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t};\n\t\t\t\tawait setApiKey(ctx, updated, opts);\n\t\t\t\tnewApiKey = updated;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new APIError$1(\"INTERNAL_SERVER_ERROR\", { message: error?.message });\n\t\t}\n\t\tdeleteAllExpiredApiKeys$1(ctx.context);\n\t\tnewApiKey.metadata = schema$1.apikey.fields.metadata.transform.output(newApiKey.metadata);\n\t\tconst { key, ...returningApiKey } = newApiKey;\n\t\treturn ctx.json({\n\t\t\t...returningApiKey,\n\t\t\tpermissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null\n\t\t});\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/rate-limit.ts\n/**\n* Determines if a request is allowed based on rate limiting parameters.\n*\n* @returns An object indicating whether the request is allowed and, if not,\n*          a message and updated ApiKey data.\n*/\nfunction isRateLimited(apiKey$1, opts) {\n\tconst now = /* @__PURE__ */ new Date();\n\tconst lastRequest = apiKey$1.lastRequest;\n\tconst rateLimitTimeWindow = apiKey$1.rateLimitTimeWindow;\n\tconst rateLimitMax = apiKey$1.rateLimitMax;\n\tlet requestCount = apiKey$1.requestCount;\n\tif (opts.rateLimit.enabled === false) return {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\tupdate: { lastRequest: now },\n\t\ttryAgainIn: null\n\t};\n\tif (apiKey$1.rateLimitEnabled === false) return {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\tupdate: { lastRequest: now },\n\t\ttryAgainIn: null\n\t};\n\tif (rateLimitTimeWindow === null || rateLimitMax === null) return {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\tupdate: null,\n\t\ttryAgainIn: null\n\t};\n\tif (lastRequest === null) return {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\tupdate: {\n\t\t\tlastRequest: now,\n\t\t\trequestCount: 1\n\t\t},\n\t\ttryAgainIn: null\n\t};\n\tconst timeSinceLastRequest = now.getTime() - new Date(lastRequest).getTime();\n\tif (timeSinceLastRequest > rateLimitTimeWindow) return {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\tupdate: {\n\t\t\tlastRequest: now,\n\t\t\trequestCount: 1\n\t\t},\n\t\ttryAgainIn: null\n\t};\n\tif (requestCount >= rateLimitMax) return {\n\t\tsuccess: false,\n\t\tmessage: ERROR_CODES.RATE_LIMIT_EXCEEDED,\n\t\tupdate: null,\n\t\ttryAgainIn: Math.ceil(rateLimitTimeWindow - timeSinceLastRequest)\n\t};\n\trequestCount++;\n\treturn {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\ttryAgainIn: null,\n\t\tupdate: {\n\t\t\tlastRequest: now,\n\t\t\trequestCount\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/verify-api-key.ts\nasync function validateApiKey({ hashedKey, ctx, opts, schema: schema$1, permissions }) {\n\tconst apiKey$1 = await getApiKey$1(ctx, hashedKey, opts);\n\tif (!apiKey$1) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.INVALID_API_KEY });\n\tif (apiKey$1.enabled === false) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\tmessage: ERROR_CODES.KEY_DISABLED,\n\t\tcode: \"KEY_DISABLED\"\n\t});\n\tif (apiKey$1.expiresAt) {\n\t\tif (Date.now() > new Date(apiKey$1.expiresAt).getTime()) {\n\t\t\ttry {\n\t\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\t\tawait deleteApiKey$1(ctx, apiKey$1, opts);\n\t\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t} else if (opts.storage === \"secondary-storage\") await deleteApiKey$1(ctx, apiKey$1, opts);\n\t\t\t\telse await ctx.context.adapter.delete({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(`Failed to delete expired API keys:`, error);\n\t\t\t}\n\t\t\tthrow new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: ERROR_CODES.KEY_EXPIRED,\n\t\t\t\tcode: \"KEY_EXPIRED\"\n\t\t\t});\n\t\t}\n\t}\n\tif (permissions) {\n\t\tconst apiKeyPermissions = apiKey$1.permissions ? safeJSONParse(apiKey$1.permissions) : null;\n\t\tif (!apiKeyPermissions) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\tmessage: ERROR_CODES.KEY_NOT_FOUND,\n\t\t\tcode: \"KEY_NOT_FOUND\"\n\t\t});\n\t\tif (!role(apiKeyPermissions).authorize(permissions).success) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\tmessage: ERROR_CODES.KEY_NOT_FOUND,\n\t\t\tcode: \"KEY_NOT_FOUND\"\n\t\t});\n\t}\n\tlet remaining = apiKey$1.remaining;\n\tlet lastRefillAt = apiKey$1.lastRefillAt;\n\tif (apiKey$1.remaining === 0 && apiKey$1.refillAmount === null) {\n\t\ttry {\n\t\t\tif (opts.storage === \"secondary-storage\") await deleteApiKey$1(ctx, apiKey$1, opts);\n\t\t\telse await ctx.context.adapter.delete({\n\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\twhere: [{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: apiKey$1.id\n\t\t\t\t}]\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tctx.context.logger.error(`Failed to delete expired API keys:`, error);\n\t\t}\n\t\tthrow new APIError$1(\"TOO_MANY_REQUESTS\", {\n\t\t\tmessage: ERROR_CODES.USAGE_EXCEEDED,\n\t\t\tcode: \"USAGE_EXCEEDED\"\n\t\t});\n\t} else if (remaining !== null) {\n\t\tlet now = Date.now();\n\t\tconst refillInterval = apiKey$1.refillInterval;\n\t\tconst refillAmount = apiKey$1.refillAmount;\n\t\tlet lastTime = new Date(lastRefillAt ?? apiKey$1.createdAt).getTime();\n\t\tif (refillInterval && refillAmount) {\n\t\t\tif (now - lastTime > refillInterval) {\n\t\t\t\tremaining = refillAmount;\n\t\t\t\tlastRefillAt = /* @__PURE__ */ new Date();\n\t\t\t}\n\t\t}\n\t\tif (remaining === 0) throw new APIError$1(\"TOO_MANY_REQUESTS\", {\n\t\t\tmessage: ERROR_CODES.USAGE_EXCEEDED,\n\t\t\tcode: \"USAGE_EXCEEDED\"\n\t\t});\n\t\telse remaining--;\n\t}\n\tconst { message, success, update, tryAgainIn } = isRateLimited(apiKey$1, opts);\n\tlet newApiKey = null;\n\tconst updated = {\n\t\t...apiKey$1,\n\t\t...update,\n\t\tremaining,\n\t\tlastRefillAt,\n\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t};\n\tif (opts.storage === \"database\") newApiKey = await ctx.context.adapter.update({\n\t\tmodel: API_KEY_TABLE_NAME,\n\t\twhere: [{\n\t\t\tfield: \"id\",\n\t\t\tvalue: apiKey$1.id\n\t\t}],\n\t\tupdate: updated\n\t});\n\telse {\n\t\tawait setApiKey(ctx, updated, opts);\n\t\tnewApiKey = updated;\n\t}\n\tif (!newApiKey) throw new APIError$1(\"INTERNAL_SERVER_ERROR\", {\n\t\tmessage: ERROR_CODES.FAILED_TO_UPDATE_API_KEY,\n\t\tcode: \"INTERNAL_SERVER_ERROR\"\n\t});\n\tif (success === false) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\tmessage: message ?? void 0,\n\t\tcode: \"RATE_LIMITED\",\n\t\tdetails: { tryAgainIn }\n\t});\n\treturn newApiKey;\n}\nfunction verifyApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {\n\treturn createAuthEndpoint(\"/api-key/verify\", {\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tkey: z.string().meta({ description: \"The key to verify\" }),\n\t\t\tpermissions: z.record(z.string(), z.array(z.string())).meta({ description: \"The permissions to verify.\" }).optional()\n\t\t}),\n\t\tmetadata: { SERVER_ONLY: true }\n\t}, async (ctx) => {\n\t\tconst { key } = ctx.body;\n\t\tif (key.length < opts.defaultKeyLength) return ctx.json({\n\t\t\tvalid: false,\n\t\t\terror: {\n\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\tcode: \"KEY_NOT_FOUND\"\n\t\t\t},\n\t\t\tkey: null\n\t\t});\n\t\tif (opts.customAPIKeyValidator) {\n\t\t\tif (!await opts.customAPIKeyValidator({\n\t\t\t\tctx,\n\t\t\t\tkey\n\t\t\t})) return ctx.json({\n\t\t\t\tvalid: false,\n\t\t\t\terror: {\n\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\t\tcode: \"KEY_NOT_FOUND\"\n\t\t\t\t},\n\t\t\t\tkey: null\n\t\t\t});\n\t\t}\n\t\tconst hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);\n\t\tlet apiKey$1 = null;\n\t\ttry {\n\t\t\tapiKey$1 = await validateApiKey({\n\t\t\t\thashedKey: hashed,\n\t\t\t\tpermissions: ctx.body.permissions,\n\t\t\t\tctx,\n\t\t\t\topts,\n\t\t\t\tschema: schema$1\n\t\t\t});\n\t\t\tawait deleteAllExpiredApiKeys$1(ctx.context);\n\t\t} catch (error) {\n\t\t\tif (error instanceof APIError$1) return ctx.json({\n\t\t\t\tvalid: false,\n\t\t\t\terror: {\n\t\t\t\t\tmessage: error.body?.message,\n\t\t\t\t\tcode: error.body?.code\n\t\t\t\t},\n\t\t\t\tkey: null\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tvalid: false,\n\t\t\t\terror: {\n\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\t\tcode: \"INVALID_API_KEY\"\n\t\t\t\t},\n\t\t\t\tkey: null\n\t\t\t});\n\t\t}\n\t\tconst { key: _, ...returningApiKey } = apiKey$1 ?? {\n\t\t\tkey: 1,\n\t\t\tpermissions: void 0\n\t\t};\n\t\tif (\"metadata\" in returningApiKey) returningApiKey.metadata = schema$1.apikey.fields.metadata.transform.output(returningApiKey.metadata);\n\t\treturningApiKey.permissions = returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null;\n\t\treturn ctx.json({\n\t\t\tvalid: true,\n\t\t\terror: null,\n\t\t\tkey: apiKey$1 === null ? null : returningApiKey\n\t\t});\n\t});\n}\n\n//#endregion\n//#region src/plugins/api-key/routes/index.ts\nlet lastChecked = null;\nasync function deleteAllExpiredApiKeys(ctx, byPassLastCheckTime = false) {\n\tif (lastChecked && !byPassLastCheckTime) {\n\t\tif ((/* @__PURE__ */ new Date()).getTime() - lastChecked.getTime() < 1e4) return;\n\t}\n\tlastChecked = /* @__PURE__ */ new Date();\n\tawait ctx.adapter.deleteMany({\n\t\tmodel: API_KEY_TABLE_NAME,\n\t\twhere: [{\n\t\t\tfield: \"expiresAt\",\n\t\t\toperator: \"lt\",\n\t\t\tvalue: /* @__PURE__ */ new Date()\n\t\t}, {\n\t\t\tfield: \"expiresAt\",\n\t\t\toperator: \"ne\",\n\t\t\tvalue: null\n\t\t}]\n\t}).catch((error) => {\n\t\tctx.logger.error(`Failed to delete expired API keys:`, error);\n\t});\n}\nfunction createApiKeyRoutes({ keyGenerator, opts, schema: schema$1 }) {\n\treturn {\n\t\tcreateApiKey: createApiKey({\n\t\t\tkeyGenerator,\n\t\t\topts,\n\t\t\tschema: schema$1,\n\t\t\tdeleteAllExpiredApiKeys\n\t\t}),\n\t\tverifyApiKey: verifyApiKey({\n\t\t\topts,\n\t\t\tschema: schema$1,\n\t\t\tdeleteAllExpiredApiKeys\n\t\t}),\n\t\tgetApiKey: getApiKey({\n\t\t\topts,\n\t\t\tschema: schema$1,\n\t\t\tdeleteAllExpiredApiKeys\n\t\t}),\n\t\tupdateApiKey: updateApiKey({\n\t\t\topts,\n\t\t\tschema: schema$1,\n\t\t\tdeleteAllExpiredApiKeys\n\t\t}),\n\t\tdeleteApiKey: deleteApiKey({\n\t\t\topts,\n\t\t\tschema: schema$1,\n\t\t\tdeleteAllExpiredApiKeys\n\t\t}),\n\t\tlistApiKeys: listApiKeys({\n\t\t\topts,\n\t\t\tschema: schema$1,\n\t\t\tdeleteAllExpiredApiKeys\n\t\t}),\n\t\tdeleteAllExpiredApiKeys: deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys })\n\t};\n}\n\n//#endregion\n//#region src/plugins/api-key/schema.ts\nconst apiKeySchema = ({ timeWindow, rateLimitMax }) => ({ apikey: { fields: {\n\tname: {\n\t\ttype: \"string\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tstart: {\n\t\ttype: \"string\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tprefix: {\n\t\ttype: \"string\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tkey: {\n\t\ttype: \"string\",\n\t\trequired: true,\n\t\tinput: false,\n\t\tindex: true\n\t},\n\tuserId: {\n\t\ttype: \"string\",\n\t\treferences: {\n\t\t\tmodel: \"user\",\n\t\t\tfield: \"id\",\n\t\t\tonDelete: \"cascade\"\n\t\t},\n\t\trequired: true,\n\t\tinput: false,\n\t\tindex: true\n\t},\n\trefillInterval: {\n\t\ttype: \"number\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\trefillAmount: {\n\t\ttype: \"number\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tlastRefillAt: {\n\t\ttype: \"date\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tenabled: {\n\t\ttype: \"boolean\",\n\t\trequired: false,\n\t\tinput: false,\n\t\tdefaultValue: true\n\t},\n\trateLimitEnabled: {\n\t\ttype: \"boolean\",\n\t\trequired: false,\n\t\tinput: false,\n\t\tdefaultValue: true\n\t},\n\trateLimitTimeWindow: {\n\t\ttype: \"number\",\n\t\trequired: false,\n\t\tinput: false,\n\t\tdefaultValue: timeWindow\n\t},\n\trateLimitMax: {\n\t\ttype: \"number\",\n\t\trequired: false,\n\t\tinput: false,\n\t\tdefaultValue: rateLimitMax\n\t},\n\trequestCount: {\n\t\ttype: \"number\",\n\t\trequired: false,\n\t\tinput: false,\n\t\tdefaultValue: 0\n\t},\n\tremaining: {\n\t\ttype: \"number\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tlastRequest: {\n\t\ttype: \"date\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\texpiresAt: {\n\t\ttype: \"date\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tcreatedAt: {\n\t\ttype: \"date\",\n\t\trequired: true,\n\t\tinput: false\n\t},\n\tupdatedAt: {\n\t\ttype: \"date\",\n\t\trequired: true,\n\t\tinput: false\n\t},\n\tpermissions: {\n\t\ttype: \"string\",\n\t\trequired: false,\n\t\tinput: false\n\t},\n\tmetadata: {\n\t\ttype: \"string\",\n\t\trequired: false,\n\t\tinput: true,\n\t\ttransform: {\n\t\t\tinput(value) {\n\t\t\t\treturn JSON.stringify(value);\n\t\t\t},\n\t\t\toutput(value) {\n\t\t\t\tif (!value) return null;\n\t\t\t\treturn parser_default(value);\n\t\t\t}\n\t\t}\n\t}\n} } });\n\n//#endregion\n//#region src/plugins/api-key/index.ts\nconst defaultKeyHasher = async (key) => {\n\tconst hash = await createHash(\"SHA-256\").digest(new TextEncoder().encode(key));\n\treturn base64Url.encode(new Uint8Array(hash), { padding: false });\n};\nconst ERROR_CODES = defineErrorCodes({\n\tINVALID_METADATA_TYPE: \"metadata must be an object or undefined\",\n\tREFILL_AMOUNT_AND_INTERVAL_REQUIRED: \"refillAmount is required when refillInterval is provided\",\n\tREFILL_INTERVAL_AND_AMOUNT_REQUIRED: \"refillInterval is required when refillAmount is provided\",\n\tUSER_BANNED: \"User is banned\",\n\tUNAUTHORIZED_SESSION: \"Unauthorized or invalid session\",\n\tKEY_NOT_FOUND: \"API Key not found\",\n\tKEY_DISABLED: \"API Key is disabled\",\n\tKEY_EXPIRED: \"API Key has expired\",\n\tUSAGE_EXCEEDED: \"API Key has reached its usage limit\",\n\tKEY_NOT_RECOVERABLE: \"API Key is not recoverable\",\n\tEXPIRES_IN_IS_TOO_SMALL: \"The expiresIn is smaller than the predefined minimum value.\",\n\tEXPIRES_IN_IS_TOO_LARGE: \"The expiresIn is larger than the predefined maximum value.\",\n\tINVALID_REMAINING: \"The remaining count is either too large or too small.\",\n\tINVALID_PREFIX_LENGTH: \"The prefix length is either too large or too small.\",\n\tINVALID_NAME_LENGTH: \"The name length is either too large or too small.\",\n\tMETADATA_DISABLED: \"Metadata is disabled.\",\n\tRATE_LIMIT_EXCEEDED: \"Rate limit exceeded.\",\n\tNO_VALUES_TO_UPDATE: \"No values to update.\",\n\tKEY_DISABLED_EXPIRATION: \"Custom key expiration values are disabled.\",\n\tINVALID_API_KEY: \"Invalid API key.\",\n\tINVALID_USER_ID_FROM_API_KEY: \"The user id from the API key is invalid.\",\n\tINVALID_API_KEY_GETTER_RETURN_TYPE: \"API Key getter returned an invalid key type. Expected string.\",\n\tSERVER_ONLY_PROPERTY: \"The property you're trying to set can only be set from the server auth instance only.\",\n\tFAILED_TO_UPDATE_API_KEY: \"Failed to update API key\",\n\tNAME_REQUIRED: \"API Key name is required.\"\n});\nconst API_KEY_TABLE_NAME = \"apikey\";\nconst apiKey = (options) => {\n\tconst opts = {\n\t\t...options,\n\t\tapiKeyHeaders: options?.apiKeyHeaders ?? \"x-api-key\",\n\t\tdefaultKeyLength: options?.defaultKeyLength || 64,\n\t\tmaximumPrefixLength: options?.maximumPrefixLength ?? 32,\n\t\tminimumPrefixLength: options?.minimumPrefixLength ?? 1,\n\t\tmaximumNameLength: options?.maximumNameLength ?? 32,\n\t\tminimumNameLength: options?.minimumNameLength ?? 1,\n\t\tenableMetadata: options?.enableMetadata ?? false,\n\t\tdisableKeyHashing: options?.disableKeyHashing ?? false,\n\t\trequireName: options?.requireName ?? false,\n\t\tstorage: options?.storage ?? \"database\",\n\t\trateLimit: {\n\t\t\tenabled: options?.rateLimit?.enabled === void 0 ? true : options?.rateLimit?.enabled,\n\t\t\ttimeWindow: options?.rateLimit?.timeWindow ?? 1e3 * 60 * 60 * 24,\n\t\t\tmaxRequests: options?.rateLimit?.maxRequests ?? 10\n\t\t},\n\t\tkeyExpiration: {\n\t\t\tdefaultExpiresIn: options?.keyExpiration?.defaultExpiresIn ?? null,\n\t\t\tdisableCustomExpiresTime: options?.keyExpiration?.disableCustomExpiresTime ?? false,\n\t\t\tmaxExpiresIn: options?.keyExpiration?.maxExpiresIn ?? 365,\n\t\t\tminExpiresIn: options?.keyExpiration?.minExpiresIn ?? 1\n\t\t},\n\t\tstartingCharactersConfig: {\n\t\t\tshouldStore: options?.startingCharactersConfig?.shouldStore ?? true,\n\t\t\tcharactersLength: options?.startingCharactersConfig?.charactersLength ?? 6\n\t\t},\n\t\tenableSessionForAPIKeys: options?.enableSessionForAPIKeys ?? false,\n\t\tfallbackToDatabase: options?.fallbackToDatabase ?? false,\n\t\tcustomStorage: options?.customStorage\n\t};\n\tconst schema$1 = mergeSchema(apiKeySchema({\n\t\trateLimitMax: opts.rateLimit.maxRequests,\n\t\ttimeWindow: opts.rateLimit.timeWindow\n\t}), opts.schema);\n\tconst getter = opts.customAPIKeyGetter || ((ctx) => {\n\t\tif (Array.isArray(opts.apiKeyHeaders)) for (const header of opts.apiKeyHeaders) {\n\t\t\tconst value = ctx.headers?.get(header);\n\t\t\tif (value) return value;\n\t\t}\n\t\telse return ctx.headers?.get(opts.apiKeyHeaders);\n\t});\n\tconst routes = createApiKeyRoutes({\n\t\tkeyGenerator: opts.customKeyGenerator || (async (options$1) => {\n\t\t\tconst key = generateRandomString(options$1.length, \"a-z\", \"A-Z\");\n\t\t\treturn `${options$1.prefix || \"\"}${key}`;\n\t\t}),\n\t\topts,\n\t\tschema: schema$1\n\t});\n\treturn {\n\t\tid: \"api-key\",\n\t\t$ERROR_CODES: ERROR_CODES,\n\t\thooks: { before: [{\n\t\t\tmatcher: (ctx) => !!getter(ctx) && opts.enableSessionForAPIKeys,\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst key = getter(ctx);\n\t\t\t\tif (typeof key !== \"string\") throw new APIError$1(\"BAD_REQUEST\", { message: ERROR_CODES.INVALID_API_KEY_GETTER_RETURN_TYPE });\n\t\t\t\tif (key.length < opts.defaultKeyLength) throw new APIError$1(\"FORBIDDEN\", { message: ERROR_CODES.INVALID_API_KEY });\n\t\t\t\tif (opts.customAPIKeyValidator) {\n\t\t\t\t\tif (!await opts.customAPIKeyValidator({\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\tkey\n\t\t\t\t\t})) throw new APIError$1(\"FORBIDDEN\", { message: ERROR_CODES.INVALID_API_KEY });\n\t\t\t\t}\n\t\t\t\tconst apiKey$1 = await validateApiKey({\n\t\t\t\t\thashedKey: opts.disableKeyHashing ? key : await defaultKeyHasher(key),\n\t\t\t\t\tctx,\n\t\t\t\t\topts,\n\t\t\t\t\tschema: schema$1\n\t\t\t\t});\n\t\t\t\tdeleteAllExpiredApiKeys(ctx.context).catch((err) => {\n\t\t\t\t\tctx.context.logger.error(\"Failed to delete expired API keys:\", err);\n\t\t\t\t});\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(apiKey$1.userId);\n\t\t\t\tif (!user) throw new APIError$1(\"UNAUTHORIZED\", { message: ERROR_CODES.INVALID_USER_ID_FROM_API_KEY });\n\t\t\t\tconst session = {\n\t\t\t\t\tuser,\n\t\t\t\t\tsession: {\n\t\t\t\t\t\tid: apiKey$1.id,\n\t\t\t\t\t\ttoken: key,\n\t\t\t\t\t\tuserId: apiKey$1.userId,\n\t\t\t\t\t\tuserAgent: ctx.request?.headers.get(\"user-agent\") ?? null,\n\t\t\t\t\t\tipAddress: ctx.request ? getIp(ctx.request, ctx.context.options) : null,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\texpiresAt: apiKey$1.expiresAt || getDate(ctx.context.options.session?.expiresIn || 3600 * 24 * 7, \"ms\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tctx.context.session = session;\n\t\t\t\tif (ctx.path === \"/get-session\") return session;\n\t\t\t\telse return { context: ctx };\n\t\t\t})\n\t\t}] },\n\t\tendpoints: {\n\t\t\tcreateApiKey: routes.createApiKey,\n\t\t\tverifyApiKey: routes.verifyApiKey,\n\t\t\tgetApiKey: routes.getApiKey,\n\t\t\tupdateApiKey: routes.updateApiKey,\n\t\t\tdeleteApiKey: routes.deleteApiKey,\n\t\t\tlistApiKeys: routes.listApiKeys,\n\t\t\tdeleteAllExpiredApiKeys: routes.deleteAllExpiredApiKeys\n\t\t},\n\t\tschema: schema$1\n\t};\n};\n\n//#endregion\n//#region src/plugins/last-login-method/index.ts\n/**\n* Plugin to track the last used login method\n*/\nconst lastLoginMethod = (userConfig) => {\n\tconst paths = [\n\t\t\"/callback/:id\",\n\t\t\"/oauth2/callback/:providerId\",\n\t\t\"/sign-in/email\",\n\t\t\"/sign-up/email\"\n\t];\n\tconst defaultResolveMethod = (ctx) => {\n\t\tif (paths.includes(ctx.path)) return ctx.params?.id || ctx.params?.providerId || ctx.path.split(\"/\").pop();\n\t\tif (ctx.path.includes(\"siwe\")) return \"siwe\";\n\t\tif (ctx.path.includes(\"/passkey/verify-authentication\")) return \"passkey\";\n\t\treturn null;\n\t};\n\tconst config = {\n\t\tcookieName: \"better-auth.last_used_login_method\",\n\t\tmaxAge: 3600 * 24 * 30,\n\t\t...userConfig\n\t};\n\treturn {\n\t\tid: \"last-login-method\",\n\t\tinit(ctx) {\n\t\t\treturn { options: { databaseHooks: {\n\t\t\t\tuser: { create: { async before(user, context) {\n\t\t\t\t\tif (!config.storeInDatabase) return;\n\t\t\t\t\tif (!context) return;\n\t\t\t\t\tconst lastUsedLoginMethod = config.customResolveMethod?.(context) ?? defaultResolveMethod(context);\n\t\t\t\t\tif (lastUsedLoginMethod) return { data: {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\tlastLoginMethod: lastUsedLoginMethod\n\t\t\t\t\t} };\n\t\t\t\t} } },\n\t\t\t\tsession: { create: { async after(session, context) {\n\t\t\t\t\tif (!config.storeInDatabase) return;\n\t\t\t\t\tif (!context) return;\n\t\t\t\t\tconst lastUsedLoginMethod = config.customResolveMethod?.(context) ?? defaultResolveMethod(context);\n\t\t\t\t\tif (lastUsedLoginMethod && session?.userId) try {\n\t\t\t\t\t\tawait ctx.internalAdapter.updateUser(session.userId, { lastLoginMethod: lastUsedLoginMethod });\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tctx.logger.error(\"Failed to update lastLoginMethod\", error);\n\t\t\t\t\t}\n\t\t\t\t} } }\n\t\t\t} } };\n\t\t},\n\t\thooks: { after: [{\n\t\t\tmatcher() {\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst lastUsedLoginMethod = config.customResolveMethod?.(ctx) ?? defaultResolveMethod(ctx);\n\t\t\t\tif (lastUsedLoginMethod) {\n\t\t\t\t\tconst setCookie = ctx.context.responseHeaders?.get(\"set-cookie\");\n\t\t\t\t\tconst sessionTokenName = ctx.context.authCookies.sessionToken.name;\n\t\t\t\t\tif (setCookie && setCookie.includes(sessionTokenName)) {\n\t\t\t\t\t\tconst cookieAttributes = {\n\t\t\t\t\t\t\t...ctx.context.authCookies.sessionToken.options,\n\t\t\t\t\t\t\tmaxAge: config.maxAge,\n\t\t\t\t\t\t\thttpOnly: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tctx.setCookie(config.cookieName, lastUsedLoginMethod, cookieAttributes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}] },\n\t\tschema: config.storeInDatabase ? { user: { fields: { lastLoginMethod: {\n\t\t\ttype: \"string\",\n\t\t\tinput: false,\n\t\t\trequired: false,\n\t\t\tfieldName: config.schema?.user?.lastLoginMethod || \"lastLoginMethod\"\n\t\t} } } } : void 0\n\t};\n};\n\n//#endregion\n//#region src/plugins/mcp/authorize.ts\nfunction redirectErrorURL(url, error, description) {\n\treturn `${url.includes(\"?\") ? \"&\" : \"?\"}error=${error}&error_description=${description}`;\n}\nasync function authorizeMCPOAuth(ctx, options) {\n\tctx.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\tctx.setHeader(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\");\n\tctx.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\");\n\tctx.setHeader(\"Access-Control-Max-Age\", \"86400\");\n\tconst opts = {\n\t\tcodeExpiresIn: 600,\n\t\tdefaultScope: \"openid\",\n\t\t...options,\n\t\tscopes: [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\",\n\t\t\t...options?.scopes || []\n\t\t]\n\t};\n\tif (!ctx.request) throw new APIError(\"UNAUTHORIZED\", {\n\t\terror_description: \"request not found\",\n\t\terror: \"invalid_request\"\n\t});\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session) {\n\t\t/**\n\t\t* If the user is not logged in, we need to redirect them to the\n\t\t* login page.\n\t\t*/\n\t\tawait ctx.setSignedCookie(\"oidc_login_prompt\", JSON.stringify(ctx.query), ctx.context.secret, {\n\t\t\tmaxAge: 600,\n\t\t\tpath: \"/\",\n\t\t\tsameSite: \"lax\"\n\t\t});\n\t\tconst queryFromURL = ctx.request.url?.split(\"?\")[1];\n\t\tthrow ctx.redirect(`${options.loginPage}?${queryFromURL}`);\n\t}\n\tconst query = ctx.query;\n\tif (!query.client_id) throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_client`);\n\tif (!query.response_type) throw ctx.redirect(redirectErrorURL(`${ctx.context.baseURL}/error`, \"invalid_request\", \"response_type is required\"));\n\tconst client = await ctx.context.adapter.findOne({\n\t\tmodel: \"oauthApplication\",\n\t\twhere: [{\n\t\t\tfield: \"clientId\",\n\t\t\tvalue: ctx.query.client_id\n\t\t}]\n\t}).then((res) => {\n\t\tif (!res) return null;\n\t\treturn {\n\t\t\t...res,\n\t\t\tredirectUrls: res.redirectUrls.split(\",\"),\n\t\t\tmetadata: res.metadata ? JSON.parse(res.metadata) : {}\n\t\t};\n\t});\n\tif (!client) throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_client`);\n\tconst redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);\n\tif (!redirectURI || !query.redirect_uri)\n /**\n\t* show UI error here warning the user that the redirect URI is invalid\n\t*/\n\tthrow new APIError(\"BAD_REQUEST\", { message: \"Invalid redirect URI\" });\n\tif (client.disabled) throw ctx.redirect(`${ctx.context.baseURL}/error?error=client_disabled`);\n\tif (query.response_type !== \"code\") throw ctx.redirect(`${ctx.context.baseURL}/error?error=unsupported_response_type`);\n\tconst requestScope = query.scope?.split(\" \").filter((s) => s) || opts.defaultScope.split(\" \");\n\tconst invalidScopes = requestScope.filter((scope) => {\n\t\treturn !opts.scopes.includes(scope);\n\t});\n\tif (invalidScopes.length) throw ctx.redirect(redirectErrorURL(query.redirect_uri, \"invalid_scope\", `The following scopes are invalid: ${invalidScopes.join(\", \")}`));\n\tif ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) throw ctx.redirect(redirectErrorURL(query.redirect_uri, \"invalid_request\", \"pkce is required\"));\n\tif (!query.code_challenge_method) query.code_challenge_method = \"plain\";\n\tif (![\"s256\", options.allowPlainCodeChallengeMethod ? \"plain\" : \"s256\"].includes(query.code_challenge_method?.toLowerCase() || \"\")) throw ctx.redirect(redirectErrorURL(query.redirect_uri, \"invalid_request\", \"invalid code_challenge method\"));\n\tconst code = generateRandomString(32, \"a-z\", \"A-Z\", \"0-9\");\n\tconst codeExpiresInMs = opts.codeExpiresIn * 1e3;\n\tconst expiresAt = new Date(Date.now() + codeExpiresInMs);\n\ttry {\n\t\t/**\n\t\t* Save the code in the database\n\t\t*/\n\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\tvalue: JSON.stringify({\n\t\t\t\tclientId: client.clientId,\n\t\t\t\tredirectURI: query.redirect_uri,\n\t\t\t\tscope: requestScope,\n\t\t\t\tuserId: session.user.id,\n\t\t\t\tauthTime: new Date(session.session.createdAt).getTime(),\n\t\t\t\trequireConsent: query.prompt === \"consent\",\n\t\t\t\tstate: query.prompt === \"consent\" ? query.state : null,\n\t\t\t\tcodeChallenge: query.code_challenge,\n\t\t\t\tcodeChallengeMethod: query.code_challenge_method,\n\t\t\t\tnonce: query.nonce\n\t\t\t}),\n\t\t\tidentifier: code,\n\t\t\texpiresAt\n\t\t});\n\t} catch (e) {\n\t\tthrow ctx.redirect(redirectErrorURL(query.redirect_uri, \"server_error\", \"An error occurred while processing the request\"));\n\t}\n\tif (query.prompt !== \"consent\") {\n\t\tconst redirectURIWithCode$1 = new URL(redirectURI);\n\t\tredirectURIWithCode$1.searchParams.set(\"code\", code);\n\t\tredirectURIWithCode$1.searchParams.set(\"state\", ctx.query.state);\n\t\tthrow ctx.redirect(redirectURIWithCode$1.toString());\n\t}\n\tif (options?.consentPage) {\n\t\tawait ctx.setSignedCookie(\"oidc_consent_prompt\", code, ctx.context.secret, {\n\t\t\tmaxAge: 600,\n\t\t\tpath: \"/\",\n\t\t\tsameSite: \"lax\"\n\t\t});\n\t\tconst urlParams = new URLSearchParams();\n\t\turlParams.set(\"consent_code\", code);\n\t\turlParams.set(\"client_id\", client.clientId);\n\t\turlParams.set(\"scope\", requestScope.join(\" \"));\n\t\tconst consentURI = `${options.consentPage}?${urlParams.toString()}`;\n\t\tthrow ctx.redirect(consentURI);\n\t}\n\tconst redirectURIWithCode = new URL(redirectURI);\n\tredirectURIWithCode.searchParams.set(\"code\", code);\n\tredirectURIWithCode.searchParams.set(\"state\", ctx.query.state);\n\tthrow ctx.redirect(redirectURIWithCode.toString());\n}\n\n//#endregion\n//#region src/plugins/mcp/index.ts\nconst getMCPProviderMetadata = (ctx, options) => {\n\tconst issuer = ctx.context.options.baseURL;\n\tconst baseURL = ctx.context.baseURL;\n\tif (!issuer || !baseURL) throw new APIError$1(\"INTERNAL_SERVER_ERROR\", {\n\t\terror: \"invalid_issuer\",\n\t\terror_description: \"issuer or baseURL is not set. If you're the app developer, please make sure to set the `baseURL` in your auth config.\"\n\t});\n\treturn {\n\t\tissuer,\n\t\tauthorization_endpoint: `${baseURL}/mcp/authorize`,\n\t\ttoken_endpoint: `${baseURL}/mcp/token`,\n\t\tuserinfo_endpoint: `${baseURL}/mcp/userinfo`,\n\t\tjwks_uri: `${baseURL}/mcp/jwks`,\n\t\tregistration_endpoint: `${baseURL}/mcp/register`,\n\t\tscopes_supported: [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\"\n\t\t],\n\t\tresponse_types_supported: [\"code\"],\n\t\tresponse_modes_supported: [\"query\"],\n\t\tgrant_types_supported: [\"authorization_code\", \"refresh_token\"],\n\t\tacr_values_supported: [\"urn:mace:incommon:iap:silver\", \"urn:mace:incommon:iap:bronze\"],\n\t\tsubject_types_supported: [\"public\"],\n\t\tid_token_signing_alg_values_supported: [\"RS256\", \"none\"],\n\t\ttoken_endpoint_auth_methods_supported: [\n\t\t\t\"client_secret_basic\",\n\t\t\t\"client_secret_post\",\n\t\t\t\"none\"\n\t\t],\n\t\tcode_challenge_methods_supported: [\"S256\"],\n\t\tclaims_supported: [\n\t\t\t\"sub\",\n\t\t\t\"iss\",\n\t\t\t\"aud\",\n\t\t\t\"exp\",\n\t\t\t\"nbf\",\n\t\t\t\"iat\",\n\t\t\t\"jti\",\n\t\t\t\"email\",\n\t\t\t\"email_verified\",\n\t\t\t\"name\"\n\t\t],\n\t\t...options?.metadata\n\t};\n};\nconst getMCPProtectedResourceMetadata = (ctx, options) => {\n\tconst baseURL = ctx.context.baseURL;\n\tconst origin = new URL(baseURL).origin;\n\treturn {\n\t\tresource: options?.resource ?? origin,\n\t\tauthorization_servers: [origin],\n\t\tjwks_uri: options?.oidcConfig?.metadata?.jwks_uri ?? `${baseURL}/mcp/jwks`,\n\t\tscopes_supported: options?.oidcConfig?.metadata?.scopes_supported ?? [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\"\n\t\t],\n\t\tbearer_methods_supported: [\"header\"],\n\t\tresource_signing_alg_values_supported: [\"RS256\", \"none\"]\n\t};\n};\nconst mcp = (options) => {\n\tconst opts = {\n\t\tcodeExpiresIn: 600,\n\t\tdefaultScope: \"openid\",\n\t\taccessTokenExpiresIn: 3600,\n\t\trefreshTokenExpiresIn: 604800,\n\t\tallowPlainCodeChallengeMethod: true,\n\t\t...options.oidcConfig,\n\t\tloginPage: options.loginPage,\n\t\tscopes: [\n\t\t\t\"openid\",\n\t\t\t\"profile\",\n\t\t\t\"email\",\n\t\t\t\"offline_access\",\n\t\t\t...options.oidcConfig?.scopes || []\n\t\t]\n\t};\n\tconst modelName = {\n\t\toauthClient: \"oauthApplication\",\n\t\toauthAccessToken: \"oauthAccessToken\",\n\t\toauthConsent: \"oauthConsent\"\n\t};\n\tconst provider = oidcProvider(opts);\n\treturn {\n\t\tid: \"mcp\",\n\t\thooks: { after: [{\n\t\t\tmatcher() {\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\tconst cookie = await ctx.getSignedCookie(\"oidc_login_prompt\", ctx.context.secret);\n\t\t\t\tconst cookieName = ctx.context.authCookies.sessionToken.name;\n\t\t\t\tconst parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get(\"set-cookie\") || \"\");\n\t\t\t\tconst hasSessionToken = parsedSetCookieHeader.has(cookieName);\n\t\t\t\tif (!cookie || !hasSessionToken) return;\n\t\t\t\tctx.setCookie(\"oidc_login_prompt\", \"\", { maxAge: 0 });\n\t\t\t\tconst sessionToken = (parsedSetCookieHeader.get(cookieName)?.value)?.split(\".\")[0];\n\t\t\t\tif (!sessionToken) return;\n\t\t\t\tconst session = await ctx.context.internalAdapter.findSession(sessionToken) || ctx.context.newSession;\n\t\t\t\tif (!session) return;\n\t\t\t\tconst promptSet = parsePrompt(String(ctx.query?.prompt));\n\t\t\t\tif (promptSet.has(\"login\")) {\n\t\t\t\t\tconst newPromptSet = new Set(promptSet);\n\t\t\t\t\tnewPromptSet.delete(\"login\");\n\t\t\t\t\tctx.query = {\n\t\t\t\t\t\t...ctx.query,\n\t\t\t\t\t\tprompt: Array.from(newPromptSet).join(\" \")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tctx.context.session = session;\n\t\t\t\treturn await authorizeMCPOAuth(ctx, opts);\n\t\t\t})\n\t\t}] },\n\t\tendpoints: {\n\t\t\toAuthConsent: provider.endpoints.oAuthConsent,\n\t\t\tgetMcpOAuthConfig: createAuthEndpoint(\"/.well-known/oauth-authorization-server\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tmetadata: { ...HIDE_METADATA }\n\t\t\t}, async (c) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst metadata = getMCPProviderMetadata(c, options);\n\t\t\t\t\treturn c.json(metadata);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(e);\n\t\t\t\t\treturn c.json(null);\n\t\t\t\t}\n\t\t\t}),\n\t\t\tgetMCPProtectedResource: createAuthEndpoint(\"/.well-known/oauth-protected-resource\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tmetadata: { ...HIDE_METADATA }\n\t\t\t}, async (c) => {\n\t\t\t\tconst metadata = getMCPProtectedResourceMetadata(c, options);\n\t\t\t\treturn c.json(metadata);\n\t\t\t}),\n\t\t\tmcpOAuthAuthorize: createAuthEndpoint(\"/mcp/authorize\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: z.record(z.string(), z.any()),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Authorize an OAuth2 request using MCP\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"Authorization response generated successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tdescription: \"Authorization response, contents depend on the authorize function implementation\"\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\treturn authorizeMCPOAuth(ctx, opts);\n\t\t\t}),\n\t\t\tmcpOAuthToken: createAuthEndpoint(\"/mcp/token\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.record(z.any(), z.any()),\n\t\t\t\tmetadata: {\n\t\t\t\t\tisAction: false,\n\t\t\t\t\tallowedMediaTypes: [\"application/x-www-form-urlencoded\", \"application/json\"]\n\t\t\t\t}\n\t\t\t}, async (ctx) => {\n\t\t\t\tctx.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\t\t\t\tctx.setHeader(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\");\n\t\t\t\tctx.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\");\n\t\t\t\tctx.setHeader(\"Access-Control-Max-Age\", \"86400\");\n\t\t\t\tlet { body } = ctx;\n\t\t\t\tif (!body) throw ctx.error(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"request body not found\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (body instanceof FormData) body = Object.fromEntries(body.entries());\n\t\t\t\tif (!(body instanceof Object)) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"request body is not an object\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tlet { client_id, client_secret } = body;\n\t\t\t\tconst authorization = ctx.request?.headers.get(\"authorization\") || null;\n\t\t\t\tif (authorization && !client_id && !client_secret && authorization.startsWith(\"Basic \")) try {\n\t\t\t\t\tconst encoded = authorization.replace(\"Basic \", \"\");\n\t\t\t\t\tconst decoded = new TextDecoder().decode(base64.decode(encoded));\n\t\t\t\t\tif (!decoded.includes(\":\")) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid authorization header format\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tconst [id, secret] = decoded.split(\":\");\n\t\t\t\t\tif (!id || !secret) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid authorization header format\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tclient_id = id;\n\t\t\t\t\tclient_secret = secret;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid authorization header format\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;\n\t\t\t\tif (grant_type === \"refresh_token\") {\n\t\t\t\t\tif (!refresh_token) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror_description: \"refresh_token is required\",\n\t\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t\t});\n\t\t\t\t\tconst token = await ctx.context.adapter.findOne({\n\t\t\t\t\t\tmodel: \"oauthAccessToken\",\n\t\t\t\t\t\twhere: [{\n\t\t\t\t\t\t\tfield: \"refreshToken\",\n\t\t\t\t\t\t\tvalue: refresh_token.toString()\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (!token) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid refresh token\",\n\t\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t\t});\n\t\t\t\t\tif (token.clientId !== client_id?.toString()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid client_id\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tif (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"refresh token expired\",\n\t\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t\t});\n\t\t\t\t\tconst accessToken$1 = generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\t\tconst newRefreshToken = generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\t\tconst accessTokenExpiresAt$1 = new Date(Date.now() + opts.accessTokenExpiresIn * 1e3);\n\t\t\t\t\tconst refreshTokenExpiresAt$1 = new Date(Date.now() + opts.refreshTokenExpiresIn * 1e3);\n\t\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\taccessToken: accessToken$1,\n\t\t\t\t\t\t\trefreshToken: newRefreshToken,\n\t\t\t\t\t\t\taccessTokenExpiresAt: accessTokenExpiresAt$1,\n\t\t\t\t\t\t\trefreshTokenExpiresAt: refreshTokenExpiresAt$1,\n\t\t\t\t\t\t\tclientId: client_id.toString(),\n\t\t\t\t\t\t\tuserId: token.userId,\n\t\t\t\t\t\t\tscopes: token.scopes,\n\t\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\taccess_token: accessToken$1,\n\t\t\t\t\t\ttoken_type: \"bearer\",\n\t\t\t\t\t\texpires_in: opts.accessTokenExpiresIn,\n\t\t\t\t\t\trefresh_token: newRefreshToken,\n\t\t\t\t\t\tscope: token.scopes\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!code) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"code is required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (opts.requirePKCE && !code_verifier) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"code verifier is missing\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\t/**\n\t\t\t\t* We need to check if the code is valid before we can proceed\n\t\t\t\t* with the rest of the request.\n\t\t\t\t*/\n\t\t\t\tconst verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());\n\t\t\t\tif (!verificationValue) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid code\",\n\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t});\n\t\t\t\tif (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"code expired\",\n\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t});\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tif (!client_id) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"client_id is required\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (!grant_type) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"grant_type is required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif (grant_type !== \"authorization_code\") throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"grant_type must be 'authorization_code'\",\n\t\t\t\t\terror: \"unsupported_grant_type\"\n\t\t\t\t});\n\t\t\t\tif (!redirect_uri) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"redirect_uri is required\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst client = await ctx.context.adapter.findOne({\n\t\t\t\t\tmodel: modelName.oauthClient,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"clientId\",\n\t\t\t\t\t\tvalue: client_id.toString()\n\t\t\t\t\t}]\n\t\t\t\t}).then((res) => {\n\t\t\t\t\tif (!res) return null;\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...res,\n\t\t\t\t\t\tredirectUrls: res.redirectUrls.split(\",\"),\n\t\t\t\t\t\tmetadata: res.metadata ? JSON.parse(res.metadata) : {}\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tif (!client) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid client_id\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (client.disabled) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"client is disabled\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (client.type === \"public\") {\n\t\t\t\t\tif (!code_verifier) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror_description: \"code verifier is required for public clients\",\n\t\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!client_secret) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"client_secret is required for confidential clients\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t\tif (!(client.clientSecret === client_secret.toString())) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\t\terror_description: \"invalid client_secret\",\n\t\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst value = JSON.parse(verificationValue.value);\n\t\t\t\tif (value.clientId !== client_id.toString()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid client_id\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (value.redirectURI !== redirect_uri.toString()) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"invalid redirect_uri\",\n\t\t\t\t\terror: \"invalid_client\"\n\t\t\t\t});\n\t\t\t\tif (value.codeChallenge && !code_verifier) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror_description: \"code verifier is missing\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tif ((value.codeChallengeMethod === \"plain\" ? code_verifier : await createHash(\"SHA-256\", \"base64urlnopad\").digest(code_verifier)) !== value.codeChallenge) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"code verification failed\",\n\t\t\t\t\terror: \"invalid_request\"\n\t\t\t\t});\n\t\t\t\tconst requestedScopes = value.scope;\n\t\t\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);\n\t\t\t\tconst accessToken = generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst refreshToken = generateRandomString(32, \"A-Z\", \"a-z\");\n\t\t\t\tconst accessTokenExpiresAt = new Date(Date.now() + opts.accessTokenExpiresIn * 1e3);\n\t\t\t\tconst refreshTokenExpiresAt = new Date(Date.now() + opts.refreshTokenExpiresIn * 1e3);\n\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\taccessToken,\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\taccessTokenExpiresAt,\n\t\t\t\t\t\trefreshTokenExpiresAt,\n\t\t\t\t\t\tclientId: client_id.toString(),\n\t\t\t\t\t\tuserId: value.userId,\n\t\t\t\t\t\tscopes: requestedScopes.join(\" \"),\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(value.userId);\n\t\t\t\tif (!user) throw new APIError$1(\"UNAUTHORIZED\", {\n\t\t\t\t\terror_description: \"user not found\",\n\t\t\t\t\terror: \"invalid_grant\"\n\t\t\t\t});\n\t\t\t\tlet secretKey = {\n\t\t\t\t\talg: \"HS256\",\n\t\t\t\t\tkey: await getWebcryptoSubtle().generateKey({\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t}, true, [\"sign\", \"verify\"])\n\t\t\t\t};\n\t\t\t\tconst profile = {\n\t\t\t\t\tgiven_name: user.name.split(\" \")[0],\n\t\t\t\t\tfamily_name: user.name.split(\" \")[1],\n\t\t\t\t\tname: user.name,\n\t\t\t\t\tprofile: user.image,\n\t\t\t\t\tupdated_at: Math.floor(new Date(user.updatedAt).getTime() / 1e3)\n\t\t\t\t};\n\t\t\t\tconst email = {\n\t\t\t\t\temail: user.email,\n\t\t\t\t\temail_verified: user.emailVerified\n\t\t\t\t};\n\t\t\t\tconst userClaims = {\n\t\t\t\t\t...requestedScopes.includes(\"profile\") ? profile : {},\n\t\t\t\t\t...requestedScopes.includes(\"email\") ? email : {}\n\t\t\t\t};\n\t\t\t\tconst additionalUserClaims = opts.getAdditionalUserInfoClaim ? await opts.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};\n\t\t\t\tconst idToken = await new SignJWT({\n\t\t\t\t\tsub: user.id,\n\t\t\t\t\taud: client_id.toString(),\n\t\t\t\t\tiat: Date.now(),\n\t\t\t\t\tauth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,\n\t\t\t\t\tnonce: value.nonce,\n\t\t\t\t\tacr: \"urn:mace:incommon:iap:silver\",\n\t\t\t\t\t...userClaims,\n\t\t\t\t\t...additionalUserClaims\n\t\t\t\t}).setProtectedHeader({ alg: secretKey.alg }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1e3) + opts.accessTokenExpiresIn).sign(secretKey.key);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\taccess_token: accessToken,\n\t\t\t\t\ttoken_type: \"Bearer\",\n\t\t\t\t\texpires_in: opts.accessTokenExpiresIn,\n\t\t\t\t\trefresh_token: requestedScopes.includes(\"offline_access\") ? refreshToken : void 0,\n\t\t\t\t\tscope: requestedScopes.join(\" \"),\n\t\t\t\t\tid_token: requestedScopes.includes(\"openid\") ? idToken : void 0\n\t\t\t\t}, { headers: {\n\t\t\t\t\t\"Cache-Control\": \"no-store\",\n\t\t\t\t\tPragma: \"no-cache\"\n\t\t\t\t} });\n\t\t\t}),\n\t\t\tregisterMcpClient: createAuthEndpoint(\"/mcp/register\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: z.object({\n\t\t\t\t\tredirect_uris: z.array(z.string()),\n\t\t\t\t\ttoken_endpoint_auth_method: z.enum([\n\t\t\t\t\t\t\"none\",\n\t\t\t\t\t\t\"client_secret_basic\",\n\t\t\t\t\t\t\"client_secret_post\"\n\t\t\t\t\t]).default(\"client_secret_basic\").optional(),\n\t\t\t\t\tgrant_types: z.array(z.enum([\n\t\t\t\t\t\t\"authorization_code\",\n\t\t\t\t\t\t\"implicit\",\n\t\t\t\t\t\t\"password\",\n\t\t\t\t\t\t\"client_credentials\",\n\t\t\t\t\t\t\"refresh_token\",\n\t\t\t\t\t\t\"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n\t\t\t\t\t\t\"urn:ietf:params:oauth:grant-type:saml2-bearer\"\n\t\t\t\t\t])).default([\"authorization_code\"]).optional(),\n\t\t\t\t\tresponse_types: z.array(z.enum([\"code\", \"token\"])).default([\"code\"]).optional(),\n\t\t\t\t\tclient_name: z.string().optional(),\n\t\t\t\t\tclient_uri: z.string().optional(),\n\t\t\t\t\tlogo_uri: z.string().optional(),\n\t\t\t\t\tscope: z.string().optional(),\n\t\t\t\t\tcontacts: z.array(z.string()).optional(),\n\t\t\t\t\ttos_uri: z.string().optional(),\n\t\t\t\t\tpolicy_uri: z.string().optional(),\n\t\t\t\t\tjwks_uri: z.string().optional(),\n\t\t\t\t\tjwks: z.record(z.string(), z.any()).optional(),\n\t\t\t\t\tmetadata: z.record(z.any(), z.any()).optional(),\n\t\t\t\t\tsoftware_id: z.string().optional(),\n\t\t\t\t\tsoftware_version: z.string().optional(),\n\t\t\t\t\tsoftware_statement: z.string().optional()\n\t\t\t\t}),\n\t\t\t\tmetadata: { openapi: {\n\t\t\t\t\tdescription: \"Register an OAuth2 application\",\n\t\t\t\t\tresponses: { \"200\": {\n\t\t\t\t\t\tdescription: \"OAuth2 application registered successfully\",\n\t\t\t\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Name of the OAuth2 application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ticon: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"Icon URL for the application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"Additional metadata for the application\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tclientId: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier for the client\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tclientSecret: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Secret key for the client. Not included for public clients.\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tredirectUrls: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tformat: \"uri\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdescription: \"List of allowed redirect URLs\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Type of the client\",\n\t\t\t\t\t\t\t\t\tenum: [\"web\", \"public\"]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tauthenticationScheme: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"Authentication scheme used by the client\",\n\t\t\t\t\t\t\t\t\tenum: [\"client_secret\", \"none\"]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tdisabled: {\n\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\tdescription: \"Whether the client is disabled\",\n\t\t\t\t\t\t\t\t\tenum: [false]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\tdescription: \"ID of the user who registered the client, null if registered anonymously\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\tdescription: \"Creation timestamp\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\tdescription: \"Last update timestamp\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\"clientId\",\n\t\t\t\t\t\t\t\t\"redirectUrls\",\n\t\t\t\t\t\t\t\t\"type\",\n\t\t\t\t\t\t\t\t\"authenticationScheme\",\n\t\t\t\t\t\t\t\t\"disabled\",\n\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\"updatedAt\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t} } }\n\t\t\t\t\t} }\n\t\t\t\t} }\n\t\t\t}, async (ctx) => {\n\t\t\t\tconst body = ctx.body;\n\t\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\t\tctx.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\t\t\t\tctx.setHeader(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\");\n\t\t\t\tctx.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\");\n\t\t\t\tctx.setHeader(\"Access-Control-Max-Age\", \"86400\");\n\t\t\t\tctx.headers?.set(\"Access-Control-Max-Age\", \"86400\");\n\t\t\t\tif ((!body.grant_types || body.grant_types.includes(\"authorization_code\") || body.grant_types.includes(\"implicit\")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\terror: \"invalid_redirect_uri\",\n\t\t\t\t\terror_description: \"Redirect URIs are required for authorization_code and implicit grant types\"\n\t\t\t\t});\n\t\t\t\tif (body.grant_types && body.response_types) {\n\t\t\t\t\tif (body.grant_types.includes(\"authorization_code\") && !body.response_types.includes(\"code\")) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client_metadata\",\n\t\t\t\t\t\terror_description: \"When 'authorization_code' grant type is used, 'code' response type must be included\"\n\t\t\t\t\t});\n\t\t\t\t\tif (body.grant_types.includes(\"implicit\") && !body.response_types.includes(\"token\")) throw new APIError$1(\"BAD_REQUEST\", {\n\t\t\t\t\t\terror: \"invalid_client_metadata\",\n\t\t\t\t\t\terror_description: \"When 'implicit' grant type is used, 'token' response type must be included\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst clientId = opts.generateClientId?.() || generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst clientSecret = opts.generateClientSecret?.() || generateRandomString(32, \"a-z\", \"A-Z\");\n\t\t\t\tconst clientType = body.token_endpoint_auth_method === \"none\" ? \"public\" : \"web\";\n\t\t\t\tconst finalClientSecret = clientType === \"public\" ? \"\" : clientSecret;\n\t\t\t\tawait ctx.context.adapter.create({\n\t\t\t\t\tmodel: modelName.oauthClient,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: body.client_name,\n\t\t\t\t\t\ticon: body.logo_uri,\n\t\t\t\t\t\tmetadata: body.metadata ? JSON.stringify(body.metadata) : null,\n\t\t\t\t\t\tclientId,\n\t\t\t\t\t\tclientSecret: finalClientSecret,\n\t\t\t\t\t\tredirectUrls: body.redirect_uris.join(\",\"),\n\t\t\t\t\t\ttype: clientType,\n\t\t\t\t\t\tauthenticationScheme: body.token_endpoint_auth_method || \"client_secret_basic\",\n\t\t\t\t\t\tdisabled: false,\n\t\t\t\t\t\tuserId: session?.session.userId,\n\t\t\t\t\t\tcreatedAt: /* @__PURE__ */ new Date(),\n\t\t\t\t\t\tupdatedAt: /* @__PURE__ */ new Date()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst responseData = {\n\t\t\t\t\tclient_id: clientId,\n\t\t\t\t\tclient_id_issued_at: Math.floor(Date.now() / 1e3),\n\t\t\t\t\tredirect_uris: body.redirect_uris,\n\t\t\t\t\ttoken_endpoint_auth_method: body.token_endpoint_auth_method || \"client_secret_basic\",\n\t\t\t\t\tgrant_types: body.grant_types || [\"authorization_code\"],\n\t\t\t\t\tresponse_types: body.response_types || [\"code\"],\n\t\t\t\t\tclient_name: body.client_name,\n\t\t\t\t\tclient_uri: body.client_uri,\n\t\t\t\t\tlogo_uri: body.logo_uri,\n\t\t\t\t\tscope: body.scope,\n\t\t\t\t\tcontacts: body.contacts,\n\t\t\t\t\ttos_uri: body.tos_uri,\n\t\t\t\t\tpolicy_uri: body.policy_uri,\n\t\t\t\t\tjwks_uri: body.jwks_uri,\n\t\t\t\t\tjwks: body.jwks,\n\t\t\t\t\tsoftware_id: body.software_id,\n\t\t\t\t\tsoftware_version: body.software_version,\n\t\t\t\t\tsoftware_statement: body.software_statement,\n\t\t\t\t\tmetadata: body.metadata,\n\t\t\t\t\t...clientType !== \"public\" ? {\n\t\t\t\t\t\tclient_secret: finalClientSecret,\n\t\t\t\t\t\tclient_secret_expires_at: 0\n\t\t\t\t\t} : {}\n\t\t\t\t};\n\t\t\t\treturn new Response(JSON.stringify(responseData), {\n\t\t\t\t\tstatus: 201,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t\"Cache-Control\": \"no-store\",\n\t\t\t\t\t\tPragma: \"no-cache\"\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}),\n\t\t\tgetMcpSession: createAuthEndpoint(\"/mcp/get-session\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\trequireHeaders: true\n\t\t\t}, async (c) => {\n\t\t\t\tconst accessToken = c.headers?.get(\"Authorization\")?.replace(\"Bearer \", \"\");\n\t\t\t\tif (!accessToken) {\n\t\t\t\t\tc.headers?.set(\"WWW-Authenticate\", \"Bearer\");\n\t\t\t\t\treturn c.json(null);\n\t\t\t\t}\n\t\t\t\tconst accessTokenData = await c.context.adapter.findOne({\n\t\t\t\t\tmodel: modelName.oauthAccessToken,\n\t\t\t\t\twhere: [{\n\t\t\t\t\t\tfield: \"accessToken\",\n\t\t\t\t\t\tvalue: accessToken\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t\tif (!accessTokenData) return c.json(null);\n\t\t\t\treturn c.json(accessTokenData);\n\t\t\t})\n\t\t},\n\t\tschema\n\t};\n};\nconst withMcpAuth = (auth, handler) => {\n\treturn async (req) => {\n\t\tconst baseURL = getBaseURL(auth.options.baseURL, auth.options.basePath);\n\t\tif (!baseURL && !isProduction) logger.warn(\"Unable to get the baseURL, please check your config!\");\n\t\tconst session = await auth.api.getMcpSession({ headers: req.headers });\n\t\tconst wwwAuthenticateValue = `Bearer resource_metadata=\"${baseURL}/.well-known/oauth-protected-resource\"`;\n\t\tif (!session) return Response.json({\n\t\t\tjsonrpc: \"2.0\",\n\t\t\terror: {\n\t\t\t\tcode: -32e3,\n\t\t\t\tmessage: \"Unauthorized: Authentication required\",\n\t\t\t\t\"www-authenticate\": wwwAuthenticateValue\n\t\t\t},\n\t\t\tid: null\n\t\t}, {\n\t\t\tstatus: 401,\n\t\t\theaders: {\n\t\t\t\t\"WWW-Authenticate\": wwwAuthenticateValue,\n\t\t\t\t\"Access-Control-Expose-Headers\": \"WWW-Authenticate\"\n\t\t\t}\n\t\t});\n\t\treturn handler(req, session);\n\t};\n};\nconst oAuthDiscoveryMetadata = (auth) => {\n\treturn async (request) => {\n\t\tconst res = await auth.api.getMcpOAuthConfig();\n\t\treturn new Response(JSON.stringify(res), {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n\t\t\t\t\"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n\t\t\t\t\"Access-Control-Max-Age\": \"86400\"\n\t\t\t}\n\t\t});\n\t};\n};\nconst oAuthProtectedResourceMetadata = (auth) => {\n\treturn async (request) => {\n\t\tconst res = await auth.api.getMCPProtectedResource();\n\t\treturn new Response(JSON.stringify(res), {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n\t\t\t\t\"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n\t\t\t\t\"Access-Control-Max-Age\": \"86400\"\n\t\t\t}\n\t\t});\n\t};\n};\n\n//#endregion\nexport { getMCPProviderMetadata as a, oAuthProtectedResourceMetadata as c, API_KEY_TABLE_NAME as d, ERROR_CODES as f, getMCPProtectedResourceMetadata as i, withMcpAuth as l, defaultKeyHasher as m, createAuthMiddleware$1 as n, mcp as o, apiKey as p, optionsMiddleware as r, oAuthDiscoveryMetadata as s, createAuthEndpoint$1 as t, lastLoginMethod as u };","import type { StandardSchemaV1 } from \"./standard-schema\";\nimport { getAuthHeader } from \"./auth\";\nimport { methods } from \"./create-fetch\";\nimport type { BetterFetchOption, FetchEsque } from \"./types\";\n\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\n\nexport type ResponseType = \"json\" | \"text\" | \"blob\";\nexport function detectResponseType(request: Response): ResponseType {\n\tconst _contentType = request.headers.get(\"content-type\");\n\tconst textTypes = new Set([\n\t\t\"image/svg\",\n\t\t\"application/xml\",\n\t\t\"application/xhtml\",\n\t\t\"application/html\",\n\t]);\n\tif (!_contentType) {\n\t\treturn \"json\";\n\t}\n\tconst contentType = _contentType.split(\";\").shift() || \"\";\n\tif (JSON_RE.test(contentType)) {\n\t\treturn \"json\";\n\t}\n\tif (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\treturn \"blob\";\n}\n\nexport function isJSONParsable(value: any) {\n\ttry {\n\t\tJSON.parse(value);\n\t\treturn true;\n\t} catch (error) {\n\t\treturn false;\n\t}\n}\n\n//https://github.com/unjs/ofetch/blob/main/src/utils.ts\nexport function isJSONSerializable(value: any) {\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\tconst t = typeof value;\n\tif (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n\t\treturn true;\n\t}\n\tif (t !== \"object\") {\n\t\treturn false;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tif (value.buffer) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t(value.constructor && value.constructor.name === \"Object\") ||\n\t\ttypeof value.toJSON === \"function\"\n\t);\n}\n\nexport function jsonParse(text: string) {\n\ttry {\n\t\treturn JSON.parse(text);\n\t} catch (error) {\n\t\treturn text;\n\t}\n}\n\nexport function isFunction(value: any): value is () => any {\n\treturn typeof value === \"function\";\n}\n\nexport function getFetch(options?: BetterFetchOption): FetchEsque {\n\tif (options?.customFetchImpl) {\n\t\treturn options.customFetchImpl;\n\t}\n\tif (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n\t\treturn globalThis.fetch;\n\t}\n\tif (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n\t\treturn window.fetch;\n\t}\n\tthrow new Error(\"No fetch implementation found\");\n}\n\nexport function isPayloadMethod(method?: string) {\n\tif (!method) {\n\t\treturn false;\n\t}\n\tconst payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n\treturn payloadMethod.includes(method.toUpperCase());\n}\n\nexport function isRouteMethod(method?: string) {\n\tconst routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n\tif (!method) {\n\t\treturn false;\n\t}\n\treturn routeMethod.includes(method.toUpperCase());\n}\n\nexport async function getHeaders(opts?: BetterFetchOption) {\n\tconst headers = new Headers(opts?.headers);\n\tconst authHeader = await getAuthHeader(opts);\n\tfor (const [key, value] of Object.entries(authHeader || {})) {\n\t\theaders.set(key, value);\n\t}\n\tif (!headers.has(\"content-type\")) {\n\t\tconst t = detectContentType(opts?.body);\n\t\tif (t) {\n\t\t\theaders.set(\"content-type\", t);\n\t\t}\n\t}\n\n\treturn headers;\n}\n\nexport function getURL(url: string, options?: BetterFetchOption) {\n\tif (url.startsWith(\"@\")) {\n\t\tconst m = url.toString().split(\"@\")[1].split(\"/\")[0];\n\t\tif (methods.includes(m)) {\n\t\t\turl = url.replace(`@${m}/`, \"/\");\n\t\t}\n\t}\n\tlet _url: string | URL;\n\ttry {\n\t\tif (url.startsWith(\"http\")) {\n\t\t\t_url = url;\n\t\t} else {\n\t\t\tlet baseURL = options?.baseURL;\n\t\t\tif (baseURL && !baseURL?.endsWith(\"/\")) {\n\t\t\t\tbaseURL = baseURL + \"/\";\n\t\t\t}\n\t\t\tif (url.startsWith(\"/\")) {\n\t\t\t\t_url = new URL(url.substring(1), baseURL);\n\t\t\t} else {\n\t\t\t\t_url = new URL(url, options?.baseURL);\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tif (!options?.baseURL) {\n\t\t\t\tthrow TypeError(\n\t\t\t\t\t`Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow TypeError(\n\t\t\t\t`Invalid URL ${url}. Please validate that you are passing the correct input.`,\n\t\t\t);\n\t\t}\n\t\tthrow e;\n\t}\n\n\t/**\n\t * Dynamic Parameters.\n\t */\n\tif (options?.params) {\n\t\tif (Array.isArray(options?.params)) {\n\t\t\tconst params = options?.params\n\t\t\t\t? Array.isArray(options.params)\n\t\t\t\t\t? `/${options.params.join(\"/\")}`\n\t\t\t\t\t: `/${Object.values(options.params).join(\"/\")}`\n\t\t\t\t: \"\";\n\t\t\t_url = _url.toString().split(\"/:\")[0];\n\t\t\t_url = `${_url.toString()}${params}`;\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(options?.params)) {\n\t\t\t\t_url = _url.toString().replace(`:${key}`, String(value));\n\t\t\t}\n\t\t}\n\t}\n\tconst __url = new URL(_url);\n\t/**\n\t * Query Parameters\n\t */\n\tconst queryParams = options?.query;\n\tif (queryParams) {\n\t\tfor (const [key, value] of Object.entries(queryParams)) {\n\t\t\t__url.searchParams.append(key, String(value));\n\t\t}\n\t}\n\treturn __url;\n}\n\nexport function detectContentType(body: any) {\n\tif (isJSONSerializable(body)) {\n\t\treturn \"application/json\";\n\t}\n\n\treturn null;\n}\n\nexport function getBody(options?: BetterFetchOption) {\n\tif (!options?.body) {\n\t\treturn null;\n\t}\n\tconst headers = new Headers(options?.headers);\n\tif (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n\t\tfor (const [key, value] of Object.entries(options?.body)) {\n\t\t\tif (value instanceof Date) {\n\t\t\t\toptions.body[key] = value.toISOString();\n\t\t\t}\n\t\t}\n\t\treturn JSON.stringify(options.body);\n\t}\n\n\treturn options.body;\n}\n\nexport function getMethod(url: string, options?: BetterFetchOption) {\n\tif (options?.method) {\n\t\treturn options.method.toUpperCase();\n\t}\n\tif (url.startsWith(\"@\")) {\n\t\tconst pMethod = url.split(\"@\")[1]?.split(\"/\")[0];\n\t\tif (!methods.includes(pMethod)) {\n\t\t\treturn options?.body ? \"POST\" : \"GET\";\n\t\t}\n\t\treturn pMethod.toUpperCase();\n\t}\n\treturn options?.body ? \"POST\" : \"GET\";\n}\n\nexport function getTimeout(\n\toptions?: BetterFetchOption,\n\tcontroller?: AbortController,\n) {\n\tlet abortTimeout: ReturnType<typeof setTimeout> | undefined;\n\tif (!options?.signal && options?.timeout) {\n\t\tabortTimeout = setTimeout(() => controller?.abort(), options?.timeout);\n\t}\n\treturn {\n\t\tabortTimeout,\n\t\tclearTimeout: () => {\n\t\t\tif (abortTimeout) {\n\t\t\t\tclearTimeout(abortTimeout);\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport function bodyParser(data: any, responseType: ResponseType) {\n\tif (responseType === \"json\") {\n\t\treturn JSON.parse(data);\n\t}\n\treturn data;\n}\n\nexport class ValidationError extends Error {\n\tpublic readonly issues: ReadonlyArray<StandardSchemaV1.Issue>;\n\n\tconstructor(issues: ReadonlyArray<StandardSchemaV1.Issue>, message?: string) {\n\t\t// Default message fallback in case one isn't supplied.\n\t\tsuper(message || JSON.stringify(issues, null, 2));\n\t\tthis.issues = issues;\n\n\t\t// Set the prototype explicitly to ensure that instanceof works correctly.\n\t\tObject.setPrototypeOf(this, ValidationError.prototype);\n\t}\n}\n\nexport async function parseStandardSchema<TSchema extends StandardSchemaV1>(\n\tschema: TSchema,\n\tinput: StandardSchemaV1.InferInput<TSchema>,\n): Promise<StandardSchemaV1.InferOutput<TSchema>> {\n\tlet result = await schema[\"~standard\"].validate(input);\n\n\tif (result.issues) {\n\t\tthrow new ValidationError(result.issues);\n\t}\n\treturn result.value;\n}\n"],"names":[],"mappings":"2CAQI,E8B4LA,EA+JA,EAqCA,MUlIC,Mc9ME,MjDxDP,ImCWwB,EAAI,InCX5B,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,KUjBA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OaCA,EAAA,EAAA,CAAA,CAAA,OnBFA,EAAA,EAAA,CAAA,CAAA,OAGA,IAAM,EAAU,CAAC,EAAM,EAAO,IAAI,GAC1B,IAAI,KAAK,KAAK,GAAG,IAAe,CAAV,OAAC,EAAiB,AAAO,MAAM,CAAA,CAAI,EAK3D,EAAwB,IAAI,EAApB,MACd,OAD2B,EAClB,EAAgB,CAAI,CAAE,CAAM,EACpC,IAAM,EAAS,EAAO,MAAM,CACtB,EAAa,CAAC,EACpB,IAAK,IAAM,KAAO,EAAM,CACvB,IAAM,EAAQ,CAAM,CAAC,EAAI,CACzB,GAAI,CAAC,EAAO,CACX,CAAU,CAAC,EAAI,CAAG,CAAI,CAAC,EAAI,CAC3B,QACD,EACuB,IAAnB,EAAM,CAAoB,OAAZ,GAClB,CAAU,CAAC,EAAI,CAAG,CAAI,CAAC,EAAA,AAAI,CAC5B,CACA,OAAO,CACR,CACA,SAAS,EAAa,CAAO,CAAE,CAAK,EAC/B,AAAC,EAAM,GAAG,CAAC,IAAU,EAAM,GAAG,CAAC,EAAyB,IAAI,GAApB,EAC5C,IAAM,EAAa,EAAM,GAAG,AAD6B,CAC5B,GAC7B,GAAI,EAAW,GAAG,CAAC,GAAQ,OAAO,EAAW,GAAG,CAAC,GACjD,IAAI,EAAS,CACZ,GAAa,SAAV,EAAmB,EAAQ,IAAI,EAAE,iBAAmB,CAAC,CAAC,CACzD,GAAG,AAAU,cAAY,EAAQ,OAAO,EAAE,iBAAmB,CAAC,CAAC,AAChE,EACA,IAAK,IAAM,KAAU,EAAQ,OAAO,EAAI,EAAE,CAAE,AAAI,EAAO,MAAM,EAAI,EAAO,MAAM,CAAC,EAAM,GAAE,EAAS,CAC/F,GAAG,CAAM,CACT,GAAG,EAAO,MAAM,CAAC,EAAM,CAAC,MAAM,CAC/B,EAEA,OADA,EAAM,GAAG,CAAC,GAAS,GAAG,CAAC,EAAO,GACvB,CACR,CACA,SAAS,EAAgB,CAAO,CAAE,CAAI,EACrC,MAAO,CACN,GAAG,EAAgB,EAAM,CAAE,OAAQ,EAAa,EAAS,OAAQ,EAAE,CACnE,GAAI,EAAK,EACV,AADY,CAEb,CAIA,SAAS,EAAmB,CAAO,CAAE,CAAO,EAC3C,OAAO,EAAgB,EAAS,CAAE,OAAQ,EAAa,EAAS,UAAW,EAC5E,CACA,SAAS,EAAe,CAAI,CAAE,CAAM,EACnC,IAAM,EAAS,EAAO,MAAM,EAAI,SAC1B,EAAS,EAAO,MAAM,CACtB,EAAa,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,MAAO,MACtD,IAAK,IAAM,KAAO,EAAQ,CACzB,GAAI,KAAO,EAAM,CAChB,IAA0B,IAAtB,CAAM,CAAC,EAAI,CAAC,KAAK,CAAY,CAChC,GAAiC,KAAK,GAAG,CAArC,CAAM,CAAC,EAAI,CAAC,YAAY,EACvB,AAAW,aAAU,CACxB,CAAU,CAAC,EAAI,CAAG,CAAM,CAAC,EAAI,CAAC,YAAY,CAC1C,QACD,CAED,GAAI,CAAI,CAAC,EAAI,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAA,EAAG,EAAI,yBAAyB,CAAC,AAAC,GAC9F,QACD,CACA,GAAI,CAAM,CAAC,EAAI,CAAC,SAAS,EAAE,OAAS,AAAc,KAAK,KAAf,CAAC,EAAI,CAAa,CACzD,CAAU,CAAC,EAAI,CAAG,CAAM,CAAC,EAAI,CAAC,SAAS,CAAC,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAI,CAAC,EAAI,EAC7E,QACD,CACA,GAAI,CAAM,CAAC,EAAI,CAAC,SAAS,EAAE,OAAuB,KAAK,IAAnB,CAAI,CAAC,EAAI,CAAa,CACzD,CAAU,CAAC,EAAI,CAAG,CAAM,CAAC,EAAI,CAAC,SAAS,EAAE,MAAM,CAAI,CAAC,EAAI,EACxD,QACD,CACA,CAAU,CAAC,EAAI,CAAG,CAAI,CAAC,EAAI,CAC3B,QACD,CACA,GAAiC,KAAK,IAAlC,CAAM,CAAC,EAAI,CAAC,YAAY,EAAe,AAAW,aAAU,CAC/D,GAAwC,YAApC,OAAO,CAAM,CAAC,EAAI,CAAC,YAAY,CAAiB,CACnD,CAAU,CAAC,EAAI,CAAG,CAAM,CAAC,EAAI,CAAC,YAAY,GAC1C,QACD,CACA,CAAU,CAAC,EAAI,CAAG,CAAM,CAAC,EAAI,CAAC,YAAY,CAC1C,QACD,CACA,GAAI,CAAM,CAAC,EAAI,CAAC,QAAQ,EAAe,WAAX,EAAqB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAA,EAAG,EAAI,YAAY,CAAC,AAAC,EACpH,CACA,OAAO,CACR,CACA,SAAS,EAAe,CAAO,CAAE,EAAO,CAAC,CAAC,CAAE,CAAM,EACjD,OAAO,EAAe,EAAM,CAC3B,OAAQ,EAAa,EAAS,eAC9B,CACD,EACD,CD/FA,EAAA,CAAA,CAAA,gCACA,EAAA,EAAA,CAAA,CAAA,MAIA,SAAS,EAAM,CAAG,CAAE,CAAO,EAC1B,GAAI,EAAQ,QAAQ,EAAE,WAAW,kBAAmB,OAAO,KAC3D,GAAI,CAAA,EAAA,EAAA,CAAA,AAAM,KAAM,CAAA,EAAA,EAAA,CAAA,AAAa,IAAI,MAHb,CAGoB,WACxC,IAAM,EAAU,YAAa,EAAM,EAAI,OAAO,CAAG,EAEjD,IAAK,IAAM,KADO,EAAQ,AACR,QADgB,EAAE,WAAW,kBAAoB,CAAC,kBAAkB,CACzD,CAC5B,IAAM,EAAQ,QAAS,EAAU,EAAQ,GAAG,CAAC,GAAO,CAAO,CAAC,EAAI,CAChE,GAAqB,UAAjB,OAAO,EAAoB,OAC9B,IAAM,EAAK,EAAM,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,GACnC,GAKgB,CALZ,CAAU,AAKI,EAChB,EAAA,IAAM,GAAG,SAAS,CAAC,GAAI,OAAO,EAAE,AAChC,EAAA,IAAM,CADiC,EAC9B,SAAS,CAAC,GAAI,OAAO,CAPb,CAOe,MAPR,CAOe,AAN1C,CACD,CACA,OAAO,IACR,CoBbA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,yCACA,GAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAAA,IAAA,GAAA,EAAA,CAAA,CAAA,OACA,GAAA,EAAA,CAAA,CAAA,O3BTA,EAAA,CAAA,CAAA,OAAA,IAAA,GAAA,EAAA,CAAA,CAAA,O2BaA,eAAe,GAAe,CAAO,CAAE,CAAoB,EAC1D,IAAI,EACJ,GAAK,CAAD,CAAS,QAAQ,CAQ8B,EAAZ,YAA5B,OAAO,EAAQ,QAAQ,CAA2B,EAAQ,QAAQ,CAAC,GAC/D,MAAM,EAAqB,OATnB,CAEtB,IAAM,EAAW,OAAO,IAAI,CADb,AACc,CADd,EAAA,EAAA,CAAa,AAAb,EAAc,IACQ,MAAM,CAAC,CAAC,EAAK,KACjD,CAAG,CAAC,EAAI,CAAG,EAAE,CACN,GACL,CAAC,GACE,CAAE,eAAa,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAC1B,EAAU,EAAc,GAAU,EACnC,CAQA,MARO,CAEF,EAAQ,WAAW,EAAE,CACzB,GAAA,MAAM,CAAC,IAAI,CAAC,oIACZ,EAAQ,WAAW,CAAG,MAAO,GACrB,EAAG,IAGL,CACR,CAIA,eAAe,GAAW,CAAO,EAChC,OAAO,GAAe,EAAS,MAAO,IACrC,GAAM,CAAE,oBAAqB,CAAqB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACjD,QAAE,CAAM,cAAE,CAAY,CAAE,aAAW,CAAE,CAAG,MAAM,EAAsB,GAC1E,GAAI,CAAC,EAAQ,MAAM,IAAI,GAAA,eAAe,CAAC,yCACvC,GAAM,eAAE,CAAa,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAC1B,OAAO,EAAc,EAAQ,CAC5B,KAAM,GAAgB,SACtB,YAAW,EAAK,QAAQ,EAAI,cAAe,EAAK,QAAQ,EAAG,EAAK,QAAQ,CAAC,SAAS,GAAG,UACrF,CACD,GAAG,EACJ,EACD,kB3B7Ce,+mM2BOf,EAAA,CAAA,CAAA,OAsNA,IAAM,GAAwB,CAAC,EAAS,KACvC,MAAM,EAAW,EAAI,MAAM,CACrB,EAAU,EAAI,OAAO,CACrB,EAAmB,EAAQ,gBAAgB,CAC3C,EAAoB,EAAQ,OAAO,EAAE,WAAa,OAAO,AACzD,KAD8D,YAC5D,CAAe,iBAAE,CAAe,qBAAE,CAAmB,iBAAE,CAAe,qBAAE,CAAmB,CAAE,EApJ/F,CAoJkG,CAAsB,AApJhH,EAAI,KAAK,CAoIhB,CACN,gBApID,eAAe,AAAgB,CAAI,CAAE,CAAK,CAAE,CAAc,EACzD,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,CAAA,AAAqB,IACvC,EAAa,EACjB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC/B,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,OACnC,GAAI,EAAO,CACV,IAAM,EAAS,MAAM,EAAM,EAAY,GACvC,IAAe,IAAX,EAAkB,OAAO,KACP,UAAlB,OAAO,GAAuB,SAAU,IAAQ,EAAa,CAChE,GAAG,CAAU,CACb,GAAG,EAAO,IAAI,CACf,CACD,CACD,CACA,IAAM,EAAgB,EAAiB,MAAM,EAAe,EAAE,CAAC,GAAc,KACvE,EAAU,CAAC,GAAkB,EAAe,aAAa,CAAG,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,MAAM,CAAC,OACjH,EACA,KAAM,EACN,cAAc,CACf,GAAK,EACL,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC/B,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,MAC/B,GAAO,MAAM,EAAM,EAAS,EACjC,CACA,OAAO,CACR,EA4GC,gBA3GD,eAAe,AAAgB,CAAI,CAAE,CAAK,CAAE,CAAK,CAAE,CAAc,EAChE,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,CAAA,AAAqB,IACvC,EAAa,EACjB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC/B,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,OACnC,GAAI,EAAO,CACV,IAAM,EAAS,MAAM,EAAM,EAAM,GACjC,IAAe,IAAX,EAAkB,OAAO,KACP,UAAlB,OAAO,GAAuB,SAAU,IAAQ,EAAa,CAChE,GAAG,CAAU,CACb,GAAG,EAAO,IAAI,CACf,CACD,CACD,CACA,IAAM,EAAgB,EAAiB,MAAM,EAAe,EAAE,CAAC,GAAc,KACvE,EAAU,CAAC,GAAkB,EAAe,aAAa,CAAG,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAiB,AAAjB,EAAkB,EAAA,CAAQ,CAAE,MAAM,CAAC,OACjH,EACA,OAAQ,QACR,CACD,GAAK,EACL,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC/B,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,MAC/B,GAAO,MAAM,EAAM,EAAS,EACjC,CACA,OAAO,CACR,EAmFC,oBAlFD,eAAe,AAAoB,CAAI,CAAE,CAAK,CAAE,CAAK,CAAE,CAAc,EACpE,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,CAAA,AAAqB,IACvC,EAAa,EACjB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC/B,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,OACnC,GAAI,EAAO,CACV,IAAM,EAAS,MAAM,EAAM,EAAM,GACjC,IAAe,IAAX,EAAkB,OAAO,KACP,UAAlB,OAAO,GAAuB,SAAU,IAAQ,EAAa,CAChE,GAAG,CAAU,CACb,GAAG,EAAO,IAAI,CACf,CACD,CACD,CACA,IAAM,EAAgB,EAAiB,MAAM,EAAe,EAAE,CAAC,GAAc,KACvE,EAAU,CAAC,GAAkB,EAAe,aAAa,CAAG,MAAM,AAAC,OAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,UAAU,CAAC,OACrH,EACA,OAAQ,EACR,OACD,GAAK,EACL,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC/B,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,MAC/B,GAAO,MAAM,EAAM,EAAS,EACjC,CACA,OAAO,CACR,EA0DC,gBAzDD,eAAe,AAAgB,CAAK,CAAE,CAAK,CAAE,CAAc,EAC1D,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,CAAA,AAAqB,IACvC,EAAiB,KACrB,GAAI,CACH,EAAiB,CAAC,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,OACnE,QACA,EACA,MAAO,CACR,EAAA,CAAE,AAAC,CAAC,EAAE,EAAI,IACX,CAAE,MAAO,EAAO,CAAC,CACjB,GAAI,EAAgB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CACnD,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,OACnC,GAAI,GACC,IADM,EACA,EAAM,EAAgB,MAAa,EAAO,OAAO,IAE7D,CACA,IAAM,EAAgB,EAAiB,MAAM,EAAe,EAAE,CAAC,GAAS,KAClE,EAAU,CAAC,GAAkB,EAAe,aAAa,CAAG,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,MAAM,CAAC,OACjH,QACA,CACD,GAAK,EACL,GAAI,EAAgB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CACnD,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,MAC/B,GAAO,MAAM,EAAM,EAAgB,EACxC,CACA,OAAO,CACR,EAgCC,oBA/BD,eAAe,AAAoB,CAAK,CAAE,CAAK,CAAE,CAAc,EAC9D,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,CAAA,AAAqB,IACvC,EAAmB,EAAE,CACzB,GAAI,CACH,EAAmB,MAAM,AAAC,OAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACpE,cACA,CACD,EACD,CAAE,MAAO,EAAO,CAAC,CACjB,IAAK,IAAM,KAAU,EAAkB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CACtE,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,OACnC,GAAI,GACC,IADM,EACA,EAAM,EAAQ,MAAa,EAAO,OAAO,IAErD,CACA,IAAM,EAAgB,EAAiB,MAAM,EAAe,EAAE,CAAC,GAAS,KAClE,EAAU,CAAC,GAAkB,EAAe,aAAa,CAAG,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EA0BoB,AA1BnB,EAAA,CAAQ,CAAE,UAAU,CAAC,OACrH,QACA,CACD,GAAK,EACL,IAAK,IAAM,KAAU,EAAkB,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CACtE,IAAM,EAAQ,CAAI,CAAC,EAAM,EAAE,QAAQ,MAC/B,GAAO,MAAM,EAAM,EAAQ,EAChC,CACA,OAAO,CACR,CAOA,GAWA,eAAe,EAAoB,CAAI,EACtC,GAAI,CAAC,EAAkB,OACvB,IAAM,EAAU,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAK,EAAE,CAAA,CAAE,EACvE,GAAI,CAAC,EAAS,OACd,IAAM,EAAM,KAAK,GAAG,GACd,EAAgB,CAAC,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,IAAY,EAAA,AAAE,EAAE,MAAM,CAAE,AAAD,GAAO,EAAE,SAAS,CAAG,EACjF,OAAM,QAAQ,GAAG,CAAC,EAAc,GAAG,CAAC,MAAO,OAAE,CAAK,CAAE,IACnD,IAAM,EAAS,MAAM,EAAiB,GAAG,CAAC,GAC1C,GAAI,CAAC,EAAQ,OACb,IAAM,EAAS,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GAC7B,GAAI,CAAC,EAAQ,OACb,IAAM,EAAa,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,IAAI,KAAK,EAAO,OAAO,CAAC,SAAS,EAAE,OAAO,GAAK,GAAO,IAAK,EAClG,OAAM,EAAiB,GAAG,CAAC,EAAO,KAAK,SAAS,CAAC,CAChD,QAAS,EAAO,OAAO,MACvB,CACD,GAAI,KAAK,KAAK,CAAC,GAChB,GACD,CACA,MAAO,CACN,gBAAiB,MAAO,EAAM,IACtB,CAAA,EAAA,EAAA,CAAA,AAAkB,EAAC,EAAS,UAClC,IAAM,EAAc,MAAM,EAAgB,CACzC,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,KAC/B,GAAG,CAAI,AACR,CAFyB,CAEtB,OAAQ,KAAK,GAChB,MAAO,CACN,KAAM,EACN,QAAS,MAAM,EAAgB,CAC9B,GAAG,CAAO,CACV,OAAQ,EAAY,EAAE,CACtB,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,IAChC,EAAG,IADsB,MACX,KAAK,EACpB,CACD,GAED,WAAY,MAAO,GACX,MAAM,EAAgB,CAC5B,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,KAC/B,GAAG,CAAI,CADiB,AAExB,MAAO,EAAK,KAAK,EAAE,aACpB,EAAG,OAAQ,KAAK,GAEjB,cAAe,MAAO,GACd,MAAM,EAAgB,CAC5B,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,KAC/B,GAAG,CAAO,AACX,CAFyB,CAEtB,UAAW,KAAK,GAEpB,aAAc,MAAO,IACpB,GAAI,EAAkB,CACrB,IAAM,EAAc,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,EAC1E,GAAI,CAAC,EAAa,MAAO,EAAE,CAC3B,IAAM,EAAO,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,IAAgB,EAAE,CACvC,EAAM,KAAK,GAAG,GACd,EAAgB,EAAK,MAAM,CAAC,AAAC,GAAM,EAAE,SAAS,CAAG,GACjD,EAAW,EAAE,CACnB,IAAK,IAAM,KAAW,EAAe,CACpC,IAAM,EAAqB,MAAM,EAAiB,GAAG,CAAC,EAAQ,KAAK,EACnE,GAAI,EAAoB,CACvB,IAAM,EAAI,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GACxB,GAAI,CAAC,EAAG,MAAO,EAAE,CACjB,IAAM,EAAgB,EAAmB,EAAI,OAAO,CAAE,CACrD,GAAG,EAAE,OAAO,CACZ,UAAW,IAAI,KAAK,EAAE,OAAO,CAAC,SAAS,CACxC,GACA,EAAS,IAAI,CAAC,EACf,CACD,CACA,OAAO,CACR,CACA,OAAO,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAiB,AAAjB,EAAkB,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACxD,MAAO,UACP,MAAO,CAAC,CACP,MAAO,SACP,MAAO,CACR,EAAE,AACH,EACD,EACA,UAAW,MAAO,EAAO,EAAQ,EAAQ,IACjC,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACxD,MAAO,aACP,SACA,SACA,QACA,CACD,GAED,gBAAiB,MAAO,IACvB,IAAM,EAAQ,MAAM,AAAC,OAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,KAAK,CAAC,CAC5D,MAAO,OACP,OACD,SACqB,AAArB,UAAI,AAA2B,OAApB,EAA2B,SAAS,GACxC,CACR,EACA,WAAY,MAAO,IACd,GAAkB,MAAM,EAAiB,MAAM,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,GAC3E,CAAC,GAAoB,EAAQ,OAAO,EAAE,sBAAA,GAAwB,MAAM,EAAoB,CAAC,CAC5F,MAAO,SACP,MAAO,CACR,EAAE,CAAE,UAAW,KAAK,GACpB,MAAM,EAAoB,CAAC,CAC1B,MAAO,SACP,MAAO,CACR,EAAE,CAAE,UAAW,KAAK,GACpB,MAAM,EAAgB,CAAC,CACtB,MAAO,KACP,MAAO,CACR,EAAE,CAAE,OAAQ,KAAK,EAClB,EACA,cAAe,MAAO,EAAQ,EAAgB,EAAU,KACvD,IAAM,EAAQ,MAAM,CAAA,EAAA,EAAA,CAAA,AAAqB,IAAG,KAAK,CAAC,IAAM,MAClD,EAAU,GAAO,SAAW,GAAO,SAAS,QAC5C,CAAE,GAAI,CAAC,CAAE,GAAG,EAAM,CAAG,GAAY,CAAC,EAClC,EnBpPD,EmBoPgF,CAAC,EnBpPzD,CAAE,OAAQ,EmBoPW,AnBpP9B,GmBoPqC,MAAzB,EAAiC,AnBpPb,SmBoPwB,EnBpPf,UAAW,GmBqPlE,EAAO,CACZ,WAAW,GAAO,SAAW,GAAO,OAAA,GAAU,EAAM,GAAO,SAAW,GAAO,QAAS,GAAO,QAAQ,UAAY,GACjH,EADsH,QAC3G,GAAS,IAAI,eAAiB,GACzC,GAAG,CAAI,CACP,UAAW,EAAiB,EAAQ,MAAW,CAAJ,MAAa,EAAQ,EAAmB,OACnF,SACA,MAAO,CAAA,EAAA,EAAA,CAAA,AAAU,EAAC,IAClB,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,KAC/B,GAAG,CAAuB,CADF,AAExB,GAAG,EAAc,EAAO,CAAC,CAAC,AAC3B,EACA,OAAO,MAAM,EAAgB,EAAM,UAAW,EAAmB,CAChE,GAAI,MAAO,IAKV,IAAM,EAAc,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,EACtE,EAAO,EAAE,CACP,EAAM,KAAK,GAAG,GAChB,GAEH,GAAO,CADP,EAAO,CAAA,EAAA,CADS,CACT,CAAA,AAAa,EAAC,IAAgB,EAAA,AAAE,EAC3B,MAAM,CAAC,AAAC,GAAY,EAAQ,SAAS,CAAG,EAAA,EAErD,IAAM,EAAS,EAAK,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,SAAS,CAAG,EAAE,SAAS,EACxD,EAAqB,EAAO,EAAE,CAAC,CAAC,IAAI,UACxC,EAAO,IAAI,CAAC,CACX,MAAO,EAAK,KAAK,CACjB,UAAW,EAAK,SAAS,CAAC,OAAO,EAClC,IACI,CAAC,GAAsB,EAAqB,EAAK,SAAS,CAAC,OAAO,EAAA,IAAI,EAAqB,EAAK,SAAS,CAAC,OAAO,EAAA,EACrH,IAAM,EAAqB,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,CAAC,EAAqB,CAAA,CAAG,CAAI,KAAM,GAC9E,EAAqB,GAAG,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,CAAE,KAAK,SAAS,CAAC,GAAS,GAC5G,IAAM,EAAO,MAAM,EAAQ,OAAO,CAAC,CAClC,MAAO,OACP,MAAO,CAAC,CACP,MAAO,KACP,MAAO,CACR,EAAE,AACH,GACM,EAAa,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,CAAC,EAAK,SAAS,CAAC,OAAO,GAAK,CAAA,CAAG,CAAI,KAAM,GAKhF,OAJI,EAAa,GAAG,MAAM,EAAiB,GAAG,CAAC,EAAK,KAAK,CAAE,KAAK,SAAS,CAAC,CACzE,QAAS,OACT,CACD,GAAI,GACG,CACR,EACA,cAAe,EAAQ,OAAO,EAAE,sBACjC,EAAI,KAAK,EACV,EACA,YAAa,MAAO,IACnB,GAAI,EAAkB,CACrB,IAAM,EAAqB,MAAM,EAAiB,GAAG,CAAC,GACtD,GAAI,CAAC,GAAsB,CAAC,EAAQ,OAAO,EAAE,uBAAwB,OAAO,KAC5E,GAAI,EAAoB,CACvB,IAAM,EAAI,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,UACxB,AAAK,EACE,CACN,CAFG,AAAI,OAEE,EAAmB,EAAI,OAAO,CAAE,CACxC,GAAG,EAAE,OAAO,CACZ,UAAW,IAAI,KAAK,EAAE,OAAO,CAAC,SAAS,EACvC,UAAW,IAAI,KAAK,EAAE,OAAO,CAAC,SAAS,EACvC,UAAW,IAAI,KAAK,EAAE,OAAO,CAAC,SAAS,CACxC,GACA,KAAM,EAAgB,EAAI,OAAO,CAAE,CAClC,GAAG,EAAE,IAAI,CACT,UAAW,IAAI,KAAK,EAAE,IAAI,CAAC,SAAS,EACpC,UAAW,IAAI,KAAK,EAAE,IAAI,CAAC,SAAS,CACrC,EACD,EAbe,IAchB,CACD,CACA,IAAM,EAAS,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CAC/D,MAAO,UACP,MAAO,CAAC,CACP,MAAO,EACP,MAAO,OACR,EAAE,CACF,KAAM,CAAE,MAAM,CAAK,CACpB,GACA,GAAI,CAAC,EAAQ,OAAO,KACpB,GAAM,MAAE,CAAI,CAAE,GAAG,EAAS,CAAG,SAC7B,AAAK,EACE,CACN,CAFG,EAAO,KAED,EAAmB,EAAI,OAAO,CAAE,GACzC,KAAM,EAAgB,EAAI,OAAO,CAAE,EACpC,EAJkB,IAKnB,EACA,aAAc,MAAO,IACpB,GAAI,EAAkB,CACrB,IAAM,EAAa,EAAE,CACrB,IAAK,IAAM,KAAgB,EAAe,CACzC,IAAM,EAAqB,MAAM,EAAiB,GAAG,CAAC,GACtD,GAAI,EAAoB,CACvB,IAAM,EAAI,CAAA,EAAA,EAAA,CAAa,AAAb,EAAc,GACxB,GAAI,CAAC,EAAG,MAAO,EAAE,CACjB,IAAM,EAAU,CACf,QAAS,CACR,GAAG,EAAE,OAAO,CACZ,UAAW,IAAI,KAAK,EAAE,OAAO,CAAC,SAAS,CACxC,EACA,KAAM,CACL,GAAG,EAAE,IAAI,CACT,UAAW,IAAI,KAAK,EAAE,IAAI,CAAC,SAAS,EACpC,UAAW,IAAI,KAAK,EAAE,IAAI,CAAC,SAAS,CACrC,CACD,EACA,EAAW,IAAI,CAAC,EACjB,CACD,CACA,OAAO,CACR,CACA,IAAM,EAAW,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CAClE,MAAO,UACP,MAAO,CAAC,CACP,MAAO,QACP,MAAO,EACP,SAAU,IACX,EAAE,CACF,KAAM,CAAE,MAAM,CAAK,CACpB,SACI,AAAJ,CAAK,EAAS,MAAM,EAAE,AAClB,EAAS,IAAI,CAAC,AAAC,GAAY,CAAC,EAAQ,IAAI,EADf,CACkB,CADhB,CAExB,EAAS,GAAG,AADmC,CAClC,AAAC,CADmC,GAEvD,GAAM,MAAE,CAAI,CAAE,GAAG,EAAS,CAAG,EAC7B,MAAO,SACN,EACA,MACD,CACD,EACD,EACA,cAAe,MAAO,EAAc,IAC5B,MAAM,EAAgB,EAAS,CAAC,CACtC,MAAO,QACP,MAAO,CACR,EAAE,CAAE,UAAW,EAAmB,CACjC,MAAM,GAAG,CAAI,EACZ,IAAM,EAAiB,MAAM,EAAiB,GAAG,CAAC,GAElD,IAAI,EAQG,OAAO,IARM,EACnB,IAAM,EAAgB,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,UACpC,AAAK,EACY,CAChB,CAFG,EAEA,EAAc,OAFE,AAEK,CACxB,GAAG,CACJ,AADQ,EAHmB,IAM5B,CACD,EACA,cAAe,EAAQ,OAAO,EAAE,sBACjC,EAAI,KAAK,GAEV,cAAe,MAAO,IACrB,GAAI,EAAkB,CACrB,IAAM,EAAO,MAAM,EAAiB,GAAG,CAAC,GACxC,GAAI,EAAM,CACT,GAAM,SAAE,CAAO,CAAE,CAAG,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,IAAS,CAAC,EAC5C,GAAI,CAAC,EAAS,YACb,EAAS,KAAK,CAAC,0CAGhB,IAAM,EAAS,EAAQ,MAAM,CACvB,EAAc,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,EAC1E,GAAI,EAAa,CAChB,IAAI,EAAO,CAAA,EAAA,EAAA,CAAa,AAAb,EAAc,IAAgB,EAAE,CACrC,EAAM,KAAK,GAAG,GACd,EAAW,EAAK,MAAM,CAAC,AAAC,GAAc,EAAU,SAAS,CAAG,GAAO,EAAU,KAAK,GAAK,GACvF,EAAqB,EAAS,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,SAAS,CAAG,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC,IAAI,UAClF,EAAS,MAAM,CAAG,GAAK,GAAsB,EAAqB,KAAK,GAAG,GAAI,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,CAAE,KAAK,SAAS,CAAC,GAAW,KAAK,KAAK,CAAC,CAAC,EAAqB,CAAA,CAAG,CAAI,MACvM,MAAM,EAAiB,MAAM,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAQ,CAC/D,MAAO,EAAS,KAAK,CAAC,sDACvB,CAEA,GADA,MAAM,EAAiB,MAAM,CAAC,GAC1B,CAAC,EAAQ,OAAO,EAAE,wBAA0B,EAAI,OAAO,CAAC,OAAO,EAAE,0BAA2B,MACjG,CACA,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,MAAM,CAAC,CAC/C,MAAO,UACP,MAAO,CAAC,CACP,MAAO,QACP,MAAO,CACR,EAAE,AACH,EACD,EACA,eAAgB,MAAO,IACtB,MAAM,EAAoB,CAAC,CAC1B,MAAO,SACP,MAAO,CACR,EAAE,CAAE,UAAW,KAAK,EACrB,EACA,cAAe,MAAO,IACrB,MAAM,EAAgB,CAAC,CACtB,MAAO,KACP,MAAO,CACR,EAAE,CAAE,UAAW,KAAK,EACrB,EACA,eAAgB,MAAO,IACtB,GAAI,EAAkB,CACrB,GAAqC,UAAjC,OAAO,EAAoC,CAC9C,IAAM,EAAgB,MAAM,EAAiB,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAA,CAAuB,EACrF,EAAW,EAAgB,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GAAiB,EAAE,CAClE,GAAI,CAAC,EAAU,OACf,IAAK,IAAM,KAAW,EAAU,MAAM,EAAiB,MAAM,CAAC,EAAQ,KAAK,CAC5E,MAAO,IAAK,IAAM,KAAgB,EAA2B,MAAM,EAAiB,GAAG,CAAC,IAAe,IAA9C,EAAoD,EAAiB,MAAM,CAAC,GACrI,GAAI,CAAC,EAAQ,OAAO,EAAE,wBAA0B,EAAI,OAAO,CAAC,OAAO,EAAE,0BAA2B,MACjG,CACA,MAAM,EAAoB,CAAC,CAC1B,MAAO,MAAM,OAAO,CAAC,GAAyB,QAAU,SACxD,MAAO,EACP,SAAU,MAAM,OAAO,CAAC,GAAyB,KAAO,KAAK,CAC9D,EAAE,CAAE,UAAW,KAAK,EACrB,EACA,cAAe,MAAO,EAAO,EAAW,KACvC,IAAM,EAAU,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACjE,MAAO,UACP,MAAO,CAAC,CACP,MAAO,EACP,MAAO,WACR,EAAE,CACF,KAAM,CAAE,MAAM,CAAK,CACpB,GAAG,IAAI,CAAC,AAAC,GACD,EAAS,IAAI,CAAC,AAAC,GAAM,EAAE,UAAU,GAAK,IAE9C,GAAI,EAAS,GAAI,EAAQ,IAAI,CAAE,MAAO,CACrC,KAAM,EAAQ,IAAI,CAClB,SAAU,CAAC,EAAQ,AACpB,MACK,CACJ,IAAM,EAAO,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CAC7D,MAAO,OACP,MAAO,CAAC,CACP,MAAO,EAAM,WAAW,GACxB,MAAO,OACR,EAAE,AACH,UACA,AAAI,EAAa,IAAP,EACT,EACA,SAAU,CAAC,EAAQ,AACpB,EACO,IACR,CACK,CACJ,IAAM,EAAO,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CAC7D,MAAO,OACP,MAAO,CAAC,CACP,MAAO,EAAM,WAAW,GACxB,MAAO,OACR,EAAE,AACH,UACA,AAAI,EAAa,IAAP,EACT,EACA,SAAU,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CAC3D,MAAO,UACP,MAAO,CAAC,CACP,MAAO,EAAK,EAAE,CACd,MAAO,QACR,EAAE,AACH,IAAM,EAAE,AACT,EACY,IACb,CACD,EACA,gBAAiB,MAAO,EAAO,KAC9B,IAAM,EAAS,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CAC/D,MAAO,OACP,MAAO,CAAC,CACP,MAAO,EAAM,WAAW,GACxB,MAAO,OACR,EAAE,CACF,KAAM,CAAE,GAAG,GAAW,gBAAkB,CAAE,SAAS,CAAK,EAAI,CAAC,CAAC,AAAC,CAChE,GACA,GAAI,CAAC,EAAQ,OAAO,KACpB,GAAM,CAAE,QAAS,CAAQ,CAAE,GAAG,EAAM,CAAG,EACvC,MAAO,MACN,EACA,SAAU,GAAY,EACvB,AADyB,CAE1B,EACA,aAAc,MAAO,GACpB,AAAK,EACE,EADH,IAAS,AACA,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CACvD,MAAO,OACP,MAAO,CAAC,CACP,MAAO,KACP,MAAO,CACR,EAAE,AACH,GAPoB,KASrB,YAAa,MAAO,GACZ,MAAM,EAAgB,CAC5B,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,KAC/B,GAAG,CAAO,AACX,CAFyB,CAEtB,UAAW,KAAK,GAEpB,WAAY,MAAO,EAAQ,KAC1B,IAAM,EAAO,MAAM,EAAgB,EAAM,CAAC,CACzC,MAAO,KACP,MAAO,CACR,EAAE,CAAE,OAAQ,KAAK,GAGjB,OAFA,MAAM,EAAoB,GAC1B,MAAM,EAAoB,GACnB,CACR,EACA,kBAAmB,MAAO,EAAO,KAChC,IAAM,EAAO,MAAM,EAAgB,EAAM,CAAC,CACzC,MAAO,QACP,MAAO,EAAM,WAAW,EACzB,EAAE,CAAE,OAAQ,KAAK,GAGjB,OAFA,MAAM,EAAoB,GAC1B,MAAM,EAAoB,GACnB,CACR,EACA,eAAgB,MAAO,EAAQ,KAC9B,MAAM,EAAoB,UAAE,CAAS,EAAG,CAAC,CACxC,MAAO,SACP,MAAO,CACR,EAAG,CACF,MAAO,aACP,MAAO,YACR,EAAE,CAAE,UAAW,KAAK,EACrB,EACA,aAAc,MAAO,GACb,MAAM,AAAC,OAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACxD,MAAO,UACP,MAAO,CAAC,CACP,MAAO,SACP,MAAO,CACR,EAAE,AACH,GAED,YAAa,MAAO,GACZ,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CACvD,MAAO,UACP,MAAO,CAAC,CACP,MAAO,YACP,MAAO,CACR,EAAE,AACH,GAED,wBAAyB,MAAO,EAAW,IACnC,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,OAAO,CAAC,CACvD,MAAO,UACP,MAAO,CAAC,CACP,MAAO,YACP,MAAO,CACR,EAAG,CACF,MAAO,aACP,MAAO,CACR,EAAE,AACH,GAED,oBAAqB,MAAO,GACpB,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACxD,MAAO,UACP,MAAO,CAAC,CACP,MAAO,SACP,MAAO,CACR,EAAE,AACH,GAED,cAAe,MAAO,EAAI,IAClB,MAAM,EAAgB,EAAM,CAAC,CACnC,MAAO,KACP,MAAO,CACR,EAAE,CAAE,UAAW,KAAK,GAErB,wBAAyB,MAAO,GACxB,MAAM,EAAgB,CAC5B,UAA2B,CAAhB,GAAoB,KAC/B,KADwB,KACG,CAAhB,GAAoB,KAC/B,GAAG,CAAI,AACR,CAFyB,CAEtB,eAAgB,KAAK,GAEzB,sBAAuB,MAAO,IAC7B,IAAM,EAAe,MAAM,AAAC,OAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,QAAQ,CAAC,CACtE,MAAO,eACP,MAAO,CAAC,CACP,MAAO,aACP,MAAO,CACR,EAAE,CACF,OAAQ,CACP,MAAO,YACP,UAAW,MACZ,EACA,MAAO,CACR,GASA,OARI,AAAC,EAAQ,YAAY,EAAE,gBAAgB,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,UAAU,CAAC,CAC9F,MAAO,eACP,MAAO,CAAC,CACP,MAAO,YACP,MAAuB,CAAhB,GAAoB,KAC3B,KADoB,IACV,IACX,EAAE,AACH,GACO,CAAY,CAAC,EACrB,AADuB,EAEvB,wBAAyB,MAAO,IAC/B,MAAM,AAAC,OAAM,CAAA,EAAA,EAAA,CAAA,AAAiB,EAAC,EAAA,CAAQ,CAAE,MAAM,CAAC,CAC/C,MAAO,eACP,MAAO,CAAC,CACP,MAAO,KACP,MAAO,CACR,EAAE,AACH,EACD,EACA,+BAAgC,MAAO,IACtC,MAAM,CAAC,MAAM,CAAA,EAAA,EAAA,CAAiB,AAAjB,EAAkB,EAAA,CAAQ,CAAE,MAAM,CAAC,CAC/C,MAAO,eACP,MAAO,CAAC,CACP,MAAO,aACP,MAAO,CACR,EAAE,AACH,EACD,EACA,wBAAyB,MAAO,EAAI,IAC5B,MAAM,EAAgB,EAAM,CAAC,CACnC,MAAO,KACP,MAAO,CACR,EAAE,CAAE,eAAgB,KAAK,EAE3B,CACD,EA6DM,GAAM,CACX,SAAU,CACT,OAAQ,CACP,oBACA,UACA,OACA,OACA,CACD,OAAQ,CACP,OACA,UACA,SACA,WACA,UACA,OACA,mBACA,CACD,QAAS,CAAC,OAAQ,UAAU,CAC5B,KAAM,CACL,cACA,YACA,OACA,CACD,KAAM,CAAC,OAAQ,QAAQ,AACxB,EACA,MAAO,CACN,OAAQ,CACP,UACA,OACA,OACA,CACD,OAAQ,CACP,UACA,MACA,SACA,WACA,UACA,QACA,SACA,CACD,QAAS,CAAC,UAAW,UAAU,CAC/B,KAAM,CACL,YACA,WACA,OACA,CACD,KAAM,CAAC,OAAO,AACf,EACA,OAAQ,CACP,OAAQ,CAAC,OAAO,CAChB,OAAQ,CAAC,UAAW,OAAO,CAC3B,QAAS,CAAC,UAAW,UAAU,CAC/B,KAAM,CAAC,OAAQ,UAAU,CACzB,KAAM,CAAC,OAAO,AACf,EACA,MAAO,CACN,OAAQ,CACP,UACA,WACA,mBACA,CACD,OAAQ,CACP,MACA,SACA,WACA,UACA,QACA,SACA,CACD,QAAS,CAAC,MAAO,WAAW,CAC5B,KAAM,CACL,YACA,OACA,WACA,CACD,KAAM,CAAC,UAAW,WAAW,AAC9B,CACD,EAaA,eAAe,GAAkB,CAAE,EAClC,GAAI,CACH,IAAM,EAAS,MAAM,GAAA,GAAG,CAAC,gBAAgB,CAAC,CAAC,OAAO,CAAC,GACnD,GAAI,EAAO,IAAI,CAAC,EAAE,EAAE,YAAa,OAAO,EAAO,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,AAAC,GAAM,EAAE,IAAI,IAAI,GAAG,CAAE,AAAD,GAAO,EAAE,OAAO,CAAC,eAAgB,KAAK,MAAM,CAAC,AAAC,GAAM,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,EAAE,EAAI,QACtL,CAAE,MAAO,EAAO,CAAC,CACjB,MAAO,QACR,CACA,eAAe,GAAc,CAAM,EAClC,IAAM,EAAmB,AArI1B,SAAS,AAAU,CAAM,EACxB,IAAM,EAAS,CAAA,EAAA,EAAA,CAAa,AAAb,EAAc,GACzB,EAAS,CAAC,EACd,IAAK,IAAM,KAAO,EAAQ,CACzB,IAAM,EAAQ,CAAM,CAAC,EAAI,CACnB,EAAS,EAAM,MAAM,CACvB,EAAe,CAAC,EAYpB,GAXA,OAAO,OAAO,CAAC,GAAQ,OAAO,CAAC,CAAC,CAAC,EAAO,EAAM,IAE7C,GADA,CAAY,CAAC,EAAM,SAAS,EAAI,EAAM,CAAG,EACrC,EAAM,UAAU,CAAE,CACrB,IAAM,EAAW,CAAM,CAAC,EAAM,UAAU,CAAC,KAAK,CAAC,CAC3C,IAAU,CAAY,CAAC,EAAM,SAAS,EAAI,EAAM,CAAC,UAAU,CAAG,CACjE,GAAG,EAAM,UAAU,CACnB,MAAO,EAAS,SAAS,CACzB,MAAO,EAAM,UAAU,CAAC,KAAK,CAC9B,CACD,CACD,GACI,CAAM,CAAC,EAAM,SAAS,CAAC,CAAE,CAC5B,CAAM,CAAC,EAAM,SAAS,CAAC,CAAC,MAAM,CAAG,CAChC,GAAG,CAAM,CAAC,EAAM,SAAS,CAAC,CAAC,MAAM,CACjC,GAAG,CAAY,AAChB,EACA,QACD,CACA,CAAM,CAAC,EAAM,SAAS,CAAC,CAAG,CACzB,OAAQ,EACR,MAAO,EAAM,KAAK,EAAI,GACvB,CACD,CACA,OAAO,CACR,EAsGoC,GAC7B,EAAW,CAAA,EAAA,GAAA,CAAA,AAAY,EAAC,EAAO,MAAM,EACvC,CAAE,OAAQ,CAAE,CAAE,aAAc,CAAM,CAAE,CAAG,MAAM,CAAA,EAAA,EAAA,CAAA,AAAmB,EAAC,GAChE,IACJ,EAAS,EADG,EACC,CAAC,yHACd,EAAS,UAEL,IAAI,AACR,EAAS,KAAK,CAAC,gJACf,QAAQ,IAAI,CAAC,IAEd,IAAI,EAAgB,SACpB,GAAe,aAAX,EAAuB,CAC1B,EAAgB,MAAM,GAAkB,GACxC,EAAS,KAAK,CAAC,CAAC,oCAAoC,EAAE,EAAc,oBAAoB,CAAC,EACzF,GAAI,CACC,AAAC,AAAC,OAAM,GAAA,GAAG,CAAC;;;wBAGK,EAAE,EAAc;GACrC,CAAC,CAAC,OAAO,CAAC,EAAA,CAAG,CAAE,IAAI,CAAC,EAAE,EAAE,EAAS,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAc,8IAA8I,CAAC,CAC/M,CAAE,MAAO,EAAO,CACf,EAAS,KAAK,CAAC,CAAC,mCAAmC,EAAE,aAAiB,MAAQ,EAAM,OAAO,CAAG,OAAO,GAAA,CAAQ,CAC9G,CACD,CACA,IAAM,EAAmB,MAAM,EAAG,aAAa,CAAC,SAAS,GACrD,EAAgB,EACpB,GAAe,aAAX,EAAuB,GAAI,CAC9B,IAAM,EAAiB,MAAM,GAAA,GAAG,CAAC;;;yBAGV,EAAE,EAAc;;GAEtC,CAAC,CAAC,OAAO,CAAC,GACL,EAAqB,IAAI,IAAI,EAAe,IAAI,CAAC,GAAG,CAAC,AAAC,GAAQ,EAAI,UAAU,GAClF,EAAgB,EAAiB,MAAM,CAAC,AAAC,GAAU,EAAM,MAAM,GAAK,GAAiB,EAAmB,GAAG,CAAC,EAAM,IAAI,GACtH,EAAS,KAAK,CAAC,CAAC,MAAM,EAAE,EAAc,MAAM,CAAC,qBAAqB,EAAE,EAAc,GAAG,EAAE,EAAc,GAAG,CAAE,AAAD,GAAO,EAAE,IAAI,EAAE,IAAI,CAAC,OAAS,SAAA,CAAU,CACjJ,CAAE,MAAO,EAAO,CACf,EAAS,IAAI,CAAC,CAAC,uEAAuE,EAAE,aAAiB,MAAQ,EAAM,OAAO,CAAG,OAAO,GAAA,CAAQ,CACjJ,CACA,IAAM,EAAc,EAAE,CAChB,EAAY,EAAE,CACpB,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GAAmB,CAC5D,IAAM,EAAQ,EAAc,IAAI,CAAC,AAAC,GAAM,EAAE,IAAI,GAAK,GACnD,GAAI,CAAC,EAAO,CACX,IAAM,EAAS,EAAY,SAAS,CAAC,AAAC,GAAM,EAAE,KAAK,GAAK,GAClD,EAAY,CACjB,MAAO,EACP,OAAQ,EAAM,MAAM,CACpB,MAAO,EAAM,KAAK,EAAI,GACvB,EACM,EAAc,EAAY,SAAS,CAAC,AAAC,GAAM,AAAC,GAAE,KAAK,EAAI,GAAA,CAAQ,CAAI,EAAU,KAAK,EACpE,CAAC,GAAG,CAApB,EAAmC,CAAC,IAAZ,EAAe,EAAY,IAAI,CAAC,GACvD,CAAW,CAAC,EAAO,CAAC,MAAM,CAAG,CACjC,GAAG,CAAW,CAAC,EAAO,CAAC,MAAM,CAC7B,GAAG,EAAM,MAAM,AAChB,EACK,EAAY,MAAM,CAAC,EAAa,EAAG,GACxC,QACD,CACA,IAAI,EAAkB,CAAC,EACvB,IAAK,GAAM,CAAC,EAAW,EAAM,GAAI,OAAO,OAAO,CAAC,EAAM,MAAM,EAAG,CAC9D,IAAM,EAAS,EAAM,OAAO,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,IAAI,GAAK,GACpD,GAAI,CAAC,EAAQ,CACZ,CAAe,CAAC,EAAU,CAAG,EAC7B,QACD,EAtFH,AAuFO,SAvFE,AAAU,CAAc,CAAE,CAAS,CAAE,CAAM,EAInD,GAAkB,aAAd,GAA0C,aAAd,EAA0B,OAAO,EAAe,WAAW,GAAG,QAAQ,CAAC,QACvG,IAAM,EAAQ,EAAG,CAAC,EAAO,CACzB,MAAO,CAAC,MAAM,OAAO,CAAC,GAAa,EAAM,GAAD,GAAU,CAAC,GAAG,CAAC,AAAC,GAAM,EAAE,WAAW,IAAM,CAAK,CAAC,EAAU,CAAC,GAAG,CAAE,AAAD,GAAO,EAAE,WAAW,GAAA,CAAG,CAAE,QAAQ,CAAW,AAAV,AAJhI,EAAK,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,GAK9C,EAgFiB,EAAO,QAAQ,CAAE,EAAM,IAAI,CAAE,IACtC,EAAS,GADsC,CAClC,CAAC,CAAC,MAAM,EAAE,EAAU,UAAU,EAAE,EAAI,gDAAgD,EAAE,EAAM,IAAI,CAAC,SAAS,EAAE,EAAO,QAAQ,CAAC,CAAC,CAAC,CACjJ,CACI,OAAO,IAAI,CAAC,GAAiB,MAAM,CAAG,GAAG,EAAU,IAAI,CAAC,CAC3D,MAAO,EACP,OAAQ,EACR,MAAO,EAAM,KAAK,EAAI,GACvB,EACD,CACA,IAAM,EAAa,EAAE,CACf,EAAW,EAAO,QAAQ,EAAE,UAAU,aAAe,OACrD,EAAc,EAAO,QAAQ,EAAE,UAAU,aAAe,EAAO,QAAQ,EAAE,UAAU,aAAe,SACxG,SAAS,EAAQ,CAAK,CAAE,CAAS,EAChC,IAAM,EAAO,EAAM,IAAI,CACjB,EAAU,CACf,OAAQ,CACP,OAAQ,OACR,SAAU,OACV,MAAO,EAAM,MAAM,CAAG,eAAiB,EAAM,UAAU,CAAG,cAAgB,EAAM,QAAQ,EAAoB,CAAjB,CAAuB,KAAK,CAAG,eAAiB,OAC3I,MAAO,EAAM,MAAM,EAAI,EAAM,QAAQ,CAAG,eAAiB,EAAM,UAAU,CAAG,cAAgB,eAC7F,EACA,QAAS,CACR,OAAQ,UACR,SAAU,UACV,MAAO,UACP,MAAO,UACR,EACA,OAAQ,CACP,OAAQ,EAAM,MAAM,CAAG,SAAW,UAClC,SAAU,EAAM,MAAM,CAAG,SAAW,UACpC,MAAO,EAAM,MAAM,CAAG,SAAW,UACjC,MAAO,EAAM,MAAM,CAAG,SAAW,SAClC,EACA,KAAM,CACL,OAAQ,OACR,SAAU,cACV,MAAO,eACP,MAAO,GAAA,GAAG,CAAC,YAAY,CAAC,AACzB,EACA,KAAM,CACL,OAAQ,OACR,SAAU,QACV,MAAO,OACP,MAAO,eACR,EACA,GAAI,CACH,SAAU,EAAc,GAAA,GAAG,CAAC,wCAAwC,CAAC,CAAG,EAAW,OAAS,OAC5F,MAAO,EAAc,UAAuB,EAAX,YACjC,EAD4D,IACrD,EAAc,UAAuB,EAAX,YACjC,EAD4D,KACpD,EAAc,UAAY,MACnC,EACA,aAAc,CACb,SAAU,EAAc,UAAY,EAAW,OAAS,OACxD,MAAO,EAAc,UAAuB,EAAX,YACjC,EAD4D,IACrD,EAAc,UAAuB,EAAX,YACjC,EAD4D,KACpD,EAAc,UAAY,MACnC,CACD,EACA,GAAkB,OAAd,GAAsB,EAAM,UAAU,EAAE,QAAU,MAAM,KAC3D,AAAkB,MAAM,CAApB,EAA2B,EAAQ,EAAE,CAAC,EAAO,CAC1C,EAAQ,YAAY,CAAC,EAAO,CAEpC,GAAe,WAAX,CAAuB,GAAU,aAAT,GAAgC,aAAT,CAAS,CAAU,CAAG,MAAO,OAChF,GAAa,aAAT,GAAgC,aAAT,EAAqB,MAAO,QACvD,GAAI,MAAM,OAAO,CAAC,GAAO,MAAO,OAChC,GAAI,CAAC,AAAC,MAAQ,CAAA,CAAO,CAAG,MAAM,AAAI,MAAM,CAAC,wBAAwB,EAAE,OAAO,GAAM,aAAa,EAAE,EAAU,+PAA+P,CAAC,EACzW,OAAO,CAAO,CAAC,EAAK,CAAC,GAAU,SAAS,AACzC,CACA,IAAM,EAAe,CAAA,EAAA,EAAA,CAAA,AAAgB,EAAC,CACrC,OAAQ,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GACtB,WAAW,CACZ,GACM,EAAe,CAAA,EAAA,EAAA,CAAA,AAAgB,EAAC,CACrC,OAAQ,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GACtB,WAAW,CACZ,GACA,SAAS,EAAiB,CAAK,CAAE,CAAK,EACrC,GAAI,CACH,MAAO,CAAA,EAAG,EAAa,GAAO,CAAC,EAAE,EAAa,CAC7C,cACA,CACD,GAAA,CAAI,AACL,CAAE,KAAM,CACP,MAAO,CAAA,EAAG,EAAM,CAAC,EAAE,EAAA,CAAO,AAC3B,CACD,CACA,GAAI,EAAU,MAAM,CAAE,IAAK,IAAM,KAAS,EAAW,IAAK,GAAM,CAAC,EAAW,EAAM,GAAI,OAAO,OAAO,CAAC,EAAM,MAAM,EAAG,CACnH,IAAM,EAAO,EAAQ,EAAO,GACxB,EAAU,EAAG,MAAM,CAAC,UAAU,CAAC,EAAM,KAAK,EAC9C,GAAI,EAAM,KAAK,CAAE,CAChB,IAAM,EAAQ,EAAG,MAAM,CAAC,UAAU,CAAC,EAAM,KAAK,EAAE,QAAQ,CAAC,CAAA,EAAG,EAAM,KAAK,CAAC,CAAC,EAAE,EAAU,IAAI,CAAC,EAC1F,EAAW,IAAI,CAAC,EACjB,CACA,IAAI,EAAQ,EAAQ,SAAS,CAAC,EAAW,EAAM,AAAC,IAC/C,GAAyB,IAAnB,EAAM,QAAQ,CAAa,EAAI,OAAO,GAAK,EAC7C,EAAM,UAAU,GAAE,EAAM,EAAI,UAAU,CAAC,EAAiB,EAAM,UAAU,CAAC,KAAK,CAAE,EAAM,UAAU,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAM,UAAU,CAAC,QAAQ,EAAI,UAAA,EAC/I,EAAM,MAAM,GAAE,EAAM,EAAI,MAAM,EAAA,EACf,SAAf,EAAM,IAAI,EAA6C,YAA9B,EAA4C,KAArC,EAAM,YAAY,GAA+B,aAAX,GAAoC,UAAX,GAAiC,UAAX,CAAW,CAAO,GAAG,AAAwB,EAAT,UAAX,EAA0B,EAAI,SAAS,CAAC,GAAA,GAAG,CAAC,oBAAoB,CAAC,EACxM,EAAI,SAAS,CAAC,GAAA,GAAG,CAAC,iBAAiB,CAAC,GACxC,IAER,EAAW,IAAI,CAAC,EACjB,CACA,IAAI,EAAc,EAAE,CAEpB,GADI,EAAO,QAAQ,EAAE,UAAU,aAAa,EAAS,IAAI,CAAC,+EACtD,EAAY,MAAM,CAAE,IAAK,IAAM,KAAS,EAAa,CACxD,IAAM,EAAS,EAAQ,CAAE,KAAM,EAAc,SAAW,QAAS,EAAG,MAChE,EAAM,EAAG,MAAM,CAAC,WAAW,CAAC,EAAM,KAAK,EAAE,SAAS,CAAC,KAAM,EAAQ,AAAC,IACrE,GAAI,QACH,AAAe,KADC,OACW,CAAvB,EAA8B,EAAI,UAAU,GAAG,OAAO,GACjD,AAAW,UAAU,GAAO,EAAI,UAAU,GAAG,OAAO,GACzC,SAAS,CAApB,EAA2B,EAAI,QAAQ,GAAG,UAAU,GAAG,OAAO,GAChE,EAAI,aAAa,GAAG,UAAU,GAAG,OAAO,UAEhD,AAAI,GACY,OADF,KACc,CAAvB,EAA8B,EAAI,UAAU,GAAG,SAAS,CAAC,GAAA,GAAG,CAAC,4BAA4B,CAAC,EAAE,OAAO,GAGjG,EAAI,UAAU,GAAG,OAAO,EAChC,GACA,IAAK,GAAM,CAAC,EAAW,EAAM,GAAI,OAAO,OAAO,CAAC,EAAM,MAAM,EAAG,CAC9D,IAAM,EAAO,EAAQ,EAAO,GAS5B,GARA,EAAM,EAAI,SAAS,CAAC,EAAW,EAAM,AAAC,IACrC,GAAyB,IAAnB,EAAM,QAAQ,CAAa,EAAI,OAAO,GAAK,EAC7C,EAAM,UAAU,GAAE,EAAM,EAAI,UAAU,CAAC,EAAiB,EAAM,UAAU,CAAC,KAAK,CAAE,EAAM,UAAU,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAM,UAAU,CAAC,QAAQ,EAAI,UAAA,EAC/I,EAAM,MAAM,EAAE,GAAM,EAAI,MAAM,EAAA,EACf,SAAf,EAAM,IAAI,EAA6C,YAA9B,EAA4C,KAArC,EAAM,YAAY,GAAoB,AAAW,gBAAyB,UAAX,GAAiC,UAAX,CAAW,CAAO,GAA2B,AAAxB,EAAe,UAAX,EAA0B,EAAI,SAAS,CAAC,GAAA,GAAG,CAAC,oBAAoB,CAAC,EACxM,EAAI,SAAS,CAAC,GAAA,GAAG,CAAC,iBAAiB,CAAC,GACxC,IAEJ,EAAM,KAAK,CAAE,CAChB,IAAI,EAAU,EAAG,MAAM,CAAC,WAAW,CAAC,CAAA,EAAG,EAAM,KAAK,CAAC,CAAC,EAAE,EAAU,CAAC,EAAE,EAAM,MAAM,CAAG,OAAS,MAAA,CAAO,EAAE,EAAE,CAAC,EAAM,KAAK,EAAE,OAAO,CAAC,CAAC,EAAU,EACvI,EAAY,IAAI,CAAC,EAAM,MAAM,CAAG,EAAQ,MAAM,GAAK,EACpD,CACD,CACA,EAAW,IAAI,CAAC,EACjB,CACA,GAAI,EAAY,MAAM,CAAE,IAAK,IAAM,KAAS,EAAa,EAAW,IAAI,CAAC,GAOzE,MAAO,aACN,YACA,EACA,cATD,eAAe,EACd,IAAK,IAAM,KAAa,EAAY,MAAM,EAAU,OAAO,EAC5D,EAQC,kBAPD,eAAe,EACd,OAAO,EAAW,GAAG,CAAC,AAAC,GAAM,EAAE,OAAO,GAAG,GAAG,EAAE,IAAI,CAAC,SAAW,GAC/D,CAMA,CACD,CbvnCA,IAAA,GAAA,EAAA,CAAA,CAAA,OgBgBA,SAAS,GAAS,CAAG,CAAE,EAAO,WAAW,EARxC,GAAI,CACH,IAAM,EAAY,IAAI,IAAI,GAC1B,GAA2B,UAAvB,EAAU,QAAQ,EAAgB,AAAuB,aAAb,QAAQ,CAAe,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,kBAAkB,EAAE,EAAI,0CAA0C,CAAC,CACtK,CAAE,MAAO,EAAO,CACf,GAAI,aAAiB,GAAA,eAAe,CAAE,MAAM,CAC5C,OAAM,IAAI,GAAA,eAAe,CAAC,CAAC,kBAAkB,EAI5B,AAJ8B,EAAI,kCAAkC,CAAC,CAAE,OAAO,GAChG,CAIA,GAAI,AAlBL,SAAS,AAAa,CAAG,EACxB,GAAI,CACH,MAA8D,AAAvD,OAAC,IAAI,IAAI,GAAK,QAAQ,CAAC,OAAO,CAAC,OAAQ,KAAO,GAAA,CAAG,AACzD,CAAE,MAAO,EAAO,CACf,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,kBAAkB,EAAE,EAAI,kCAAkC,CAAC,CACvF,CACD,EAYkB,GAAM,OAAO,EAC9B,IAAM,EAAa,EAAI,OAAO,CAAC,OAAQ,WAClC,AAAL,AAAI,GAAkB,KAAK,CAAd,GACb,EAAO,EAAK,UAAU,CAAC,KAAO,EAAO,CAAC,CAAC,EAAE,EAAA,CAAM,CACxC,CAAA,EAAG,EAAA,EAAa,EAAA,CAAM,EAFK,CAGnC,CACA,SAAS,GAAW,CAAG,CAAE,CAAI,CAAE,CAAO,CAAE,CAAO,CAAE,CAAmB,EACnE,GAAI,EAAK,OAAO,GAAS,EAAK,GAC9B,IAAgB,IAAZ,EAAmB,CACtB,IAAM,EAAU,GAAA,CAAG,CAAC,eAAe,EAAI,GAAA,CAAG,CAAC,2BAA2B,EAAI,GAAA,CAAG,CAAC,sBAAsB,EAAI,GAAA,CAAG,CAAC,2BAA2B,EAAI,GAAA,CAAG,CAAC,oBAAoB,GAAsB,CAAlB,KAAC,GAAA,CAAG,CAAC,QAAQ,CAAW,GAAA,CAAG,CAAC,QAAQ,CAAG,MAAK,CAAC,CACpN,GAAI,EAAS,OAAO,GAAS,EAAS,EACvC,CACA,IAAM,EAAc,GAAS,QAAQ,IAAI,oBACnC,EAAmB,GAAS,QAAQ,IAAI,qBAC9C,GAAI,GAAe,GAAoB,EAAqB,OAAO,GAAS,CAAA,EAAG,EAAiB,GAAG,EAAE,EAAA,CAAa,CAAE,GACpH,GAAI,EAAS,CACZ,IAAM,EAAQ,GAAU,EAAQ,GAAG,EACnC,GAAI,CAAC,EAAO,MAAM,IAAI,GAAA,eAAe,CAAC,uEACtC,OAAO,GAAS,EAAO,EACxB,CAED,CACA,SAAS,GAAU,CAAG,EACrB,GAAI,CACH,IAAM,EAAY,IAAI,IAAI,GAC1B,MAAO,AAAqB,WAAX,MAAM,CAAc,KAAO,EAAU,MAAM,AAC7D,CAAE,MAAO,EAAO,CACf,OAAO,IACR,CACD,CACA,SAAS,GAAY,CAAG,EACvB,GAAI,CACH,OAAO,IAAI,IAAI,GAAK,QACrB,AAD6B,CAC3B,MAAO,EAAO,CACf,OAAO,IACR,CACD,CACA,SAAS,GAAQ,CAAG,EACnB,GAAI,CACH,OAAO,IAAI,IAAI,GAAK,IAAI,AACzB,CAAE,MAAO,EAAO,CACf,OAAO,IACR,CACD,ChB5DA,EAAA,CAAA,CAAA,qBiCEA,GAAA,EAAA,CAAA,CAAA,O9CPA,IAAM,GAA2B,IAAI,IAApB,AAEX,GAAS,CACb,OAAQ,CAAC,CAHmB,CAGb,EAAW,OAAO,IAC3B,AAAC,GAAS,GAAG,CAAC,IAChB,GAAS,GAAG,CADe,AACd,EAAU,IAAI,YAAY,IAEzB,AACT,GADkB,GAAG,CAAC,GACd,MAAM,CAAC,IAExB,OAAQ,AATM,IAAI,cASF,MAAM,AACxB,ECXA,IAAA,GAAA,EAAA,CAAA,CAAA,OAEA,GAAA,EAAA,CAAA,CAAA,OAEA,IAAM,GAAa,CAAC,EAAY,SAAS,CAAE,EAAW,MAAM,IAC1D,IAAM,EAAO,CACX,UAAW,MAAO,EAAK,IACd,CAAA,EAAA,GAAA,kBAAkB,AAAlB,IAAqB,SAAS,CACnC,MACe,UAAf,OAAO,EAAmB,IAAI,cAAc,MAAM,CAAC,GAAO,EAC1D,CAAE,KAAM,OAAQ,KAAM,CAAE,KAAM,CAAU,CAAE,GAC1C,EACA,CAAC,EAAS,EAGd,KAAM,MAAO,EAAS,KACG,UAAnB,AAA6B,OAAtB,IACT,EAAU,MAAM,EAAK,SAAS,CAAC,EAAS,OAAA,EAE1C,IAAM,EAAY,MAAM,CAAA,EAAA,GAAA,kBAAA,AAAkB,IAAG,IAAI,CAC/C,OACA,EACgB,UAAhB,OAAO,EAAoB,IAAI,cAAc,MAAM,CAAC,GAAQ,SAE9D,AAAiB,OAAO,CAApB,EACK,GAAA,GAAG,CAAC,MAAM,CAAC,GAEhB,AAAa,cAAY,AAAa,iBAA4B,kBAAkB,CAA/B,EAChD,GAAA,SAAS,CAAC,MAAM,CAAC,EAAW,CACjC,QAAsB,mBAAb,CACX,GAEK,CACT,EACA,OAAQ,MAAO,EAAS,EAAM,KACL,UAAnB,AAA6B,OAAtB,IACT,EAAU,MAAM,EAAK,SAAS,CAAC,EAAS,SAAA,EAEzB,OAAO,CAApB,GACF,GAAY,GAAA,GAAG,CAAC,MAAM,CAAC,EAAA,GAER,WAAb,GAAsC,cAAb,GAA4B,AAAa,oBAAA,GAAkB,CACtF,EAAY,MAAM,GAAA,MAAM,CAAC,MAAM,CAAC,EAAA,EAE3B,CAAA,EAAA,GAAA,kBAAA,AAAkB,IAAG,MAAM,CAChC,OACA,EACqB,UAArB,OAAO,EAAyB,IAAI,cAAc,MAAM,CAAC,GAAa,EACtD,UAAhB,OAAO,EAAoB,IAAI,cAAc,MAAM,CAAC,GAAQ,GAGlE,EACA,OAAO,CACT,EC7CA,SAAS,GAAG,CAAK,CAAE,CAAO,EACzB,GAAqB,UAAjB,OAAO,EAAoB,OAAO,AAWvC,SAAS,AAAM,CAAG,EACjB,GAAmB,AAAf,iBAAO,GAAmC,IAAf,EAAI,MAAM,EAAU,EAAI,MAAM,CAAG,IAAK,MAAM,AAAI,MAAM,CAAC,kFAAkF,EAAE,KAAK,SAAS,CAAC,GAAA,CAAM,EAC/L,IAAM,EAAQ,wJAAwJ,IAAI,CAAC,GAC3K,GAAI,CAAC,GAAO,OAAQ,OAAO,IAC3B,GAAM,CAAE,OAAK,CAAE,OAAO,IAAI,CAAE,CAAG,EAAM,MAAM,CACrC,EAAI,WAAW,GACf,EAAY,EAAK,WAAW,GAElC,OAAQ,GACP,IAAK,QACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,IAAK,gBAAO,CACjB,GADqB,EAChB,SACL,IAAK,QACL,IAAK,KAAM,OAAO,IAAI,KACtB,KAAK,QACL,IAAK,OACL,IAAK,IAAK,cAAO,CACjB,GADqB,EAChB,OACL,IAAK,MACL,IAAK,IAAK,aAAO,CACjB,GADqB,EAChB,QACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,IAAK,YAAO,CACjB,GADqB,EAChB,UACL,IAAK,SACL,IAAK,OACL,IAAK,MACL,IAAK,IAAK,WAAO,CACjB,GADqB,EAChB,UACL,IAAK,SACL,IAAK,OACL,IAAK,MACL,IAAK,IAAK,OAAO,IAAI,CACrB,KAAK,eACL,IAAK,cACL,IAAK,QACL,IAAK,OACL,IAAK,KAAM,OAAO,CAClB,SAAS,MAAM,AAAI,MAAM,CAAC,cAAc,EAAE,EAAU,gCAAgC,EAAE,KAAK,SAAS,CAAC,GAAA,CAAM,CAC5G,CACD,EAxD6C,GACvC,GAAqB,UAAjB,OAAO,EAAoB,OAqGrC,AArG4C,SAqGnC,AAAO,CAAI,CAAE,CAAO,MAjBtB,IAkBN,GAAoB,UAAhB,OAAO,GAAqB,CAAC,OAAO,QAAQ,CAAC,GAAO,MAAM,AAAI,MAAM,yDACxE,OAAO,GAAS,KAlBZ,EAkBmB,CAnBT,KAAK,CACN,EADS,CAAC,AACP,cAAO,KAAa,EAAN,KAAa,IAAG,QAC1C,SAAS,EAAW,EAAP,GAAoB,EAAN,KAAa,GAAI,SAC5C,SAAS,CAAU,EAAP,GAAoB,EAAN,KAAa,EAAG,QAC1C,SAAS,AAAU,GAAP,EAAoB,EAAN,KAAa,CAAG,OAC1C,QAAmB,CAAV,GAAG,CAAoB,EAAN,KAAa,AAAG,QAC1C,OAAmB,EAAV,CAakB,EAbK,AAApB,EAAc,IAAgB,AAaP,CAbI,SACvC,OAAmB,EAAV,GAAG,AAAoB,EAAN,AApGrB,IAoGqC,CAAH,SACpC,CAAA,EAAG,EAAK,GAAG,CAAC,CArBf,CADE,EAAQ,KAAK,CACN,EADS,CAAC,AACP,cAAO,CAAA,EAAG,KAAK,KAAK,CAAC,EA3E5B,IAAI,CA2E+B,KAAG,CAAC,CAAC,CAC7C,SAAS,EAAW,CAAA,CAAP,CAAU,KAAK,KAAK,CAAC,EA3E5B,IAAI,CA2E+B,IAAI,EAAE,CAAC,CAChD,GA9EK,IAAI,EA8EA,CAAU,CAAA,CAAP,CAAU,KAAK,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAC7C,SAAS,AAAU,CAAA,EAAP,AAAU,KAAK,KAAK,CAAC,EAhF5B,IAAI,CAgF+B,EAAG,CAAC,CAAC,CAC7C,QAAmB,CAAV,AAAU,EAAG,CAAV,IAAe,KAAK,CA4BY,AA5BX,EAlF5B,IAAI,CAkF+B,CAAG,CAAC,CAAC,CAC7C,GApFK,IAoFc,AApFV,CAoFU,CAAV,CAAa,EAAV,GAAe,KAAK,CAAC,OAAO,AAAG,CAAC,CAAC,CAC7C,OAAmB,CAAA,CAAV,CAAa,EAAV,GAAe,KAAK,CAAC,OAAO,AAAG,CAAC,CAAC,CAC1C,CAAA,EAAG,EAAK,EAAE,CAAC,AA0BnB,EAxGmD,EAAO,EACzD,OAAU,AAAJ,MAAU,CAAC,yDAAyD,EAAE,KAAK,SAAS,CAAC,GAAA,CAAQ,CACpG,CA0GA,SAAS,GAAO,CAAI,CAAE,CAAK,CAAE,CAAC,CAAE,CAAI,EAEnC,MAAO,CAAA,EAAG,KAAK,KAAK,CAAC,EAAO,GAAG,CAAC,EAAE,EAAA,EAAO,AADxB,GAAa,IAAJ,EAC0B,IAAM,GAAA,CAAI,AAC/D,C4CxFA,SAAS,GAAc,CAAU,EAChC,IAAM,EAAQ,EAAW,KAAK,CAAC,KAEzB,EAAQ,SADG,AACM,CADD,CAAC,EAAM,MAAM,CAAG,EAAE,EACL,IAAK,IACxC,OAAO,MAAM,GAAS,EAAI,CAC3B,CAmDA,SAAS,GAAgB,CAAM,CAAE,CAAa,EAC7C,IAAM,EAAgB,CAAC,EACvB,IAAK,IAAM,KAAQ,EAAQ,CAAa,CAAC,EAAK,CAAG,MAChD,EACA,MAAO,GACP,QAAS,CACR,GAAG,CAAa,CAChB,OAAQ,CACT,CACD,EACA,OAAO,CACR,CAQA,IAAM,GAAe,AAAC,GAAc,CAAC,EAAY,EAAe,KAC/D,IAAM,EAnEP,AAmEgB,SAnEP,AAAmB,CAAU,CAAE,CAAG,EAC1C,IAAM,EAAS,CAAC,EAEhB,IAAK,GAAM,CAAC,EAAM,EAAM,GAAI,OAAO,OAAO,CAD1B,AAzBjB,AA0B4C,SA1BnC,AAAwB,AA0BqB,CA1BlB,EACnC,IAAM,EAAe,EAAI,OAAO,EAAE,IAAI,UACtC,GAAI,CAAC,EAAc,MAAO,CAAC,EAC3B,IAAM,EAAU,CAAC,EAEjB,IAAK,IAAM,KADG,EAAa,CACR,IADa,CAAC,MACP,CACzB,GAAM,CAAC,EAAM,GAAG,EAAW,CAAG,EAAK,KAAK,CAAC,KACrC,GAAQ,EAAW,MAAM,CAAG,IAAG,CAAO,CAAC,EAAK,CAAG,EAAW,IAAI,CAAC,IAAA,CACpE,CACA,OAAO,CACR,EAeyC,IACiB,EAAK,UAAU,CAAC,KAAa,CAAM,CAAC,EAAK,CAAG,CAAA,EACrG,OAAO,CACR,EA8DmC,EAAY,GACxC,EAAW,EAAI,OAAO,CAAC,MAAM,CACnC,MAAO,UACN,IA5DM,OAAO,IAAI,CAAC,GAAQ,IAAI,CAAC,CAAC,EAAG,IAC5B,GAAc,GAAK,GAAc,IACtC,GAAG,CAAC,AAAC,GAAQ,AA2DI,CA3DE,CAAC,EAAI,EAAE,IAAI,CAAC,cA6DjC,IACQ,OAAO,IAAI,CAAC,GAAQ,MAAM,CAAG,EAErC,MAAM,CAAK,CAAE,CAAO,EACnB,IAAM,EAAgB,GAAgB,EAAQ,GAC9C,IAAK,IAAM,KAAQ,EAAQ,OAAO,CAAM,CAAC,EAAK,CAU9C,IAAK,IAAM,KAvEd,AA+DmB,IAQI,KAvEd,AAAY,CAAS,CAAE,CAAM,CAAE,CAAM,CAAE,CAAQ,EACvD,IAAM,EAAa,KAAK,IAAI,CAAC,EAAO,KAAK,CAAC,MAAM,GAAG,IACnD,GAAmB,GAAG,CAAlB,EAEH,OADA,CAAM,CAAC,EAAO,IAAI,CAAC,CAAG,EAAO,KAAK,CAC3B,CAAC,EAAO,CAEhB,IAAM,EAAU,EAAE,CAClB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,IAAK,CACpC,IAAM,EAAO,CAAA,EAAG,EAAO,IAAI,CAAC,CAAC,EAAE,EAAA,CAAG,CAC5B,OAAQ,EACR,EADY,AACJ,EAAO,KAAK,CAAC,SAAS,CAAC,EAAO,EAtD3B,MAuDjB,AADoD,EAC5C,IAAI,CAAC,CACZ,GAAG,CAAM,IAxD6B,EAyDtC,QACA,CACD,GACA,CAAM,CAAC,EAAK,CAAG,CAChB,CAQA,OAPA,EAAS,KAAK,CAAC,CAAC,SAAS,EAAE,EAAU,WAAW,GAAG,OAAO,CAAC,CAAE,CAC5D,QAAS,GAAG,UAAU,wBAAwB,EAAE,EAA4B,CAC5E,iBADoE,AACnD,GACjB,IAF2E,MAEhE,EAAO,KAAK,CAAC,MAAM,YAC9B,EACA,OAAQ,EAAQ,GAAG,CAAC,AAAC,GAAM,EAAE,KAAK,CAAC,MAAM,CApEP,EAoEU,EAC7C,GACO,CACR,EAqC+B,EAAW,CACtC,KAAM,QACN,EACA,QAAS,CACR,GAAG,CAAa,CAChB,GAAG,CAAO,AACX,CACD,EAAG,EAAQ,GACkB,CAAO,CAAC,EAAM,IAAI,CAAC,CAAG,EACnD,OAAO,OAAO,MAAM,CAVJ,AAUK,EACtB,EACA,QACC,IAAM,EAAgB,GAAgB,EAAQ,GAC9C,IAAK,IAAM,KAAQ,EAAQ,OAAO,CAAM,CAAC,EAAK,CAC9C,OAAO,OAAO,MAAM,CAAC,EACtB,EACA,WAAW,CAAO,EACjB,IAAK,IAAM,KAAU,EAAS,EAAI,SAAS,CAAC,EAAO,IAAI,CAAE,EAAO,KAAK,CAAE,EAAO,OAAO,CACtF,CACD,CACD,EACM,GAAqB,GAAa,WAClC,GAAqB,GAAa,WACxC,SAAS,GAAiB,CAAG,CAAE,CAAU,EACxC,IAAM,EAAQ,EAAI,SAAS,CAAC,GAC5B,GAAI,EAAO,OAAO,EAClB,IAAM,EAAS,EAAE,CACX,EAAe,EAAI,OAAO,EAAE,IAAI,UACtC,GAAI,CAAC,EAAc,OAAO,KAC1B,IAAM,EAAU,CAAC,EAEjB,IAAK,IAAM,KADG,EAAa,CACR,IADa,CAAC,MACP,CACzB,GAAM,CAAC,EAAM,GAAG,EAAW,CAAG,EAAK,KAAK,CAAC,KACrC,GAAQ,EAAW,MAAM,CAAG,IAAG,CAAO,CAAC,EAAK,CAAG,EAAW,IAAI,CAAC,IAAA,CACpE,CACA,IAAK,GAAM,CAAC,EAAM,EAAI,GAAI,OAAO,OAAO,CAAC,GAAU,GAAI,EAAK,UAAU,CAAC,EAAa,KAAM,CAEzF,IAAM,EAAQ,SAAS,AADN,EAAK,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,IACF,IAAK,GACpC,CAAC,MAAM,IAAQ,EAAO,IAAI,CAAC,OAC9B,EACA,MAAO,CACR,EACD,QACA,AAAI,EAAO,MAAM,CAAG,GAAG,AACtB,EAAO,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,KAAK,CAAG,EAAE,KAAK,EAChC,EAAO,GAAG,CAAC,AAAC,GAAM,EAAE,KAAK,EAAE,IAAI,CAAC,KAEjC,IACR,CACA,eAAe,GAAiB,CAAC,CAAE,CAAW,EAC7C,IAAM,EAAoB,EAAE,OAAO,CAAC,WAAW,CAAC,WAAW,CACrD,EAAU,CACf,OAAQ,IACR,GAAG,EAAkB,OAAO,AAC7B,EACM,EAAO,MAAM,CAAA,EAAA,GAAA,CAAA,AAAkB,EAAC,EAAa,EAAE,OAAO,CAAC,MAAM,CAAE,sBAAuB,EAAQ,MAAM,EAC1G,GAAI,EAAK,MAAM,CArKY,EAqKT,GAAqB,CACtC,IAAM,EAAe,GAAmB,EAAkB,IAAI,CAAE,EAAS,GACnE,EAAU,EAAa,KAAK,CAAC,EAAM,GACzC,EAAa,UAAU,CAAC,EACzB,KAAO,CACN,IAAM,EAAe,GAAmB,EAAkB,IAAI,CAAE,EAAS,GACzE,GAAI,EAAa,SAAS,GAAI,CAC7B,IAAM,EAAe,EAAa,KAAK,GACvC,EAAa,UAAU,CAAC,EACzB,CACA,EAAE,SAAS,CAAC,EAAkB,IAAI,CAAE,EAAM,EAC3C,CACD,CACA,eAAe,GAAiB,CAAC,EAChC,IAAM,EAAgB,GAAiB,EAAG,EAAE,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,EAChF,GAAI,EAAe,CAClB,IAAM,EAAc,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,MAAM,CAAA,EAAA,GAAA,CAAA,AAAkB,EAAC,EAAe,EAAE,OAAO,CAAC,MAAM,CAAE,wBAC5F,GAAI,EAAa,OAAO,CACzB,CACA,OAAO,IACR,CACA,IAAM,GAAwB,EAAA,QAAU,CAAC,EAAA,MAAQ,CAAC,CACjD,mBAAoB,GAAA,MAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,CAAE,YAAa,sDAAuD,GAAG,QAAQ,GAC7H,eAAgB,GAAA,MAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,CAAE,YAAa,2FAA4F,GAAG,QAAQ,EAC/J,IAoEA,SAAS,GAAmB,CAAO,EAClC,IAAM,EAAsB,AAAD,GAAS,QAAQ,EAAE,mBAAqB,KAAK,EAAI,EAAQ,QAAQ,EAAE,iBAAmB,AAAoB,KAAK,MAAjB,OAAO,GAAc,EAAQ,OAAO,CAAC,UAAU,CAAC,YAA6B,EAAf,CAAe,CAAA,AAAY,EAAI,GAAxB,SAAsC,GAC9N,EAAwB,CAAC,CAAC,EAAQ,QAAQ,EAAE,uBAAuB,QACnE,EAAS,EAAwB,EAAQ,QAAQ,EAAE,uBAAuB,SAAW,CAAD,CAAS,OAAO,CAAG,IAAI,IAAI,EAAQ,OAAO,EAAE,QAAQ,CAAG,MAAK,CAAC,CAAI,KAAK,EAChK,GAAI,GAAyB,CAAC,EAAQ,MAAM,IAAI,GAAA,eAAe,CAAC,8DAmBhE,OAAO,AAlBP,SAAS,AAAa,CAAU,CAAE,EAAqB,CAAC,CAAC,EACxD,IAAM,EAAS,EAAQ,QAAQ,EAAE,cAAgB,cAC3C,EAAO,EAAQ,QAAQ,EAAE,SAAS,CAAC,EAAW,EAAE,MAAQ,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAY,CACjF,EAAa,EAAQ,QAAQ,EAAE,SAAS,CAAC,EAAW,EAAE,WAC5D,MAAO,CACN,KAAM,CAAA,EAAG,EAAA,EAAqB,EAAA,CAAM,CACpC,WAAY,CACX,OAAQ,CAAC,CAAC,EACV,SAAU,MACV,KAAM,IACN,UAAU,EACV,GAAG,EAAwB,QAAE,CAAO,EAAI,CAAC,CAAC,CAC1C,GAAG,EAAQ,QAAQ,EAAE,uBAAuB,CAC5C,GAAG,CAAkB,CACrB,GAAG,CAAU,AACd,CACD,CACD,CAED,CA0BA,eAAe,GAAe,CAAG,CAAE,CAAO,CAAE,CAAc,EACzD,GAAI,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,QAAS,CACtD,IA2BI,EA3BE,EAAkB,OAAO,OAAO,CAAC,EAAQ,OAAO,EAAE,MAAM,CAAC,CAAC,EAAK,CAAC,EAAK,EAAM,IAChF,IAAM,EAAc,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,kBAAkB,CAAC,EAAI,CAExE,OADI,AAAC,IAAwC,IAAzB,EAAY,QAAQ,GAAY,CAAG,CAAC,EAAI,CAAG,CAAA,EACxD,CACR,EAAG,CAAC,GACE,EAAe,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,EAAQ,IAAI,EAChE,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,QAC5D,EAAU,IACd,GAAI,GACH,GAA6B,SADX,CACd,OAAO,EAA4B,EAAU,OAC5C,GAA6B,YAAzB,OAAO,EAA8B,CAC7C,IAAM,EAAS,EAAc,EAAQ,OAAO,CAAE,EAAQ,IAAI,EAC1D,EAAU,aAAkB,QAAU,MAAM,EAAS,EACtD,CAED,IAAM,EAAc,CACnB,QAAS,EACT,KAAM,EACN,UAAW,KAAK,GAAG,GACnB,SACD,EACM,EAAU,CACf,GAAG,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,CAC9C,OAAQ,EAAiB,KAAK,EAAI,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,AACrF,EACM,EAAgB,EAAQ,EAAQ,MAAM,EAAI,GAAI,OAAO,OAAO,GAC5D,EAAW,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,UAAY,UAYvE,GAAI,CAVoB,EAAP,QAAb,EAA2B,MAAM,CAAA,EAAA,GAAA,CAAA,AAAkB,EAAC,EAAa,EAAI,OAAO,CAAC,MAAM,CAAE,sBAAuB,EAAQ,MAAM,EAAI,KAC5G,OAAO,CAApB,EAA2B,MAAM,CAAA,EAAA,GAAA,CAAO,AAAP,EAAQ,EAAa,EAAI,OAAO,CAAC,MAAM,CAAE,EAAQ,MAAM,EAAI,KACzF,GAAA,SAAS,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC,CAC3C,QAAS,EACT,UAAW,EACX,UAAW,MAAM,GAAW,UAAW,kBAAkB,IAAI,CAAC,EAAI,OAAO,CAAC,MAAM,CAAE,KAAK,SAAS,CAAC,CAChG,GAAG,CAAW,CACd,UAAW,CACZ,GACD,GAAI,CAAE,SAAS,CAAM,IACZ,MAAM,CAAG,KAAM,CACvB,IAAM,EAAe,GAAmB,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAE,EAAS,GACrF,EAAU,EAAa,KAAK,CAAC,EAAM,GACzC,EAAa,UAAU,CAAC,EACzB,KAAO,CACN,IAAM,EAAe,GAAmB,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAE,EAAS,GAC3F,GAAI,EAAa,SAAS,GAAI,CAC7B,IAAM,EAAe,EAAa,KAAK,GACvC,EAAa,UAAU,CAAC,EACzB,CACA,EAAI,SAAS,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAE,EAAM,EAC/D,CACD,CACD,CACA,eAAe,GAAiB,CAAG,CAAE,CAAO,CAAE,CAAc,CAAE,CAAS,EACtE,IAAM,EAAuB,MAAM,EAAI,eAAe,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAE,EAAI,OAAO,CAAC,MAAM,EACzH,EAAoC,KAAK,IAAxB,EAA4B,EAAiB,CAAC,CAAC,EAChE,IAAM,EAAU,EAAI,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,OAAO,CACtD,EAAS,EAAiB,KAAK,EAAI,EAAI,OAAO,CAAC,aAAa,CAAC,SAAS,AAC5E,OAAM,EAAI,eAAe,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAE,EAAQ,OAAO,CAAC,KAAK,CAAE,EAAI,OAAO,CAAC,MAAM,CAAE,CAC/G,GAAG,CAAO,QACV,EACA,GAAG,CAAS,AACb,GACI,GAAgB,MAAM,EAAI,eAAe,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAE,OAAQ,EAAI,OAAO,CAAC,MAAM,CAAE,EAAI,OAAO,CAAC,WAAW,CAAC,iBAAiB,CAAC,OAAO,EAC3K,MAAM,GAAe,EAAK,EAAS,GACnC,EAAI,OAAO,CAAC,aAAa,CAAC,GAMtB,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,MAAM,EAAI,OAAO,CAAC,gBAAgB,EAAE,IAAI,EAAQ,OAAO,CAAC,KAAK,CAAE,KAAK,SAAS,CAAC,CACvH,KAAM,EAAQ,IAAI,CAClB,QAAS,EAAQ,OAAO,AACzB,GAAI,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,EAAQ,OAAO,CAAC,SAAS,EAAE,OAAO,GAAK,KAAK,GAAG,EAAA,CAAE,CAAI,KAC/E,CACA,SAAS,GAAoB,CAAG,CAAE,CAAkB,EACnD,EAAI,SAAS,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAE,GAAI,CAC5D,GAAG,EAAI,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,OAAO,CAC/C,OAAQ,CACT,GACA,IAAM,EAAe,GAAmB,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAE,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,CAAE,GACzH,EAAe,EAAa,KAAK,GACvC,EAAa,UAAU,CAAC,GACpB,AAAC,GAAoB,EAAI,SAAS,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAE,GAAI,CAC1F,GAAG,EAAI,OAAO,CAAC,WAAW,CAAC,iBAAiB,CAAC,OAAO,CACpD,OAAQ,CACT,EACD,yB1CzZA,EAAA,CAAA,CAAA,eAKA,IAAM,GAAoB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,UAMnC,EAAC,GAEH,GAAuB,EAAA,gBAAgB,CAAC,MAAM,CAAC,CAAE,IAAK,CAAC,GAAmB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,UACzF,EAAC,GACN,AAAC,GACE,GAAM,CAAC,GAAkB,CACzB,GAAqB,CAAC,EAAM,EAAS,IACnC,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAM,CAC3B,GAAG,CAAO,CACV,IAAK,IAAI,GAAS,KAAO,EAAE,IAAK,GACjC,AADqC,EAClC,MAAO,GAAQ,CAAA,EAAA,GAAA,CAAA,AAAsB,EAAC,EAAK,IAAM,EAAQ,KmDRvD,GAAa,IAAM,GAAmB,eAAgB,CAC3D,OAAQ,MACR,YAAa,aACb,MAAO,GACP,eAAgB,GAChB,SAAU,CAAE,QAAS,CACpB,YAAa,aACb,YAAa,0BACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,QAAS,CAAE,KAAM,8BAA+B,EAChD,KAAM,CAAE,KAAM,2BAA4B,CAC3C,EACA,SAAU,CAAC,UAAW,OAAO,AAC9B,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CACH,IAAM,EAAqB,MAAM,EAAI,eAAe,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAE,EAAI,OAAO,CAAC,MAAM,EAClH,GAAI,CAAC,EAAoB,OAAO,KAChC,IAAM,EAAoB,GAAiB,EAAK,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,EACpF,EAAqB,KACzB,GAAI,EAAmB,CACtB,IAAM,EAAW,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,UAAY,UACvE,GAAiB,QAAb,EAAoB,CACvB,IAAM,EAAU,MAAM,CAAA,EAAA,GAAA,CAAA,AAAkB,EAAC,EAAmB,EAAI,OAAO,CAAC,MAAM,CAAE,uBAChF,GAAI,GAAW,EAAQ,OAAO,EAAI,EAAQ,IAAI,CAAE,EAAqB,CACpE,QAAS,CACR,QAAS,EAAQ,OAAO,CACxB,KAAM,EAAQ,IAAI,CAClB,UAAW,EAAQ,SAAS,CAC5B,QAAS,EAAQ,OAAO,AACzB,EACA,UAAW,EAAQ,GAAG,CAAG,AAAc,MAAN,GAAG,CAAS,KAAK,GAAG,EACtD,MACK,CACJ,IAAM,EAAa,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAE3D,OADA,EAAI,SAAS,CAAC,EAAY,GAAI,CAAE,OAAQ,CAAE,GACnC,EAAI,IAAI,CAAC,KACjB,CACD,MAAO,GAAiB,QAAb,EAAoB,CAC9B,IAAM,EAAU,MAAM,CAAA,EAAA,GAAA,CAAA,AAAS,EAAC,EAAmB,EAAI,OAAO,CAAC,MAAM,EACrE,GAAI,GAAW,EAAQ,OAAO,EAAI,EAAQ,IAAI,CAAE,EAAqB,CACpE,QAAS,CACR,QAAS,EAAQ,OAAO,CACxB,KAAM,EAAQ,IAAI,CAClB,UAAW,EAAQ,SAAS,CAC5B,QAAS,EAAQ,OAAO,AACzB,EACA,UAAW,EAAQ,GAAG,CAAG,AAAc,MAAN,GAAG,CAAS,KAAK,GAAG,EACtD,MACK,CACJ,IAAM,EAAa,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAE3D,OADA,EAAI,SAAS,CAAC,EAAY,GAAI,CAAE,OAAQ,CAAE,GACnC,EAAI,IAAI,CAAC,KACjB,CACD,KAAO,CACN,IAAM,EAAS,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GAAO,MAAM,CAAC,GAAA,SAAS,CAAC,MAAM,CAAC,KAC5D,GAAI,EAAQ,GAAI,MAAM,GAAW,UAAW,kBAAkB,MAAM,CAAC,EAAI,OAAO,CAAC,MAAM,CAAE,KAAK,SAAS,CAAC,CACvG,GAAG,EAAO,OAAO,CACjB,UAAW,EAAO,SAAS,AAC5B,GAAI,EAAO,SAAS,EAAG,EAAqB,MACvC,CACJ,IAAM,EAAa,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAE3D,OADA,EAAI,SAAS,CAAC,EAAY,GAAI,CAAE,OAAQ,CAAE,GACnC,EAAI,IAAI,CAAC,KACjB,CACD,CACD,CACA,IAAM,EAAiB,MAAM,EAAI,eAAe,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAE,EAAI,OAAO,CAAC,MAAM,EAInH,GAAI,GAAoB,SAAW,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,SAAW,CAAC,EAAI,KAAK,EAAE,mBAAoB,CACvH,IAAM,EAAY,EAAmB,OAAO,CACtC,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,QAC5D,EAAkB,IACtB,GAAI,GACH,GAA6B,SADX,CACd,OAAO,EAA4B,EAAkB,OACpD,GAA6B,YAAzB,OAAO,EAA8B,CAC7C,IAAM,EAAS,EAAc,EAAU,OAAO,CAAE,EAAU,IAAI,EAC9D,EAAkB,aAAkB,QAAU,MAAM,EAAS,EAC9D,CAED,GAAI,CAAC,EAAU,OAAO,EAAI,GAAA,CAAG,GAAM,EAAiB,CACnD,IAAM,EAAa,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAC3D,EAAI,SAAS,CAAC,EAAY,GAAI,CAAE,OAAQ,CAAE,EAC3C,MAAO,GAAI,EAAmB,SAAS,CAAG,KAAK,GAAG,IAAM,EAAU,OAAO,CAAC,SAAS,CAAmB,EAAhB,EAAoB,KAAQ,CACjH,IAAM,CAD4F,CAC/E,EAAI,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAC3D,EAAI,SAAS,CAAC,EAAY,GAAI,CAAE,OAAQ,CAAE,EAC3C,KAAO,CACN,IAAM,EAAqB,EAAI,OAAO,CAAC,aAAa,CAAC,kBAAkB,CACvE,IAA2B,IAAvB,EAEH,CAFiC,MACjC,EAAI,OAAO,CAAC,OAAO,CAAG,EACf,EAAI,IAAI,CAAC,CACf,QAAS,EAAU,OAAO,CAC1B,KAAM,EAAU,IACjB,AADqB,GAGtB,GAAI,EAAmB,SAAS,CAAG,KAAK,GAAG,GAAoC,IAA/B,EAAmB,SAAS,CAAQ,CACnF,IAAM,EAAe,EAAQ,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,QAAU,IAAK,OAChF,EAAmB,CACxB,QAAS,CACR,GAAG,EAAU,OAAO,CACpB,UAAW,CACZ,EACA,KAAM,EAAU,IAAI,CACpB,UAAW,KAAK,GAAG,EACpB,CACA,OAAM,GAAe,EAAK,EAAkB,IAC5C,IAAM,EAAyB,EAAmB,EAAI,OAAO,CAAC,OAAO,CAAE,CACtE,GAAG,EAAiB,OAAO,CAC3B,UAAW,IAAI,KAAK,EAAiB,OAAO,CAAC,SAAS,EACtD,UAAW,IAAI,KAAK,EAAiB,OAAO,CAAC,SAAS,EACtD,UAAW,IAAI,KAAK,EAAiB,OAAO,CAAC,SAAS,CACvD,GACM,EAAsB,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,CAChE,GAAG,EAAiB,IAAI,CACxB,UAAW,IAAI,KAAK,EAAiB,IAAI,CAAC,SAAS,EACnD,UAAW,IAAI,KAAK,EAAiB,IAAI,CAAC,SAAS,CACpD,GAKA,OAJA,EAAI,OAAO,CAAC,OAAO,CAAG,CACrB,QAAS,EACT,KAAM,CACP,EACO,EAAI,IAAI,CAAC,CACf,QAAS,EACT,KAAM,CACP,EACD,CACA,IAAM,EAAgB,EAAmB,EAAI,OAAO,CAAC,OAAO,CAAE,CAC7D,GAAG,EAAU,OAAO,CACpB,UAAW,IAAI,KAAK,EAAU,OAAO,CAAC,SAAS,EAC/C,UAAW,IAAI,KAAK,EAAU,OAAO,CAAC,SAAS,EAC/C,UAAW,IAAI,KAAK,EAAU,OAAO,CAAC,SAAS,CAChD,GACM,EAAa,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,CACvD,GAAG,EAAU,IAAI,CACjB,UAAW,IAAI,KAAK,EAAU,IAAI,CAAC,SAAS,EAC5C,UAAW,IAAI,KAAK,EAAU,IAAI,CAAC,SAAS,CAC7C,GAKA,OAJA,EAAI,OAAO,CAAC,OAAO,CAAG,CACrB,QAAS,EACT,KAAM,CACP,EACO,EAAI,IAAI,CAAC,CACf,QAAS,EACT,KAAM,CACP,EACD,CACD,CACA,IAAM,EAAU,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,GAE9D,GADA,EAAI,OAAO,CAAC,OAAO,CAAG,EAClB,CAAC,GAAW,EAAQ,OAAO,CAAC,SAAS,CAAmB,EAAhB,EAAoB,KAO/D,GAPuE,GAAf,CACxD,GAAoB,GAChB,GAIJ,MAHF,AAGQ,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAQ,OAAO,CAAC,KAAK,EAC9D,EAAI,IAAI,CAAC,MAMjB,GAAI,GAAkB,EAAI,KAAK,EAAE,eAAgB,CAChD,IAAM,EAAgB,EAAmB,EAAI,OAAO,CAAC,OAAO,CAAE,EAAQ,OAAO,EACvE,EAAa,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,EAAQ,IAAI,EACpE,OAAO,EAAI,IAAI,CAAC,CACf,QAAS,EACT,KAAM,CACP,EACD,CACA,IAAM,EAAY,EAAI,OAAO,CAAC,aAAa,CAAC,SAAS,CAC/C,EAAY,EAAI,OAAO,CAAC,aAAa,CAAC,SAAS,CACrD,GAAI,EAAQ,OAAO,CAAC,SAAS,CAAC,OAAO,GAAiB,IAAZ,EAA8B,IAAZ,GAAmB,KAAK,GAAG,KAAO,CAAD,AAAE,EAAI,KAAK,EAAE,gBAAkB,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,qBAAA,CAAqB,CAAG,CACjL,IAAM,EAAiB,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAQ,OAAO,CAAC,KAAK,CAAE,CAC7F,UAAW,EAAQ,EAAI,OAAO,CAAC,aAAa,CAAC,SAAS,CAAE,OACxD,UAA2B,CAAhB,GAAoB,IAChC,GACA,GAFyB,AAErB,CAAC,EAKJ,OADA,GAAoB,GACb,CALa,CAKT,IAAI,CAAC,KAAM,CAAE,OAAQ,GAAI,GAErC,IAAM,EAAS,CAAC,EAAe,SAAS,CAAC,OAAO,GAAK,KAAK,GAAG,EAAA,CAAE,CAAI,GACnE,OAAM,GAAiB,EAAK,CAC3B,QAAS,EACT,KAAM,EAAQ,IAAI,AACnB,GAAG,EAAO,QAAE,CAAO,GACnB,IAAM,EAAuB,EAAmB,EAAI,OAAO,CAAC,OAAO,CAAE,GAC/D,EAAa,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,EAAQ,IAAI,EACpE,OAAO,EAAI,IAAI,CAAC,CACf,QAAS,EACT,KAAM,CACP,EACD,CAEA,OADA,MAAM,GAAe,EAAK,EAAS,CAAC,CAAC,GAC9B,EAAI,IAAI,CAAC,EACjB,CAAE,MAAO,EAAO,CAEf,MADA,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAyB,GAC5C,IAAI,EAAA,QAAQ,CAAC,wBAAyB,CAAE,QAAS,GAAA,CAAgB,CAAC,qBAAqB,AAAC,EAC/F,CACD,GACM,GAAoB,MAAO,EAAK,KACrC,GAAI,EAAI,OAAO,CAAC,OAAO,CAAE,OAAO,EAAI,OAAO,CAAC,OAAO,CACnD,IAAM,EAAU,MAAM,KAAa,CAClC,GAAG,CAAG,CACN,YAAY,EACZ,QAAS,EAAI,OAAO,CACpB,eAAe,EACf,cAAc,EACd,MAAO,CACN,GAAG,CAAM,CACT,GAAG,EAAI,KAAK,AACb,CACD,GAAG,KAAK,CAAC,AAAC,GACF,MAGR,OADA,EAAI,OAAO,CAAC,OAAO,CAAG,EACf,CACR,EAIM,GAAoB,GAAqB,MAAO,IACrD,IAAM,EAAU,MAAM,GAAkB,GACxC,GAAI,CAAC,GAAS,QAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,gBAC1C,MAAO,CAAE,SAAQ,CAClB,GAMM,GAA6B,GAAqB,MAAO,IAC9D,IAAM,EAAU,MAAM,GAAkB,EAAK,CAAE,oBAAoB,CAAK,GACxE,GAAI,CAAC,GAAS,QAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,gBAC1C,MAAO,SAAE,CAAQ,CAClB,GAKqC,GAAqB,MAAO,IAChE,IAAM,EAAU,MAAM,GAAkB,GACxC,GAAI,CAAC,GAAS,UAAY,CAAD,CAAK,OAAO,EAAI,EAAI,OAAA,AAAO,EAAG,MAAM,IAAI,EAAA,QAAQ,CAAC,gBAC1E,MAAO,SAAE,CAAQ,CAClB,GAQA,IAAM,GAAyB,GAAqB,MAAO,IAC1D,IAAM,EAAU,MAAM,GAAkB,GACxC,GAAI,CAAC,GAAS,QAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,gBAC1C,GAA2C,IAAvC,EAAI,OAAO,CAAC,aAAa,CAAC,QAAQ,CAAQ,MAAO,SAAE,CAAQ,EAC/D,IAAM,EAAW,EAAI,OAAO,CAAC,aAAa,CAAC,QAAQ,CAC7C,EAAc,IAAI,KAAK,EAAQ,OAAO,CAAC,SAAS,EAAI,EAAQ,OAAO,CAAC,SAAS,EAAE,OAAO,GAC5F,GAAI,CAAC,CAAC,KAAK,GAAG,GAAK,EAAc,AAAW,KAAA,CAAG,CAAG,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,sBAAuB,GACpH,MAAO,SAAE,CAAQ,CAClB,GAkCM,GAAgB,GAAmB,kBAAmB,CAC3D,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CAAE,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,qBAAsB,EAAG,GAChF,IAAK,CAAC,GAA2B,CACjC,gBAAgB,EAChB,SAAU,CAAE,QAAS,CACpB,YAAa,0BACb,YAAa,CAAE,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACvD,KAAM,SACN,WAAY,CAAE,MAAO,CACpB,KAAM,SACN,YAAa,qBACd,CAAE,EACF,SAAU,CAAC,QAAQ,AACpB,CAAE,CAAE,CAAE,EACN,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,OAAQ,CACrB,KAAM,UACN,YAAa,mDACd,CAAE,EACF,SAAU,CAAC,SAAS,AACrB,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,IAAM,EAAQ,EAAI,IAAI,CAAC,KAAK,CAC5B,GAAI,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,EAAA,CAAM,EAAG,QAAQ,SAAW,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAE,GAAI,CAC/G,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EACjD,CAAE,MAAO,EAAO,CAEf,MADA,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAA0B,UAAjB,OAAO,GAAsB,SAAU,EAAQ,EAAM,IAAI,CAAG,GAAI,GAC5F,IAAI,EAAA,QAAQ,CAAC,wBACpB,CACA,OAAO,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,GAIM,GAAiB,GAAmB,mBAAoB,CAC7D,OAAQ,OACR,IAAK,CAAC,GAA2B,CACjC,gBAAgB,EAChB,SAAU,CAAE,QAAS,CACpB,YAAa,mCACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,OAAQ,CACrB,KAAM,UACN,YAAa,qDACd,CAAE,EACF,SAAU,CAAC,SAAS,AACrB,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CACH,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAC7E,CAAE,MAAO,EAAO,CAEf,MADA,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAA0B,UAAjB,OAAO,GAAsB,SAAU,EAAQ,EAAM,IAAI,CAAG,GAAI,GAC5F,IAAI,EAAA,QAAQ,CAAC,wBACpB,CACA,OAAO,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,GACM,GAAsB,GAAmB,yBAA0B,CACxE,OAAQ,OACR,gBAAgB,EAChB,IAAK,CAAC,GAA2B,CACjC,SAAU,CAAE,QAAS,CACpB,YAAa,gEACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,OAAQ,CACrB,KAAM,UACN,YAAa,2DACd,CAAE,EACF,SAAU,CAAC,SAAS,AACrB,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,IAAM,EAAU,EAAI,OAAO,CAAC,OAAO,CACnC,GAAI,CAAC,EAAQ,IAAI,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,gBACtC,IAAM,EAAgB,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAQ,IAAI,CAAC,GAAE,CAAC,CAAE,MAAM,CAAC,AAAC,GACxF,EAAU,SAAS,CAAmB,EAAhB,EAAoB,MAC/C,KADwC,CAClC,CAAC,AAAC,GAAc,EAAU,KAAK,GAAK,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAE9E,OADA,MAAM,QAAQ,GAAG,CAAC,EAAc,GAAG,CAAC,AAAC,GAAc,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAU,KAAK,IACrG,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,8CG9YA,GAAA,EAAA,CAAA,CAAA,WrDbI,GAAY,OAAO,cAAc,CACjC,GAAa,OAAO,gBAAgB,CACpC,GAAoB,OAAO,yBAAyB,CACpD,GAAsB,OAAO,qBAAqB,CAClD,GAAe,OAAO,SAAS,CAAC,cAAc,CAC9C,GAAe,OAAO,SAAS,CAAC,oBAAoB,CACpD,GAAkB,CAAC,EAAK,EAAK,IAAU,KAAO,EAAM,GAAU,EAAK,EAAK,CAAE,YAAY,EAAM,aAAc,GAAM,UAAU,QAAM,CAAM,GAAK,CAAG,CAAC,EAAI,CAAG,EACtJ,GAAiB,CAAC,EAAG,KACvB,IAAK,IAAI,KAAQ,IAAM,CAAD,CAAK,EAAC,CAAC,CACvB,CAAJ,EAAiB,IAAI,CAAC,EAAG,IACvB,GAAgB,EAAG,EAAM,CAAC,CAAC,EAAK,EACpC,GAAI,GACF,IAAK,IAAI,KAAQ,GAAoB,GAAI,AACnC,GAAa,IAAI,CAAC,EAAG,IACvB,GAAgB,EAAG,EAAM,CAAC,CAAC,EAAK,EAEtC,OAAO,CACT,EACI,GAAgB,CAAC,EAAG,IAAM,GAAW,EAAG,GAAkB,IAG1D,GAAmB,cAAc,MACnC,YAAY,CAAM,CAAE,CAAU,CAAE,CAAK,CAAE,CACrC,KAAK,CAAC,GAAc,EAAO,QAAQ,GAAI,CACrC,MAAO,CACT,GACA,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,KAAK,CAAG,CACf,CACF,EAGI,GAAoB,MAAO,EAAK,KAClC,IAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EACxB,IAAI,EAAO,GAAW,CAAC,EACjB,EAAQ,CACZ,UAAW,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,SAAS,CAAC,CACzD,WAAY,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,UAAU,CAAC,CAC3D,UAAW,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,SAAS,CAAC,CACzD,QAAS,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,OAAO,CAAC,CACrD,QAAS,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,OAAO,CAAC,AACvD,EACA,GAAI,CAAC,GAAW,CAAC,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,OAAA,AAAO,EAC1D,CAD6D,KACtD,KACL,EACA,QAAS,QACT,CACF,EAEF,IAAK,IAAM,IAAU,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,OAAA,AAAO,GAAK,EAAE,CAAE,CACvE,GAAI,EAAO,IAAI,CAAE,CACf,IAAM,EAAY,MAAM,CAAuB,AAAtB,OAAC,EAAK,EAAO,IAAI,AAAJ,EAAgB,KAAK,EAAI,EAAG,IAAI,CAAC,EAAQ,EAAI,QAAQ,GAAI,EAAA,CAAQ,CACvG,EAAO,EAAU,OAAO,EAAI,EAC5B,EAAM,EAAU,GAAG,AACrB,CACA,EAAM,SAAS,CAAC,IAAI,CAAC,AAAuB,OAAtB,EAAK,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAG,SAAS,EACxE,EAAM,UAAU,CAAC,IAAI,CAAC,AAAuB,OAAtB,EAAK,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAG,UAAU,EAC1E,EAAM,SAAS,CAAC,IAAI,CAAwB,AAAvB,OAAC,EAAK,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAG,SAAS,EACxE,EAAM,OAAO,CAAC,IAAI,CAAwB,AAAvB,OAAC,EAAK,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAG,OAAO,EACpE,EAAM,OAAO,CAAC,IAAI,CAAC,AAAuB,MAAtB,GAAK,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAG,OAAO,CACtE,CACA,MAAO,KACL,EACA,QAAS,EACT,OACF,CACF,EAGI,GAAsB,MACxB,YAAY,CAAO,CAAE,CACnB,IAAI,CAAC,OAAO,CAAG,CACjB,CACA,mBAAmB,CAAO,CAAE,CAAQ,CAAE,QACpC,AAAI,IAAI,CAAC,OAAO,CAAC,WAAW,CACnB,CADqB,OACb,OAAO,CACpB,EAAU,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAI,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAGzD,QAAQ,OAAO,CAAC,EAAU,IAAI,CAAC,OAAO,CAAC,QAAQ,CACxD,CACA,UAAW,CACT,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,AAC3B,CACF,EACI,GAA2B,MAC7B,YAAY,CAAO,CAAE,CACnB,IAAI,CAAC,OAAO,CAAG,CACjB,CACA,mBAAmB,CAAO,CAAE,CAAQ,CAAE,QACpC,AAAI,IAAI,CAAC,OAAO,CAAC,WAAW,CACnB,CADqB,OACb,OAAO,CACpB,EAAU,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAI,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAGzD,QAAQ,OAAO,CAAC,EAAU,IAAI,CAAC,OAAO,CAAC,QAAQ,CACxD,CACA,SAAS,CAAO,CAAE,CAKhB,OAAO,AAJO,KAAK,GAAG,CACpB,IAAI,CAAC,OAAO,CAAC,QAAQ,CACrB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAG,GAAK,EAGlC,CACF,EAoBI,GAAgB,MAAO,IACzB,IAAM,EAAU,CAAC,EACX,EAAW,MAAO,GAAU,AAAiB,mBAAV,EAAuB,MAAM,IAAU,EAChF,GAAe,MAAX,EAAkB,KAAK,EAAI,EAAQ,IAAI,EAAE,AAC3C,GAA0B,WAAtB,EAAQ,IAAI,CAAC,IAAI,CAAe,CAClC,IAAM,EAAQ,MAAM,EAAS,EAAQ,IAAI,CAAC,KAAK,EAC/C,GAAI,CAAC,EACH,KADU,EACH,EAET,EAAQ,KAAD,QAAiB,CAAG,CAAC,OAAO,EAAE,EAAA,CAAO,AAC9C,MAAO,GAA0B,UAAtB,EAAQ,IAAI,CAAC,IAAI,CAAc,CACxC,IAAM,EAAW,EAAS,EAAQ,IAAI,CAAC,QAAQ,EACzC,EAAW,EAAS,EAAQ,IAAI,CAAC,QAAQ,EAC/C,GAAI,CAAC,GAAY,CAAC,EAChB,OAAO,CADmB,CAG5B,EAAQ,KAAD,QAAiB,CAAG,CAAC,MAAM,EAAE,KAAK,CAAA,EAAG,EAAS,CAAC,EAAE,EAAA,CAAU,EAAA,CAAG,AACvE,MAAO,GAA0B,WAAtB,EAAQ,IAAI,CAAC,IAAI,CAAe,CACzC,IAAM,EAAQ,EAAS,EAAQ,IAAI,CAAC,KAAK,EACzC,GAAI,CAAC,EACH,KADU,EACH,EAET,EAAQ,KAAD,QAAiB,CAAG,CAAA,EAAG,EAAS,EAAQ,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAA,CAAO,CACxE,CAEF,OAAO,CACT,EAGI,GAAU,oDA6Bd,SAAS,GAAmB,CAAK,EAC/B,GAAc,KAAK,GAAG,CAAlB,EACF,OAAO,EAET,IAAM,EAAI,OAAO,QACjB,AAAU,WAAN,GAAwB,AAAN,cAAwB,AAAN,eAAyB,MAAM,CAAZ,GAGjD,UAAU,CAAhB,MAGA,MAAM,OAAO,CAAC,KAGd,EAAM,CAHgB,KAGV,EAAE,CAGX,EAAM,WAAW,EAA+B,WAA3B,EAAM,WAAW,CAAC,IAAI,EAAyC,YAAxB,OAAO,EAAM,MAAM,AAAK,EAC7F,CACA,SAAS,GAAU,CAAI,EACrB,GAAI,CACF,OAAO,KAAK,KAAK,CAAC,EACpB,CAAE,MAAO,EAAO,CACd,OAAO,CACT,CACF,CA8BA,eAAe,GAAW,CAAI,EAC5B,IAAM,EAAU,IAAI,QAAgB,MAAR,EAAe,KAAK,EAAI,EAAK,OAAO,EAEhE,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,AADvB,MAAM,GAAc,IACiB,CAAC,GAAI,AAC3D,EAAQ,GAAG,CAAC,EAAK,GAEnB,GAAI,CAAC,EAAQ,GAAG,CAAC,gBAAiB,CAChC,IAAM,EA+DR,AAAI,EA/DQ,CAA0B,MAAR,EAAe,KAAK,EAAI,CA+D/B,CA/DoC,IAAI,EA+DjC,AACrB,mBAEF,IAjED,GAAG,CACL,EAAQ,GAAG,CAAC,eAAgB,EAEhC,CACA,OAAO,CACT,CA+GA,IAAI,GAAkB,MAAM,UAAyB,MACnD,YAAY,CAAM,CAAE,CAAO,CAAE,CAC3B,KAAK,CAAC,GAAW,KAAK,SAAS,CAAC,EAAQ,KAAM,IAC9C,IAAI,CAAC,MAAM,CAAG,EACd,OAAO,cAAc,CAAC,IAAI,CAAE,EAAiB,SAAS,CACxD,CACF,EACA,eAAe,GAAoB,CAAM,CAAE,CAAK,EAC9C,IAAI,EAAS,MAAM,CAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,GAChD,GAAI,EAAO,MAAM,CACf,CADiB,KACX,IAAI,GAAgB,EAAO,MAAM,EAEzC,OAAO,EAAO,KAAK,AACrB,CAGA,IAAI,GAAU,CAAC,MAAO,OAAQ,MAAO,QAAS,SAAS,CAoInD,GAAc,MAAO,EAAK,SACxB,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,MAxK5B,EAyKE,OACJ,CAAK,CACL,IAAK,CAAK,CACV,QAAS,CAAI,CACd,CAAG,MAAM,GAAkB,EAAK,GAC3B,EAAQ,AAjThB,SAAkB,AAAT,CAAgB,EACvB,GAAe,MAAX,EAAkB,KAAK,EAAI,EAAQ,eAAe,CACpD,CADsD,MAC/C,EAAQ,eAAe,CAEhC,GAA0B,aAAtB,EAAqC,KAA9B,YANa,YAAjB,OAM6C,AANtC,WAMiD,KAAK,CAClE,EADqE,KAC9D,WAAW,KAAK,AAKzB,OAAM,AAAI,MAAM,gCAClB,EAsSyB,GACjB,EAAa,IAAI,gBACjB,EAAS,AAAsB,OAArB,EAAK,EAAK,MAAA,AAAM,EAAY,EAAK,EAAW,MAAM,CAC5D,EAvDR,AAuDe,SAvDE,AAAR,CAAW,CAAE,CAAM,EAC1B,GAAI,SAAE,CAAO,QAAE,CAAM,OAAE,CAAK,CAAE,CAAG,GAAU,CACzC,MAAO,CAAC,EACR,OAAQ,CAAC,EACT,QAAS,EACX,EACI,EAAW,EAAI,UAAU,CAAC,QAAU,EAAI,KAAK,CAAC,KAAK,KAAK,CAAC,EAAG,GAAG,IAAI,CAAC,KAAO,GAAW,GAC1F,GAAI,EAAI,UAAU,CAAC,KAAM,CACvB,IAAM,EAAI,EAAI,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAChD,GAAQ,QAAQ,CAAC,IAAI,CACvB,EAAM,EAAI,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAE,IAAA,CAEhC,CACI,AAAC,EAAS,QAAQ,CAAC,OAAM,GAAY,GAAA,EACzC,GAAI,CAAC,EAAM,EAAS,CAAG,EAAI,OAAO,CAAC,EAAU,IAAI,KAAK,CAAC,KACjD,EAAc,IAAI,gBAAgB,GACxC,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GAAS,CAAC,GAAI,AACzC,MAAT,AAAe,GACnB,EAAY,GAAG,CAAC,EAAK,OAAO,IAE9B,GAAI,EACF,GAAI,GADM,GACA,OAAO,CAAC,GAEhB,IAAK,EAFoB,CAEd,CAAC,EAAO,EAAI,GADJ,AACQ,EADH,KAAK,CAAC,KAAK,MAAM,CAAE,AAAD,GAAO,EAAE,UAAU,CAAC,MACxB,OAAO,GAAI,CAC/C,IAAM,EAAQ,CAAM,CAAC,EAAM,CAC3B,EAAO,EAAK,OAAO,CAAC,EAAK,EAC3B,MAEA,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GACxC,EAAO,EAAK,CADqC,MAC9B,CAAC,CAAC,CAAC,EAAE,EAAA,CAAK,CAAE,OAAO,IAKxC,CADJ,EAAO,EAAK,KAAK,CAAC,KAAK,GAAG,CAAC,oBAAoB,IAAI,CAAC,IAAA,EAC3C,UAAU,CAAC,OAAM,EAAO,EAAK,KAAK,CAAC,EAAA,EAC5C,IAAI,EAAmB,EAAY,QAAQ,SAE3C,CADA,EAAmB,CACf,CADgC,MAAM,CAAG,EAAI,CAAC,CAAC,EAAE,EAAA,CAAkB,CAAC,OAAO,CAAC,MAAO,OAAS,GAC3F,EAAS,UAAU,CAAC,SAAS,AAGrB,IAAI,IAAI,CAAA,EAAG,EAAA,EAAO,EAAA,CAAkB,CAAE,GAF1C,CAAA,EAAG,EAAA,EAAW,EAAA,EAAO,EAAA,CAAkB,AAIlD,EAauB,EAAO,GACtB,EAhNR,AAgNe,SAhNN,AAAQ,CAAO,EACtB,GAAI,CAAC,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,IAAA,AAAI,EAC3C,CAD8C,MACvC,KAET,IAAM,EAAU,IAAI,QAAmB,MAAX,EAAkB,KAAK,EAAI,EAAQ,OAAO,EACtE,GAAI,GAAmB,EAAQ,IAAI,GAAK,CAAC,EAAQ,GAAG,CAAC,gBAAiB,CACpE,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,IAAI,EAAG,AAC9E,aAAiB,MAAM,CACzB,EAAQ,IAAI,CAAC,EAAI,CAAG,EAAM,WAAW,EAAA,EAGzC,OAAO,KAAK,SAAS,CAAC,EAAQ,IAAI,CACpC,CACA,OAAO,EAAQ,IAAI,AACrB,EAkMuB,GACf,EAAU,MAAM,GAAW,GAC3B,EAAS,AAnMjB,SAAS,AAAU,CAAG,CAAE,CAAO,EAC7B,IAAI,EACJ,GAAe,MAAX,EAAkB,KAAK,EAAI,EAAQ,MAAM,CAC3C,CAD6C,MACtC,EAAQ,MAAM,CAAC,WAAW,GAEnC,GAAI,EAAI,UAAU,CAAC,KAAM,CACvB,IAAM,EAAU,AAA4B,OAA3B,EAAK,EAAI,KAAK,CAAC,IAAI,CAAC,EAAA,AAAE,EAAY,KAAK,EAAI,EAAG,KAAK,CAAC,IAAI,CAAC,EAAE,QACvE,AAAL,GAAa,CAAT,OAAiB,CAAC,GAGf,EAAQ,KAHiB,MAGN,GAFjB,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,IAAA,AAAI,EAAI,OAAS,KAGhE,CACA,MAAO,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,IAAA,AAAI,EAAI,OAAS,KAC9D,EAsL2B,EAAO,GAC5B,EAAU,GAAc,GAAe,CAAC,EAAG,GAAO,CACpD,IAAK,UACL,EACA,cACA,SACA,CACF,GACA,IAAK,IAAM,KAAa,EAAM,SAAS,CAAE,AACvC,GAAI,EAAW,CACb,IAAM,EAAM,MAAM,EAAU,GACxB,aAAe,QAAQ,CACzB,EAAU,CAAA,CAEd,EAEE,WAAY,GAAW,AAA0B,mBAAnB,EAAQ,MAAM,EAA0G,YAAvF,OAAO,AAAC,AAAkD,OAAjD,EAAgB,MAAX,EAAkB,KAAK,EAAI,EAAQ,IAAA,AAAI,EAAY,KAAK,EAAI,EAAG,IAAA,AAAI,CAAM,GAAY,AAChK,CAAC,CAAC,WAAY,CAAA,CAAO,GACvB,AAD0B,EAClB,MAAM,CAAG,MAAA,EAGrB,GAAM,CAAE,aAAc,CAAa,CAAE,EAxMjC,CAAC,AAwMmC,CAxMlC,AAAW,QAAO,KAAK,EAAI,EAAQ,MAAA,AAAM,IAAM,AAAW,CAAZ,OAAmB,KAAK,EAAI,EAAQ,OAAO,AAAP,GAAU,CAChG,EAAe,WAAW,IAAM,AAAc,MAuMS,EAvMF,KAAK,EAAI,EAAW,KAAK,GAAI,AAAW,QAAO,KAAK,EAAI,AAuM5D,EAvMoE,OAAO,GAEvH,cACL,EACA,aAAc,KACR,GACF,WADgB,EACH,EAEjB,CACF,GA+LI,EAAW,MAAM,EAAM,EAAQ,GAAG,CAAE,GACxC,IACA,IAAM,EAAkB,UACtB,EACA,QAAS,CACX,EACA,IAAK,IAAM,KAAc,EAAM,UAAU,CAAE,AACzC,GAAI,EAAY,CACd,IAAM,EAAI,MAAM,EAAW,GAAc,GAAe,CAAC,EAAG,GAAkB,CAC5E,SAAU,CAAC,AAAyD,OAAxD,EAAgB,MAAX,EAAkB,KAAK,EAAI,EAAQ,WAAA,AAAW,EAAY,KAAK,EAAI,EAAG,aAAA,AAAa,EAAI,EAAS,KAAK,GAAK,CAC7H,IACI,aAAa,SACf,CADyB,CACd,EACF,aAAa,QAAQ,CAC9B,EAAW,EAAE,QAAA,AAAQ,CAEzB,CAEF,GAAI,EAAS,EAAE,CAAE,CAEf,GADgB,AAAmB,CAC/B,CAAC,SADmB,AACV,MADgB,CAE5B,MAAO,CACL,KAAM,GACN,MAAO,IACT,EAEF,IAAM,EAAe,AAhazB,SAA4B,AAAnB,CAA0B,EACjC,IAAM,EAAe,EAAQ,OAAO,CAAC,GAAG,CAAC,gBACnC,EAA4B,IAAI,IAAI,CACxC,CADgB,WAEhB,EAF6B,gBAG7B,oBACA,mBACD,EACD,GAAI,CAAC,EACH,MAAO,MADU,CAGnB,IAAM,EAAc,EAAa,KAAK,CAAC,KAAK,KAAK,IAAM,UACvD,AAAI,GAAQ,IAAI,CAAC,GACR,OAEL,EAAU,EAHiB,CAGd,CAAC,IAAgB,EAAY,UAAU,CAAC,SAChD,CAD0D,MAG5D,MACT,EA6Y4C,GAClC,EAAiB,CACrB,KAAM,YACN,EACA,QAAS,CACX,EACA,GAAqB,SAAjB,GAA4C,SAAjB,EAAyB,CACtD,IAAM,EAAO,MAAM,EAAS,IAAI,GAC1B,EAAU,AAA6B,OAA5B,EAAK,EAAQ,UAAA,AAAU,EAAY,EAAK,EAEzD,GAAe,IAAI,CADN,EACS,IADH,EAAQ,EAE7B,MACE,CADK,CACU,IAAI,CAAG,MAAM,CAAQ,CAAC,EAAa,GAUpD,IAAK,IAAM,MARI,MAAX,EAAkB,KAAK,EAAI,EAAQ,MAAA,AAAM,EAAE,CACzC,EAAQ,MAAM,EAAI,CAAC,EAAQ,iBAAiB,EAAE,CAChD,EAAe,IAAI,CAAG,MAAM,GAC1B,EAAQ,MAAM,CACd,EAAe,KAAI,EAID,EAAM,SAAS,CAAE,CACnC,GACF,MAAM,EADO,AACG,GAAc,GAAe,CAAC,EAAG,GAAiB,CAChE,SAAU,AAAC,CAAyD,MAAxD,GAAgB,MAAX,EAAkB,KAAK,EAAI,EAAQ,WAAA,AAAW,EAAY,KAAK,EAAI,EAAG,aAAA,AAAa,EAAI,EAAS,KAAK,GAAK,CAC7H,UAGJ,CAAe,MAAX,EAAkB,KAAK,EAAI,EAAQ,KAAA,AAAK,EAAE,AACrC,EAAe,IAAI,CAErB,CACL,KAAM,EAAe,IAAI,CACzB,MAAO,IACT,CACF,CACA,IAAM,EAAiE,AAAxD,OAAC,EAAK,AAAW,QAAO,KAAK,EAAI,EAAQ,UAAA,AAAU,EAAY,EAAK,GAC7E,EAAe,MAAM,EAAS,IAAI,GAClC,EAnbR,AAmbyB,SAnbhB,AAAe,CAAK,EAC3B,GAAI,CAEF,OADA,KAAK,KAAK,CAAC,IACJ,CACT,CAAE,MAAO,EAAO,CACd,OAAO,CACT,CACF,EA4awC,GAChC,EAAc,EAAiB,MAAM,EAAO,GAAgB,KAC5D,EAAe,UACnB,eACA,EACA,QAAS,EACT,MAAO,GAAc,GAAe,CAAC,EAAG,GAAc,CACpD,OAAQ,EAAS,MAAM,CACvB,WAAY,EAAS,UAAU,AACjC,EACF,EACA,IAAK,IAAM,KAAW,EAAM,OAAO,CAAE,AAC/B,GACF,MAAM,AADK,EACG,GAAc,GAAe,CAAC,EAAG,GAAe,CAC5D,SAAU,CAA0D,AAAzD,OAAC,EAAgB,MAAX,EAAkB,KAAK,EAAI,EAAQ,WAAW,AAAX,EAAuB,KAAK,EAAI,EAAG,aAAA,AAAa,EAAI,EAAS,KAAK,GAAK,CAC7H,IAGJ,GAAe,MAAX,EAAkB,KAAK,EAAI,EAAQ,KAAK,CAAE,CAC5C,IAAM,EA3gBV,AA2gB0B,SA3gBjB,AAAoB,CAAO,EAClC,GAAuB,UAAU,AAA7B,OAAO,EACT,OAAO,IAAI,GAAoB,CAC7B,KAAM,SACN,SAAU,EACV,MAAO,GACT,GAEF,OAAQ,EAAQ,IAAI,EAClB,IAAK,SACH,OAAO,IAAI,GAAoB,EACjC,KAAK,cACH,OAAO,IAAI,GAAyB,EACtC,SACE,MAAM,AAAI,MAAM,yBACpB,CACF,EA2f8C,EAAQ,KAAK,EACjD,EAA+C,AAA/B,OAAC,EAAK,EAAQ,YAAY,AAAZ,EAAwB,EAAK,EACjE,GAAI,MAAM,EAAc,kBAAkB,CAAC,EAAe,GAAW,CACnE,IAAK,IAAM,KAAW,EAAM,OAAO,CAC7B,AAD+B,GAEjC,MADW,AACL,EAAQ,GAGlB,IAAM,EAAQ,EAAc,QAAQ,CAAC,GAErC,OADA,MAAM,IAAI,QAAS,AAAD,GAAa,WAAW,EAAS,IAC5C,MAAM,GAAY,EAAK,GAAc,GAAe,CAAC,EAAG,GAAU,CACvE,aAAc,EAAgB,CAChC,GACF,CACF,CACA,GAAI,AAAW,QAAO,KAAK,EAAI,EAAQ,KAAK,CAC1C,CAD4C,KACtC,IAAI,GACR,EAAS,MAAM,CACf,EAAS,UAAU,CACnB,EAAiB,EAAc,GAGnC,MAAO,CACL,KAAM,KACN,MAAO,GAAc,GAAe,CAAC,EAAG,GAAc,CACpD,OAAQ,EAAS,MAAM,CACvB,WAAY,EAAS,UAAU,AACjC,EACF,CACF,E2B3lBA,SAAS,GAAgB,CAAI,EAC5B,IAAM,EAAU,AAAC,GAET,IAAI,KADiB,AACZ,IADgB,OACZ,OAAO,GAAe,IAAV,GAEjC,MAAO,CACN,UAAW,EAAK,UAAU,CAC1B,YAAa,EAAK,YAAY,CAC9B,aAAc,EAAK,aAAa,CAChC,qBAAsB,EAAK,UAAU,CAAG,EAAQ,EAAK,UAAU,EAAI,KAAK,EACxE,sBAAuB,EAAK,wBAAwB,CAAG,EAAQ,EAAK,wBAAwB,EAAI,KAAK,EACrG,OAAQ,GAAM,MAA8B,UAAtB,OAAO,EAAK,KAAK,CAAgB,EAAK,KAAK,CAAC,KAAK,CAAC,KAAO,EAAK,KAAK,CAAG,EAAE,CAC9F,QAAS,EAAK,QAAQ,CACtB,IAAK,CACN,CACD,CACA,eAAe,GAAsB,CAAY,EAChD,IAAM,EAAO,IAAI,cAAc,MAAM,CAAC,GAChC,EAAO,MAAM,OAAO,MAAM,CAAC,MAAM,CAAC,UAAW,GACnD,OAAO,GAAA,SAAS,CAAC,MAAM,CAAC,IAAI,WAAW,GAAO,CAAE,SAAS,CAAM,EAChE,CAIA,eAAe,GAAuB,IAAE,CAAE,CAAE,SAAO,uBAAE,CAAqB,OAAE,CAAK,cAAE,CAAY,QAAE,CAAM,QAAE,CAAM,aAAE,CAAW,UAAE,CAAQ,QAAE,CAAM,YAAE,CAAU,cAAE,CAAY,SAAE,CAAO,WAAE,CAAS,IAAE,CAAE,cAAE,CAAY,kBAAE,CAAgB,CAAE,aAAW,CAAE,EAC9O,IAAM,EAAM,IAAI,IAAI,GACpB,EAAI,YAAY,CAAC,GAAG,CAAC,gBAAiB,GAAgB,QACtD,IAAM,EAAkB,MAAM,OAAO,CAAC,EAAQ,QAAQ,EAAI,EAAQ,QAAQ,CAAC,EAAE,CAAG,EAAQ,QAAQ,CAYhG,GAXA,EAAI,YAAY,CAAC,GAAG,CAAC,YAAa,GAClC,EAAI,YAAY,CAAC,GAAG,CAAC,QAAS,GAC1B,GAAQ,EAAI,YAAY,CAAC,GAAG,CAAC,QAAS,EAAO,IAAI,CAAC,GAAe,MACrE,EAAI,YAAY,CAAC,GAAG,CAAC,eAAgB,EAAQ,WAAW,EAAI,GAC5D,GAAY,EAAI,YAAY,CAAC,GAAG,CAAC,WAAY,GAC7C,GAAW,EAAI,YAAY,CAAC,GAAG,CAAC,UAAW,GAC3C,GAAa,EAAI,YAAY,CAAC,GAAG,CAAC,aAAc,GAChD,GAAU,EAAI,YAAY,CAAC,GAAG,CAAC,SAAU,GACzC,GAAM,EAAI,YAAY,CAAC,GAAG,CAAC,KAAM,GACjC,GAAc,EAAI,YAAY,CAAC,GAAG,CAAC,cAAe,GAClD,GAAgB,EAAI,YAAY,CAAC,GAAG,CAAC,gBAAiB,GAClD,EAAc,CACjB,IAAM,EAAgB,MAAM,GAAsB,GAClD,EAAI,YAAY,CAAC,GAAG,CAAC,wBAAyB,QAC9C,EAAI,YAAY,CAAC,GAAG,CAAC,iBAAkB,EACxC,CACA,GAAI,EAAQ,CACX,IAAM,EAAY,EAAO,MAAM,CAAC,CAAC,EAAK,KACrC,CAAG,CAAC,EAAM,CAAG,KACN,GACL,CAAC,GACJ,EAAI,YAAY,CAAC,GAAG,CAAC,SAAU,KAAK,SAAS,CAAC,CAAE,SAAU,CACzD,MAAO,KACP,eAAgB,KAChB,GAAG,CAAS,AACb,CAAE,GACH,CAIA,OAHI,GAAkB,OAAO,OAAO,CAAC,GAAkB,OAAO,CAAC,CAAC,CAAC,EAAK,EAAM,IAC3E,EAAI,YAAY,CAAC,GAAG,CAAC,EAAK,EAC3B,GACO,CACR,CA6BA,eAAe,GAAmB,CAAE,cAAY,SAAE,CAAO,eAAE,CAAa,gBAAE,CAAc,CAAE,aAAW,CAAE,EACtG,GAAM,MAAE,CAAI,SAAE,CAAO,CAAE,CAAG,AA1B3B,SAAS,AAAgC,cAAE,CAAY,CAAE,SAAO,gBAAE,CAAc,aAAE,CAAW,UAAE,CAAQ,CAAE,EACxG,IAAM,EAAO,IAAI,gBACX,EAAU,CACf,eAAgB,oCAChB,OAAQ,kBACT,EAGA,GAFA,EAAK,GAAG,CAAC,aAAc,iBACvB,EAAK,GAAG,CAAC,gBAAiB,GACtB,AAAmB,YAAS,CAC/B,IAAM,EAAkB,MAAM,OAAO,CAAC,EAAQ,QAAQ,EAAI,EAAQ,QAAQ,CAAC,EAAE,CAAG,EAAQ,QAAQ,CAC5F,EAAiB,EAAQ,KAAD,QAAiB,CAAG,SAAW,GAAA,MAAM,CAAC,MAAM,CAAC,CAAA,EAAG,EAAgB,CAAC,EAAE,EAAQ,YAAY,EAAI,GAAA,CAAI,EACtH,EAAQ,KAAD,QAAiB,CAAG,SAAW,GAAA,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAQ,YAAY,EAAI,GAAA,CAAI,CAC1F,KAAO,CACN,IAAM,EAAkB,MAAM,OAAO,CAAC,EAAQ,QAAQ,EAAI,EAAQ,QAAQ,CAAC,EAAE,CAAG,EAAQ,QAAQ,CAChG,EAAK,GAAG,CAAC,YAAa,GAClB,EAAQ,YAAY,EAAE,EAAK,GAAG,CAAC,gBAAiB,EAAQ,YAAY,CACzE,CACA,GAAI,EAAU,GAAwB,UAApB,OAAO,EAAuB,EAAK,MAAM,CAAC,WAAY,QACnE,IAAK,IAAM,KAAa,EAAU,EAAK,MAAM,CAAC,WAAY,GAC/D,GAAI,EAAa,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GAAc,EAAK,GAAG,CAAC,EAAK,GACvF,MAAO,MACN,UACA,CACD,CACD,EAE2D,cACzD,EACA,UACA,6BACA,CACD,GACM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,EAAe,CACxD,OAAQ,OACR,eACA,CACD,GACA,GAAI,EAAO,MAAM,EACjB,IAAM,EAAS,CACd,YAAa,EAAK,YAAY,CAC9B,aAAc,EAAK,aAAa,CAChC,UAAW,EAAK,UAAU,CAC1B,OAAQ,EAAK,KAAK,EAAE,MAAM,KAC1B,QAAS,EAAK,QAAQ,AACvB,EAKA,OAJI,EAAK,UAAU,EAAE,CAEpB,EAAO,oBAAoB,CAAG,IAAI,KADN,AACW,IADP,OACW,OAAO,GAAuB,IAAlB,EAAK,UAAU,CAAG,EAEnE,CACR,CAiCA,eAAe,GAA0B,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,SAAE,CAAO,eAAE,CAAa,gBAAE,CAAc,CAAE,UAAQ,SAAE,CAAO,kBAAE,EAAmB,CAAC,CAAC,UAAE,CAAQ,CAAE,EACvK,GAAM,MAAE,CAAI,CAAE,QAAS,CAAc,CAAE,CAAG,AA9B3C,SAAwC,AAA/B,MAAiC,CAAI,cAAE,CAAY,aAAE,CAAW,SAAE,CAAO,gBAAE,CAAc,UAAE,CAAQ,SAAE,CAAO,CAAE,mBAAmB,CAAC,CAAC,UAAE,CAAQ,CAAE,EACvJ,IAAM,EAAO,IAAI,gBACX,EAAiB,CACtB,eAAgB,oCAChB,OAAQ,mBACR,GAAG,CAAO,AACX,EAOA,GANA,EAAK,GAAG,CAAC,aAAc,sBACvB,EAAK,GAAG,CAAC,OAAQ,GACjB,GAAgB,EAAK,GAAG,CAAC,gBAAiB,GAC1C,EAAQ,SAAS,EAAI,EAAK,GAAG,CAAC,aAAc,EAAQ,SAAS,EAC7D,GAAY,EAAK,GAAG,CAAC,YAAa,GAClC,EAAK,GAAG,CAAC,eAAgB,EAAQ,WAAW,EAAI,GAC5C,EAAU,GAAwB,UAApB,OAAO,EAAuB,EAAK,MAAM,CAAC,WAAY,QACnE,IAAK,IAAM,KAAa,EAAU,EAAK,MAAM,CAAC,WAAY,GAC/D,GAAuB,UAAnB,EAA4B,CAC/B,IAAM,EAAkB,MAAM,OAAO,CAAC,EAAQ,QAAQ,EAAI,EAAQ,QAAQ,CAAC,EAAE,CAAG,EAAQ,QAAQ,CAChG,EAAe,YAAD,CAAiB,CAAG,CAAC,MAAM,EAAE,GAAA,MAAM,CAAC,MAAM,CAAC,CAAA,EAAG,EAAgB,CAAC,EAAE,EAAQ,YAAY,EAAI,GAAA,CAAI,EAAA,CAAG,AAC/G,KAAO,CACN,IAAM,EAAkB,MAAM,OAAO,CAAC,EAAQ,QAAQ,EAAI,EAAQ,QAAQ,CAAC,EAAE,CAAG,EAAQ,QAAQ,CAChG,EAAK,GAAG,CAAC,YAAa,GAClB,EAAQ,YAAY,EAAE,EAAK,GAAG,CAAC,gBAAiB,EAAQ,YAAY,CACzE,CACA,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GAAuB,AAAC,EAAK,GAAG,CAAC,IAAM,EAAK,GAAzB,GAA+B,CAAC,EAAK,GAClG,MAAO,MACN,EACA,QAAS,CACV,CACD,EAE0E,MACxE,eACA,cACA,UACA,iBACA,WACA,UACA,mBACA,WACA,CACD,GACM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,EAAe,CACxD,OAAQ,OACR,OACA,QAAS,CACV,GACA,GAAI,EAAO,MAAM,EACjB,OAAO,GAAgB,EACxB,Cd1NA,IAAA,GAAA,EAAA,CAAA,CAAA,apBFA,GAAA,EAAA,CAAA,CAAA,OUAA,GAAA,EAAA,CAAA,CAAA,OAEA,GAAA,EAAA,CAAA,CAAA,OAsBA,SAAS,GAAU,CAAG,EAClB,MAAO,CAAA,EAAA,GAAA,QAAA,AAAQ,EAAC,EACpB,CACA,MAAM,IACF,CAAA,AAAK,AAAC,EACN,CAAA,AAAO,CAAG,IAAI,OAAU,AACxB,aAAY,CAAI,CAAE,CACd,GAAI,CAbZ,AAaa,SAbO,AAAX,CAAe,EACpB,OAAQ,GACY,UAAhB,OAAO,GACP,MAAM,OAAO,CAAC,EAAK,IAAI,GACvB,EAAK,IAAI,CAAC,KAAK,CAAC,GACxB,EAQwB,GACZ,IADmB,EACb,IAAI,GAAA,WAAW,CAAC,8BAE1B,IAAI,EAAC,CAAA,AAAK,CAAG,gBAAgB,EACjC,CACA,MAAO,CACH,OAAO,IAAI,EAAC,CAAA,AAAK,AACrB,CACA,MAAM,OAAO,CAAe,CAAE,CAAK,CAAE,CACjC,GAAM,KAAE,CAAG,KAAE,CAAG,CAAE,CAAG,CAAE,GAAG,CAAe,CAAE,GAAG,GAAO,MAAM,AAAC,EACtD,EAAM,AAtCpB,SAAS,AAAc,CAAG,EACtB,OAAuB,UAAf,OAAO,GAAoB,EAAI,KAAK,CAAC,EAAG,IAC5C,IAAK,KACL,IAAK,KACD,MAAO,KACX,KAAK,KACD,MAAO,IACX,KAAK,KACD,MAAO,KACX,KAAK,KACD,MAAO,KACX,SACI,MAAM,IAAI,GAAA,gBAAgB,CAAC,iDACnC,CACJ,EAwBkC,GACpB,EAAa,IAAI,EAAC,CAAA,AAAK,CAAC,IAAI,CAAC,MAAM,CAAC,AAAC,IACvC,IAAI,EAAY,IAAQ,EAAI,GAAG,CAa/B,GAZI,GAA4B,UAAU,AAAzB,OAAO,IACpB,EAAY,IAAQ,EAAI,GAAG,AAAH,EAExB,IAAiC,SAApB,CAAC,OAAO,EAAI,GAAG,EAAyB,QAAR,CAAQ,CAAK,GAAG,AAC7D,EAAY,IAAQ,EAAI,GAAA,AAAG,EAE3B,GAAgC,UAAnB,AAA6B,OAAtB,EAAI,GAAG,GAC3B,EAAwB,AAAZ,UAAI,GAAQ,AAAL,EAEnB,GAAa,MAAM,OAAO,CAAC,EAAI,OAAO,GAAG,CACzC,EAAY,EAAI,OAAO,CAAC,QAAQ,CAAC,SAAA,EAEjC,EACA,OAAQ,EADG,CAEP,IAAK,QACD,EAAY,AAAY,YAAR,GAAG,CACnB,KACJ,KAAK,QACD,EAAwB,UAAZ,EAAI,GAAG,CACnB,KACJ,KAAK,QACD,EAAwB,UAAZ,EAAI,GAAG,CACnB,KACJ,KAAK,UACL,IAAK,QACD,EAAwB,YAAZ,EAAI,GAExB,AAF2B,CAI/B,OAAO,CACX,GACM,CAAE,EAAG,CAAG,QAAE,CAAM,CAAE,CAAG,EAC3B,GAAe,GAAG,CAAd,EACA,MAAM,IAAI,GAAA,iBAAiB,CAE/B,GAAe,IAAX,EAAc,CACd,IAAM,EAAQ,IAAI,GAAA,wBAAwB,CACpC,EAAU,IAAI,CAAC,CAAA,CASrB,AAT4B,OAC5B,CAAK,CAAC,OAAO,aAAa,CAAC,CAAG,kBAC1B,IAAK,IAAM,KAAO,EACd,GAAI,CACA,KAFsB,CAEhB,MAAM,GAAmB,EAAS,EAAK,EACjD,CACA,KAAM,CAAE,CAEhB,EACM,CACV,CACA,OAAO,GAAmB,IAAI,EAAC,CAAA,AAAO,CAAE,EAAK,EACjD,CACJ,CACA,eAAe,GAAmB,CAAK,CAAE,CAAG,CAAE,CAAG,EAC7C,IAAM,EAAS,EAAM,GAAG,CAAC,IAAQ,EAAM,GAAG,CAAC,EAAK,CAAC,GAAG,GAAG,CAAC,GACxD,QAAoB,IAAhB,CAAM,CAAC,EAAI,CAAgB,CAC3B,IAAM,EAAM,MAAM,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,CAAE,GAAG,CAAG,CAAE,KAAK,CAAK,EAAG,GACnD,GAAI,aAAe,YAA2B,UAAU,CAAvB,EAAI,IAAI,CACrC,MAAM,IAAI,GAAA,WAAW,CAAC,gDAE1B,CAAM,CAAC,EAAI,CAAG,CAClB,CACA,OAAO,CAAM,CAAC,EAAI,AACtB,CACO,SAAS,GAAkB,CAAI,EAClC,IAAM,EAAM,IAAI,GAAY,GACtB,EAAc,MAAO,EAAiB,IAAU,EAAI,MAAM,CAAC,EAAiB,GASlF,OARA,OAAO,gBAAgB,CAAC,EAAa,CACjC,KAAM,CACF,MAAO,IAAM,gBAAgB,EAAI,IAAI,IACrC,WAAY,GACZ,cAAc,EACd,UAAU,CACd,CACJ,GACO,CACX,CV7GyB,aAArB,EAAoC,KAA7B,WAA8B,UAAU,SAAS,EAAE,aAAa,iBAAiB,CAGxF,EAAa,GAAG,KAAK,CAAC,EAAE,EAAA,CAAS,CAE9B,IAAM,GAAc,SAC3B,eAAe,GAAU,CAAG,CAAE,CAAO,CAAE,CAAM,CAAE,EAAY,KAAK,EAC5D,IAAM,EAAW,MAAM,EAAU,EAAK,CAClC,OAAQ,aACR,EACA,SAAU,SACV,SACJ,GAAG,KAAK,CAAC,AAAC,IACN,GAAiB,gBAAgB,CAA7B,EAAI,IAAI,CACR,MAAM,IAAI,GAAA,WAAW,AAEzB,OAAM,CACV,GACA,GAAwB,KAAK,CAAzB,EAAS,MAAM,CACf,MAAM,IAAI,GAAA,SAAS,CAAC,2DAExB,GAAI,CACA,OAAO,MAAM,EAAS,IAAI,EAC9B,CACA,KAAM,CACF,MAAM,IAAI,GAAA,SAAS,CAAC,6DACxB,CACJ,CACO,IAAM,GAAY,QAgBzB,OAAM,IACF,CAAK,AAAL,AAAI,EACJ,CAAiB,AAAjB,AAAgB,EAChB,CAAA,AAAiB,AAAC,EAClB,CAAA,AAAY,AAAC,EACb,CAAe,AAAf,AAAc,EACd,CAAA,AAAa,AAAC,EACd,CAAA,AAAQ,AAAC,EACT,CAAA,AAAY,AAAC,EACb,CAAA,AAAM,AAAC,EACP,CACA,AADM,AAAC,AAAP,aACY,CAAG,CAAE,CAAO,CAAE,CACtB,GAAI,CAAC,CAAC,aAAe,GAAA,CAAG,CACpB,EADuB,IACjB,AAAI,UAAU,kCAExB,IAAI,CAAC,CAAA,CAAI,CAAG,IAAI,IAAI,EAAI,IAAI,EAC5B,IAAI,EAAC,CAAA,AAAgB,CACmB,UAApC,OAAO,GAAS,gBAA+B,GAAS,gBAAkB,IAC9E,IAAI,EAAC,CAAA,AAAiB,CACmB,UAArC,OAAO,GAAS,iBAAgC,GAAS,iBAAmB,IAChF,IAAI,EAAC,CAAA,AAAY,CAAG,AAAgC,iBAAzB,GAAS,YAA2B,GAAS,YAAc,IACtF,IAAI,EAAC,CAAA,AAAQ,CAAG,IAAI,QAAQ,GAAS,SACjC,GAAc,CAAC,IAAI,EAAC,CAAQ,AAAR,CAAS,GAAG,CAAC,eAAe,AAChD,IAAI,EAAC,CAAA,AAAQ,CAAC,GAAG,CAAC,aAAc,GAE/B,IAAI,EAAC,CAAA,AAAQ,CAAC,GAAG,CAAC,WAAW,CAC9B,IAAI,EAAC,CAAA,AAAQ,CAAC,GAAG,CAAC,SAAU,oBAC5B,IAAI,EAAC,CAAA,AAAQ,CAAC,MAAM,CAAC,SAAU,6BAEnC,IAAI,CAAC,CAAA,CAAY,CAAG,GAAS,CAAC,GAAY,CACtC,GAAS,CAAC,GAAU,QAAK,IACzB,IAAI,EAAC,CAD+B,AAC/B,AAAM,CAAG,GAAS,CAAC,GAAU,CAC9B,AA/ChB,SAAS,AAAiB,CAAK,CAAE,CAAW,UACnB,UAAjB,OAAO,GAAgC,MAAM,CAAhB,GAG7B,CAAC,CAAC,QAAS,CAAA,CAAK,EAA0B,UAArB,OAAO,EAAM,GAAG,EAAiB,KAAK,GAAG,GAAK,EAAM,GAAG,EAAI,IAGhF,AAAE,CAAD,QAAW,AAHiF,IAI7F,CADiB,AAChB,CAAA,EAAA,GAAA,QAAA,AAAQ,EAAC,EAAM,IAAI,IACpB,CAAC,MAAM,OAAO,CAAC,EAAM,IAAI,CAAC,IAAI,IAC9B,CAAC,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAM,IAAI,CAAC,IAAI,CAAE,GAAA,QAAQ,CAI7D,EAJgE,AAqC/B,GAAS,CAAC,GAAU,CAAE,IAAI,EAAC,CAAA,AAAY,GAAG,CAC3D,IAAI,CAAC,CAAA,CAAc,CAAG,IAAI,EAAC,CAAA,AAAM,CAAC,GAAG,CACrC,IAAI,EAAC,CAAA,AAAM,CAAG,GAAkB,IAAI,EAAC,CAAA,AAAM,CAAC,IAAI,GAG5D,CACA,cAAe,CACX,MAAO,CAAC,CAAC,IAAI,EAAC,CAAA,AAAa,AAC/B,CACA,aAAc,CACV,MAAsC,UAA/B,OAAO,IAAI,EAAC,CAAc,AAAd,EACb,KAAK,GAAG,GAAK,IAAI,CAAC,CAAA,CAAc,CAAG,IAAI,CAAC,CAAA,CAElD,AAFmE,CAGnE,EAFU,KAEF,CACJ,MAAsC,UAA/B,OAAO,IAAI,EAAC,CAAA,AAAc,EAC3B,KAAK,GAAG,GAAK,IAAI,EAAC,CAAA,AAAc,CAAG,IAAI,EAAC,CAAA,AAAY,AAE9D,CACA,EAFU,IAEH,CACH,OAAO,IAAI,EAAC,CAAA,AAAM,EAAE,MACxB,CACA,MAAM,OAAO,CAAe,CAAE,CAAK,CAAE,CAC5B,AAAD,IAAK,EAAC,CAAA,AAAM,EAAK,EAAD,EAAK,CAAC,KAAK,IAAI,AAC/B,MAAM,IAAI,CAAC,MAAM,GAErB,GAAI,CACA,OAAO,MAAM,IAAI,CAAC,CAAA,CAAM,CAAC,EAAiB,EAC9C,CACA,MAAO,EAAK,CACR,GAAI,aAAe,GAAA,iBAAiB,EAAE,AACP,KAAvB,EAA8B,EAA1B,CAAC,WAAW,GAEhB,OADA,MAAM,IAAI,CAAC,MAAM,GACV,IAAI,EAAC,CAAA,AAAM,CAAC,EAAiB,EAG5C,OAAM,CACV,CACJ,CACA,MAAM,QAAS,CACP,IAAI,EAAC,CAAA,AAAa,GAzHO,AAAzB,CAyHsB,mBAzHf,IAyHsC,WAxH3B,aAArB,OAAO,WAA6B,AAAwB,iCAAd,SAAS,EAChC,aAAvB,OAAO,aAA+C,WAAhB,WAAgB,IAwHnD,IAAI,CAAC,CAAA,CAAa,MAAG,CAAA,EAEzB,IAAI,EAAC,CAAA,AAAa,GAAK,GAAU,IAAI,EAAC,CAAA,AAAI,CAAC,IAAI,CAAE,IAAI,EAAC,CAAA,AAAQ,CAAE,YAAY,OAAO,CAAC,IAAI,EAAC,CAAA,AAAgB,EAAG,IAAI,EAAC,CAAA,AAAY,EACxH,IAAI,CAAC,AAAC,IACP,IAAI,EAAC,CAAA,AAAM,CAAG,GAAkB,GAC5B,IAAI,EAAC,CAAA,AAAM,EAAE,CACb,IAAI,EAAC,CAAA,AAAM,CAAC,GAAG,CAAG,KAAK,GAAG,GAC1B,IAAI,EAAC,CAAA,AAAM,CAAC,IAAI,CAAG,GAEvB,IAAI,EAAC,CAAc,AAAd,CAAiB,KAAK,GAAG,GAC9B,IAAI,EAAC,CAAA,AAAa,MAAG,CACzB,GACK,KAAK,CAAC,AAAC,IAER,MADA,IAAI,EAAC,CAAa,AAAb,MAAgB,EACf,CACV,GACA,MAAM,IAAI,EAAC,CAAA,AAAa,AAC5B,CACJ,CWhJA,IAAA,GAAA,EAAA,CAAA,CAAA,OACA,GAAA,EAAA,CAAA,CAAA,OAGO,SAAS,GAAU,CAAG,MAUrB,EAOA,EAhBJ,GAAI,AAAe,iBAAR,EACP,MAAM,IAAI,GAAA,UAAU,CAAC,iEACzB,GAAM,CAAE,EAAG,CAAO,QAAE,CAAM,CAAE,CAAG,EAAI,KAAK,CAAC,KACzC,GAAe,IAAX,EACA,MAAM,IAAI,GAAA,UAAU,CAAC,4DACzB,GAAe,IAAX,EACA,MAAM,IAAI,GAAA,UAAU,CAAC,eACzB,GAAI,CAAC,EACD,MAAM,IAAI,GAAA,UAAU,CAAC,+BAEzB,GAAI,CACA,EAAU,CAAA,EAAA,GAAA,MAAA,AAAI,EAAC,EACnB,CACA,KAAM,CACF,MAAM,IAAI,GAAA,UAAU,CAAC,yCACzB,CAEA,GAAI,CACA,EAAS,KAAK,KAAK,CAAC,GAAA,OAAO,CAAC,MAAM,CAAC,GACvC,CACA,KAAM,CACF,MAAM,IAAI,GAAA,UAAU,CAAC,8CACzB,CACA,GAAI,CAAC,CAAA,EAAA,GAAA,QAAA,AAAQ,EAAC,GACV,MAAM,IAAI,GAAA,UAAU,CAAC,0BACzB,OAAO,CACX,CqB5BO,SAAS,GAAsB,CAAK,EACvC,IAAI,EACJ,GAAqB,UAAjB,OAAO,EAAoB,CAC3B,IAAM,EAAQ,EAAM,KAAK,CAAC,MACL,IAAjB,EAAM,MAAM,MAAU,EAAM,MAAM,AAAK,GAEvC,AAF0C,EAEzC,EAAc,CAAG,CAAA,CAE1B,MACK,GAAqB,UAAjB,OAAO,GAAsB,EAClC,GAAI,EADqC,YACtB,EACf,EAAgB,EAAM,CADA,QACS,MAG/B,MAAU,AAAJ,UAAc,6CAG5B,GAAI,CACA,GAA6B,UAAzB,OAAO,GAA8B,CAAC,EACtC,MAAM,AAAI,OAD2C,CAGzD,IAAM,EAAS,KAAK,KAAK,CAAC,GAAA,OAAO,CAAC,MAAM,CAAC,CAAA,EAAA,GAAA,MAAI,AAAJ,EAAK,KAC9C,GAAI,CAAC,CAAA,EAAA,GAAA,QAAA,AAAQ,EAAC,GACV,MADmB,AACb,AAAI,QAEd,OAAO,CACX,CACA,KAAM,CACF,MAAM,AAAI,UAAU,+CACxB,CACJ,CZ6DA,IAAM,GAAoB,MAAO,IAChC,GAAM,MAAE,CAAI,CAAE,CAAG,MAAM,GAAY,CAAC,mCAAmC,CAAC,EACxE,GAAI,CAAC,GAAM,KAAM,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,gBAAiB,GAC/E,IAAM,EAAM,EAAK,IAAI,CAAC,IAAI,CAAC,AAAC,GAAQ,EAAI,GAAG,GAAK,GAChD,GAAI,CAAC,EAAK,MAAM,AAAI,MAAM,CAAC,aAAa,EAAE,EAAI,UAAU,CAAC,EACzD,OAAO,MAAM,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,EAAK,EAAI,GAAG,CACpC,EA8MM,GAAsB,MAAO,EAAK,EAAQ,KAC/C,IAAM,EAAmB,CAAC,oBAAoB,EAAE,EAAO,eAAe,EAAE,EAAW,sBAAsB,CAAC,CAC1G,GAAI,CACH,GAAM,MAAE,CAAI,CAAE,CAAG,MAAM,GAAY,GACnC,GAAI,CAAC,GAAM,KAAM,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,gBAAiB,GAC/E,IAAM,EAAM,EAAK,IAAI,CAAC,IAAI,CAAC,AAAC,GAAQ,EAAI,GAAG,GAAK,GAChD,GAAI,CAAC,EAAK,MAAM,AAAI,MAAM,CAAC,aAAa,EAAE,EAAI,UAAU,CAAC,EACzD,OAAO,MAAM,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,EAAK,EAAI,GAAG,CACpC,CAAE,MAAO,EAAO,CAEf,MADA,GAAA,CAAM,CAAC,KAAK,CAAC,sCAAuC,GAC9C,CACP,CACD,EAqYM,GAAqB,CAAC,EAAQ,EAAE,GAC9B,EAAM,KAAK,CAAC,OAAO,GAAG,CAAC,AAAC,GAAQ,EAAI,OAAO,CAAC,UAAW,MAAM,IAAI,CAAC,OAwyDpE,GAAkB,CACvB,MAl+Ea,AAAC,IAEP,CACN,GAAI,QACJ,KAAM,QACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EAC1D,IAAM,EAAS,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,QAAS,OAAO,CAGnE,OAFI,EAAQ,KAAK,EAAE,EAAO,IAAI,IAAI,EAAQ,KAAK,EAC3C,GAAQ,EAAO,IAAI,IAAI,GACpB,MAAM,GAAuB,CACnC,GAAI,gBACJ,EACA,sBAAuB,2CACvB,OAAQ,QACR,cACA,EACA,aAAc,YACd,aAAc,eACf,EACD,EACA,0BAA2B,MAAO,CAAE,MAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAzBmB,sCA0BpB,GAED,MAAM,cAAc,CAAK,CAAE,CAAK,EAC/B,GAAI,EAAQ,oBAAoB,CAAE,OAAO,EACzC,GAAI,EAAQ,aAAa,CAAE,OAAO,EAAQ,aAAa,CAAC,EAAO,GAC/D,GAAM,KAAE,CAAG,CAAE,IAAK,CAAM,CAAE,CAAG,GAAsB,GACnD,GAAI,CAAC,GAAO,CAAC,EAAQ,MAAO,GAC5B,GAAM,CAAE,QAAS,CAAS,CAAE,CAAG,MAAM,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,EAAO,MAAM,GAAkB,GAAM,CACnF,WAAY,CAAC,EAAO,CACpB,OAAQ,4BACR,SAAU,EAAQ,QAAQ,EAAI,EAAQ,QAAQ,CAAC,MAAM,CAAG,EAAQ,QAAQ,CAAG,EAAQ,mBAAmB,CAAG,EAAQ,mBAAmB,CAAG,EAAQ,QAAQ,CACvJ,YAAa,IACd,SACA,AAGA,CAHC,iBAAkB,mBAAmB,CAAC,OAAO,CAAC,AAAC,IACtB,KAAK,IAA1B,CAAS,CAAC,EAAM,GAAa,CAAS,CAAC,EAAM,CAAG,EAAQ,CAAS,CAAC,EAAM,CAC7E,KACI,GAAS,EAAU,KAAK,GAAK,CAAA,GAAO,AACjC,CAAC,CAAC,CACV,EACA,EAHgD,iBAG5B,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YACvB,AADmC,EAEnC,cAAe,sCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAM,OAAO,CAAE,OAAO,KAC3B,IAAM,EAAU,GAAU,EAAM,OAAO,EACvC,GAAI,CAAC,EAAS,OAAO,KACrB,IAAM,EAAO,EAAM,IAAI,CAAG,CAAA,EAAG,EAAM,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,EAAM,IAAI,CAAC,IAAI,EAAE,SAAA,CAAU,CAAG,EAAQ,IAAI,EAAI,EAAQ,KAAK,CAChH,EAAkD,WAAlC,OAAO,EAAQ,cAAc,CAAiB,EAAQ,cAAc,CAA8B,SAA3B,EAAQ,cAAc,CAC7G,EAAkB,CACvB,GAAG,CAAO,MACV,CACD,EACM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAgB,IAAI,eAC1B,EACA,MAAO,EAAQ,KAAK,CACpB,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAk5EA,UAt4EkB,AAAD,IACV,CACN,GAAI,YACJ,KAAM,YACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EACxE,GAAI,CAAC,EAAQ,QAAQ,EAAI,CAAC,EAAQ,YAAY,CAE7C,CAF+C,KAC/C,GAAA,CAAM,CAAC,KAAK,CAAC,mDACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,GAAI,CAAC,EAAc,MAAM,IAAI,GAAA,CAAe,CAAC,0CAC7C,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,iBAAkB,iBAAiB,CAGvF,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,oBACJ,EACA,sBAAuB,uCACvB,OAAQ,QACR,eACA,cACA,EACA,iBAAkB,CAAE,SAAU,mBAAoB,EAClD,OAAQ,EAAQ,MAAM,AACvB,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAAe,wCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,wCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAM,WAAW,CAAE,OAAO,KAC/B,GAAI,CACH,GAAM,CAAE,KAAM,CAAO,CAAE,CAAG,MAAM,GAAY,+BAAgC,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAG,AAAD,CAAG,GACxI,GAAI,CAAC,EAAS,OAAO,KACrB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,UAAU,CACtB,KAAM,EAAQ,IAAI,CAClB,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CACtB,eAAe,EACf,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,CAAE,MAAO,EAAO,CAEf,OADA,GAAA,CAAM,CAAC,KAAK,CAAC,wCAAyC,GAC/C,IACR,CACD,UACA,EACD,EAm0EA,QA9zEgB,AAAD,IACf,GAAI,CAAC,EAAQ,MAAM,EAAI,CAAC,EAAQ,MAAM,EAAI,CAAC,EAAQ,UAAU,CAE5D,CAF8D,KAC9D,GAAA,CAAM,CAAC,KAAK,CAAC,4GACP,IAAI,GAAA,CAAe,CAAC,8BAE3B,IAAM,EAAc,EAAQ,MAAM,CAAC,OAAO,CAAC,eAAgB,IACrD,EAAwB,CAAC,QAAQ,EAAE,EAAY,iBAAiB,CAAC,CACjE,EAAgB,CAAC,QAAQ,EAAE,EAAY,aAAa,CAAC,CACrD,EAAmB,CAAC,QAAQ,EAAE,EAAY,gBAAgB,CAAC,CACjE,MAAO,CACN,GAAI,UACJ,KAAM,UACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,CAAE,aAAW,CAAE,EACxE,GAAI,CAAC,EAAQ,QAAQ,CAEpB,CAFsB,KACtB,GAAA,CAAM,CAAC,KAAK,CAAC,sFACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,GAAI,EAAQ,mBAAmB,EAAI,CAAC,EAAQ,YAAY,CAEvD,CAFyD,KACzD,GAAA,CAAM,CAAC,KAAK,CAAC,uGACP,IAAI,GAAA,CAAe,CAAC,0BAE3B,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,UACA,QACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,UACJ,QAAS,CAAE,GAAG,CAAO,AAAC,EACtB,wBACA,OAAQ,QACR,eACA,cACA,EACA,OAAQ,EAAQ,MAAM,AACvB,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,gBACA,CACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,cAAc,CAAK,CAAE,CAAK,EAC/B,GAAI,EAAQ,oBAAoB,CAAE,OAAO,EACzC,GAAI,EAAQ,aAAa,CAAE,OAAO,EAAQ,aAAa,CAAC,EAAO,GAC/D,GAAI,CACH,GAAM,KAAE,CAAG,CAAE,IAAK,CAAM,CAAE,CAAG,GAAsB,GACnD,GAAI,CAAC,GAAO,CAAC,EAAQ,OAAO,EAC5B,IAAM,EAAY,MAAM,GAAoB,EAAK,EAAQ,MAAM,CAAE,EAAQ,UAAU,EAC7E,EAAiB,CAAC,oBAAoB,EAAE,EAAQ,MAAM,CAAC,eAAe,EAAE,EAAQ,UAAU,CAAA,CAAE,CAC5F,CAAE,QAAS,CAAS,CAAE,CAAG,MAAM,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,EAAO,EAAW,CAChE,WAAY,CAAC,EAAO,CACpB,OAAQ,EACR,SAAU,EAAQ,QAAQ,CAC1B,YAAa,IACd,GACA,GAAI,GAAS,EAAU,KAAK,GAAK,EAAO,OAAO,EAC/C,OAAO,CACR,CAAE,MAAO,EAAO,CAEf,OADA,GAAA,CAAM,CAAC,KAAK,CAAC,6BAA8B,IACpC,CACR,CACD,EACA,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,EAAM,OAAO,CAAE,GAAI,CACtB,IAAM,EAAU,GAAU,EAAM,OAAO,EACvC,GAAI,CAAC,EAAS,OAAO,KACrB,IAAM,EAAO,EAAQ,IAAI,EAAI,EAAQ,UAAU,EAAI,EAAQ,QAAQ,EAAI,EAAQ,KAAK,CAC9E,EAAkB,CACvB,GAAG,CAAO,MACV,CACD,EACM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAgB,IAAI,CAC1B,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CACtB,cAAe,EAAQ,cAAc,CACrC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,CAAE,MAAO,EAAO,CACf,GAAA,CAAM,CAAC,KAAK,CAAC,6BAA8B,EAC5C,CACA,GAAI,EAAM,WAAW,CAAE,GAAI,CAC1B,GAAM,CAAE,KAAM,CAAQ,CAAE,CAAG,MAAM,GAAY,EAAkB,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GAC3H,GAAI,EAAU,CACb,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAS,GAAG,CAChB,KAAM,EAAS,IAAI,EAAI,EAAS,UAAU,EAAI,EAAS,QAAQ,CAC/D,MAAO,EAAS,KAAK,CACrB,MAAO,EAAS,OAAO,CACvB,cAAe,EAAS,cAAc,CACtC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,CACD,CAAE,MAAO,EAAO,CACf,GAAA,CAAM,CAAC,KAAK,CAAC,0CAA2C,EACzD,CACA,OAAO,IACR,UACA,CACD,CACD,EA+rEC,QA9qEe,AAAC,GACT,EACN,GAAI,UACJ,KAAM,UACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,WAAY,QAAQ,CACpE,GAAQ,EAAQ,IAAI,IAAI,GACxB,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAChD,IAAM,EAAmB,EAAQ,QAAQ,CAAC,QAAkC,KAAK,IAA7B,EAAQ,WAAW,CAAc,CAAC,aAAa,EAAE,EAAQ,WAAW,CAAA,CAAE,CAAG,GAC7H,OAAO,IAAI,IAAI,CAAC,+CAA+C,EAAE,EAAQ,IAAI,CAAC,KAAK,8BAA8B,EAAE,EAAQ,QAAQ,CAAC,cAAc,EAAE,mBAAmB,EAAQ,WAAW,EAAI,GAAa,OAAO,EAAE,EAAM,QAAQ,EAAE,EAAQ,MAAM,EAAI,OAAA,EAAS,EAAA,CAAkB,CAClR,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,cACA,UACA,EACA,cAAe,sCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,CACzB,eACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,sCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,oCAAqC,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GACpJ,GAAI,EAAO,OAAO,KAClB,GAAuB,OAAnB,EAAQ,MAAM,CAAW,EAAQ,SAAS,CAAG,CAAC,yCAAyC,EAA4B,MAA1B,EAAQ,aAAa,CAAW,OAAO,OAAO,EAAQ,EAAE,GAAK,OAAO,KAAO,EAAI,SAAS,EAAQ,aAAa,EAAI,EAAE,IAAI,CAAC,KAChN,CACJ,IAAM,EAAS,EAAQ,MAAM,CAAC,UAAU,CAAC,MAAQ,MAAQ,MACzD,EAAQ,SAAS,CAAG,CAAC,mCAAmC,EAAE,EAAQ,EAAE,CAAC,CAAC,EAAE,EAAQ,MAAM,CAAC,CAAC,EAAE,EAAA,CAAQ,AACnG,CACA,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,WAAW,EAAI,EAAQ,QAAQ,EAAI,GACjD,MAAO,EAAQ,KAAK,CACpB,cAAe,EAAQ,QAAQ,CAC/B,MAAO,EAAQ,SAAS,CACxB,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,CACD,GA0nEA,SAjjEiB,AAAD,IACT,CACN,GAAI,WACJ,KAAM,WACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,aAAE,CAAW,WAAE,CAAS,CAAE,EACrE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,QAAS,iBAAiB,CAG9E,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,mBACJ,EACA,sBAAuB,8CACvB,OAAQ,QACR,cACA,YACA,EACA,iBAAkB,EAAQ,QAAQ,CAAG,CAAE,UAAW,EAAQ,QAAQ,AAAC,EAAI,CAAC,CACzE,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,CAChC,mBACA,UACA,EACA,cAAe,+CAChB,GAED,MAAM,cAAc,CAAK,CAAE,CAAK,EAC/B,GAAI,EAAQ,oBAAoB,CAAE,OAAO,EACzC,GAAI,EAAQ,aAAa,CAAE,OAAO,EAAQ,aAAa,CAAC,EAAO,GAC/D,GAAI,AAA4B,MAAtB,KAAK,CAAC,KAAK,MAAM,CAAQ,GAAI,eAChC,CAAE,QAAS,CAAS,CAAE,CAAG,MAAM,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,GpB9UhB,EoB8U0C,CpB9UvC,CoB8UoB,EAAuB,IAAI,+DpB7U3E,EAAM,IAAI,GAAa,KAAK,EADE,GAE9B,EAAe,EAFsB,IAEf,EAAiB,IAAU,EAAI,MAAM,CAAC,EAAiB,GACnF,OAAO,gBAAgB,CAAC,EAAc,CAClC,YAAa,CACT,IAAK,IAAM,EAAI,WAAW,GAC1B,WAAY,GACZ,aAAc,EAClB,EACA,MAAO,CACH,IAAK,IAAM,EAAI,KAAK,GACpB,YAAY,EACZ,cAAc,CAClB,EACA,OAAQ,CACJ,MAAO,IAAM,EAAI,MAAM,GACvB,YAAY,EACZ,cAAc,EACd,UAAU,CACd,EACA,UAAW,CACP,IAAK,IAAM,EAAI,YAAY,GAC3B,YAAY,EACZ,cAAc,CAClB,EACA,KAAM,CACF,MAAO,IAAM,EAAI,IAAI,GACrB,WAAY,GACZ,cAAc,EACd,UAAU,CACd,CACJ,GACO,GoB8S2I,CACjJ,WAAY,CAAC,QAAQ,CACrB,SAAU,EAAQ,QAAQ,CAC1B,OAAQ,0BACT,GACA,GAAI,GAAS,EAAU,KAAK,GAAK,EAAO,OAAO,EAC/C,MAAO,CAAC,CAAC,CACV,CAAE,MAAO,EAAO,CACf,OAAO,CACR,CACA,OAAO,CACR,EACA,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,qDAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,EAAM,OAAO,EAAwC,AAApC,MAAM,OAAO,CAAC,KAAK,CAAC,KAAK,MAAM,CAAQ,CAC3D,IAAM,EAAY,GAAU,EAAM,OAAO,EACnC,EAAO,CACZ,GAAI,EAAU,GAAG,CACjB,KAAM,EAAU,IAAI,CACpB,MAAO,EAAU,KAAK,CACtB,QAAS,CAAE,KAAM,CAChB,IAAK,EAAU,OAAO,CACtB,OAAQ,IACR,MAAO,IACP,eAAe,CAChB,CAAE,CACH,EACM,EAAY,MAAM,EAAQ,gBAAgB,GAAG,CAClD,GAAG,CAAI,CACP,eAAgB,EACjB,GACA,MAAO,CACN,KAAM,CACL,GAAG,CAAI,CACP,eAAe,EACf,GAAG,CAAS,AACb,EACA,KAAM,CACP,CACD,CACA,GAAM,CAAE,KAAM,CAAO,CAAE,OAAK,CAAE,CAAG,MAAM,GAAY,wCAA0C,CAC5F,KACA,OACA,QACA,aACG,GAAS,QAAU,EAAE,CACxB,CAAC,IAAI,CAAC,KAAM,CAAE,KAAM,CACpB,KAAM,SACN,MAAO,EAAM,WAAW,AACzB,CAAE,GACF,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,IAAI,CAClB,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CAAC,IAAI,CAAC,GAAG,CAC/B,cAAe,EAAQ,cAAc,CACrC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAu8DA,MAl8Da,AAAC,IACP,CACN,GAAI,QACJ,KAAM,QACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EACxE,GAAI,CAAC,EAAQ,QAAQ,EAAI,CAAC,EAAQ,YAAY,CAE7C,CAF+C,KAC/C,GAAA,CAAM,CAAC,KAAK,CAAC,iGACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,GAAI,CAAC,EAAc,MAAM,IAAI,GAAA,CAAe,CAAC,sCAC7C,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,YAAY,CAGhE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,gBACJ,EACA,sBAAuB,8BACvB,OAAQ,QACR,EACA,eACA,aACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,CAChC,oBACA,cACA,UACA,EACA,cAAe,uCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,uCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CACH,GAAM,CAAE,KAAM,CAAO,CAAE,CAAG,MAAM,GAAY,8BAA+B,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GACvI,GAAI,CAAC,EAEJ,OAFa,AACb,GAAA,CAAM,CAAC,KAAK,CAAC,mCACN,KAER,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,MAAM,CACpB,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CACtB,cAAe,CAAC,CAAC,EAAQ,KAAK,CAC9B,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,CAAE,MAAO,EAAO,CAEf,OADA,GAAA,CAAM,CAAC,KAAK,CAAC,wCAAyC,GAC/C,IACR,CACD,UACA,EACD,EA83DA,OAz3Dc,AAAC,IAER,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,CAAE,OAAK,QAAE,CAAM,WAAE,CAAS,cAAE,CAAY,aAAE,CAAW,CAAE,EAC7E,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,YAAa,aAAa,CAG9E,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,iBACJ,EACA,sBAAuB,2CACvB,OAAQ,QACR,eACA,EACA,wBACA,EACA,OAAQ,EAAQ,MAAM,AACvB,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,EACA,eACA,sBACA,EACA,cA1BmB,6CA2BpB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,CACzB,eACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,6CAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,8BAA+B,CAAE,QAAS,CAC5F,aAAc,cACd,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAC7C,CAAE,GACF,GAAI,EAAO,OAAO,KAClB,GAAM,CAAE,KAAM,CAAM,CAAE,CAAG,MAAM,GAAY,qCAAsC,CAAE,QAAS,CAC3F,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,CAC5C,aAAc,aACf,CAAE,EACE,EAAC,EAAQ,KAAK,EAAI,IAAQ,EAAQ,KAAK,EAAI,CAAD,CAAQ,IAAI,CAAC,AAAC,GAAM,EAAE,OAAO,GAAK,CAAM,CAAC,EAAA,AAAE,GAAG,KAAA,EAC5F,IAAM,EAAgB,GAAQ,KAAK,AAAC,GAAM,EAAE,KAAK,GAAK,EAAQ,KAAK,GAAG,WAAY,EAC5E,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,IAAI,EAAI,EAAQ,KAAK,CACnC,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,UAAU,eACzB,EACA,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAszDA,UAztCiB,AAAC,IAClB,IAAM,EAAS,EAAQ,QAAQ,EAAI,SAC7B,EAAY,EAAQ,SAAS,EAAI,oCACjC,EAAwB,CAAA,EAAG,EAAU,CAAC,EAAE,EAAO,sBAAsB,CAAC,CACtE,EAAgB,CAAA,EAAG,EAAU,CAAC,EAAE,EAAO,kBAAkB,CAAC,CAChE,MAAO,CACN,GAAI,YACJ,KAAM,oBACN,uBAAuB,CAAI,EAC1B,IAAM,EAAS,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CACjD,SACA,UACA,QACA,YACA,iBACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAO,IAAI,IAAI,EAAQ,KAAK,EAC3C,EAAK,MAAM,EAAE,EAAO,IAAI,IAAI,EAAK,MAAM,EACpC,GAAuB,CAC7B,GAAI,oBACJ,wBACA,EACA,MAAO,EAAK,KAAK,CACjB,aAAc,EAAK,YAAY,QAC/B,EACA,YAAa,EAAK,WAAW,CAC7B,OAAQ,EAAQ,MAAM,CACtB,UAAW,EAAK,SAAS,AAC1B,EACD,EACA,2BAA0B,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GACrD,GAA0B,MAChC,eACA,cACA,EACA,wBACA,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAM,OAAO,CAAE,OAAO,KAC3B,IAAM,EAAO,GAAU,EAAM,OAAO,EAC9B,EAAmB,EAAQ,gBAAgB,EAAI,EACrD,OAAM,GAAY,CAAC,2CAA2C,EAAE,EAAiB,CAAC,EAAE,EAAiB,OAAO,CAAC,CAAE,CAC9G,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,EACxD,MAAM,WAAW,CAAO,EACvB,IAAI,EAAQ,mBAAmB,EAAK,EAAD,AAAS,QAAQ,CAAC,EAAE,CACvD,CADyD,EACrD,CACH,IAAM,EAAgB,MAAM,EAAQ,QAAQ,CAAC,KAAK,GAAG,WAAW,GAChE,EAAK,OAAO,CAAG,CAAC,wBAAwB,EAAE,GAAA,MAAM,CAAC,MAAM,CAAC,GAAA,CAAgB,AACzE,CAAE,MAAO,EAAG,CACX,GAAA,CAAM,CAAC,KAAK,CAAC,GAAK,AAAa,iBAAN,GAAkB,SAAU,EAAI,EAAE,IAAI,CAAG,GAAI,EACvE,CACD,CACD,GACA,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GAC3C,EAAgB,AAAwB,KAAK,MAAxB,cAAc,CAAc,EAAK,cAAc,IAAG,EAAK,KAAK,GAAK,CAAD,CAAM,sBAAsB,EAAE,SAAS,EAAK,KAAK,GAAK,EAAK,wBAAwB,EAAE,SAAS,EAAK,MAAK,CAAC,EACpM,EADwM,IACjM,CACN,EAF8M,GAExM,CACL,GAAI,EAAK,GAAG,CACZ,KAAM,EAAK,IAAI,CACf,MAAO,EAAK,KAAK,CACjB,MAAO,EAAK,OAAO,eACnB,EACA,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,EACA,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,IACpF,IAAM,EAAS,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CACjD,SACA,UACA,QACA,YACA,iBACA,CAED,OADI,EAAQ,KAAK,EAAE,EAAO,IAAI,IAAI,EAAQ,KAAK,EACxC,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,aAAc,EAAQ,YACvB,AADmC,EAEnC,YAAa,CAAE,MAAO,EAAO,IAAI,CAAC,IAAK,gBACvC,CACD,EACD,UACA,CACD,CACD,EA+nCC,OAvuDe,AAAD,IACP,CACN,GAAI,SACJ,KAAM,SACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,WAAS,CAAE,SAAO,CAAE,EAC5F,GAAI,CAAC,EAAQ,QAAQ,EAAI,CAAC,EAAQ,YAAY,CAE7C,CAF+C,KAC/C,GAAA,CAAM,CAAC,KAAK,CAAC,iGACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,GAAI,CAAC,EAAc,MAAM,IAAI,GAAA,CAAe,CAAC,uCAC7C,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,QACA,UACA,SACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,iBACJ,EACA,sBAAuB,4CACvB,OAAQ,QACR,eACA,cACA,EACA,OAAQ,EAAQ,MAAM,CACtB,WAAY,EAAQ,UAAU,CAC9B,QAAS,GAAW,EAAQ,OAAO,WACnC,EACA,GAAI,EAAQ,EAAE,CACd,iBAAkB,CAAE,uBAAwB,MAAO,CACpD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAAe,qCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YACvB,AADmC,EAEnC,cAAe,4CAChB,GAED,MAAM,cAAc,CAAK,CAAE,CAAK,EAC/B,GAAI,EAAQ,oBAAoB,CAAE,OAAO,EACzC,GAAI,EAAQ,aAAa,CAAE,OAAO,EAAQ,aAAa,CAAC,EAAO,GAC/D,GAAM,CAAE,KAAM,CAAS,CAAE,CAAG,MAAM,GAAY,CAAC,wDAAwD,EAAE,EAAA,CAAO,QAChH,CAAI,CAAC,GACE,EAAU,GAAG,GAAK,AADT,EACiB,KADV,GACkB,GAAuB,CAAnB,+BAAC,EAAU,GAAG,EAAwD,wBAAlB,EAAU,GAAQ,AAAL,CAA0B,AACzI,EACA,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAM,OAAO,CAAE,OAAO,KAC3B,IAAM,EAAO,GAAU,EAAM,OAAO,EAC9B,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAK,GAAG,CACZ,KAAM,EAAK,IAAI,CACf,MAAO,EAAK,KAAK,CACjB,MAAO,EAAK,OAAO,CACnB,cAAe,EAAK,cAAc,CAClC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EA0pDA,YArpDoB,AAAD,IACZ,CACN,GAAI,cACJ,KAAM,eACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EAClE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,UACA,QACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,sBACJ,EACA,sBAAuB,yCACvB,OAAQ,QACR,eACA,cACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAAe,oCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,oCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,CAAE,OAAK,CAAE,CAAG,MAAM,GAAY,wCAAyC,CAC3F,OAAQ,MACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAG,AAAD,CACxD,GACA,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAQ,IAAI,EAAI,EAAQ,kBAAkB,CAChD,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CACtB,cAAe,EAAQ,cAAc,GAAI,EACzC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAulDA,MAzhBa,AAAC,GACP,EACN,GAAI,QACJ,KAAM,QACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,CAAE,aAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,UACA,QACA,CACG,GAAQ,EAAQ,IAAI,IAAI,GACxB,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAChD,IAAM,EAAM,IAAI,IAAI,8CAMpB,OALA,EAAI,YAAY,CAAC,GAAG,CAAC,QAAS,EAAQ,IAAI,CAAC,MAC3C,EAAI,YAAY,CAAC,GAAG,CAAC,gBAAiB,QACtC,EAAI,YAAY,CAAC,GAAG,CAAC,YAAa,EAAQ,QAAQ,EAClD,EAAI,YAAY,CAAC,GAAG,CAAC,eAAgB,EAAQ,WAAW,EAAI,GAC5D,EAAI,YAAY,CAAC,GAAG,CAAC,QAAS,GACvB,CACR,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,CAChC,OACA,sBACA,EACA,cAAe,4CAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YACvB,AADmC,EAEnC,cAAe,4CAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,gDAAiD,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GAChK,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,CAAO,CAAC,4BAA4B,CACxC,KAAM,EAAQ,IAAI,EAAI,GACtB,MAAO,EAAQ,KAAK,CACpB,cAAe,EAAQ,cAAc,CACrC,MAAO,EAAQ,OAAO,EAAI,CAAO,CAAC,mCAAmC,CACrE,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAieA,QA5de,AAAC,IACT,CACN,GAAI,UACJ,KAAM,UACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EAClE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,kBAAkB,CAGtE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,kBACJ,EACA,sBAAuB,yCACvB,OAAQ,QACR,eACA,cACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAAe,wCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,CACzB,eACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,wCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,gCAAiC,CACnF,OAAQ,MACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CACzD,GACA,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,YAAY,CAC1B,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,MAAM,CAAC,EAAE,EAAE,IAC1B,eAAe,EACf,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAkaA,OArWc,AAAC,IACR,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,kBAAmB,SAAS,CAGhF,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,qBACJ,UACA,EACA,sBAAuB,wCACvB,OAAQ,QACR,EACA,OAAQ,EAAQ,MAAM,EAAI,CACzB,QACA,iBACA,qBACA,UACA,AACF,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,cACA,UACA,EACA,cAAe,mCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,mCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,IAAM,EAAU,EAAM,OAAO,CAC7B,GAAI,CAAC,EAEJ,OAFa,AACb,GAAA,CAAM,CAAC,KAAK,CAAC,6BACN,KAER,IAAM,EAAU,GAAU,GACpB,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAQ,kBAAkB,CAChC,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CACtB,cAAe,EAAQ,cAAc,CACrC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAsSA,QAjSe,AAAC,IACT,CACN,GAAI,UACJ,KAAM,UACN,uBAAuB,CAAI,EAC1B,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,aACA,aACA,iBACA,cACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,EAAK,MAAM,EAAE,EAAQ,IAAI,IAAI,EAAK,MAAM,EACrC,GAAuB,CAC7B,GAAI,kBACJ,EACA,sBAAuB,mCACvB,OAAQ,EACR,MAAO,EAAK,KAAK,CACjB,aAAc,EAAK,YAAY,CAC/B,YAAa,EAAK,WAAW,AAC9B,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,EACA,eAAgB,oBAChB,UACA,EACA,cAAe,kCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,eAAgB,QAChB,cAAe,kCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,CAAE,MAAO,CAAY,CAAE,CAAG,MAAM,GAAY,6DAA8D,CAC9H,OAAQ,MACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CACzD,GACA,GAAI,EAAc,OAAO,KACzB,GAAM,CAAE,KAAM,CAAS,CAAE,MAAO,CAAU,CAAE,CAAG,MAAM,GAAY,2DAA4D,CAC5H,OAAQ,MACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CACzD,GACI,GAAgB,CAChB,EAAC,GAAc,GAAW,MAAM,iBAAiB,CACpD,EAAQ,IAAI,CAAC,KAAK,CAAG,EAAU,IAAI,CAAC,eAAe,CACnD,GAAgB,GAEjB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,IAAI,CAAC,EAAE,CACnB,KAAM,EAAQ,IAAI,CAAC,IAAI,CACvB,MAAO,EAAQ,IAAI,CAAC,KAAK,EAAI,EAAQ,IAAI,CAAC,QAAQ,EAAI,KACtD,MAAO,EAAQ,IAAI,CAAC,iBAAiB,eACrC,EACA,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,CACD,GAuNA,QA/nEe,AAAC,IAET,CACN,GAAI,UACJ,KAAM,UACN,uBAAwB,MAAO,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,CAAE,aAAW,CAAE,IAC1E,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,oBAAoB,CACpE,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GAC5B,IAAM,EAAmB,CAAC,EAE1B,OADI,EAAQ,UAAU,GAAE,EAAiB,iBAAiB,CAAG,EAAQ,UAAA,AAAU,EACxE,MAAM,GAAuB,CACnC,GAAI,kBACJ,EACA,sBAAuB,2CACvB,OAAQ,QACR,cACA,eACA,mBACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,MAAM,GAA0B,CACtC,OACA,2BACA,UACA,EACA,cA3BmB,yCA4BpB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,sCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,yDAA0D,CAC5G,OAAQ,OACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CACzD,GACA,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,UAAU,CACtB,KAAM,EAAQ,IAAI,EAAE,aACpB,MAAO,EAAQ,KAAK,CACpB,cAAe,EAAQ,cAAc,GAAI,EACzC,MAAO,EAAQ,iBAAiB,CAChC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAikEA,KAthDY,AAAC,IACN,CACN,GAAI,OACJ,KAAM,OACN,uBAAuB,OAAE,CAAK,CAAE,QAAM,aAAE,CAAW,cAAE,CAAY,CAAE,EAClE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,YAAY,CAGhE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,mBACJ,EACA,UACA,sBAAuB,sCACvB,OAAQ,eACR,QACA,CACD,EACD,EACM,0BAAN,MAAgC,MAAE,CAAI,aAAE,CAAW,cAAE,CAAY,CAAE,GAC3D,GAA0B,MAChC,cACA,UACA,EACA,cAAe,+CACf,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,uCAAwC,CACjF,OAAQ,MACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CACzD,GACA,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,EAAK,IAAI,CAAC,EAAE,CACtB,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,OAAO,CACnB,KAAM,EAAQ,IAAI,CAClB,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,eAAe,CAC9B,eAAe,EACf,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,EACA,SACD,GAs+CA,OAx3Cc,AAAC,IACf,IAAM,EAAgB,qCACtB,MAAO,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,WAAE,CAAS,aAAE,CAAW,CAAE,EAC/D,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,OAAO,CAG3D,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,iBACJ,EACA,sBAAuB,qCACvB,OAAQ,EACR,oBACA,YACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,cACA,EACA,wBACA,CACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,CAAE,OAAK,CAAE,CAAG,MAAM,GAAY,iCAAkC,CACpF,OAAQ,OACR,QAAS,CACR,eAAgB,mBAChB,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAC3C,AAD6C,EAE7C,KAAM,KAAK,SAAS,CAAC,CAAE,MAAO,CAAC;;;;;;;;;;;;MAY7B,CAAC,AAAC,EACL,GACA,GAAI,GAAS,CAAC,GAAS,MAAM,OAAQ,OAAO,KAC5C,IAAM,EAAW,EAAQ,IAAI,CAAC,MAAM,CAC9B,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAC1B,KAAM,EAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,CAC9B,MAAO,EAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAChC,MAAO,EAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CACpC,eAAe,EACf,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,EACA,SACD,CACD,EA4yCC,SAxyCgB,AAAC,IAEjB,IAAM,EAAgB,gDACtB,MAAO,CACN,GAAI,WACJ,KAAM,WACN,uBAAwB,MAAO,CAAE,OAAK,QAAE,CAAM,aAAE,CAAW,WAAE,CAAS,CAAE,IACvE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,UACA,QACA,SACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,mBACJ,EACA,sBAhB2B,kDAiB3B,OAAQ,EACR,kBACA,cACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,MAAM,GAA0B,CACtC,mBACA,UACA,gBACA,CACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,uCAAwC,CAC1F,OAAQ,MACR,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CACzD,GACA,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAQ,IAAI,CAClB,MAAO,EAAQ,KAAK,CACpB,cAAe,EAAQ,cAAc,GAAI,EACzC,MAAO,EAAQ,OAAO,CACtB,GAAG,CACJ,AADW,EAEX,KAAM,CACP,CACD,UACA,CACD,CACD,EAwuCC,OAjzDc,AAAC,IACf,MAAM,CAAE,uBAAqB,eAAE,CAAa,kBAAE,CAAgB,CAAE,EAR5D,CAQ+D,CARrD,AAQuE,EAAQ,MAAM,EAR3E,qBACjB,CACN,sBAAuB,GAAmB,CAAA,EAAG,EAAQ,gBAAgB,CAAC,EACtE,cAAe,GAAmB,CAAA,EAAG,EAAQ,YAAY,CAAC,EAC1D,iBAAkB,GAAmB,CAAA,EAAG,EAAQ,YAAY,CAAC,CAC9D,GAIM,EAAW,SACjB,MAAO,CACN,GAAI,EACJ,KAAM,SACN,uBAAwB,MAAO,OAAE,CAAK,CAAE,QAAM,cAAE,CAAY,WAAE,CAAS,CAAE,aAAW,CAAE,IACrF,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,YAAY,CAGhE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,UACJ,wBACA,EACA,OAAQ,QACR,EACA,cACA,yBACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,cAAE,CAAY,CAAE,GAC7D,GAA0B,MAChC,EACA,cACA,uBACA,gBACA,CACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,eACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,EAAkB,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAG,AAAD,CAAG,GACjI,GAAI,GAA2B,WAAlB,EAAQ,KAAK,EAAiB,EAAQ,MAAM,CAAE,OAAO,KAClE,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,IAAI,EAAI,EAAQ,QAAQ,CACtC,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,UAAU,CACzB,cAAe,EAAQ,cAAc,GAAI,EACzC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,CACD,CACD,EAsvDC,OApae,AAAD,IACP,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,CAAE,aAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,oBAAoB,CAGxE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,IAAI,IAAI,CAAC,+CAA+C,EAAE,EAAQ,IAAI,CAAC,KAAK,+BAA+B,EAAE,EAAQ,SAAS,CAAC,cAAc,EAAE,mBAAmB,EAAQ,WAAW,EAAI,GAAa,OAAO,EAAE,EAAA,CAAO,CAC9N,EACA,0BAA2B,MAAO,CAAE,MAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,EACA,YAAa,EAAQ,WAAW,EAAI,EACpC,QAAS,CACR,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,6CAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CAAE,aAAc,EAAQ,YAAY,AAAC,EAC9C,cAAe,8CACf,eAAgB,OAChB,YAAa,CAAE,WAAY,EAAQ,SAAS,AAAC,CAC9C,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,CAAC,iDAAiD,EAAE,8CAKxF,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,UAC3E,AAAI,EAAc,KAAP,AACJ,CACN,KAAM,CACL,MAAO,EAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,EAAI,EAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAC5D,GAAI,EAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,CAC7B,KAAM,EAAQ,IAAI,CAAC,IAAI,CAAC,YAAY,EAAI,EAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAClE,MAAO,EAAQ,IAAI,CAAC,IAAI,CAAC,gBAAgB,CACzC,aAAA,GAAe,EAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,AACvC,EACA,CAF0C,IAEpC,CACP,CACD,CAJmD,SAKnD,EACD,EAkXA,OApvBe,AAAD,IACP,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,CAAE,OAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,WAAW,CAG/D,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,iBACJ,EACA,sBAAuB,0CACvB,OAAQ,QACR,EACA,cACA,SAAU,EAAQ,QAAQ,AAC3B,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,IACtD,IAAM,EAAO,IAAI,gBAAgB,CAChC,WAAY,qBACZ,OACA,aAAc,EAAQ,WAAW,EAAI,CACtC,GACM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,6CAA8C,CACvF,OAAQ,OACR,QAAS,CACR,eAAgB,oCAChB,OAAQ,aACR,aAAc,cACd,cAAe,CAAC,MAAM,EAAE,GAAA,MAAM,CAAC,MAAM,CAAC,CAAA,EAAG,EAAQ,QAAQ,CAAC,CAAC,EAAE,EAAQ,YAAY,CAAA,CAAE,EAAA,CAAG,AACvF,EACA,KAAM,EAAK,QAAQ,EACpB,GACA,GAAI,EAAO,MAAM,EACjB,OAAO,GAAgB,EACxB,EACA,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,eAAgB,QAChB,cAAe,4CAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,qCAAsC,CAAE,QAAS,CACnG,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,CAC5C,aAAc,aACf,CAAE,GACF,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,IAAI,CAClB,MAAO,EAAQ,eAAe,CAC9B,cAAe,EAAQ,kBAAkB,CACzC,MAAO,EAAQ,QAAQ,EAAE,MAAM,IAAI,CAAC,EAAE,CACtC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,EACA,UACD,EA+qBA,OA1qBc,AAAC,IACR,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,SAAU,UAAU,CAGxE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,IAAI,IAAI,CAAC,iDAAiD,EAAE,EAAQ,IAAI,CAAC,KAAK,8BAA8B,EAAE,EAAQ,QAAQ,CAAC,cAAc,EAAE,mBAAmB,EAAQ,WAAW,EAAI,GAAa,OAAO,EAAE,EAAM,QAAQ,EAAE,EAAQ,MAAM,EAAI,yBAAA,CAA0B,CACnR,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,EACA,YAAa,EAAQ,WAAW,EAAI,UACpC,EACA,cAAe,yCACf,eAAgB,MACjB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,wCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,4CAA6C,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GAC5J,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAQ,QAAQ,EAAI,EAAQ,kBAAkB,EAAI,GACxD,MAAO,EAAQ,OAAO,CACtB,MAAO,EAAQ,kBAAkB,EAAI,KACrC,eAAe,EACf,GAAG,CAAO,AACX,EACA,KAAM,CAAE,GAAG,CAAO,AAAC,CACpB,CACD,UACA,EACD,EA2nBA,WAtnBkB,AAAC,IACnB,IAAM,EAAY,CAAC,EAAQ,WAAW,EAAI,YAAA,CAAY,GAAM,UACtD,EAAwB,EAAQ,QAAQ,CAAG,CAAC,QAAQ,EAAE,EAAQ,QAAQ,CAAC,0BAA0B,CAAC,CAAG,EAAY,wDAA0D,yDAC3K,EAAgB,EAAQ,QAAQ,CAAG,CAAC,QAAQ,EAAE,EAAQ,QAAQ,CAAC,sBAAsB,CAAC,CAAG,EAAY,oDAAsD,qDAC3J,EAAmB,EAAQ,QAAQ,CAAG,CAAC,QAAQ,EAAE,EAAQ,QAAQ,CAAC,yBAAyB,CAAC,CAAG,EAAY,uDAAyD,wDAC1K,MAAO,CACN,GAAI,aACJ,KAAM,aACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EACxE,GAAI,CAAC,EAAQ,QAAQ,EAAI,CAAC,EAAQ,YAAY,CAE7C,CAF+C,KAC/C,GAAA,CAAM,CAAC,KAAK,CAAC,sGACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,GAAI,CAAC,EAAc,MAAM,IAAI,GAAA,CAAe,CAAC,2CAC7C,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,QACA,UACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,qBACJ,wBACA,EACA,OAAQ,QACR,eACA,EACA,YAAa,EAAQ,WAAW,EAAI,CACrC,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,EACA,YAAa,EAAQ,WAAW,EAAI,UACpC,gBACA,CACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CACH,GAAM,CAAE,KAAM,CAAI,CAAE,CAAG,MAAM,GAAY,EAAkB,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GACvH,GAAI,CAAC,EAEJ,IAFU,GACV,GAAA,CAAM,CAAC,KAAK,CAAC,6CACN,KAER,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAK,OAAO,CAChB,KAAM,EAAK,IAAI,CACf,MAAO,EAAK,KAAK,CACjB,MAAO,EAAK,MAAM,EAAE,SAAW,EAAK,MAAM,EAAE,UAC5C,cAAe,EAAK,cAAc,GAAI,EACtC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,CAAE,MAAO,EAAO,CAEf,OADA,GAAA,CAAM,CAAC,KAAK,CAAC,6CAA8C,GACpD,IACR,CACD,UACA,CACD,CACD,EA0iBC,GArKU,AAAC,GACJ,EACN,GAAI,KACJ,KAAM,KACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EACxE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,QAAS,QAAQ,CAGrE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,aACJ,EACA,sBAAuB,8BACvB,OAAQ,QACR,cACA,eACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,UAAE,CAAQ,CAAE,GACvE,GAA0B,MAChC,EACA,eACA,YAAa,EAAQ,WAAW,EAAI,UACpC,EACA,WACA,cAAe,+BAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,+BAChB,GAED,MAAM,YAAY,CAAI,EACrB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAK,WAAW,CAAE,OAAO,KAC9B,IAAM,EAAW,IAAI,gBAAgB,CACpC,aAAc,EAAK,WAAW,CAC9B,UAAW,EAAQ,QAAQ,AAC5B,GAAG,QAAQ,GACL,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,qCAAsC,CACxF,OAAQ,OACR,QAAS,CAAE,eAAgB,mCAAoC,EAC/D,KAAM,CACP,GACA,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,UAC7C,AAAC,AAAL,EAAa,IAAI,CAAC,KAAK,EAAK,EAAD,CAAU,MAC9B,CADqC,AAE3C,KAAM,CACL,GAAI,EAAQ,IAAI,CAAC,OAAO,CACxB,WAAY,EAAQ,IAAI,CAAC,UAAU,CACnC,UAAW,EAAQ,IAAI,CAAC,SAAS,CACjC,MAAO,EAAQ,IAAI,CAAC,KAAK,CACzB,MAAO,EAAQ,IAAI,CAAC,MAAM,CAC1B,cAAe,CAAC,CAAC,EAAQ,IAAI,CAAC,KAAK,CACnC,SAAU,EAAQ,IAAI,CAAC,QAAQ,CAC/B,IAAK,EAAQ,IAAI,CAAC,GAAG,CACrB,KAAM,CAAA,EAAG,EAAQ,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,EAAQ,IAAI,CAAC,SAAS,CAAA,CAAE,CAC5D,GAAG,CAAO,AACX,EACA,KAAM,CACP,EAfmD,IAgBpD,UACA,EACD,EA+FA,KA1FY,AAAC,IACb,IAAM,EAAU,CACf,MAAM,EACN,GAAG,CACJ,AADe,EAEf,MAAO,CACN,GAAI,OACJ,KAAM,OACN,uBAAwB,MAAO,OAAE,CAAK,aAAE,CAAW,cAAE,CAAY,CAAE,IAClE,IAAM,EAAS,IAAI,gBAAgB,CAClC,cAAe,OACf,aAAc,EAAQ,WAAW,CAAG,EAAQ,WAAW,CAAG,EAC1D,UAAW,EAAQ,QAAQ,OAC3B,CACD,GACA,GAAI,EAAQ,IAAI,CAAE,CACjB,IAAM,EAAgB,MAAM,GAAsB,GAClD,EAAO,GAAG,CAAC,wBAAyB,QACpC,EAAO,GAAG,CAAC,iBAAkB,EAC9B,CACA,IAAM,EAAM,IAAI,IAAI,mCAEpB,OADA,EAAI,MAAM,CAAG,EAAO,QAAQ,GACrB,CACR,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,cAAE,CAAY,CAAE,GAC7D,GAA0B,MAChC,EACA,YAAa,EAAQ,WAAW,EAAI,eACpC,UACA,EACA,cAAe,8BACf,eAAgB,MACjB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAAiB,GAAmB,CACxH,eACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,6BAChB,GACA,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,kCAAmC,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GAClJ,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,YAAY,CAC1B,MAAO,EAAQ,OAAO,CACtB,MAAO,EAAQ,KAAK,CACpB,eAAe,CAAQ,EAAQ,QAAQ,CACvC,GAAG,CAAO,AACX,EACA,KAAM,CAAE,GAAG,CAAO,AAAC,CACpB,CACD,CACD,CACD,EA8BC,OAhlCc,AAAC,IACf,IAAM,EAAgB,wCACtB,MAAO,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,CAAE,WAAS,aAAE,CAAW,CAAE,EAC/D,IAAM,GAAU,EAAQ,mBAAmB,CAAG,EAAE,EAGhD,CAHmD,EAAE,IACjD,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,iBACJ,EACA,sBAAuB,4CACvB,OAAQ,QACR,cACA,YACA,EACA,iBAAkB,CAAE,MAAO,MAAO,CACnC,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,cACA,UACA,gBACA,EACA,eAAgB,OACjB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,qCAAsC,CAAE,QAAS,CACnG,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,CAC5C,iBAAkB,YACnB,CAAE,GACF,GAAI,GAAS,CAAC,EAAS,OAAO,KAC9B,IAAM,EAAc,EAAQ,GAAG,EAAE,OAAO,KACxC,GAAI,CAAC,EAAa,OAAO,KACzB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAY,EAAE,CAClB,KAAM,EAAY,IAAI,EAAI,cAC1B,MAAO,EAAY,MAAM,EAAE,OAAS,KACpC,MAAO,EAAY,UAAU,CAC7B,cAAe,CAAC,CAAC,EAAY,MAAM,EAAE,MACrC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,CACD,CACD,EAihCC,MAlmDa,AAAC,IACP,CACN,GAAI,QACJ,KAAM,QACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,gBACA,gBACA,mBACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,QACJ,UACA,sBAAuB,0CACvB,OAAQ,QACR,cACA,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,cACA,UACA,EACA,cAAe,qCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,qCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,oCAAqC,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GACpJ,GAAI,GAAS,CAAC,EAAS,OAAO,KAC9B,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GAC3C,EAAU,EAAQ,aAAa,EAAI,CAAC,EACpC,EAAe,EAAQ,OAAO,EAAI,CAAC,EACzC,MAAO,CACN,KAAM,CACL,GAAI,OAAO,EAAQ,EAAE,EACrB,KAAM,EAAa,QAAQ,EAAI,EAAQ,IAAI,EAAI,KAAK,EACpD,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAa,iBAAiB,EAAI,EAAa,mBAAmB,CACzE,cAAe,CAAC,CAAC,EAAQ,cAAc,EAAI,CAAC,CAAC,EAAQ,iBAAiB,CACtE,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAuiDA,MA9oCa,AAAC,IACP,CACN,GAAI,QACJ,KAAM,QACN,uBAAuB,CAAE,OAAK,QAAE,CAAM,aAAE,CAAW,CAAE,EACpD,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAAC,UAAW,QAAQ,CAGvE,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,gBACJ,EACA,sBAAuB,2CACvB,OAAQ,QACR,cACA,CACD,EACD,EACA,0BAA2B,MAAO,CAAE,MAAI,aAAE,CAAW,CAAE,GAC/C,GAA0B,MAChC,cACA,UACA,EACA,cAAe,sCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,sCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,sCAAuC,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GACtJ,GAAI,GAAS,CAAC,GAAkC,OAAvB,EAAQ,UAAU,CAAW,OAAO,KAC7D,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GAC3C,EAAM,EAAQ,QAAQ,EAAI,CAAC,EACjC,MAAO,CACN,KAAM,CACL,GAAI,EAAI,EAAE,CACV,KAAM,EAAI,IAAI,EAAI,EAAI,QAAQ,CAC9B,MAAO,EAAI,KAAK,CAChB,MAAO,EAAI,aAAa,CACxB,eAAe,EACf,GAAG,CACJ,AADW,EAEX,KAAM,CACP,CACD,UACA,EACD,EAwlCA,KAp+Ca,AAAD,IAEZ,IAAM,EAAgB,wCAGtB,MAAO,CACN,GAAI,OACJ,KAAM,OACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,CAAE,aAAW,WAAE,CAAS,CAAE,EACnF,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,UACA,QACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,eACJ,EACA,sBAlB2B,+CAmB3B,OAAQ,QACR,eACA,cACA,EACA,WACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,gBACA,CACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,cAAc,CAAK,CAAE,CAAK,EAC/B,GAAI,EAAQ,oBAAoB,CAAE,OAAO,EACzC,GAAI,EAAQ,aAAa,CAAE,OAAO,EAAQ,aAAa,CAAC,EAAO,GAC/D,IAAM,EAAO,IAAI,gBACjB,EAAK,GAAG,CAAC,WAAY,GACrB,EAAK,GAAG,CAAC,YAAa,EAAQ,QAAQ,EAClC,GAAO,EAAK,GAAG,CAAC,QAAS,GAC7B,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,GAjDF,SAiDc,gCAAuB,CAChE,OAAQ,OACR,QAAS,CAAE,eAAgB,mCAAoC,OAC/D,CACD,UACI,IAAS,CAAC,GACV,EAAK,CADW,EACR,GAAK,EADU,AACF,QAAQ,EAAE,EAC/B,IAAS,CAD6B,CACxB,KAAK,EAAI,EAAK,KAAK,GAAK,CAAA,CAE3C,EAFkD,AAGlD,MAAM,CAHmD,WAGvC,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,IAAI,EAAU,KACd,GAAI,EAAM,OAAO,CAAE,GAAI,CACtB,EAAU,GAAU,EAAM,OAAO,CAClC,CAAE,KAAM,CAAC,CACT,GAAI,CAAC,EAAS,CACb,GAAM,MAAE,CAAI,CAAE,CAAG,MAAM,GAnED,SAmEa,kCAAkB,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GACjH,EAAU,GAAQ,IACnB,CACA,GAAI,CAAC,EAAS,OAAO,KACrB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GAC3C,EAAK,EAAQ,GAAG,EAAI,EAAQ,MAAM,CAClC,EAAO,EAAQ,IAAI,EAAI,EAAQ,WAAW,CAC1C,EAAQ,EAAQ,OAAO,EAAI,EAAQ,UAAU,EAAI,KAAK,EAC5D,MAAO,CACN,KAAM,IACL,OACA,EACA,MAAO,EAAQ,KAAK,OACpB,EACA,eAAe,EACf,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,CACD,CACD,EAy4CC,OAhhCc,AAAC,IACf,IAAM,EAAS,EAAQ,MAAM,EAAI,wBAC3B,EAAwB,CAAA,EAAG,EAAO,iBAAiB,CAAC,CACpD,EAAgB,CAAA,EAAG,EAAO,aAAa,CAAC,CAC9C,MAAO,CACN,GAAI,SACJ,KAAM,SACN,MAAM,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,WAAS,CAAE,EACnF,GAAI,CAAC,EAAQ,QAAQ,EAAI,CAAC,EAAQ,YAAY,CAE7C,CAF+C,KAC/C,GAAA,CAAM,CAAC,KAAK,CAAC,iGACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,GAAI,CAAC,EAAc,MAAM,IAAI,GAAA,CAAe,CAAC,uCAC7C,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,QACA,UACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,MAAM,GAAuB,CACnC,GAAI,iBACJ,wBACA,EACA,OAAQ,QACR,EACA,2BACA,EACA,OAAQ,EAAQ,MAAM,WACtB,CACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,CAChC,oBACA,cACA,EACA,UACA,eACD,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,gBACA,CACD,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAM,OAAO,CAAE,OAAO,KAC3B,IAAM,EAAO,GAAU,EAAM,OAAO,EAC9B,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAK,GAAG,CACZ,KAAM,EAAK,IAAI,EAAI,EAAK,kBAAkB,GAAK,CAAD,CAAM,KAAK,CAAG,EAAK,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAG,MAAA,CAAM,EAAK,OAClG,MAAO,EAAK,KAAK,CACjB,MAAO,EAAK,OAAO,CACnB,cAAe,EAAK,cAAc,GAAI,EACtC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,CACD,CACD,EA08BC,OAt8Bc,AAAC,IACf,IAAM,EAAY,AAAuC,aAAtC,EAAQ,WAAW,EAAI,SAAA,CAAS,CAC7C,EAAwB,EAAY,kDAAoD,0CACxF,EAAgB,EAAY,mDAAqD,2CACjF,EAAmB,EAAY,+DAAiE,uDACtG,MAAO,CACN,GAAI,SACJ,KAAM,SACN,MAAM,uBAAuB,OAAE,CAAK,cAAE,CAAY,aAAE,CAAW,CAAE,EAChE,GAAI,CAAC,EAAQ,QAAQ,EAAI,CAAC,EAAQ,YAAY,CAE7C,CAF+C,KAC/C,GAAA,CAAM,CAAC,KAAK,CAAC,iGACP,IAAI,GAAA,CAAe,CAAC,iCAE3B,OAAO,MAAM,GAAuB,CACnC,GAAI,iBACJ,EACA,wBACA,OAAQ,EAAE,OACV,eACA,EACA,cACA,OAAQ,EAAQ,MAAM,AACvB,EACD,EACA,0BAA2B,MAAO,CAAE,MAAI,aAAE,CAAW,CAAE,IAItD,IAAM,EAAc,GAAA,MAAM,CAAC,MAAM,CAAC,CAAA,EAAG,EAAQ,QAAQ,CAAC,CAAC,EAAE,EAAQ,YAAY,CAAA,CAAE,EAC/E,GAAI,CACH,IAAM,EAAW,MAAM,GAAY,EAAe,CACjD,OAAQ,OACR,QAAS,CACR,cAAe,CAAC,MAAM,EAAE,EAAA,CAAa,CACrC,OAAQ,mBACR,kBAAmB,QACnB,eAAgB,mCACjB,EACA,KAAM,IAAI,gBAAgB,CACzB,WAAY,0BACZ,EACA,aAAc,CACf,GAAG,QAAQ,EACZ,GACA,GAAI,CAAC,EAAS,IAAI,CAAE,MAAM,IAAI,GAAA,CAAe,CAAC,8BAC9C,IAAM,EAAO,EAAS,IAAI,CAC1B,MAAO,CACN,YAAa,EAAK,YAAY,CAC9B,aAAc,EAAK,aAAa,CAChC,qBAAsB,EAAK,UAAU,CAAG,IAAI,KAAK,KAAK,GAAG,GAAK,AAAkB,MAAb,UAAU,EAAU,KAAK,EAC5F,QAAS,EAAK,QAAQ,AACvB,CACD,CAAE,MAAO,EAAO,CAEf,MADA,GAAA,CAAM,CAAC,KAAK,CAAC,gCAAiC,GACxC,IAAI,GAAA,CAAe,CAAC,6BAC3B,CACD,EACA,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,IACpF,IAAM,EAAc,GAAA,MAAM,CAAC,MAAM,CAAC,CAAA,EAAG,EAAQ,QAAQ,CAAC,CAAC,EAAE,EAAQ,YAAY,CAAA,CAAE,EAC/E,GAAI,CACH,IAAM,EAAW,MAAM,GAAY,EAAe,CACjD,OAAQ,OACR,QAAS,CACR,cAAe,CAAC,MAAM,EAAE,EAAA,CAAa,CACrC,OAAQ,mBACR,kBAAmB,QACnB,eAAgB,mCACjB,EACA,KAAM,IAAI,gBAAgB,CACzB,WAAY,gBACZ,cAAe,CAChB,GAAG,QAAQ,EACZ,GACA,GAAI,CAAC,EAAS,IAAI,CAAE,MAAM,IAAI,GAAA,CAAe,CAAC,kCAC9C,IAAM,EAAO,EAAS,IAAI,CAC1B,MAAO,CACN,YAAa,EAAK,YAAY,CAC9B,aAAc,EAAK,aAAa,CAChC,qBAAsB,EAAK,UAAU,CAAG,IAAI,KAAK,KAAK,GAAG,GAAuB,IAAlB,EAAK,UAAU,EAAU,KAAK,CAC7F,CACD,CAAE,MAAO,EAAO,CAEf,MADA,GAAA,CAAM,CAAC,KAAK,CAAC,+BAAgC,GACvC,IAAI,GAAA,CAAe,CAAC,iCAC3B,CACD,EACA,MAAM,cAAc,CAAK,CAAE,CAAK,EAC/B,GAAI,EAAQ,oBAAoB,CAAE,OAAO,EACzC,GAAI,EAAQ,aAAa,CAAE,OAAO,EAAQ,aAAa,CAAC,EAAO,GAC/D,GAAI,CACH,MAAO,CAAC,CAAC,GAAU,GAAO,GAAG,AAC9B,CAAE,MAAO,EAAO,CAEf,OADA,GAAA,CAAM,CAAC,KAAK,CAAC,oCAAqC,IAC3C,CACR,CACD,EACA,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAI,CAAC,EAAM,WAAW,CAErB,CAFuB,MACvB,GAAA,CAAM,CAAC,KAAK,CAAC,sDACN,KAER,GAAI,CACH,IAAM,EAAW,MAAM,GAAY,CAAA,EAAG,EAAiB,kBAAkB,CAAC,CAAE,CAAE,QAAS,CACtF,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,CAC5C,OAAQ,kBACT,CAAE,GACF,GAAI,CAAC,EAAS,IAAI,CAEjB,CAFmB,MACnB,GAAA,CAAM,CAAC,KAAK,CAAC,yCACN,KAER,IAAM,EAAW,EAAS,IAAI,CACxB,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAS,OAAO,CACpB,KAAM,EAAS,IAAI,CACnB,MAAO,EAAS,KAAK,CACrB,MAAO,EAAS,OAAO,CACvB,cAAe,EAAS,cAAc,CACtC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,CAAE,MAAO,EAAO,CAEf,OADA,GAAA,CAAM,CAAC,KAAK,CAAC,yCAA0C,GAChD,IACR,CACD,UACA,CACD,CACD,EAq0BC,MAj0Ba,AAAC,GACP,EACN,GAAI,QACJ,KAAM,QACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,cAAE,CAAY,aAAE,CAAW,CAAE,EAClE,IAAM,EAAU,EAAQ,mBAAmB,CAAG,EAAE,CAAG,CAClD,SACA,UACA,QACA,CAGD,OAFI,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,GACrB,GAAuB,CAC7B,GAAI,gBACJ,EACA,sBAAuB,oCACvB,OAAQ,QACR,eACA,cACA,EACA,OAAQ,EAAQ,MAAM,AACvB,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,cAAE,CAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAAe,sCAChB,GAED,mBAAoB,EAAQ,kBAAkB,CAAG,EAAQ,kBAAkB,CAAG,MAAO,GAC7E,GAAmB,cACzB,EACA,QAAS,CACR,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EAAQ,SAAS,CAC5B,aAAc,EAAQ,YAAY,AACnC,EACA,cAAe,sCAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,0CAA2C,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GAC1J,GAAI,EAAO,OAAO,KAClB,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,EAAE,CACd,KAAM,EAAQ,WAAW,EAAI,EAAQ,QAAQ,CAC7C,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,UAAU,CACzB,cAAe,EAAQ,cAAc,GAAI,EACzC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,EAqwBA,OApOc,AAAC,IACR,CACN,GAAI,SACJ,KAAM,SACN,uBAAuB,OAAE,CAAK,QAAE,CAAM,CAAE,cAAY,aAAE,CAAW,CAAE,MAE9D,EADJ,GAAI,CAAC,EAAc,EACL,IADW,CACN,GADU,GAAA,CAAe,CAAC,uCAO7C,OALsB,KAAK,IAAvB,EAAQ,KAAK,EAA0B,SAAX,CAAgB,GAAG,CAClD,EAAU,EAAE,CACR,EAAQ,KAAK,EAAE,EAAQ,IAAI,IAAI,EAAQ,KAAK,EAC5C,GAAQ,EAAQ,IAAI,IAAI,IAEtB,GAAuB,CAC7B,GAAI,iBACJ,EACA,sBAAuB,qCACvB,OAAQ,EACR,qBACA,EACA,aACD,EACD,EACA,0BAA2B,MAAO,MAAE,CAAI,CAAE,cAAY,aAAE,CAAW,CAAE,GAC7D,GAA0B,MAChC,eACA,cACA,UACA,EACA,cAAe,0CAChB,GAED,MAAM,YAAY,CAAK,EACtB,GAAI,EAAQ,WAAW,CAAE,OAAO,EAAQ,WAAW,CAAC,GACpD,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,GAAY,8CAA+C,CAAE,QAAS,CAAE,cAAe,CAAC,OAAO,EAAE,EAAM,WAAW,CAAA,CAAE,AAAC,CAAE,GAC9J,GAAI,GAAS,CAAC,EAAS,OAAO,KAC9B,IAAM,EAAU,MAAM,EAAQ,gBAAgB,GAAG,GACjD,MAAO,CACN,KAAM,CACL,GAAI,EAAQ,GAAG,CACf,KAAM,EAAQ,IAAI,EAAI,EAAQ,kBAAkB,CAChD,MAAO,EAAQ,KAAK,CACpB,MAAO,EAAQ,OAAO,CACtB,cAAe,EAAQ,cAAc,GAAI,EACzC,GAAG,CAAO,AACX,EACA,KAAM,CACP,CACD,UACA,EACD,CAoLD,EACM,GAAqB,OAAO,IAAI,CAAC,IACjC,GAAyB,EAAA,IAAM,CAAC,IAAoB,EAAE,CAAC,EAAA,MAAQ,IRhhFrE,SAAS,GAAc,CAAK,EAC1B,GAAc,OAAV,GAAmC,UAAjB,AAA2B,OAApB,EAC3B,OAAO,EAET,IAAM,EAAY,OAAO,cAAc,CAAC,SACxC,AAAI,CAAc,UAAQ,IAAc,OAAO,SAAS,EAAyC,OAArC,OAAO,cAAc,CAAC,EAAe,GAAM,EAGnG,OAAO,QAAQ,IAAI,CAAA,GAAO,GAG1B,OAAO,WAAW,IAAI,CAAA,GACyB,AADlB,oBACxB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,GAG1C,CAiCA,SAAS,GAAW,CAAM,EACxB,MAAO,CAAC,GAAG,IAET,EAAW,MAAM,CADjB,AACkB,CAAC,EAAG,IAAM,CAlChC,SAAS,EAAM,CAAU,CAAE,CAAQ,CAAE,EAAY,GAAG,CAAE,CAAM,EAC1D,GAAI,CAAC,GAAc,GACjB,OAAO,CADqB,CAgCuB,AA/BtC,EAAY,CAAC,EAAG,EAAW,GAE1C,IAAM,EAAS,OAAO,MAAM,CAAC,CAAC,EAAG,GACjC,IAAK,IAAM,KAAO,EAAY,CAC5B,GAAY,cAAR,GAA+B,eAAe,CAAvB,EACzB,SAEF,IAAM,EAAQ,CAAU,CAAC,EAAI,OACzB,IAGA,GAAU,EAAO,CAHP,CAGe,EAAK,EAAO,GAHnB,EAMlB,MAAM,CAH2C,CAHrB,KAMf,AANoB,CAMnB,EANsB,EAMZ,MAAM,OAAO,CAAC,CAAM,CAAC,EAAI,EACnD,CADsD,AAChD,CAAC,EAAI,CAAG,IAAI,KAAU,CAAM,CAAC,EAAI,CAAC,CAC/B,GAAc,IAAU,GAAc,CAAM,CAAC,EAAI,EAC1D,CAD6D,AACvD,CAAC,EAAI,CAAG,EACZ,EACA,CAAM,CAAC,EAAI,CACX,CAAC,EAAY,CAAA,EAAG,EAAU,CAAC,CAAC,CAAG,EAAA,CAAE,CAAI,EAAI,QAAQ,GACjD,GAGF,CAAM,CAAC,EAAI,CAAG,GAElB,CACA,OAAO,EACT,EAIsC,EAAG,EAAG,GAAI,GAAS,CAAC,EAE1D,CACA,IAAM,GAAO,KgD9Bb,SAAS,GAAiB,CAAI,QAC7B,AAAa,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,AAAT,SAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAT,GAAyB,MAAM,CAAf,EAAsB,CAAC,EAAE,EAAE,EAAA,CAAM,CACzP,CACb,CA+DA,SAAS,GAAQ,CAAM,CAAE,CAAM,EAC9B,GAAsB,UAAlB,OAAO,EAAqB,MAAM,AAAI,UAAU,CAAC,6BAA6B,EAAE,OAAO,EAAO,MAAM,CAAC,EACzG,OAAO,EAAO,IAAI,CAAC,EACpB,CAgBA,SAAS,GAAc,CAAO,CAAE,CAAO,EACtC,GAAuB,UAAnB,OAAO,GAAwB,CAAC,MAAM,OAAO,CAAC,GAAU,MAAM,AAAI,UAAU,CAAC,gFAAgF,EAAE,OAAO,EAAQ,MAAM,CAAC,EAEzL,IADuB,UAAnB,OAAO,GAA2C,AAAnB,kBAAO,CAAY,IAAW,EAAU,CAAE,UAAW,CAAQ,GACvE,GAArB,UAAU,MAAM,EAAU,CAAC,CAAC,KAAmB,IAAZ,GAA8C,UAAnB,OAAO,GAAoC,OAAZ,GAAoB,CAAC,MAAM,OAAO,CAAC,EAAA,CAAQ,CAAG,MAAM,AAAI,UAAU,CAAC,iFAAiF,EAAE,OAAO,EAAQ,MAAM,CAAC,EAE7Q,GAA0B,OAAtB,CADJ,EAAU,GAAW,CAAC,GACV,SAAS,CAAW,MAAM,AAAI,MAAM,4GAChD,IAAI,EA5EL,AA4EqB,SA5EZ,EAAU,CAAO,CAAE,EAAY,EAAI,EAC3C,GAAI,MAAM,OAAO,CAAC,GAAU,MAAO,CAAC,GAAG,EAAE,EAAQ,GAAG,CAAC,AAAC,GAAM,CAAC,CAAC,EAAE,EAAU,EAAG,GAAW,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CACxG,IAAI,EAAoB,GACpB,EAAmB,GACnB,EAAW,GACX,EAAc,MAAM,CACvB,EAAoB,IACpB,EAAmB,UACnB,EAAW,YACD,IAGN,CADJ,EAnBF,AAmBqB,IAFE,KAjBd,AAAmB,CAAG,EAC9B,IAAI,EAAS,CAkB0B,EAjBvC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAAK,GAAU,GAAiB,CAAG,CAAC,EAAE,EACtE,OAAO,CACR,EAcE,EAAoB,EACkB,EACjB,MAAM,CAAG,GAAG,AAChC,EAAmB,CAAC,GAAG,EAAE,EAAiB,CAAC,CAAC,CAC5C,EAAW,CAAC,IAAI,EAAE,EAAiB,GAAG,CAAC,EACjC,EAAW,CAAC,EAAE,EAAE,EAAiB,CAAC,CAAC,EAE3C,IAAI,EAAoB,EAAY,CAAA,EAAG,EAAiB,EAAE,CAAC,CAAG,GAC1D,EAAoB,EAAY,CAAA,EAAG,EAAiB,EAAE,CAAC,CAAG,GAC1D,EAAW,EAAY,EAAQ,KAAK,CAAC,GAAqB,CAAC,EAAQ,CACnE,EAAS,GACb,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAAK,CACzC,IAAI,EAAU,CAAQ,CAAC,EAAE,CACrB,EAAc,CAAQ,CAAC,EAAI,EAAE,CAC7B,EAAmB,GACvB,GAAI,AAAC,KAAW,GAAI,GAAG,AAIvB,GAHI,IAA0C,EAA3B,IAAM,CAAV,CAAmB,MAAM,CAAG,EAAsB,EACxC,MAAM,CAAtB,EAAyC,EAC1B,IACpB,GAAyB,OAAZ,EAAkB,CAC9B,IACH,GAAgB,IAAN,EAAU,GAAK,EADJ,AAErB,GAAU,CAAC,GAAG,EAAE,EAAS,EAAE,EAAE,EAAiB,GAAG,CAAC,EAEnD,QACD,CACA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,IAAK,CACxC,IAAI,EAAO,CAAO,CAAC,EAAE,CACR,MAAM,CAAf,EACC,EAAI,EAAQ,MAAM,CAAG,GAAG,CAC3B,GAAU,GAAiB,CAAO,CAAC,EAAI,EAAE,EACzC,KAEkB,MAAT,EAAc,GAAU,EAC1B,AAAS,QAAK,GAAU,CAAA,EAAG,EAAS,EAAE,CAAC,CAC3C,GAAU,GAAiB,EACjC,CACA,GAAU,EACX,CACA,OAAO,CACR,EA0B+B,EAAS,EAAQ,SAAS,EACpD,EAAS,AAAI,OAAO,CAAC,CAAC,EAAE,EAAc,CAAC,CAAC,CAAE,EAAQ,KAAK,EACvD,EAAK,GAAQ,IAAI,CAAC,KAAM,GAI5B,OAHA,EAAG,OAAO,CAAG,EACb,EAAG,OAAO,CAAG,EACb,EAAG,MAAM,CAAG,EACL,CACR,ChDnEe,GAAW,CAAC,EAAQ,EAAK,KACtC,GAAoB,KAAK,IAArB,CAAM,CAAC,EAAI,EAAuC,YAAxB,AAAoC,OAA7B,EAEnC,OADA,CAAM,CAAC,EAAI,CAAG,EAAa,CAAM,CAAC,EAAI,GAC/B,CAEX,GACoB,GAAW,CAAC,EAAQ,EAAK,KAC3C,GAAI,MAAM,OAAO,CAAC,CAAM,CAAC,EAAI,GAA6B,YAAY,AAApC,OAAO,EAEvC,OADA,CAAM,CAAC,EAAI,CAAG,EAAa,CAAM,CAAC,EAAI,GAC/B,CAEX,GgDgEA,IAAM,GAAwB,GAAqB,MAAO,IACzD,GAAI,EAAI,OAAO,EAAE,SAAW,OAAS,EAAI,OAAO,EAAE,SAAW,WAAa,EAAI,OAAO,EAAE,SAAW,QAAU,CAAC,EAAI,OAAO,CAAE,OAC1H,IAAM,EAAU,EAAI,OAAO,EAAE,QACvB,EAAU,EAAI,OAAO,CACrB,MAAE,CAAI,OAAE,CAAK,SAAE,CAAO,CAAE,CAAG,EAC3B,EAAe,GAAS,IAAI,WAAa,GAAS,IAAI,YAAc,GACpE,EAAc,GAAM,aAAe,GAAO,YAC1C,EAAc,GAAM,WACpB,EAAmB,GAAM,iBACzB,EAAqB,GAAM,mBAC3B,EAAiB,MAAM,OAAO,CAAC,EAAQ,OAAO,CAAC,cAAc,EAAI,EAAQ,cAAc,CAAG,IAAI,EAAQ,cAAc,IAAK,MAAM,EAAQ,OAAO,CAAC,cAAc,GAAG,IAAY,EAAE,CAAC,CAC/K,EAAa,GAAS,IAAI,UAY1B,EAAc,CAAC,EAAK,KACzB,GAAK,CAAD,EACA,CAAC,CADK,CACU,IAAI,CAAC,AAAC,GAAW,CAbf,CAAC,EAAK,KAC5B,GAAI,EAAI,UAAU,CAAC,KAAM,OAAO,EAChC,GAAI,EAAQ,QAAQ,CAAC,KAAM,CAC1B,GAAI,EAAQ,QAAQ,CAAC,OAAQ,OAAO,GAAc,GAAS,GAAU,IAAQ,GAC7E,IAAM,EAAO,GAAQ,SACrB,CAAI,CAAC,GACE,GADI,AACU,GAAS,EAC/B,CACA,CAHmB,GAGb,EAAW,GAAY,GAC7B,MAAoB,UAAb,GAAqC,WAAb,CAAyB,EAAC,EAAwC,EAAI,UAAU,CAAC,GAA5C,IAAY,GAAU,GAC3F,EAGqD,EAAK,IAAW,GAAK,WAAW,MAAkB,WAAV,GAAsB,0DAA0D,IAAI,CAAC,IAGhL,GAHuL,GACvL,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,EAAM,EAAE,EAAE,EAAA,CAAK,EACnD,EAAI,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,gCAAgC,EAAE,EAAI;AAAwC,CAAC,CAAE,CAAC,gCAAgC,EAAE,EAAA,CAAgB,EACvJ,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,CAAC,QAAQ,EAAE,EAAA,CAAO,AAAC,EAEhE,EACA,GAAI,GAAc,CAAC,EAAI,OAAO,CAAC,aAAa,EAAI,CAAC,EAAI,OAAO,CAAC,eAAe,CAAE,CAC7E,GAAI,CAAC,GAAiC,SAAjB,EAAyB,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,wBAAyB,GAClH,EAAY,EAAc,SAC3B,CACA,GAAe,EAAY,EAAa,eACxC,GAAe,EAAY,EAAa,eACxC,GAAoB,EAAY,EAAkB,oBAClD,GAAsB,EAAY,EAAoB,qBACvD,GACM,GAAc,AAAC,GAAa,GAAqB,MAAO,IAC7D,GAAI,CAAC,EAAI,OAAO,CAAE,OAClB,GAAM,CAAE,SAAO,CAAE,CAAG,EACd,EAAc,EAAS,GACvB,EAAiB,MAAM,OAAO,CAAC,EAAQ,OAAO,CAAC,cAAc,EAAI,EAAQ,cAAc,CAAG,IAAI,EAAQ,cAAc,IAAK,MAAM,EAAQ,OAAO,CAAC,cAAc,GAAG,EAAI,OAAO,GAAK,EAAE,CAAC,CAYnL,EAAc,CAAC,EAAK,KACzB,GAAK,CAAD,EACA,CAAC,CADK,CACU,IAAI,CAAC,AAAC,GAAW,CAbf,CAAC,EAAK,KAC5B,GAAI,EAAI,UAAU,CAAC,KAAM,OAAO,EAChC,GAAI,EAAQ,QAAQ,CAAC,KAAM,CAC1B,GAAI,EAAQ,QAAQ,CAAC,OAAQ,OAAO,GAAc,GAAS,GAAU,IAAQ,GAC7E,IAAM,EAAO,GAAQ,SACrB,CAAI,CAAC,GACE,GAAc,AADV,GACmB,EAC/B,CACA,CAHmB,GAGb,EAAW,GAAY,GAC7B,MAAoB,UAAb,GAAqC,WAAb,CAAyB,EAAC,EAAwC,EAAI,UAAU,CAAC,GAA5C,IAAY,GAAU,GAC3F,EAGqD,EAAK,IAAW,GAAK,WAAW,MAAkB,WAAV,GAAsB,0DAA0D,IAAI,CAAC,IAGhL,GAHuL,GACvL,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,EAAM,EAAE,EAAE,EAAA,CAAK,EACnD,EAAI,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,gCAAgC,EAAE,EAAI;AAAwC,CAAC,CAAE,CAAC,gCAAgC,EAAE,EAAA,CAAgB,EACvJ,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,CAAC,QAAQ,EAAE,EAAA,CAAO,AAAC,EAEhE,EAEA,IAAK,IAAM,KADO,EACA,IADM,OAAO,CAAC,GAAe,EAAc,CAAC,EAAY,CAC7C,EAAY,EAAK,cAC/C,GA+DM,GAAyB,IAAI,EAApB,EAwBf,WAxB4B,IAwBb,GAAmB,CAAG,CAAE,CAAG,EACzC,GAAI,CAAC,EAAI,SAAS,CAAC,OAAO,CAAE,OAC5B,IAAM,EAAO,IAAI,IAAI,EAAI,GAAG,EAAE,QAAQ,CAAC,OAAO,CAAC,EAAI,OAAO,CAAC,QAAQ,EAAI,YAAa,IAChF,EAAS,EAAI,SAAS,CAAC,MAAM,CAC7B,EAAM,EAAI,SAAS,CAAC,GAAG,CACrB,EAAK,EAAM,EAAK,EAAI,OAAO,EACjC,GAAI,CAAC,EAAI,OACT,IAAM,EAAM,EAAK,EACX,EAAc,AAoDb,CAAC,aACP,AAAY,GACJ,CADQ,CACH,UAAU,CAAC,aAAe,EAAK,UAAU,CAAC,aAAe,EAAK,UAAU,CAAC,qBAAuB,EAAK,UAAU,CAAC,iBAE7H,OAAQ,GACR,IAAK,CACN,EAAE,CA1D2C,IAAI,CAAC,AAAC,GAAS,EAAK,WAAW,CAAC,IAK7E,IAAK,IAAM,KAJP,IACH,EAAS,EAAY,KADL,CACW,CAC3B,EAAM,EAAY,GAAG,EAED,EAAI,OAAO,CAAC,OAAO,EAAI,EAAE,EAAE,GAAI,EAAO,SAAS,CAAE,CACrE,IAAM,EAAc,EAAO,SAAS,CAAC,IAAI,CAAC,AAAC,GAAS,EAAK,WAAW,CAAC,IACrE,GAAI,EAAa,CAChB,EAAS,EAAY,MAAM,CAC3B,EAAM,EAAY,GAAG,CACrB,KACD,CACD,CACA,GAAI,EAAI,SAAS,CAAC,WAAW,CAAE,CAC9B,IAAM,EAAQ,OAAO,IAAI,CAAC,EAAI,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,AAAC,GAC1D,AAAI,EAAE,QAAQ,CAAC,KAAa,CAAP,EAAqB,GAAG,GACtC,IAAM,GAEd,GAAI,EAAO,CACV,IAAM,EAAa,EAAI,SAAS,CAAC,WAAW,CAAC,EAAM,CAC7C,EAAiC,YAAtB,OAAO,EAA4B,MAAM,EAAW,GAAO,EAK5E,GAJI,IACH,EAAS,EAAS,EADL,IACW,CACxB,EAAM,EAAS,GAAG,GAEF,IAAb,EAAoB,MACzB,CACD,CACA,IAAM,EAAU,AA3DjB,SAAS,AAAoB,CAAG,CAAE,CAAiB,UAClD,GAAI,EAAI,OAAO,CAAC,SAAS,EAAE,cAAe,OAAO,EAAI,OAAO,CAAC,SAAS,CAAC,aAAa,CACpF,IAAM,EAAU,EAAI,SAAS,CAAC,OAAO,OACrB,AAAhB,qBAAqC,CAAjC,EAAwC,CAC3C,IAAK,MAAO,IACX,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,gBAAgB,EAAE,IAAI,GACrD,OAAO,EAAO,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,GAAQ,KAAK,CAC1C,EACA,IAAK,MAAO,EAAK,EAAO,KACvB,IAAM,EAAM,GAAmB,QAAU,EAAI,OAAO,CAAC,SAAS,EAAE,QAAU,EAC1E,OAAM,EAAI,OAAO,CAAC,gBAAgB,EAAE,MAAM,EAAK,KAAK,SAAS,CAAC,GAAQ,EACvE,CACD,EACqB,UAAU,CAAtB,EAA6B,CAC/B,IAAN,MAAU,GAAG,AACL,GAAO,GAAG,CAAC,GAEnB,MAAM,IAAI,CAAG,CAAE,CAAK,CAAE,CAAO,EAC5B,GAAO,GAAG,CAAC,EAAK,EACjB,CACD,GA9DM,EAAQ,YACR,EAAK,EAAI,OAAO,CACf,CACN,IAAK,MAAO,IACX,IAAM,EAAO,CAAC,MAAM,EAAG,QAAQ,CAAC,CAC/B,QACA,MAAO,CAAC,CACP,MAAO,MACP,MAAO,CACR,EAAE,AACH,EAAA,CAAE,AAAC,CAAC,EAAE,CAEN,MADiC,UAA7B,OAAO,GAAM,cAA0B,EAAK,WAAW,CAAG,OAAO,EAAK,YAAW,EAC9E,CACR,EACA,IAAK,MAAO,EAAK,EAAO,KACvB,GAAI,CACC,EAAS,MAAM,EAAG,UAAU,CAAC,OAChC,EACA,MAAO,CAAC,CACP,MAAO,MACP,MAAO,CACR,EAAE,CACF,OAAQ,CACP,MAAO,EAAM,KAAK,CAClB,YAAa,EAAM,WAAW,AAC/B,CACD,GACK,MAAM,EAAG,MAAM,CAAC,OACpB,EACA,KAAM,KACL,EACA,MAAO,EAAM,KAAK,CAClB,YAAa,EAAM,WAAW,AAC/B,CACD,EACD,CAAE,MAAO,EAAG,CACX,AA2BoB,EA3BhB,MAAM,CAAC,KAAK,CAAC,2BAA4B,EAC9C,CACD,CACD,EAyBD,EAqCqC,EAAK,CAAE,OAAA,CAAO,GAC5C,EAAO,MAAM,EAAQ,GAAG,CAAC,GACzB,EAAM,KAAK,GAAG,GACpB,GAAK,CAAD,CAKC,KA/HmB,EAAK,CAAF,GAgI1B,GAhIkC,CAgI5B,CAhI8B,CAgIP,EAAM,EAAK,QAhIS,GAgIE,CACnD,IAAI,CAAgB,IAAK,EAhId,AAEL,KAFU,GAAG,GAgIc,AA9HrB,EAAc,WAAW,CADnB,AAAS,EACa,KAAc,EAAc,KAAK,EAAI,EA8HrC,OAAO,AA5HtB,EAUnB,KAAK,GAVwB,CAUpB,CAAC,AAAC,CAkH8D,EAAK,GAAnB,QAA8B,AAlHhE,CADJ,AAAT,IAmH+E,EApHtF,KAAK,CAE4B,EAFzB,EAEyB,CAAG,CAAI,KAT7C,IAAI,SAAS,KAAK,SAAS,CAAC,CAAE,QAAS,4CAA6C,GAAI,CAC9F,OAAQ,IACR,WAAY,oBACZ,QAAS,CAAE,gBAAiB,EAAW,QAAQ,EAAG,CACnD,GAwHU,EAAgC,IAAT,EAAc,MAAM,EAAQ,GAAG,CAAC,EAAK,CACpE,GAAG,CAAI,CACP,MAAO,EACP,YAAa,CACd,GAAG,GACE,MAAM,EAAQ,GAAG,CAAC,EAAK,CAC3B,GAAG,CAAI,CACP,MAAO,EAAK,KAAK,CAAG,EACpB,YAAa,CACd,GAAG,EACJ,MAlBW,MAAM,EAAQ,GAAG,CAAC,EAAK,KACjC,EACA,MAAO,EACP,YAAa,CACd,EAeD,CAaA,SAAS,GAAkB,CAAK,CAAE,CAAG,SAC/B,GACD,EAAI,EADI,KACG,CAAC,CADG,MACI,EAAE,mBAA2B,CAAP,AAAO,EAAA,GAAA,CAAgB,AAAhB,EAAiB,CACpE,IAAK,EAAI,MAAM,CACf,KAAM,CACP,GACO,CACR,CACA,SAAS,GAAa,CAAK,CAAE,CAAG,SAC/B,AAAI,EAAI,OAAO,CAAC,OAAO,EAAE,oBAAsB,EAAc,CAAA,EAAA,EAAP,CAAO,CAAA,AAAgB,EAAC,CAC7E,IAAK,EAAI,MAAM,CACf,KAAM,CACP,GACO,CACR,CAIA,IAAM,GAAmB,GAAmB,iBAAkB,CAC7D,OAAQ,MACR,IAAK,CAAC,GAAkB,CACxB,SAAU,CAAE,QAAS,CACpB,YAAa,mBACb,YAAa,uCACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,QACN,MAAO,CACN,KAAM,SACN,WAAY,CACX,GAAI,CAAE,KAAM,QAAS,EACrB,WAAY,CAAE,KAAM,QAAS,EAC7B,UAAW,CACV,KAAM,SACN,OAAQ,WACT,EACA,UAAW,CACV,KAAM,SACN,OAAQ,WACT,EACA,UAAW,CAAE,KAAM,QAAS,EAC5B,OAAQ,CAAE,KAAM,QAAS,EACzB,OAAQ,CACP,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,CACzB,CACD,EACA,SAAU,CACT,KACA,aACA,YACA,YACA,YACA,SACA,SACA,AACF,CACD,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,IAAM,EAAU,EAAE,OAAO,CAAC,OAAO,CAC3B,EAAW,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAQ,IAAI,CAAC,EAAE,EAC7E,OAAO,EAAE,IAAI,CAAC,EAAS,GAAG,CAAC,AAAC,IAAM,AAAC,CAClC,GAAI,EAAE,EAAE,CACR,WAAY,EAAE,UAAU,CACxB,UAAW,EAAE,SAAS,CACtB,UAAW,EAAE,SAAS,CACtB,UAAW,EAAE,SAAS,CACtB,OAAQ,EAAE,MAAM,CAChB,OAAQ,EAAE,KAAK,EAAE,MAAM,MAAQ,EAAE,AAClC,CAAC,GACF,GACM,GAAoB,GAAmB,eAAgB,CAC5D,OAAQ,OACR,gBAAgB,EAChB,KAAM,EAAA,MAAQ,CAAC,CACd,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,qDAAsD,GAAG,QAAQ,GAC7G,SAAU,GACV,QAAS,EAAA,MAAQ,CAAC,CACjB,MAAO,EAAA,MAAQ,GACf,MAAO,EAAA,MAAQ,GAAG,QAAQ,GAC1B,YAAa,EAAA,MAAQ,GAAG,QAAQ,GAChC,aAAc,EAAA,MAAQ,GAAG,QAAQ,GACjC,OAAQ,EAAA,KAAO,CAAC,EAAA,MAAQ,IAAI,QAAQ,EACrC,GAAG,QAAQ,GACX,cAAe,EAAA,OAAS,GAAG,QAAQ,GACnC,OAAQ,EAAA,KAAO,CAAC,EAAA,MAAQ,IAAI,IAAI,CAAC,CAAE,YAAa,gDAAiD,GAAG,QAAQ,GAC5G,iBAAkB,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,qEAAsE,GAAG,QAAQ,GAClI,gBAAiB,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,6FAA8F,GAAG,QAAQ,GAC1J,eAAgB,EAAA,MAAQ,CAAC,EAAA,MAAQ,GAAI,EAAA,GAAK,IAAI,QAAQ,EACvD,GACA,IAAK,CAAC,GAAkB,CACxB,SAAU,CAAE,QAAS,CACpB,YAAa,oCACb,YAAa,oBACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,IAAK,CACJ,KAAM,SACN,YAAa,+CACd,EACA,SAAU,CACT,KAAM,UACN,YAAa,qEACd,EACA,OAAQ,CAAE,KAAM,SAAU,CAC3B,EACA,SAAU,CAAC,WAAW,AACvB,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,IAAM,EAAU,EAAE,OAAO,CAAC,OAAO,CAC3B,EAAW,EAAE,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,EAAE,IAAI,CAAC,QAAQ,EAC/E,GAAI,CAAC,EAEJ,MADA,EADc,AACZ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,wEAAyE,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACtH,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,GAEhF,GAAI,EAAE,IAAI,CAAC,OAAO,CAAE,CACnB,GAAI,CAAC,EAAS,aAAa,CAE1B,CAF4B,KAC5B,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,kDAAmD,CAAE,SAAU,EAAE,IAAI,CAAC,QAAS,AAAD,GAC/F,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,sBAAsB,AAAC,GAEpF,GAAM,OAAE,CAAK,OAAE,CAAK,CAAE,CAAG,EAAE,IAAI,CAAC,OAAO,CACvC,GAAI,CAAC,MAAM,EAAS,aAAa,CAAC,EAAO,GAExC,KAFgD,CAChD,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAoB,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACjE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAa,AAAC,GAE9E,IAAM,EAAkB,MAAM,EAAS,WAAW,CAAC,CAClD,QAAS,EACT,YAAa,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,CACvC,aAAc,EAAE,IAAI,CAAC,OAAO,CAAC,YAAY,AAC1C,GACA,GAAI,CAAC,GAAmB,CAAC,GAAiB,KAEzC,CAF+C,KAC/C,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA2B,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACxE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,uBAAuB,AAAC,GAExF,IAAM,EAAgB,OAAO,EAAgB,IAAI,CAAC,EAAE,EACpD,GAAI,CAAC,EAAgB,IAAI,CAAC,KAAK,CAE9B,CAFgC,KAChC,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,uBAAwB,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACrE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,oBAAoB,AAAC,GAErF,GAAI,CAAC,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAQ,IAAI,CAAC,GAAE,CAAC,CAAE,IAAI,CAAC,AAAC,GAAM,EAAE,UAAU,GAAK,EAAS,EAAE,EAAI,EAAE,SAAS,GAAK,GAAgB,OAAO,EAAE,IAAI,CAAC,CAC7J,IAAK,GACL,QAAQ,EACR,UAAU,CACX,GACA,GAAI,CAAE,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,kBAAmB,SAAS,EAAS,EAAE,GAAK,CAAC,EAAgB,IAAI,CAAC,aAAa,EAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,WAAY,EAAO,MAAM,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,0CAA2C,GAC3R,GAAI,EAAgB,IAAI,CAAC,KAAK,GAAK,EAAQ,IAAI,CAAC,KAAK,EAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,uBAAyB,GAAM,MAAM,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,mDAAoD,GACrO,GAAI,CACH,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,CAC7C,OAAQ,EAAQ,IAAI,CAAC,EAAE,CACvB,WAAY,EAAS,EAAE,CACvB,UAAW,EACX,YAAa,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,CACvC,QAAS,EACT,aAAc,EAAE,IAAI,CAAC,OAAO,CAAC,YAAY,CACzC,MAAO,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,IACpC,EACD,CAAE,MAAO,EAAG,CACX,MAAM,IAAI,EAAA,QAAQ,CAAC,qBAAsB,CAAE,QAAS,+CAAgD,EACrG,CACA,GAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,wBAAyB,EAAM,GAAI,CACjF,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAQ,IAAI,CAAC,EAAE,CAAE,CAC3D,KAAM,EAAgB,IAAI,EAAE,KAC5B,MAAO,EAAgB,IAAI,EAAE,KAC9B,EACD,CAAE,MAAO,EAAG,CACX,QAAQ,IAAI,CAAC,2BAA6B,EAAE,QAAQ,GACrD,CACA,OAAO,EAAE,IAAI,CAAC,CACb,IAAK,GACL,QAAQ,EACR,UAAU,CACX,EACD,CACA,IAAM,EAAQ,MAAM,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,EAAG,CACpC,OAAQ,EAAQ,IAAI,CAAC,EAAE,CACvB,MAAO,EAAQ,IAAI,CAAC,KAAK,AAC1B,EAAG,EAAE,IAAI,CAAC,cAAc,EAClB,EAAM,MAAM,EAAS,sBAAsB,CAAC,CACjD,MAAO,EAAM,KAAK,CAClB,aAAc,EAAM,YAAY,CAChC,YAAa,CAAA,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,EAAS,EAAE,CAAA,CAAE,CAC3D,OAAQ,EAAE,IAAI,CAAC,MAAM,AACtB,GACA,OAAO,EAAE,IAAI,CAAC,CACb,IAAK,EAAI,QAAQ,GACjB,SAAU,CAAC,EAAE,IAAI,CAAC,eACnB,AADkC,EAEnC,GACM,GAAgB,GAAmB,kBAAmB,CAC3D,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CACd,WAAY,EAAA,MAAQ,GACpB,UAAW,EAAA,MAAQ,GAAG,QAAQ,EAC/B,GACA,IAAK,CAAC,GAAuB,CAC7B,SAAU,CAAE,QAAS,CACpB,YAAa,oBACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,OAAQ,CAAE,KAAM,SAAU,CAAE,CAC3C,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAM,CAAE,YAAU,WAAE,CAAS,CAAE,CAAG,EAAI,IAAI,CACpC,EAAW,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAC3F,GAAI,AAAoB,MAAX,MAAM,EAAU,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,kBAAmB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,6BAA6B,AAAC,GAC1L,IAAM,EAAe,EAAS,IAAI,CAAC,AAAC,GAAY,EAAY,EAAQ,SAAS,GAAK,GAAa,EAAQ,UAAU,GAAK,EAAa,EAAQ,UAAU,GAAK,GAC1J,GAAI,CAAC,EAAc,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,iBAAiB,AAAC,GAEnG,OADA,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAa,EAAE,EACxD,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,GACM,GAAiB,GAAmB,oBAAqB,CAC9D,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CACd,WAAY,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,wCAAyC,GACpF,UAAW,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,kDAAmD,GAAG,QAAQ,GACxG,OAAQ,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,yCAA0C,GAAG,QAAQ,EAC7F,GACA,SAAU,CAAE,QAAS,CACpB,YAAa,sDACb,UAAW,CACV,IAAK,CACJ,YAAa,uBACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,UAAW,CAAE,KAAM,QAAS,EAC5B,QAAS,CAAE,KAAM,QAAS,EAC1B,YAAa,CAAE,KAAM,QAAS,EAC9B,aAAc,CAAE,KAAM,QAAS,EAC/B,qBAAsB,CACrB,KAAM,SACN,OAAQ,WACT,EACA,sBAAuB,CACtB,KAAM,SACN,OAAQ,WACT,CACD,CACD,CAAE,CAAE,CACL,EACA,IAAK,CAAE,YAAa,iDAAkD,CACvE,CACD,CAAE,CACH,EAAG,MAAO,IACT,IAQI,EARE,QAQQ,IARN,CAQW,AARD,WAAE,CAAS,QAAE,CAAM,CAAE,CAAG,EAAI,IAAI,EAAI,CAAC,EACjD,EAAM,EAAI,OAAO,CACjB,EAAU,MAAM,GAAkB,GACxC,GAAI,GAAO,CAAC,EAAS,MAAM,EAAI,KAAK,CAAC,gBACrC,IAAI,EAAiB,GAAS,MAAM,IAAM,EAC1C,GAAI,CAAC,EAAgB,MAAM,EAAI,KAAK,CAAC,gBACrC,GAAI,CAAC,EAAI,OAAO,CAAC,eAAe,CAAC,IAAI,CAAE,AAAD,GAAO,EAAE,EAAE,GAAK,GAAa,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAC,SAAS,EAAE,EAAW,kBAAkB,CAAE,AAAD,GAC1J,IAAM,EAAc,MAAM,GAAiB,GAI3C,GAAI,CAAC,CAFqG,EAAtG,GAAe,IAAe,EAAY,UAAU,GAAK,CAAD,AAAE,GAAa,EAAY,EAAE,GAAK,CAAA,CAAS,CAAa,EACrG,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAA,CAAe,CAAE,IAAI,CAAC,AAAC,GAAQ,EAAY,EAAI,EAAE,GAAK,GAAa,EAAI,UAAU,GAAK,EAAa,EAAI,UAAU,GAAK,IACvK,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,mBAAoB,GAC/E,IAAM,EAAW,EAAI,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,GAClE,GAAI,CAAC,EAAU,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAC,SAAS,EAAE,EAAW,WAAW,CAAC,AAAC,GAChG,GAAI,CACH,IAAI,EAAY,KACV,EAAqB,EAAQ,oBAAoB,EAAI,IAAI,KAAK,EAAQ,oBAAoB,EAAE,OAAO,GAAK,KAAK,GAAG,GAAK,IAC3H,GAAI,EAAQ,YAAY,EAAI,GAAsB,EAAS,kBAAkB,CAAE,CAC9E,IAAM,EAAiB,MAAM,GAAkB,EAAQ,YAAY,CAAE,EAAI,OAAO,EAChF,EAAY,MAAM,EAAS,kBAAkB,CAAC,GAC9C,IAAM,EAAiB,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAQ,EAAE,CAAE,CAClF,YAAa,MAAM,GAAa,EAAU,WAAW,CAAE,EAAI,OAAO,EAClE,qBAAsB,EAAU,oBAAoB,CACpD,aAAc,MAAM,GAAa,EAAU,YAAY,CAAE,EAAI,OAAO,EACpE,sBAAuB,EAAU,qBAAqB,AACvD,GACI,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,oBAAsB,GAAgB,MAAM,GAAiB,EAAK,EACpG,CACA,IAAM,EAAS,CACd,YAAa,GAAW,aAAe,MAAM,GAAkB,EAAQ,WAAW,EAAI,GAAI,EAAI,OAAO,EACrG,qBAAsB,GAAW,sBAAwB,EAAQ,oBAAoB,EAAI,KAAK,EAC9F,OAAQ,EAAQ,KAAK,EAAE,MAAM,MAAQ,EAAE,CACvC,QAAS,GAAW,SAAW,EAAQ,OAAO,EAAI,KAAK,CACxD,EACA,OAAO,EAAI,IAAI,CAAC,EACjB,CAAE,MAAO,EAAS,CACjB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CACjC,QAAS,qCACT,MAAO,CACR,EACD,CACD,GACM,GAAe,GAAmB,iBAAkB,CACzD,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CACd,WAAY,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,wCAAyC,GACpF,UAAW,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,kDAAmD,GAAG,QAAQ,GACxG,OAAQ,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,yCAA0C,GAAG,QAAQ,EAC7F,GACA,SAAU,CAAE,QAAS,CACpB,YAAa,iDACb,UAAW,CACV,IAAK,CACJ,YAAa,sCACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,UAAW,CAAE,KAAM,QAAS,EAC5B,QAAS,CAAE,KAAM,QAAS,EAC1B,YAAa,CAAE,KAAM,QAAS,EAC9B,aAAc,CAAE,KAAM,QAAS,EAC/B,qBAAsB,CACrB,KAAM,SACN,OAAQ,WACT,EACA,sBAAuB,CACtB,KAAM,SACN,OAAQ,WACT,CACD,CACD,CAAE,CAAE,CACL,EACA,IAAK,CAAE,YAAa,iDAAkD,CACvE,CACD,CAAE,CACH,EAAG,MAAO,IACT,IASI,EAKA,EAdE,MASQ,KAAK,CATX,CAAU,EAcG,KAAK,IAdN,CAAS,CAAE,QAAM,CAAE,CAAG,EAAI,IAAI,CAC5C,EAAM,EAAI,OAAO,CACjB,EAAU,MAAM,GAAkB,GACxC,GAAI,GAAO,CAAC,EAAS,MAAM,EAAI,KAAK,CAAC,gBACrC,IAAI,EAAiB,GAAS,MAAM,IAAM,EAC1C,GAAI,CAAC,EAAgB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAC,oCAAoC,CAAC,AAAC,GACzG,IAAM,EAAW,EAAI,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,GAClE,GAAI,CAAC,EAAU,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAC,SAAS,EAAE,EAAW,WAAW,CAAC,AAAC,GAChG,GAAI,CAAC,EAAS,kBAAkB,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,CAAC,SAAS,EAAE,EAAW,mCAAmC,CAAC,AAAC,GAE3I,IAAM,EAAc,MAAM,GAAiB,GAG3C,GAAI,CAAC,CAFuE,EAAxE,IAAgB,CAAC,GAAc,IAAe,GAA/B,AAA4C,UAAA,CAAU,CAAa,EACvE,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAA,CAAe,CAAE,IAAI,CAAE,AAAD,GAAS,EAAY,EAAI,EAAE,GAAK,GAAa,EAAI,UAAU,GAAK,EAAa,EAAI,UAAU,GAAK,IACvK,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,mBAAoB,GAI/E,GAAI,CAAC,CAFqD,EAAtD,GAAe,IAAe,EAAY,UAAU,CAAmB,EAAY,YAAY,EAAI,KAAK,EACtF,EAAQ,YAAY,EAAI,KAAK,GAC9B,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,yBAA0B,GAC5F,GAAI,CACH,IAAM,EAAwB,MAAM,GAAkB,EAAgB,EAAI,OAAO,EAC3E,EAAS,MAAM,EAAS,kBAAkB,CAAC,GACjD,GAAI,EAAQ,EAAE,CAAE,CACf,IAAM,EAAa,CAClB,GAAG,GAAW,CAAC,CAAC,CAChB,YAAa,MAAM,GAAa,EAAO,WAAW,CAAE,EAAI,OAAO,EAC/D,aAAc,MAAM,GAAa,EAAO,YAAY,CAAE,EAAI,OAAO,EACjE,qBAAsB,EAAO,oBAAoB,CACjD,sBAAuB,EAAO,qBAAqB,CACnD,MAAO,EAAO,MAAM,EAAE,KAAK,MAAQ,EAAQ,KAAK,CAChD,QAAS,EAAO,OAAO,EAAI,EAAQ,OAAO,AAC3C,CACA,OAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAQ,EAAE,CAAE,EAC7D,CAUA,OATI,GAAe,IAAe,EAAY,UAAU,EAAI,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,oBAAoB,MAAM,GAAiB,EAAK,CACxI,GAAG,CAAW,CACd,YAAa,MAAM,GAAa,EAAO,WAAW,CAAE,EAAI,OAAO,EAC/D,aAAc,MAAM,GAAa,EAAO,YAAY,CAAE,EAAI,OAAO,EACjE,qBAAsB,EAAO,oBAAoB,CACjD,sBAAuB,EAAO,qBAAqB,CACnD,MAAO,EAAO,MAAM,EAAE,KAAK,MAAQ,EAAY,KAAK,CACpD,QAAS,EAAO,OAAO,EAAI,EAAY,OAAO,AAC/C,GACO,EAAI,IAAI,CAAC,CACf,YAAa,EAAO,WAAW,CAC/B,aAAc,EAAO,YAAY,CACjC,qBAAsB,EAAO,oBAAoB,CACjD,sBAAuB,EAAO,qBAAqB,CACnD,MAAO,EAAO,MAAM,EAAE,KAAK,MAAQ,EAAQ,KAAK,CAChD,QAAS,EAAO,OAAO,EAAI,EAAQ,OAAO,CAC1C,WAAY,EAAQ,UAAU,CAC9B,UAAW,EAAQ,SACpB,AAD6B,EAE9B,CAAE,MAAO,EAAS,CACjB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CACjC,QAAS,iCACT,MAAO,CACR,EACD,CACD,GAEM,GAAc,GAAmB,gBAAiB,CACvD,OAAQ,MACR,IAAK,CAAC,GAAkB,CACxB,SAAU,CAAE,QAAS,CACpB,YAAa,gDACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,KAAM,CACL,KAAM,SACN,WAAY,CACX,GAAI,CAAE,KAAM,QAAS,EACrB,KAAM,CAAE,KAAM,QAAS,EACvB,MAAO,CAAE,KAAM,QAAS,EACxB,MAAO,CAAE,KAAM,QAAS,EACxB,cAAe,CAAE,KAAM,SAAU,CAClC,EACA,SAAU,CAAC,KAAM,gBAAgB,AAClC,EACA,KAAM,CACL,KAAM,SACN,WAAY,CAAC,EACb,sBAAsB,CACvB,CACD,EACA,SAAU,CAAC,OAAQ,OAAO,CAC1B,sBAAsB,CACvB,CAAE,CAAE,CACL,CAAE,CACH,CAAE,EACF,MAjC8B,CAiCvB,CAjCuB,QAAU,CAAC,EAAA,MAAQ,CAAC,CAAE,UAAW,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iEAAkE,GAAG,QAAQ,EAAG,GAkC/K,EAAG,MAAO,IACT,IACI,EADE,EAAoB,EAAI,IAChB,CADqB,EAAE,EAClB,QACnB,GAAK,CAAD,CAKG,CACN,IAAM,EAAc,MAAM,EAAI,EANP,KAMc,CAAC,eAAe,CAAC,WAAW,CAAC,GAC9D,IAAa,EAAU,CAAA,CAC5B,MAPC,GAAI,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,mBAAoB,CACpD,IAAM,EAAc,MAAM,GAAiB,GACvC,IAAa,EAAU,CAAA,CAC5B,CAKD,GAAI,CAAC,GAAW,EAAQ,MAAM,GAAK,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,mBAAoB,GACjI,IAAM,EAAW,EAAI,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,EAAQ,UAAU,EACpF,GAAI,CAAC,EAAU,MAAM,IAAI,EAAA,QAAQ,CAAC,wBAAyB,CAAE,QAAS,CAAC,6BAA6B,EAAE,EAAQ,UAAU,CAAC,yBAAyB,CAAC,AAAC,GACpJ,IAAM,EAAS,MAAM,GAAe,CACnC,GAAG,CAAG,CACN,OAAQ,OACR,KAAM,CACL,UAAW,EAAQ,EAAE,CACrB,WAAY,EAAQ,UACrB,AAD+B,EAE/B,eAAe,EACf,cAAc,CACf,GACA,GAAI,CAAC,EAAO,WAAW,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,wBAAyB,GAC/F,IAAM,EAAO,MAAM,EAAS,WAAW,CAAC,CACvC,GAAG,CAAM,CACT,YAAa,EAAO,WACrB,AADgC,GAEhC,OAAO,EAAI,IAAI,CAAC,EACjB,GAIA,eAAe,GAAoB,CAAC,CAAE,UAAE,CAAQ,SAAE,CAAO,CAAE,aAAW,eAAE,CAAa,kBAAE,CAAgB,CAAE,EACxG,IAAM,EAAS,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAS,KAAK,CAAC,WAAW,GAAI,EAAQ,SAAS,CAAE,EAAQ,UAAU,EAAE,KAAK,CAAC,AAAC,IACxI,GAAA,MAAM,CAAC,KAAK,CAAC,0DAA2D,GACxE,IAAM,EAAW,EAAE,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,UAAY,CAAA,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,AACvF,OAAM,EAAE,QAAQ,CAAC,CAAA,EAAG,EAAS,4BAA4B,CAAC,CAC3D,GACI,EAAO,GAAQ,KACf,EAAa,CAAC,EAClB,GAAI,EAAQ,CACX,IAAM,EAAgB,EAAO,QAAQ,CAAC,IAAI,CAAE,AAAD,GAAO,EAAE,UAAU,GAAK,EAAQ,UAAU,EAAI,EAAE,SAAS,GAAK,EAAQ,SAAS,EAC1H,GAAK,CAAD,CA4BG,CACN,GAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,yBAA0B,EAAO,CAC/D,IAAM,EAAa,OAAO,WAAW,CAAC,OAAO,OAAO,CAAC,CACpD,QAAS,EAAQ,OAAO,CACxB,YAAa,MAAM,GAAa,EAAQ,WAAW,CAAE,EAAE,OAAO,EAC9D,aAAc,MAAM,GAAa,EAAQ,YAAY,CAAE,EAAE,OAAO,EAChE,qBAAsB,EAAQ,oBAAoB,CAClD,sBAAuB,EAAQ,qBAAqB,CACpD,MAAO,EAAQ,KAAK,AACrB,GAAG,MAAM,CAAC,CAAC,CAAC,EAAG,EAAM,GAAK,AAAU,KAAK,QACrC,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,oBAAoB,MAAM,GAAiB,EAAG,GACzE,OAAO,IAAI,CAAC,GAAY,MAAM,CAAG,GAAG,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAc,EAAE,CAAE,EACzG,CACI,EAAS,aAAa,EAAI,CAAC,EAAO,IAAI,CAAC,aAAa,EAAI,EAAS,KAAK,CAAC,WAAW,KAAO,EAAO,IAAI,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAO,IAAI,CAAC,EAAE,CAAE,CAAE,eAAe,CAAK,EAClM,KA1CoB,CACnB,GAAI,CAAE,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,kBAAmB,SAAS,EAAQ,UAAU,GAAK,CAAC,EAAS,aAAa,EAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,WAAY,EAErL,KAF4L,CACxL,CAAA,EAAA,EAAA,CAAA,AAAa,KAAI,GAAA,MAAM,CAAC,IAAI,CAAC,CAAC,+CAA+C,EAAE,EAAQ,UAAU,CAAC,2IAA2I,CAAC,EAC3O,CACN,MAAO,qBACP,KAAM,IACP,EAED,GAAI,CACH,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,CAC3C,WAAY,EAAQ,UAAU,CAC9B,UAAW,EAAS,EAAE,CAAC,QAAQ,GAC/B,OAAQ,EAAO,IAAI,CAAC,EAAE,CACtB,YAAa,MAAM,GAAa,EAAQ,WAAW,CAAE,EAAE,OAAO,EAC9D,aAAc,MAAM,GAAa,EAAQ,YAAY,CAAE,EAAE,OAAO,EAChE,QAAS,EAAQ,OAAO,CACxB,qBAAsB,EAAQ,oBAAoB,CAClD,sBAAuB,EAAQ,qBAAqB,CACpD,MAAO,EAAQ,KAAK,AACrB,EACD,CAAE,MAAO,EAAG,CAEX,OADA,GAAA,MAAM,CAAC,KAAK,CAAC,yBAA0B,GAChC,CACN,MAAO,yBACP,KAAM,IACP,CACD,CACI,EAAS,aAAa,EAAI,CAAC,EAAO,IAAI,CAAC,aAAa,EAAI,EAAS,KAAK,CAAC,WAAW,KAAO,EAAO,IAAI,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAO,IAAI,CAAC,EAAE,CAAE,CAAE,eAAe,CAAK,EAClM,CAeA,GAAI,EAAkB,CACrB,GAAM,CAAE,GAAI,CAAC,CAAE,GAAG,EAAc,CAAG,EACnC,EAAO,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAO,IAAI,CAAC,EAAE,CAAE,CACjE,GAAG,CAAY,CACf,MAAO,EAAS,KAAK,CAAC,WAAW,GACjC,cAAe,EAAS,KAAK,CAAC,WAAW,KAAO,EAAO,IAAI,CAAC,KAAK,EAAG,EAAO,IAAI,CAAC,aAAa,EAAI,EAAS,aAAa,AACxH,EACD,CAF4H,AAG7H,KAAO,CACN,GAAI,AAJiI,EAIlH,MAAO,CACzB,IALiJ,EAK1I,kBACP,KAAM,KACN,YAAY,CACb,EACA,GAAI,CACH,GAAM,CAAE,GAAI,CAAC,CAAE,GAAG,EAAc,CAAG,EAC7B,EAAc,CACnB,YAAa,MAAM,GAAa,EAAQ,WAAW,CAAE,EAAE,OAAO,EAC9D,aAAc,MAAM,GAAa,EAAQ,YAAY,CAAE,EAAE,OAAO,EAChE,QAAS,EAAQ,OAAO,CACxB,qBAAsB,EAAQ,oBAAoB,CAClD,sBAAuB,EAAQ,qBAAqB,CACpD,MAAO,EAAQ,KAAK,CACpB,WAAY,EAAQ,UAAU,CAC9B,UAAW,EAAS,EAAE,CAAC,QAAQ,EAChC,EACM,CAAE,KAAM,CAAW,CAAE,QAAS,CAAc,CAAE,CAAG,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,CACtG,GAAG,CAAY,CACf,MAAO,EAAS,KAAK,CAAC,WAAW,EAClC,EAAG,GAGH,GAFA,EAAO,EACH,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,oBAAoB,MAAM,GAAiB,EAAG,GACzE,CAAC,EAAS,aAAa,EAAI,GAAQ,EAAE,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,aAAc,CACzF,IAAM,EAAQ,MAAM,GAA6B,EAAE,OAAO,CAAC,MAAM,CAAE,EAAK,KAAK,CAAE,KAAK,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WACtH,EAAM,CAAA,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAM,aAAa,EAAE,EAAA,CAAa,AACzF,OAAM,EAAE,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,wBAAwB,MAClE,MACA,QACA,CACD,EAAG,EAAE,OAAO,CACb,CACD,CAAE,MAAO,EAAG,CAEX,GADA,GAAA,MAAM,CAAC,KAAK,CAAC,GACT,aAAa,EAAA,QAAU,CAAE,MAAO,CACnC,MAAO,EAAE,OAAO,CAChB,KAAM,KACN,YAAY,CACb,EACA,MAAO,CACN,MAAO,wBACP,KAAM,KACN,YAAY,CACb,CACD,CACD,CACA,GAAI,CAAC,EAAM,MAAO,CACjB,MAAO,wBACP,KAAM,KACN,WAAY,EACb,EACA,IAAM,EAAU,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAK,EAAE,SACrE,AAAK,EAKE,CACN,CANG,IAMG,CANO,QAOZ,OACA,CACD,EACA,MAAO,gBACP,CACD,EAZqB,CACpB,MAAO,2BACP,KAAM,KACN,YAAY,CACb,CASD,CAIA,IAAM,GAAS,EAAA,MAAQ,CAAC,CACvB,KAAM,EAAA,MAAQ,GAAG,QAAQ,GACzB,MAAO,EAAA,MAAQ,GAAG,QAAQ,GAC1B,UAAW,EAAA,MAAQ,GAAG,QAAQ,GAC9B,kBAAmB,EAAA,MAAQ,GAAG,QAAQ,GACtC,MAAO,EAAA,MAAQ,GAAG,QAAQ,GAC1B,KAAM,EAAA,MAAQ,GAAG,QAAQ,EAC1B,GACM,GAAgB,GAAmB,gBAAiB,CACzD,OAAQ,CAAC,MAAO,OAAO,CACvB,YAAa,sBACb,KAAM,GAAO,QAAQ,GACrB,MAAO,GAAO,QAAQ,GACtB,SAAU,CACT,GAAG,EAAA,CAAa,CAChB,kBAAmB,CAAC,oCAAqC,mBAAmB,AAC7E,CACD,EAAG,MAAO,IAET,IADI,EA8CA,EA0FA,EAvIE,EAAkB,EAAE,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,UAAY,CAAA,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAC9F,GAAiB,SAAb,EAAE,MAAM,CAAa,CACxB,IAAM,EAAW,EAAE,IAAI,CAAG,GAAO,KAAK,CAAC,EAAE,IAAI,EAAI,CAAC,EAC5C,EAAY,EAAE,KAAK,CAAG,GAAO,KAAK,CAAC,EAAE,KAAK,EAAI,CAAC,EAC/C,EAAa,GAAO,KAAK,CAAC,CAC/B,GAAG,CAAQ,CACX,GAAG,CAAS,AACb,GACM,EAAS,IAAI,gBACnB,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,SAAiB,GAAJ,AAAwC,EAAO,GAAG,CAAC,CAArC,CAA0C,IAArC,GAA4C,EAAvC,EAC/E,IAAM,EAAc,CAAA,CADqE,CAClE,EAAE,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,EAAO,QAAQ,GAAA,CAAI,AACvF,OAAM,EAAE,QAAQ,CAAC,EAClB,CACA,GAAI,CACH,GAAiB,QAAb,EAAE,MAAM,CAAY,EAAc,GAAO,KAAK,CAAC,EAAE,KAAK,OACrD,GAAiB,SAAb,EAAE,MAAM,CAAa,EAAc,GAAO,KAAK,CAAC,EAAE,IAAI,OAC1D,MAAM,AAAI,MAAM,qBACtB,CAAE,MAAO,EAAG,CAEX,MADA,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,2BAA4B,GAC7C,EAAE,QAAQ,CAAC,CAAA,EAAG,EAAgB,+BAA+B,CAAC,CACrE,CACA,GAAM,MAAE,CAAI,CAAE,MAAO,CAAO,OAAE,CAAK,mBAAE,CAAiB,WAAE,CAAS,CAAE,CAAG,EACtE,GAAI,CAAC,EAAO,CACX,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAmB,GAC1C,IAAM,EAAM,CAAA,EAAG,EAAA,EAAkB,EAAgB,QAAQ,CAAC,KAAO,IAAM,IAAI,qBAAqB,CAAC,AACjG,OAAM,EAAE,QAAQ,CAAC,EAClB,CACA,GAAM,cAAE,CAAY,CAAE,aAAW,MAAE,CAAI,UAAE,CAAQ,YAAE,CAAU,eAAE,CAAa,CAAE,CAAG,MAAM,CAAA,EAAA,EAAA,CAAA,AAAU,EAAC,GAClG,SAAS,EAAgB,CAAO,CAAE,CAAW,EAC5C,IAAM,EAAU,GAAY,EACtB,EAAS,IAAI,gBAAgB,CAAE,MAAO,CAAQ,EAChD,IAAa,EAAO,GAAG,CAAC,oBAAqB,GACjD,IAAM,EAAM,CAAA,EAAG,EAAA,EAAU,EAAQ,QAAQ,CAAC,KAAO,IAAM,IAAA,EAAM,EAAO,QAAQ,GAAA,CAAI,AAChF,OAAM,EAAE,QAAQ,CAAC,EAClB,CAEA,GADI,GAAS,EAAgB,EAAS,GAClC,CAAC,EAEJ,IAFU,EACV,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,kBACjB,EAAgB,WAEvB,IAAM,EAAW,EAAE,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,EAAE,MAAM,CAAC,EAAE,EAC3E,GAAI,CAAC,EAEJ,MADA,EADc,AACZ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,yBAA0B,EAAE,MAAM,CAAC,EAAE,CAAE,aACxD,EAAgB,4BAGvB,GAAI,CACH,EAAS,MAAM,EAAS,yBAAyB,CAAC,MACjD,eACA,EACA,SAAU,EACV,YAAa,CAAA,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,EAAS,EAAE,CAAA,CAAE,AAC5D,EACD,CAAE,MAAO,EAAG,CAEX,MADA,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAI,GACrB,EAAgB,eACvB,CACA,IAAM,EAAW,MAAM,EAAS,WAAW,CAAC,CAC3C,GAAG,CAAM,CACT,KAAM,EAAE,IAAI,EAAE,KAAO,CAAA,EAAA,EAAA,CAAa,AAAb,EAAc,EAAE,IAAI,CAAC,IAAI,EAAI,KAAK,CACxD,GAAG,IAAI,CAAC,AAAC,GAAQ,GAAK,MACtB,GAAI,CAAC,EAEJ,OADA,CADc,CACZ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,2BAChB,EAAgB,2BAExB,GAAI,CAAC,EAEJ,MADA,EAAE,GADe,IACR,CAAC,MAAM,CAAC,KAAK,CAAC,yBACjB,EAAgB,mBAEvB,GAAI,EAAM,KA2BL,EA1BJ,GAAI,CAAE,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,kBAAmB,SAAS,EAAS,EAAE,GAAK,CAAC,EAAS,aAAa,EAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,UAAY,GAE9K,IAFqL,GACrL,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,+CAChB,EAAgB,0BAExB,GAAI,EAAS,KAAK,GAAK,EAAK,KAAK,EAAI,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,gBAAgB,wBAAyB,EAAM,OAAO,EAAgB,uBACtI,IAAM,EAAkB,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,OAAO,EAAS,EAAE,GACtF,GAAI,EAAiB,CACpB,GAAI,EAAgB,MAAM,CAAC,QAAQ,KAAO,EAAK,MAAM,CAAC,QAAQ,GAAI,OAAO,EAAgB,4CACzF,IAAM,EAAa,OAAO,WAAW,CAAC,OAAO,OAAO,CAAC,CACpD,YAAa,MAAM,GAAa,EAAO,WAAW,CAAE,EAAE,OAAO,EAC7D,aAAc,MAAM,GAAa,EAAO,YAAY,CAAE,EAAE,OAAO,EAC/D,QAAS,EAAO,OAAO,CACvB,qBAAsB,EAAO,oBAAoB,CACjD,sBAAuB,EAAO,qBAAqB,CACnD,MAAO,EAAO,MAAM,EAAE,KAAK,IAC5B,GAAG,MAAM,CAAC,CAAC,CAAC,EAAG,EAAM,GAAe,KAAK,IAAf,GAC1B,OAAM,EAAE,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAgB,EAAE,CAAE,EACnE,MAAO,GAAI,CAAC,MAAM,EAAE,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,CACzD,OAAQ,EAAK,MAAM,CACnB,WAAY,EAAS,EAAE,CACvB,UAAW,OAAO,EAAS,EAAE,EAC7B,GAAG,CAAM,CACT,YAAa,MAAM,GAAa,EAAO,WAAW,CAAE,EAAE,OAAO,EAC7D,aAAc,MAAM,GAAa,EAAO,YAAY,CAAE,EAAE,OAAO,EAC/D,MAAO,EAAO,MAAM,EAAE,KAAK,IAC5B,GAAI,OAAO,EAAgB,0BAE3B,GAAI,CACH,EAAiB,EAAY,QAAQ,EACtC,CAAE,KAAM,CACP,EAAiB,CAClB,CACA,MAAM,EAAE,QAAQ,CAAC,EAClB,CACA,GAAI,CAAC,EAAS,KAAK,CAElB,CAFoB,MACpB,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,kGAChB,EAAgB,mBAExB,IAAM,EAAc,CACnB,WAAY,EAAS,EAAE,CACvB,UAAW,OAAO,EAAS,EAAE,EAC7B,GAAG,CAAM,CACT,MAAO,EAAO,MAAM,EAAE,KAAK,IAC5B,EACM,EAAS,MAAM,GAAoB,EAAG,CAC3C,SAAU,CACT,GAAG,CAAQ,CACX,GAAI,OAAO,EAAS,EAAE,EACtB,MAAO,EAAS,KAAK,CACrB,KAAM,EAAS,IAAI,EAAI,EAAS,KAAK,AACtC,EACA,QAAS,cACT,EACA,cAAe,EAAS,qBAAqB,EAAI,CAAC,GAAiB,EAAS,OAAO,EAAE,cACrF,iBAAkB,EAAS,OAAO,EAAE,wBACrC,GACA,GAAI,EAAO,KAAK,CAEf,CAFiB,MACjB,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAO,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,MAC7C,EAAgB,EAAO,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,MAErD,GAAM,SAAE,CAAO,MAAE,CAAI,CAAE,CAAG,EAAO,IAAI,AACrC,OAAM,GAAiB,EAAG,SACzB,OACA,CACD,GAEA,GAAI,CACH,EAAe,CAAC,EAAO,UAAU,EAAG,GAAc,CAAc,CAAW,CAAE,QAAQ,EACtF,CADiE,AAC/D,KAAM,CACP,EAAe,EAAO,UAAU,EAAG,GAAc,CAClD,CACA,MAAM,EAAE,IAFwD,IAEhD,CAAC,EAClB,GAIA,eAAe,GAA6B,CAAM,CAAE,CAAK,CAAE,CAAQ,CAAE,EAAY,IAAI,CAAE,CAAY,EAClG,OAAO,MAAM,CAAA,EAAA,GAAA,CAAO,AAAP,EAAQ,CACpB,MAAO,EAAM,WAAW,YACxB,EACA,GAAG,CAAY,AAChB,EAAG,EAAQ,EACZ,CAIA,eAAe,GAAwB,CAAG,CAAE,CAAI,EAC/C,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,sBAE3C,CAFkE,KAClE,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qCACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,kCAAmC,GAEjF,IAAM,EAAQ,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAK,KAAK,CAAE,KAAK,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WAC1H,EAAc,EAAI,IAAI,CAAC,WAAW,CAAG,mBAAmB,EAAI,IAAI,CAAC,WAAW,EAAI,mBAAmB,KACnG,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAM,aAAa,EAAE,EAAA,CAAa,AAC3F,OAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,CACjE,WACA,QACA,CACD,EAAG,EAAI,OAAO,CACf,CACA,IAAM,GAAwB,GAAmB,2BAA4B,CAC5E,OAAQ,OACR,YAAa,wBACb,KAAM,EAAA,MAAQ,CAAC,CACd,MAAO,EAAA,KAAO,GAAG,IAAI,CAAC,CAAE,YAAa,6CAA8C,GACnF,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,gDAAiD,GAAG,QAAQ,EACzG,GACA,SAAU,CAAE,QAAS,CACpB,YAAa,wBACb,YAAa,wCACb,YAAa,CAAE,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACvD,KAAM,SACN,WAAY,CACX,MAAO,CACN,KAAM,SACN,YAAa,8CACb,QAAS,kBACV,EACA,YAAa,CACZ,KAAM,SACN,YAAa,iDACb,QAAS,+BACT,UAAU,CACX,CACD,EACA,SAAU,CAAC,QAAQ,AACpB,CAAE,CAAE,CAAE,EACN,UAAW,CACV,IAAO,CACN,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,OAAQ,CACrB,KAAM,UACN,YAAa,+CACb,SAAS,CACV,CAAE,CACH,CAAE,CAAE,CACL,EACA,IAAO,CACN,YAAa,cACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,QAAS,CACtB,KAAM,SACN,YAAa,gBACb,QAAS,kCACV,CAAE,CACH,CAAE,CAAE,CACL,CACD,CACD,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,sBAE3C,CAFkE,KAClE,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qCACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,kCAAmC,GAEjF,GAAM,OAAE,CAAK,CAAE,CAAG,EAAI,IAAI,CACpB,EAAU,MAAM,GAAkB,GACxC,GAAI,CAAC,EAAS,CACb,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,UAC1D,EAIL,IAJW,EAIL,GAAwB,EAAK,EAAK,IAAI,EAH3C,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAO,KAAK,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WACtG,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAIjC,CACA,GAAI,GAAS,KAAK,cAAe,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,+DAAgE,GAC9I,GAAI,GAAS,KAAK,QAAU,EAAO,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,0DAA2D,GAE3I,OADA,MAAM,GAAwB,EAAK,EAAQ,IAAI,EACxC,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,GACM,GAAc,GAAmB,gBAAiB,CACvD,OAAQ,MACR,YAAa,cACb,MAAO,EAAA,MAAQ,CAAC,CACf,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,+BAAgC,GACtE,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iDAAkD,GAAG,QAAQ,EAC1G,GACA,IAAK,CAAC,GAAa,AAAD,GAAS,EAAI,KAAK,CAAC,WAAW,EAAE,CAClD,SAAU,CAAE,QAAS,CACpB,YAAa,+BACb,WAAY,CAAC,CACZ,KAAM,QACN,GAAI,QACJ,YAAa,gCACb,UAAU,EACV,OAAQ,CAAE,KAAM,QAAS,CAC1B,EAAG,CACF,KAAM,cACN,GAAI,QACJ,YAAa,kDACb,UAAU,EACV,OAAQ,CAAE,KAAM,QAAS,CAC1B,EAAE,CACF,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,KAAM,CACL,KAAM,SACN,KAAM,2BACP,EACA,OAAQ,CACP,KAAM,UACN,YAAa,kDACd,CACD,EACA,SAAU,CAAC,OAAQ,SAAS,AAC7B,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,QASL,EARJ,SAAS,EAAgB,CAAO,EAC/B,GAAI,EAAI,KAAK,CAAC,WAAW,CAAE,CAC1B,GAAI,EAAI,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAM,MAAM,EAAI,QAAQ,CAAC,CAAA,EAAG,EAAI,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,EAAA,CAAS,CACvG,OAAM,EAAI,QAAQ,CAAC,CAAA,EAAG,EAAI,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,EAAA,CAAS,CAC/D,CACA,MAAM,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,CAAQ,EACvD,CACA,GAAM,OAAE,CAAK,CAAE,CAAG,EAAI,KAAK,CAE3B,GAAI,CACH,EAAM,MAAM,CAAA,EAAA,GAAA,SAAS,AAAT,EAAU,EAAO,IAAI,cAAc,MAAM,CAAC,EAAI,OAAO,CAAC,MAAM,EAAG,CAAE,WAAY,CAAC,QAAS,AAAD,EACnG,CAAE,MAAO,EAAG,CACX,GAAI,aAAa,GAAA,UAAU,CAAE,OAAO,EAAgB,iBACpD,OAAO,EAAgB,gBACxB,CACA,IAAM,EAAS,EAAA,MAAQ,CAAC,CACvB,MAAO,EAAA,KAAO,GACd,SAAU,EAAA,MAAQ,GAAG,QAAQ,GAC7B,YAAa,EAAA,MAAQ,GAAG,QAAQ,EACjC,GAAG,KAAK,CAAC,EAAI,OAAO,EACd,EAAO,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,EAAO,KAAK,EAC3E,GAAI,CAAC,EAAM,OAAO,EAAgB,kBAClC,GAAI,EAAO,QAAQ,CAAE,CACpB,IAAI,EAAU,MAAM,GAAkB,GACtC,GAAI,GAAW,EAAQ,IAAI,CAAC,KAAK,GAAK,EAAO,KAAK,CAAE,OAAO,EAAgB,gBAC3E,GAA2B,8BAAvB,EAAO,WAAW,CAAkC,CACvD,IAAM,EAAa,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAO,KAAK,CAAE,EAAO,QAAQ,CAAE,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,UAAW,CAAE,YAAa,2BAA4B,GAChM,EAAsB,EAAI,KAAK,CAAC,WAAW,CAAG,mBAAmB,EAAI,KAAK,CAAC,WAAW,EAAI,mBAAmB,KAC7G,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAW,aAAa,EAAE,EAAA,CAAqB,CASxG,GARA,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,wBAAwB,CACpE,KAAM,CACL,GAAG,EAAK,IAAI,CACZ,MAAO,EAAO,QAAQ,AACvB,MACA,EACA,MAAO,CACR,EAAG,EAAI,OAAO,EACV,EAAI,KAAK,CAAC,WAAW,CAAE,MAAM,EAAI,QAAQ,CAAC,EAAI,KAAK,CAAC,WAAW,EACnE,OAAO,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,CACA,GAAI,CAAC,EAAS,CACb,IAAM,EAAa,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAK,IAAI,CAAC,EAAE,EAC/E,GAAI,CAAC,EAAY,MAAM,IAAI,EAAA,QAAQ,CAAC,wBAAyB,CAAE,QAAS,0BAA2B,GACnG,EAAU,CACT,QAAS,EACT,KAAM,EAAK,IAAI,AAChB,CACD,CACA,GAA2B,8BAAvB,EAAO,WAAW,CAAkC,CACvD,IAAM,EAAgB,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,EAAO,KAAK,CAAE,CACvF,MAAO,EAAO,QAAQ,CACtB,eAAe,CAChB,GASA,GARA,MAAM,GAAiB,EAAK,CAC3B,QAAS,EAAQ,OAAO,CACxB,KAAM,CACL,GAAG,EAAQ,IAAI,CACf,MAAO,EAAO,QAAQ,CACtB,eAAe,CAChB,CACD,GACI,EAAI,KAAK,CAAC,WAAW,CAAE,MAAM,EAAI,QAAQ,CAAC,EAAI,KAAK,CAAC,WAAW,EACnE,OAAO,EAAI,IAAI,CAAC,CACf,QAAQ,EACR,KAAM,CACP,EACD,CACA,IAAM,EAAgB,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,EAAO,KAAK,CAAE,CACvF,MAAO,EAAO,QAAQ,CACtB,eAAe,CAChB,GACM,EAAW,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAO,QAAQ,EACjF,EAAoB,EAAI,KAAK,CAAC,WAAW,CAAG,mBAAmB,EAAI,KAAK,CAAC,WAAW,EAAI,mBAAmB,KAcjH,GAbA,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,wBAAwB,CACpE,KAAM,EACN,IAAK,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAS,aAAa,EAAE,EAAA,CAAmB,CAC7F,MAAO,CACR,EAAG,EAAI,OAAO,EACd,MAAM,GAAiB,EAAK,CAC3B,QAAS,EAAQ,OAAO,CACxB,KAAM,CACL,GAAG,EAAQ,IAAI,CACf,MAAO,EAAO,QAAQ,CACtB,cAAe,EAChB,CACD,GACI,EAAI,KAAK,CAAC,WAAW,CAAE,MAAM,EAAI,QAAQ,CAAC,EAAI,KAAK,CAAC,WAAW,EACnE,OAAO,EAAI,IAAI,CAAC,CACf,QAAQ,EACR,KAAM,CACL,GAAI,EAAc,EAAE,CACpB,MAAO,EAAc,KAAK,CAC1B,KAAM,EAAc,IAAI,CACxB,MAAO,EAAc,KAAK,CAC1B,cAAe,EAAc,aAAa,CAC1C,UAAW,EAAc,SAAS,CAClC,UAAW,EAAc,SAAS,AACnC,CACD,EACD,CACA,GAAI,EAAK,IAAI,CAAC,aAAa,CAAE,CAC5B,GAAI,EAAI,KAAK,CAAC,WAAW,CAAE,MAAM,EAAI,QAAQ,CAAC,EAAI,KAAK,CAAC,WAAW,EACnE,OAAO,EAAI,IAAI,CAAC,CACf,QAAQ,EACR,KAAM,IACP,EACD,CACI,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,qBAAqB,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,EAAK,IAAI,CAAE,EAAI,OAAO,EACtJ,IAAM,EAAc,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,EAAO,KAAK,CAAE,CAAE,eAAe,CAAK,GAE5G,GADI,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,wBAAwB,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,sBAAsB,CAAC,EAAa,EAAI,OAAO,EAC1J,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,4BAA6B,CACvE,IAAM,EAAiB,MAAM,GAAkB,GAC/C,GAAI,AAAC,GAAkB,EAAe,IAAI,CAAC,KAAK,GAAK,EAAO,KAAK,CAU1D,MAAM,GAAiB,EAAK,CAClC,QAAS,EAAe,OAAO,CAC/B,KAAM,CACL,GAAG,EAAe,IAAI,CACtB,cAAe,EAChB,CACD,OAhBmE,CAClE,IAAM,EAAU,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAK,IAAI,CAAC,EAAE,EAC5E,GAAI,CAAC,EAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,wBAAyB,CAAE,QAAS,0BAA2B,EAChG,OAAM,GAAiB,EAAK,SAC3B,EACA,KAAM,CACL,GAAG,EAAK,IAAI,CACZ,eAAe,CAChB,CACD,EACD,CAOD,CACA,GAAI,EAAI,KAAK,CAAC,WAAW,CAAE,MAAM,EAAI,QAAQ,CAAC,EAAI,KAAK,CAAC,WAAW,EACnE,OAAO,EAAI,IAAI,CAAC,CACf,OAAQ,GACR,KAAM,IACP,EACD,GAIA,SAAS,GAAS,CAAK,EACtB,OAAO,EAAM,OAAO,CAAC,KAAM,QAAQ,OAAO,CAAC,KAAM,QAAQ,OAAO,CAAC,KAAM,UAAU,OAAO,CAAC,KAAM,SAAS,OAAO,CAAC,yDAA0D,QAC3K,CAmVA,IAAM,GAAQ,GAAmB,SAAU,CAC1C,OAAQ,MACR,SAAU,CACT,GAAG,EAAA,CAAa,CAChB,QAAS,CACR,YAAa,yBACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,YAAa,CAAE,OAAQ,CACjC,KAAM,SACN,YAAa,oCACd,CAAE,CAAE,CACL,CAAE,CACH,CACD,CACD,EAAG,MAAO,IACT,IAAM,EAAM,IAAI,IAAI,EAAE,OAAO,EAAE,KAAO,IAChC,EAAkB,EAAI,YAAY,CAAC,GAAG,CAAC,UAAY,UACnD,EAAyB,EAAI,YAAY,CAAC,GAAG,CAAC,sBAAwB,KACtE,EAAW,qBAAqB,IAAI,CAAC,GAAmB,IAAM,EAAkB,UAChF,EAAkB,EAAyB,GAAS,GAA0B,KAC9E,EAAc,IAAI,gBACxB,EAAY,GAAG,CAAC,QAAS,GACrB,GAAwB,EAAY,GAAG,CAAC,oBAAqB,GACjE,IAAM,EAAU,EAAE,OAAO,CAAC,OAAO,CAC3B,EAAW,EAAQ,UAAU,EAAE,gBACjC,AAAJ,EAAqB,IAAI,IAAX,KAAoB,KAAM,CACvC,OAAQ,IACR,QAAS,CAAE,SAAU,CAAA,EAAG,EAAA,EAAW,EAAS,QAAQ,CAAC,KAAO,IAAM,IAAA,EAAM,EAAY,QAAQ,GAAA,CAAI,AAAC,CAClG,GACI,GAAA,CAAY,EAAI,CAAC,EAAQ,UAAU,EAAE,0BAAkC,CAAP,GAAW,SAAS,KAAM,CAC7F,OAAQ,IACR,QAAS,CAAE,SAAU,CAAC,EAAE,EAAE,EAAY,QAAQ,GAAA,CAAI,AAAC,CACpD,GACO,IAAI,SApXC,AAoXQ,EApXP,EAAS,EAAO,SAAS,CAAE,EAAc,IAAI,IAC1D,IAAM,EAAS,EAAQ,UAAU,EAAE,0BACnC,MAAO,CAAC;;;;;;;;;;;qBAWY,EAAE,GAAQ,MAAM,eAAiB,6FAA6F;oBAC/H,EAAE,GAAQ,QAAQ,YAAc,oBAAoB;;;;;;;;mBAQrD,EAAE,GAAQ,MAAM,QAAU,WAAW;;oBAEpC,EAAE,GAAQ,MAAM,SAAW,SAAS;;oBAEpC,EAAE,GAAQ,MAAM,SAAW,UAAU;;oBAErC,EAAE,GAAQ,MAAM,SAAW,OAAO;;;;;;;kBAOpC,EAAE,GAAQ,MAAM,UAAY,WAAW;oCACrB,EAAE,GAAQ,MAAM,YAAc,yBAAyB;mBACxE,EAAE,GAAQ,QAAQ,SAAW,QAAQ;8BAC1B,EAAE,GAAQ,QAAQ,mBAAqB,QAAQ;sBACvD,EAAE,GAAQ,QAAQ,YAAc,QAAQ;sBACxC,EAAE,GAAQ,QAAQ,YAAc,mBAAmB;kBACvD,EAAE,GAAQ,QAAQ,QAAU,kBAAkB;uBACzC,EAAE,GAAQ,QAAQ,aAAe,0BAA0B;4BACtD,EAAE,GAAQ,QAAQ,iBAAmB,mBAAmB;yBAC3D,EAAE,GAAQ,QAAQ,cAAgB,UAAU;;;;;;;;;;;;;;;;;;;qBAmBhD,EAAE,GAAQ,QAAQ,SAAW,QAAQ;gCAC1B,EAAE,GAAQ,QAAQ,mBAAqB,QAAQ;wBACvD,EAAE,GAAQ,QAAQ,YAAc,kBAAkB;wBAClD,EAAE,GAAQ,QAAQ,YAAc,kBAAkB;oBACtD,EAAE,GAAQ,QAAQ,QAAU,kBAAkB;yBACzC,EAAE,GAAQ,QAAQ,aAAe,0BAA0B;8BACtD,EAAE,GAAQ,QAAQ,iBAAmB,kBAAkB;2BAC1D,EAAE,GAAQ,QAAQ,cAAgB,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCvE,EAAE,GAAQ,sBAAwB,GAAK,CAAC;;;;;sDAKc,EAAE,GAAQ,QAAQ,WAAa,gBAAgB;uCAC9D,EAAE,GAAQ,QAAQ,WAAa,gBAAgB;;;;;;;;;;;;;;;sBAehE,EAAE,GAAQ,QAAQ,YAAc,oBAAoB;;;;;;AAM1E,CAAC,CAAC;;;;;;;gBAOc,EAAE,GAAQ,QAAQ,gBAAkB,oBAAoB;;;;;;IAMpE,EAAE,GAAQ,yBAA2B,GAAK,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eA8ChC,CAAC,CAAC;;;;;;;kCAOiB,EAAE,GAAQ,mBAAqB,cAAgB,GAAQ,QAAQ,aAAe,qBAAqB;;;;;;;;yBAQ5G,EAAE,GAAQ,QAAQ,YAAc,oBAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBA4D7D,EAAE,GAAS,MAAM;;;;;;;;;;;;;;YAcrB,EAAE,CAAC,EAAc,CAAC,mMAAmM,EAAE,mBAAmB,GAAM,mHAAmH,CAAC,CAAG,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAkCzU,EAAE,mBAAmB,GAAM,OAAO,EAAE,mBAAmB,CAAC,yBAAyB,EAAE,EAAK,MAAM,CAAC,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;OAyBhJ,CAAC,CACR,EAmC0B,EAAE,OAAO,CAAC,OAAO,CAAE,EAAU,GAAkB,CAAE,QAAS,CAAE,eAAgB,WAAY,CAAE,EACpH,GAIM,GAAK,GAAmB,MAAO,CACpC,OAAQ,MACR,SAAU,CACT,GAAG,EAAA,CAAa,CAChB,QAAS,CACR,YAAa,8BACb,UAAW,CAAE,IAAO,CACnB,YAAa,iBACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,GAAI,CACjB,KAAM,UACN,YAAa,iCACd,CAAE,EACF,SAAU,CAAC,KAAK,AACjB,CAAE,CAAE,CACL,CAAE,CACH,CACD,CACD,EAAG,MAAO,GACF,EAAI,IAAI,CAAC,CAAE,IAAI,CAAK,IAK5B,SAAS,GAAc,CAAG,CAAE,CAAW,CAAE,CAAK,EAC7C,IAAM,EAAM,EAAc,IAAI,IAAI,EAAa,EAAI,OAAO,EAAI,IAAI,IAAI,CAAA,EAAG,EAAI,OAAO,CAAC,MAAM,CAAC,EAE5F,OADI,GAAO,OAAO,OAAO,CAAC,GAAO,OAAO,CAAC,CAAC,CAAC,EAAG,EAAE,GAAK,EAAI,YAAY,CAAC,GAAG,CAAC,EAAG,IACtE,EAAI,IAAI,AAChB,CAMA,IAAM,GAAuB,GAAmB,0BAA2B,CAC1E,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CACd,MAAO,EAAA,KAAO,GAAG,IAAI,CAAC,CAAE,YAAa,iEAAkE,GACvG,WAAY,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,qPAAsP,GAAG,QAAQ,EAC7S,GACA,SAAU,CAAE,QAAS,CACpB,YAAa,uBACb,YAAa,0CACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,OAAQ,CAAE,KAAM,SAAU,EAC1B,QAAS,CAAE,KAAM,QAAS,CAC3B,CACD,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,kBAE1C,CAF6D,KAC7D,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,gHACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,8BAA+B,GAE7E,GAAM,OAAE,CAAK,YAAE,CAAU,CAAE,CAAG,EAAI,IAAI,CAChC,EAAO,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,EAAO,CAAE,iBAAiB,CAAK,GAC9F,GAAI,CAAC,EAQJ,IARU,EAKV,CAAA,EAAA,EAAA,CAAA,AAAU,EAAC,IACX,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,qBAAqB,CAAC,4BACxD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,iCAAkC,OAAE,CAAM,GAC5D,EAAI,IAAI,CAAC,CACf,QAAQ,EACR,QAAS,yEACV,GAED,IAAM,EAAY,EAAQ,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,2BAA2B,EAAI,KAAU,EAAH,KAC/F,EAAoB,CAAA,EAAA,EAAA,CAAA,AAAU,EAAC,GACrC,OAAM,EAAI,OAAO,CAAC,eAAe,CAAC,uBAAuB,CAAC,CACzD,MAAO,EAAK,IAAI,CAAC,EAAE,CACnB,WAAY,CAAC,eAAe,EAAE,EAAA,CAAmB,WACjD,CACD,GACA,IAAM,EAAc,EAAa,mBAAmB,GAAc,GAC5D,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,EAAkB,aAAa,EAAE,EAAA,CAAa,CAQnG,OAPA,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAC5D,KAAM,EAAK,IAAI,KACf,EACA,MAAO,CACR,EAAG,EAAI,OAAO,EAAE,KAAK,CAAC,AAAC,IACtB,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,sCAAuC,EACjE,GACO,EAAI,IAAI,CAAC,CACf,QAAQ,EACR,QAAS,yEACV,EACD,GACM,GAA+B,GAAmB,yBAA0B,CACjF,OAAQ,MACR,YAAa,yBACb,MAAO,EAAA,MAAQ,CAAC,CAAE,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,sDAAuD,EAAG,GACxH,IAAK,CAAC,GAAY,AAAC,GAAQ,EAAI,KAAK,CAAC,WAAW,EAAE,CAClD,SAAU,CAAE,QAAS,CACpB,YAAa,wBACb,YAAa,wDACb,WAAY,CAAC,CACZ,KAAM,QACN,GAAI,OACJ,SAAU,GACV,YAAa,kCACb,OAAQ,CAAE,KAAM,QAAS,CAC1B,EAAG,CACF,KAAM,cACN,GAAI,QACJ,UAAU,EACV,YAAa,uDACb,OAAQ,CAAE,KAAM,QAAS,CAC1B,EAAE,CACF,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,MAAO,CAAE,KAAM,QAAS,CAAE,CACzC,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,QA/FgB,GAAG,CAgG5B,CAhG8B,KAgGxB,MAhGmC,CAgGjC,CAAK,CAAE,CAAG,EAAI,MAAM,CACtB,aAAE,CAAW,CAAE,CAAG,EAAI,KAAK,CACjC,GAAI,CAAC,GAAS,CAAC,EAAa,MAAM,EAAI,QAAQ,CAAC,GAAc,EAAI,OAAO,CAAE,EAAa,CAAE,MAAO,eAAgB,IAChH,IAAM,EAAe,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,qBAAqB,CAAC,CAAC,eAAe,EAAE,EAAA,CAAO,EACtG,GAAI,CAAC,GAAgB,EAAa,SAAS,CAAmB,EAAhB,EAAoB,KAAQ,MAAf,AAAqB,EAAI,QAAQ,CAAC,GAAc,EAAI,OAAO,CAAE,EAAa,CAAE,MAAO,eAAgB,GAC9J,OAAM,EAAI,QAAQ,CAAC,GAAiB,EAAI,OAAO,CArGJ,EAqGmB,GArGd,IAqGgB,CAAM,EApGhE,EAAM,IAAI,IAAI,AAoG6B,EApGhB,EAAI,OAAO,EACxC,GAAO,OAAO,OAAO,CAAC,GAAO,OAAO,CAAC,CAAC,CAAC,EAAG,EAAE,GAAK,EAAI,YAAY,CAAC,GAAG,CAAC,EAAG,IACtE,EAAI,IAAI,EAmGhB,GACM,GAAgB,GAAmB,kBAAmB,CAC3D,OAAQ,OACR,YAAa,gBACb,MAAO,EAAA,MAAQ,CAAC,CAAE,MAAO,EAAA,MAAQ,GAAG,QAAQ,EAAG,GAAG,QAAQ,GAC1D,KAAM,EAAA,MAAQ,CAAC,CACd,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,yBAA0B,GACtE,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iCAAkC,GAAG,QAAQ,EACpF,GACA,SAAU,CAAE,QAAS,CACpB,YAAa,gBACb,YAAa,gCACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,OAAQ,CAAE,KAAM,SAAU,CAAE,CAC3C,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,IAAM,EAAQ,EAAI,IAAI,CAAC,KAAK,EAAI,EAAI,KAAK,EAAE,MAC3C,GAAI,CAAC,EAAO,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAa,AAAC,GACxF,GAAM,aAAE,CAAW,CAAE,CAAG,EAAI,IAAI,CAC1B,EAAY,EAAI,OAAO,CAAC,QAAQ,EAAE,OAAO,kBACzC,EAAY,EAAI,OAAO,CAAC,QAAQ,EAAE,OAAO,kBAC/C,GAAI,EAAY,MAAM,CAAG,EAAW,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAmB,AAAD,GACpH,GAAI,EAAY,MAAM,CAAG,EAAW,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,iBAAiB,AAAC,GACpH,IAAM,EAAK,CAAC,eAAe,EAAE,EAAA,CAAO,CAC9B,EAAe,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,qBAAqB,CAAC,GAC7E,GAAI,CAAC,GAAgB,EAAa,SAAS,CAAmB,EAAhB,EAAoB,KAAQ,MAAM,AAArB,IAAyB,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAa,AAAC,GACtJ,IAAM,EAAS,EAAa,KAAK,CAC3B,EAAiB,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GASvD,GARK,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAA,CAAO,CAAE,IAAI,CAAC,AAAC,GAAyB,eAAlB,EAAG,UAAU,EAMnF,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAQ,GAN8C,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,QAC3J,EACA,WAAY,aACZ,SAAU,EACV,UAAW,CACZ,GAEA,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,uBAAuB,CAAC,EAAa,EAAE,EACrE,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,gBAAiB,CAC1D,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,GACxD,GAAM,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,eAAe,CAAC,MAAE,CAAK,EAAG,EAAI,OAAO,CAC3F,CAEA,OADI,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,+BAA+B,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,GACnH,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,GAIM,GAAyB,EAAA,MAAQ,CAAC,CACvC,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0DAA2D,GAAG,QAAQ,GAClH,mBAAoB,EAAA,MAAQ,GAAG,QAAQ,GACvC,iBAAkB,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iDAAkD,GAAG,QAAQ,GAC9G,SAAU,GACV,gBAAiB,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,6FAA8F,GAAG,QAAQ,GAC1J,QAAS,EAAA,QAAU,CAAC,EAAA,MAAQ,CAAC,CAC5B,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,4BAA6B,GACnE,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,kCAAmC,GAAG,QAAQ,GACpF,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,gCAAiC,GAAG,QAAQ,GACxF,aAAc,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iCAAkC,GAAG,QAAQ,GAC1F,UAAW,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0BAA2B,GAAG,QAAQ,EACjF,IACA,OAAQ,EAAA,KAAO,CAAC,EAAA,MAAQ,IAAI,IAAI,CAAC,CAAE,YAAa,6FAA8F,GAAG,QAAQ,GACzJ,cAAe,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,yFAA0F,GAAG,QAAQ,GACpJ,UAAW,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0DAA2D,GAAG,QAAQ,GAChH,eAAgB,EAAA,MAAQ,CAAC,EAAA,MAAQ,GAAI,EAAA,GAAK,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,qDAAsD,EACpI,GA6NM,GAAU,GAAmB,YAAa,CAC/C,OAAQ,OACR,YAAa,UACb,gBAAgB,EAChB,SAAU,CAAE,QAAS,CACpB,YAAa,UACb,YAAa,4BACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,QAAS,CAAE,KAAM,SAAU,CAAE,CAC5C,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,IAAM,EAAqB,MAAM,EAAI,eAAe,CAAC,EAAI,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAE,EAAI,OAAO,CAAC,MAAM,EAClH,GAAI,EAAoB,GAAI,CAC3B,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EACjD,CAAE,MAAO,EAAG,CACX,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,yCAA0C,EACpE,CAEA,OADA,GAAoB,GACb,EAAI,IAAI,CAAC,CAAE,SAAS,CAAK,EACjC,GA4QM,GAAiB,GAAmB,mBAAoB,CAC7D,OAAQ,OACR,YAAa,iBACb,KAAM,EAAA,MAAQ,CAAC,CACd,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,yBAA0B,GACtE,gBAAiB,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,kCAAmC,GACnF,oBAAqB,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,yBAA0B,GAAG,QAAQ,EAC3F,GACA,IAAK,CAAC,GAA2B,CACjC,SAAU,CAAE,QAAS,CACpB,YAAa,iBACb,YAAa,kCACb,UAAW,CAAE,IAAO,CACnB,YAAa,gCACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,MAAO,CACN,KAAM,SACN,UAAU,EACV,YAAa,kDACd,EACA,KAAM,CACL,KAAM,SACN,WAAY,CACX,GAAI,CACH,KAAM,SACN,YAAa,mCACd,EACA,MAAO,CACN,KAAM,SACN,OAAQ,QACR,YAAa,+BACd,EACA,KAAM,CACL,KAAM,SACN,YAAa,sBACd,EACA,MAAO,CACN,KAAM,SACN,OAAQ,MACR,UAAU,EACV,YAAa,mCACd,EACA,cAAe,CACd,KAAM,UACN,YAAa,qCACd,EACA,UAAW,CACV,KAAM,SACN,OAAQ,YACR,YAAa,2BACd,EACA,UAAW,CACV,KAAM,SACN,OAAQ,YACR,YAAa,gCACd,CACD,EACA,SAAU,CACT,KACA,QACA,OACA,gBACA,YACA,YACA,AACF,CACD,EACA,SAAU,CAAC,OAAO,AACnB,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAM,CAAE,aAAW,iBAAE,CAAe,CAAE,oBAAqB,CAAqB,CAAE,CAAG,EAAI,IAAI,CACvF,EAAU,EAAI,OAAO,CAAC,OAAO,CAC7B,EAAoB,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CACvE,GAAI,EAAY,MAAM,CAAG,EAExB,MADA,EAAI,OAAO,CAAC,CAD+B,KACzB,CAAC,KAAK,CAAC,yBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,GAElF,IAAM,EAAoB,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CACvE,GAAI,EAAY,MAAM,CAAG,EAExB,MADA,EAAI,OAAO,CAAC,CAD+B,KACzB,CAAC,KAAK,CAAC,wBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,iBAAiB,AAAC,GAEjF,IAAM,EAAU,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAQ,IAAI,CAAC,GAAE,CAAC,CAAE,IAAI,CAAC,AAAC,GAAuC,eAAzB,EAAU,UAAU,EAAqB,EAAU,QAAQ,EACjK,GAAI,CAAC,GAAW,CAAC,EAAQ,QAAQ,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,4BAA4B,AAAC,GAC9H,IAAM,EAAe,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GACrD,GAAI,CAAC,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CACtC,KAAM,EAAQ,QAAQ,CACtB,SAAU,CACX,GAAI,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,gBAAgB,AAAC,EACnF,OAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAQ,EAAE,CAAE,CAAE,SAAU,CAAa,GACrF,IAAI,EAAQ,KACZ,GAAI,EAAuB,CAC1B,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAQ,IAAI,CAAC,EAAE,EAChE,IAAM,EAAa,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAQ,IAAI,CAAC,EAAE,EAClF,GAAI,CAAC,EAAY,MAAM,IAAI,EAAA,QAAQ,CAAC,wBAAyB,CAAE,QAAS,GAAA,CAAgB,CAAC,qBAAqB,AAAC,EAC/G,OAAM,GAAiB,EAAK,CAC3B,QAAS,EACT,KAAM,EAAQ,IAAI,AACnB,GACA,EAAQ,EAAW,KAAK,AACzB,CACA,OAAO,EAAI,IAAI,CAAC,CACf,QACA,KAAM,CACL,GAAI,EAAQ,IAAI,CAAC,EAAE,CACnB,MAAO,EAAQ,IAAI,CAAC,KAAK,CACzB,KAAM,EAAQ,IAAI,CAAC,IAAI,CACvB,MAAO,EAAQ,IAAI,CAAC,KAAK,CACzB,cAAe,EAAQ,IAAI,CAAC,aAAa,CACzC,UAAW,EAAQ,IAAI,CAAC,SAAS,CACjC,UAAW,EAAQ,IAAI,CAAC,SAAS,AAClC,CACD,EACD,GACM,GAAc,GAAmB,gBAAiB,CACvD,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CAAE,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,qCAAsC,EAAG,GACtG,SAAU,CAAE,aAAa,CAAK,EAC9B,IAAK,CAAC,GAA2B,AAClC,EAAG,MAAO,IACT,GAAM,aAAE,CAAW,CAAE,CAAG,EAAI,IAAI,CAC1B,EAAU,EAAI,OAAO,CAAC,OAAO,CAC7B,EAAoB,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CACvE,GAAI,EAAY,MAAM,CAAG,EAExB,MADA,EAAI,OAAO,CAAC,CAD+B,KACzB,CAAC,KAAK,CAAC,yBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,GAElF,IAAM,EAAoB,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CACvE,GAAI,EAAY,MAAM,CAAG,EAExB,MADA,EAAI,OAAO,CAAC,CAD+B,KACzB,CAAC,KAAK,CAAC,wBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,iBAAiB,AAAC,GAEjF,IAAM,EAAU,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAQ,IAAI,CAAC,GAAE,CAAC,CAAE,IAAI,CAAC,AAAC,GAAuC,eAAzB,EAAU,UAAU,EAAqB,EAAU,QAAQ,EAC3J,EAAe,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GACrD,GAAI,CAAC,EAOJ,OAPa,AACb,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,CAC7C,OAAQ,EAAQ,IAAI,CAAC,EAAE,CACvB,WAAY,aACZ,UAAW,EAAQ,IAAI,CAAC,EAAE,CAC1B,SAAU,CACX,GACO,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAEhC,OAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,6BAA8B,EAC5E,GACM,GAAa,GAAmB,eAAgB,CACrD,OAAQ,OACR,IAAK,CAAC,GAA2B,CACjC,KAAM,EAAA,MAAQ,CAAC,CACd,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,2DAA4D,GAAG,QAAQ,GACnH,SAAU,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,yDAA0D,GAAG,QAAQ,GAC9G,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0CAA2C,GAAG,QAAQ,EAC7F,GACA,SAAU,CAAE,QAAS,CACpB,YAAa,aACb,YAAa,kBACb,YAAa,CAAE,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACvD,KAAM,SACN,WAAY,CACX,YAAa,CACZ,KAAM,SACN,YAAa,2DACd,EACA,SAAU,CACT,KAAM,SACN,YAAa,uDACd,EACA,MAAO,CACN,KAAM,SACN,YAAa,iCACd,CACD,CACD,CAAE,CAAE,CAAE,EACN,UAAW,CAAE,IAAO,CACnB,YAAa,uCACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,QAAS,CACR,KAAM,UACN,YAAa,2CACd,EACA,QAAS,CACR,KAAM,SACN,KAAM,CAAC,eAAgB,0BAA0B,CACjD,YAAa,wCACd,CACD,EACA,SAAU,CAAC,UAAW,UAAU,AACjC,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,QAE1C,CAFmD,KACnD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qDACnB,IAAI,EAAA,QAAQ,CAAC,aAEpB,IAAM,EAAU,EAAI,OAAO,CAAC,OAAO,CACnC,GAAI,EAAI,IAAI,CAAC,QAAQ,CAAE,CACtB,IAAM,EAAU,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAQ,IAAI,CAAC,GAAE,CAAC,CAAE,IAAI,CAAC,AAAC,GAAuC,eAAzB,EAAU,UAAU,EAAqB,EAAU,QAAQ,EACjK,GAAI,CAAC,GAAW,CAAC,EAAQ,QAAQ,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,4BAA4B,AAAC,GAC9H,GAAI,CAAC,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CACtC,KAAM,EAAQ,QAAQ,CACtB,SAAU,EAAI,IAAI,CAAC,QAAQ,AAC5B,GAAI,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,gBAAgB,AAAC,EACpF,CACA,GAAI,EAAI,IAAI,CAAC,KAAK,CAKjB,CALmB,MACnB,MAAM,GAAmB,CACxB,GAAG,CAAG,CACN,MAAO,CAAE,MAAO,EAAI,IAAI,CAAC,KAAK,AAAC,CAChC,GACO,EAAI,IAAI,CAAC,CACf,SAAS,EACT,QAAS,cACV,GAED,GAAI,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,8BAA+B,CACvE,IAAM,EAAQ,CAAA,EAAA,GAAA,CAAA,AAAoB,EAAC,GAAI,MAAO,MAC9C,OAAM,EAAI,OAAO,CAAC,eAAe,CAAC,uBAAuB,CAAC,CACzD,MAAO,EAAQ,IAAI,CAAC,EAAE,CACtB,WAAY,CAAC,eAAe,EAAE,EAAA,CAAO,CACrC,UAAW,IAAI,KAAK,KAAK,GAAG,GAAK,AAA2E,IAA1E,GAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,sBAAwB,KAAO,CAAE,CAAF,AACvG,GACA,IAAM,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,4BAA4B,EAAE,EAAM,aAAa,EAAE,EAAI,IAAI,CAAC,WAAW,EAAI,IAAA,CAAK,CAMnH,OALA,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,6BAA6B,CAAC,CACvE,KAAM,EAAQ,IAAI,KAClB,QACA,CACD,EAAG,EAAI,OAAO,EACP,EAAI,IAAI,CAAC,CACf,SAAS,EACT,QAAS,yBACV,EACD,CACA,GAAI,CAAC,EAAI,IAAI,CAAC,QAAQ,EAA2C,IAAvC,EAAI,OAAO,CAAC,aAAa,CAAC,QAAQ,CAAQ,CACnE,IAAM,EAAa,IAAI,KAAK,EAAQ,OAAO,CAAC,SAAS,EAAE,OAAO,GACxD,EAAgD,IAArC,EAAI,OAAO,CAAC,aAAa,CAAC,QAAQ,CACnD,GAAI,KAAK,GAAG,GAAK,EAAa,AAAW,MAAK,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,eAAe,AAAC,EAC7H,CACA,IAAM,EAAe,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,YACtD,IAAc,MAAM,EAAa,EAAQ,IAAI,CAAE,EAAI,OAAO,EAC9D,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAQ,IAAI,CAAC,EAAE,EAC5D,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAQ,IAAI,CAAC,EAAE,EAChE,GAAoB,GACpB,IAAM,EAAc,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,YAEzD,OADI,GAAa,MAAM,EAAY,EAAQ,IAAI,CAAE,EAAI,OAAO,EACrD,EAAI,IAAI,CAAC,CACf,SAAS,EACT,QAAS,cACV,EACD,GACM,GAAqB,GAAmB,wBAAyB,CACtE,OAAQ,MACR,MAAO,EAAA,MAAQ,CAAC,CACf,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0CAA2C,GACjF,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,uCAAwC,GAAG,QAAQ,EAChG,GACA,IAAK,CAAC,GAAY,AAAC,GAAQ,EAAI,KAAK,CAAC,WAAW,EAAE,CAClD,SAAU,CAAE,QAAS,CACpB,YAAa,6DACb,UAAW,CAAE,IAAO,CACnB,YAAa,4BACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,QAAS,CACR,KAAM,UACN,YAAa,0CACd,EACA,QAAS,CACR,KAAM,SACN,KAAM,CAAC,eAAe,CACtB,YAAa,sBACd,CACD,EACA,SAAU,CAAC,UAAW,UAAU,AACjC,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,QAE1C,CAFmD,KACnD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qDACnB,IAAI,EAAA,QAAQ,CAAC,aAEpB,IAAM,EAAU,MAAM,GAAkB,GACxC,GAAI,CAAC,EAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,uBAAuB,AAAC,GAClG,IAAM,EAAQ,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,qBAAqB,CAAC,CAAC,eAAe,EAAE,EAAI,KAAK,CAAC,KAAK,CAAA,CAAE,EACzG,GAAI,CAAC,GAAS,EAAM,SAAS,CAAmB,EAAhB,EAAoB,MAChD,EAAM,GADmC,EAC9B,GAAK,EAAQ,IAAI,CAAC,EAAE,CADyB,CACvB,KAD6B,CACvB,GAD2B,CACvB,CADuB,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAc,AAAD,EAC9E,CAAC,AACxD,IAAM,EAAe,EAAI,KAD4C,EACrC,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,aACtD,GAAc,MAAM,EAAa,EAAQ,IAAI,CAAE,EAAI,OAAO,EAC9D,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAQ,IAAI,CAAC,EAAE,EAC5D,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAQ,IAAI,CAAC,EAAE,EAChE,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAQ,IAAI,CAAC,EAAE,EAChE,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,uBAAuB,CAAC,EAAM,EAAE,EAClE,GAAoB,GACpB,IAAM,EAAc,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,YAEzD,GADI,GAAa,MAAM,EAAY,EAAQ,IAAI,CAAE,EAAI,OAAO,EACxD,EAAI,KAAK,CAAC,WAAW,CAAE,MAAM,EAAI,QAAQ,CAAC,EAAI,KAAK,CAAC,WAAW,EAAI,KACvE,OAAO,EAAI,IAAI,CAAC,CACf,SAAS,EACT,QAAS,cACV,EACD,GACM,GAAc,GAAmB,gBAAiB,CACvD,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CACd,SAAU,EAAA,KAAO,GAAG,IAAI,CAAC,CAAE,YAAa,4DAA6D,GACrG,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iDAAkD,GAAG,QAAQ,EAC1G,GACA,IAAK,CAAC,GAA2B,CACjC,SAAU,CAAE,QAAS,CACpB,YAAa,cACb,UAAW,CACV,IAAO,CACN,YAAa,8CACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,KAAM,CACL,KAAM,SACN,KAAM,2BACP,EACA,OAAQ,CACP,KAAM,UACN,YAAa,yCACd,EACA,QAAS,CACR,KAAM,SACN,KAAM,CAAC,gBAAiB,0BAA0B,CAClD,YAAa,6CACb,UAAU,CACX,CACD,EACA,SAAU,CAAC,SAAS,AACrB,CAAE,CAAE,CACL,EACA,IAAO,CACN,YAAa,6CACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,QAAS,CAAE,KAAM,QAAS,CAAE,CAC3C,CAAE,CAAE,CACL,CACD,CACD,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,aAAa,QAE3C,CAFoD,KACpD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,6BACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,0BAA2B,GAEzE,IAAM,EAAW,EAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,GAC9C,GAAI,IAAa,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAE9C,CAFgD,KAChD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,mBAAoB,GAElE,GAAI,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,GAErD,MADA,EADgE,AAC5D,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,wBACnB,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAA,CAAgB,CAAC,qCAAqC,AAAC,GAK9G,IAA+C,IAA3C,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAa,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,8BAA8B,CAAE,CAS3H,GARA,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAE,CAAE,MAAO,CAAS,GACtG,MAAM,GAAiB,EAAK,CAC3B,QAAS,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CACpC,KAAM,CACL,GAAG,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAC3B,MAAO,CACR,CACD,GACI,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,sBAAuB,CACjE,IAAM,EAAU,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAU,KAAK,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WAC1H,EAAQ,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAQ,aAAa,EAAE,EAAI,IAAI,CAAC,WAAW,EAAI,IAAA,CAAK,AAC/G,OAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,CACjE,KAAM,CACL,GAAG,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAC3B,MAAO,CACR,EACA,IAAK,EACL,MAAO,CACR,EAAG,EAAI,OAAO,CACf,CACA,OAAO,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,CACA,GAAI,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAK,EAAD,CAAK,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,2BAA2B,EAAI,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,2BAAA,AAA2B,EAAG,CACrL,IAAM,EAAU,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAE,EAAU,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,UAAW,CAAE,YAAa,2BAA4B,GACxM,EAAQ,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAQ,aAAa,EAAE,EAAI,IAAI,CAAC,WAAW,EAAI,IAAA,CAAK,CACzG,EAAS,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,2BAA2B,EAAI,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,2BAA2B,CAOnJ,OANI,GAAQ,MAAM,EAAO,CACxB,KAAM,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAC9B,WACA,IAAK,EACL,MAAO,CACR,EAAG,EAAI,OAAO,EACP,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,CACA,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,sBAE3C,CAFkE,KAClE,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qCACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,kCAAmC,GAEjF,IAAM,EAAQ,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAE,EAAU,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,UAAW,CAAE,YAAa,2BAA4B,GACtM,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAM,aAAa,EAAE,EAAI,IAAI,CAAC,WAAW,EAAI,IAAA,CAAK,CAS3G,OARA,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,CACjE,KAAM,CACL,GAAG,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAC3B,MAAO,CACR,MACA,QACA,CACD,EAAG,EAAI,OAAO,EACP,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,GAIM,GAAoB,GAAW,CAAC,EAAK,EAAK,KAC/C,GAAI,MAAM,OAAO,CAAC,CAAG,CAAC,EAAI,GAAK,MAAM,OAAO,CAAC,GAE5C,KAFoD,EACpD,CAAG,CAAC,EAAI,CAAG,GACJ,CAET,GAuFA,eAAe,GAAe,CAAO,CAAE,CAAK,EAC3C,IAAI,EAAkB,CAAC,EACvB,IAAK,IAAM,KAAQ,EAAO,GAAI,EAAK,OAAO,CAAC,GAAU,CACpD,IAAM,EAAS,MAAM,EAAK,OAAO,CAAC,CACjC,GAAG,CAAO,CACV,cAAe,EAChB,GAAG,KAAK,CAAC,AAAC,IAET,MADI,aAAa,EAAA,QAAQ,EAAI,CAAA,EAAA,GAAA,CAAgB,AAAhB,EAAiB,EAAQ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAE,WAAU,EAAE,KAAK,CAAG,EAAE,UAAA,AAAU,EACtG,CACP,GACA,GAAI,GAA4B,UAAlB,OAAO,EAAqB,CACzC,GAAI,YAAa,GAAoC,UAA1B,OAAO,EAAO,OAAO,CAAe,CAC9D,GAAM,SAAE,CAAO,CAAE,GAAG,EAAM,CAAG,EAAO,OAAO,CACvC,aAAmB,SAAS,CAAI,EAAgB,OAAO,CAAE,EAAQ,OAAO,CAAC,CAAC,EAAO,KACpF,EAAgB,OAAO,EAAE,IAAI,EAAK,EACnC,GACK,EAAgB,OAAO,CAAG,GAC/B,EAAkB,GAAkB,EAAM,GAC1C,QACD,CACA,OAAO,CACR,CACD,CACA,MAAO,CAAE,QAAS,CAAgB,CACnC,CACA,eAAe,GAAc,CAAO,CAAE,CAAK,EAC1C,IAAK,IAAM,KAAQ,EAAO,GAAI,EAAK,OAAO,CAAC,GAAU,CACpD,IAAM,EAAS,MAAM,EAAK,OAAO,CAAC,GAAS,KAAK,CAAC,AAAC,IACjD,GAAI,aAAa,EAAA,QAAQ,CAExB,CAF0B,KACtB,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,EAAQ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAE,WAAU,EAAE,KAAK,CAAG,EAAE,UAAA,AAAU,EAC5E,CACN,SAAU,EACV,QAAS,EAAE,OAAO,CAAG,IAAI,QAAQ,EAAE,OAAO,EAAI,IAC/C,CAED,OAAM,CACP,GACI,EAAO,OAAO,EAAE,EAAO,OAAO,CAAC,OAAO,CAAC,CAAC,EAAO,KAC7C,EAAQ,OAAO,CAAC,eAAe,CAC3B,AAAsB,iBAAlB,WAAW,GAAqB,EAAQ,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC,EAAK,GACpF,EAAQ,OAAO,CAAC,eAAe,CAAC,GAAG,CAAC,EAAK,GAFR,EAAQ,OAAO,CAAC,eAAe,CAAG,IAAI,QAAQ,CAAE,CAAC,EAAI,CAAE,CAAM,EAGpG,GACI,EAAO,QAAQ,GAAE,EAAQ,OAAO,CAAC,QAAQ,CAAG,EAAO,QAAA,AAAQ,CAChE,CACA,MAAO,CACN,SAAU,EAAQ,OAAO,CAAC,QAAQ,CAClC,QAAS,EAAQ,OAAO,CAAC,eAAe,AACzC,CACD,CAuFA,SAAS,GAAa,CAAG,CAAE,CAAO,EACjC,IAAM,EAAkB,EAAQ,OAAO,EAAE,OAAO,CAAC,EAAK,KAC9C,CACN,GAAG,CAAG,CACN,GAAG,EAAO,SAAS,AACpB,GACE,CAAC,IAAM,CAAC,EACL,EAAc,EAAQ,OAAO,EAAE,IAAI,AAAC,GAAW,EAAO,WAAW,EAAE,IAAI,AAAC,IAC7E,IAAM,EAAc,MAAO,IAC1B,IAAM,EAAc,MAAM,EAC1B,OAAO,EAAE,UAAU,CAAC,CACnB,GAAG,CAAO,CACV,QAAS,CACR,GAAG,CAAW,CACd,GAAG,EAAQ,OAAO,AACnB,CACD,EACD,EAEA,OADA,EAAW,OAAO,CAAG,EAAE,UAAU,CAAC,OAAO,CAClC,CACN,KAAM,EAAE,IAAI,YACZ,CACD,CACD,IAAI,OAAQ,AAAD,GAAuB,KAAK,IAAhB,GAAmB,QAAU,EAAE,CACtD,MAAO,CACN,IAtPF,AAsPO,SAtPkB,AAAhB,CAAyB,CAAE,CAAG,EACtC,IAAM,EAAM,CAAC,EACb,IAAK,GAAM,CAAC,EAAK,EAAS,GAAI,OAAO,OAAO,CAAC,GAC5C,CAAG,CAAC,EAAI,CAAG,GAD6C,GACtC,IACjB,IAAM,EAAM,UACX,IAAM,EAAc,MAAM,EACtB,EAAkB,CACrB,GAAG,CAAO,CACV,QAAS,CACR,GAAG,CAAW,CACd,SAAU,KAAK,EACf,gBAAiB,KAAK,EACtB,QAAS,IACV,EACA,KAAM,EAAS,IAAI,CACnB,QAAS,GAAS,QAAU,IAAI,QAAQ,GAAS,SAAW,KAAK,CAClE,EACA,MAAO,CAAA,EAAA,GAAA,CAAA,AAAsB,EAAC,EAAiB,UAC9C,GAAM,aAAE,CAAW,YAAE,CAAU,CAAE,CAAG,AAqHzC,SAAS,AAAS,CAAW,EAC5B,IAAM,EAAU,EAAY,OAAO,CAAC,OAAO,EAAI,EAAE,CAC3C,EAAc,EAAE,CAChB,EAAa,EAAE,CACjB,EAAY,OAAO,CAAC,KAAK,EAAE,QAAQ,EAAY,IAAI,CAAC,CACvD,QAAS,KAAM,EACf,QAAS,EAAY,OAAO,CAAC,KAAK,CAAC,MAAM,AAC1C,GACI,EAAY,OAAO,CAAC,KAAK,EAAE,OAAO,EAAW,IAAI,CAAC,CACrD,QAAS,KAAM,EACf,QAAS,EAAY,OAAO,CAAC,KAAK,CAAC,KAAK,AACzC,GACA,IAAM,EAAoB,EAAQ,GAAG,CAAC,AAAC,IACtC,GAAI,EAAO,KAAK,EAAE,OAAQ,OAAO,EAAO,KAAK,CAAC,MAAM,AACrD,GAAG,MAAM,CAAC,AAAC,GAAW,AAAW,KAAK,OAAG,IAAI,GACvC,EAAmB,EAAQ,GAAG,CAAC,AAAC,IACrC,GAAI,EAAO,KAAK,EAAE,MAAO,OAAO,EAAO,KAAK,CAAC,KAAK,AACnD,GAAG,MAAM,CAAC,AAAC,GAAW,AAAW,KAAK,OAAG,IAAI,GAM7C,OAFI,EAAkB,MAAM,EAAE,EAAY,IAAI,IAAI,GAC9C,EAAiB,MAAM,EAAE,EAAW,IAAI,IAAI,GACzC,aACN,EACA,YACD,CACD,EAhJkD,GACvC,EAAS,MAAM,GAAe,EAAiB,GAKrD,GAAI,YAAa,GAAU,EAAO,OAAO,EAA8B,AAA1B,iBAAO,EAAO,OAAO,CAAe,CAChF,GAAM,SAAE,CAAO,CAAE,GAAG,EAAM,CAAG,EAAO,OAAO,CAMvC,GAAS,EAAQ,OAAO,CAAC,CAAC,EAAO,KACpC,EAAgB,OAAO,CAAC,GAAG,CAAC,EAAO,EACpC,GACA,EAAkB,GAAkB,EAAM,EAC3C,MAAO,GAAI,EAAQ,OAAO,GAAS,WAAa,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAQ,CAAE,QAAS,GAAS,OAAQ,GAAK,GAAS,cAAgB,CAC5H,QAAS,GAAS,QAClB,SAAU,CACX,EAAI,EACJ,EAAgB,UAAU,EAAG,EAC7B,EAAgB,aAAa,EAAG,EAChC,EAAgB,YAAY,EAAG,EAC/B,IAAM,EAAS,MAAM,CAAA,EAAA,GAAA,CAAA,AAAsB,EAAC,EAAiB,IAAM,EAAS,IAAkB,KAAK,CAAC,AAAC,IACpG,GAAI,aAAa,EAAA,QAAQ,CAKzB,CAJL,KAIY,CACN,SAAU,EACV,OAAQ,EAAE,UAAU,CACpB,QAAS,EAAE,OAAO,CAAG,IAAI,QAAQ,EAAE,OAAO,EAAI,IAC/C,CACA,OAAM,CACP,GACA,GAAI,GAAU,aAAkB,SAAU,OAAO,EACjD,EAAgB,OAAO,CAAC,QAAQ,CAAG,EAAO,QAAQ,CAClD,EAAgB,OAAO,CAAC,eAAe,CAAG,EAAO,OAAO,CACxD,IAAM,EAAQ,MAAM,GAAc,EAAiB,GAGnD,GAFI,EAAM,QAAQ,GAAE,EAAO,QAAQ,CAAG,EAAM,QAAA,AAAQ,EAChD,EAAO,QAAQ,YAAY,EAAA,QAAQ,EAAI,CAAA,EAAA,GAAA,CAAgB,AAAhB,EAAiB,EAAY,MAAM,CAAC,KAAK,CAAE,WAAU,EAAO,QAAQ,CAAC,KAAK,CAAG,EAAO,QAAQ,CAAC,UAAA,AAAU,EAC9I,EAAO,QAAQ,YAAY,EAAA,QAAQ,EAAI,CAAC,GAAS,WAAY,MAAM,EAAO,QAAQ,CACtF,OAAO,GAAS,WAAa,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAO,QAAQ,CAAE,CACxD,QAAS,EAAO,OAAO,CACvB,OAAQ,EAAO,MAAM,AACtB,GAAK,GAAS,cAAgB,GAAS,aAAe,CACrD,QAAS,EAAO,OAAO,CACvB,SAAU,EAAO,QAAQ,CACzB,OAAQ,EAAO,MAAM,AACtB,EAAI,CACH,QAAS,EAAO,OAAO,CACvB,SAAU,EAAO,QAAQ,AAC1B,EAAI,GAAS,aAAe,CAC3B,SAAU,EAAO,QAAQ,CACzB,OAAQ,EAAO,MAAM,AACtB,EAAI,EAAO,QAAQ,AACpB,EACD,SACA,AAAI,MAAM,CAAA,EAAA,GAAA,CAAA,AAAe,IAAW,CAAP,GACjB,CAAA,EAAA,GAAA,CAAA,AAAmB,EAAC,AAAgB,IAAI,QAAW,CAAlB,CAC9C,EACA,CAAG,CAAC,EAAI,CAAC,IAAI,CAAG,EAAS,IAAI,CAC7B,CAAG,CAAC,EAAI,CAAC,OAAO,CAAG,EAAS,OAAO,CAEpC,OAAO,CACR,EAiKuB,CACpB,aAlqCwB,CAkqCV,EAlqC6B,kBAAmB,CAChE,OAAQ,OACR,YAAa,eACb,KAAM,GACN,SAAU,CACT,OAAQ,CACP,KAAM,CAAC,EACP,SAAU,CAAC,CACZ,EACA,QAAS,CACR,YAAa,iCACb,YAAa,eACb,UAAW,CAAE,IAAO,CACnB,YAAa,2DACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,YAAa,4CACb,WAAY,CACX,MAAO,CAAE,KAAM,QAAS,EACxB,KAAM,CACL,KAAM,SACN,KAAM,2BACP,EACA,IAAK,CAAE,KAAM,QAAS,EACtB,SAAU,CACT,KAAM,UACN,KAAM,CAAC,GAAM,AACd,CACD,EACA,SAAU,CACT,WACA,QACA,OAEF,AADE,CACA,CAAE,CACL,CAAE,CACH,CACD,CACD,EAAG,MAAO,IACT,IAAM,EAAW,EAAE,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,EAAE,IAAI,CAAC,QAAQ,EAC/E,GAAI,CAAC,EAEJ,MADA,EADc,AACZ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,wEAAyE,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACtH,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,GAEhF,GAAI,EAAE,IAAI,CAAC,OAAO,CAAE,CACnB,GAAI,CAAC,EAAS,aAAa,CAE1B,CAF4B,KAC5B,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,kDAAmD,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GAChG,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,sBAAsB,AAAC,GAEpF,GAAM,OAAE,CAAK,OAAE,CAAK,CAAE,CAAG,EAAE,IAAI,CAAC,OAAO,CACvC,GAAI,CAAC,MAAM,EAAS,aAAa,CAAC,EAAO,GAExC,KAFgD,CAChD,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAoB,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACjE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAa,AAAC,GAE9E,IAAM,EAAW,MAAM,EAAS,WAAW,CAAC,CAC3C,QAAS,EACT,YAAa,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,CACvC,aAAc,EAAE,IAAI,CAAC,OAAO,CAAC,YAAY,AAC1C,GACA,GAAI,CAAC,GAAY,CAAC,GAAU,KAE3B,CAFiC,KACjC,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA2B,CAAE,SAAU,EAAE,IAAI,CAAC,QAAQ,AAAC,GACxE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,uBAAuB,AAAC,GAExF,GAAI,CAAC,EAAS,IAAI,CAAC,KAAK,CAEvB,CAFyB,KACzB,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,uBAAwB,CAAE,SAAU,EAAE,IAAI,CAAC,QAAS,AAAD,GACpE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,oBAAoB,AAAC,GAErF,IAAM,EAAO,MAAM,GAAoB,EAAG,CACzC,SAAU,CACT,GAAG,EAAS,IAAI,CAChB,MAAO,EAAS,IAAI,CAAC,KAAK,CAC1B,GAAI,OAAO,EAAS,IAAI,CAAC,EAAE,EAC3B,KAAM,EAAS,IAAI,CAAC,IAAI,EAAI,GAC5B,MAAO,EAAS,IAAI,CAAC,KAAK,CAC1B,cAAe,EAAS,IAAI,CAAC,aAAa,GAAI,CAC/C,EACA,QAAS,CACR,WAAY,EAAS,EAAE,CACvB,UAAW,OAAO,EAAS,IAAI,CAAC,EAAE,EAClC,YAAa,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,AACxC,EACA,YAAa,EAAE,IAAI,CAAC,WAAW,CAC/B,cAAe,EAAS,qBAAqB,EAAI,CAAC,EAAE,IAAI,CAAC,aAAa,EAAI,EAAS,aAAa,AACjG,GACA,GAAI,EAAK,KAAK,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,EAAK,KAAK,AAAC,GAEzE,OADA,MAAM,GAAiB,EAAG,EAAK,IAAI,EAC5B,EAAE,IAAI,CAAC,CACb,UAAU,EACV,MAAO,EAAK,IAAI,CAAC,OAAO,CAAC,KAAK,CAC9B,IAAK,KAAK,EACV,KAAM,EAAgB,EAAE,OAAO,CAAC,OAAO,CAAE,EAAK,IAAI,CAAC,IAAI,CACxD,EACD,CACA,GAAM,cAAE,CAAY,OAAE,CAAK,CAAE,CAAG,MAAM,CAAA,EAAA,EAAA,CAAA,AAAa,EAAC,EAAG,KAAK,EAAG,EAAE,IAAI,CAAC,cAAc,EAC9E,EAAM,MAAM,EAAS,sBAAsB,CAAC,CACjD,qBACA,EACA,YAAa,CAAA,EAAG,EAAE,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,EAAS,EAAE,CAAA,CAAE,CAC3D,OAAQ,EAAE,IAAI,CAAC,MAAM,CACrB,UAAW,EAAE,IAAI,CAAC,SAAS,AAC5B,GACA,OAAO,EAAE,IAAI,CAAC,CACb,IAAK,EAAI,QAAQ,GACjB,SAAU,CAAC,EAAE,IAAI,CAAC,eAAe,AAClC,EACD,iBA0jCG,GACA,WAAY,aACZ,GACA,YA96BuB,CA86BV,EA96B6B,iBAAkB,CAC9D,OAAQ,OACR,YAAa,6BACb,KAAM,EAAA,MAAQ,CAAC,EAAA,MAAQ,GAAI,EAAA,GAAK,IAChC,SAAU,CACT,OAAQ,CACP,KAAM,CAAC,EACP,SAAU,CAAC,CACZ,EACA,QAAS,CACR,YAAa,6BACb,YAAa,0CACb,YAAa,CAAE,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACvD,KAAM,SACN,WAAY,CACX,KAAM,CACL,KAAM,SACN,YAAa,sBACd,EACA,MAAO,CACN,KAAM,SACN,YAAa,uBACd,EACA,SAAU,CACT,KAAM,SACN,YAAa,0BACd,EACA,MAAO,CACN,KAAM,SACN,YAAa,mCACd,EACA,YAAa,CACZ,KAAM,SACN,YAAa,gDACd,EACA,WAAY,CACX,KAAM,UACN,YAAa,0EACd,CACD,EACA,SAAU,CACT,OACA,QACA,WACA,AACF,CAAE,CAAE,CAAE,EACN,UAAW,CACV,IAAO,CACN,YAAa,4BACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,MAAO,CACN,KAAM,SACN,UAAU,EACV,YAAa,sCACd,EACA,KAAM,CACL,KAAM,SACN,WAAY,CACX,GAAI,CACH,KAAM,SACN,YAAa,mCACd,EACA,MAAO,CACN,KAAM,SACN,OAAQ,QACR,YAAa,+BACd,EACA,KAAM,CACL,KAAM,SACN,YAAa,sBACd,EACA,MAAO,CACN,KAAM,SACN,OAAQ,MACR,UAAU,EACV,YAAa,mCACd,EACA,cAAe,CACd,KAAM,UACN,YAAa,qCACd,EACA,UAAW,CACV,KAAM,SACN,OAAQ,YACR,YAAa,2BACd,EACA,UAAW,CACV,KAAM,SACN,OAAQ,YACR,YAAa,gCACd,CACD,EACA,SAAU,CACT,KACA,QACA,OACA,gBACA,YACA,YACA,AACF,CACD,EACA,SAAU,CAAC,OAAO,AACnB,CAAE,CAAE,CACL,EACA,IAAO,CACN,YAAa,sEACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,QAAS,CAAE,KAAM,QAAS,CAAE,CAC3C,CAAE,CAAE,CACL,CACD,CACD,CACD,CACD,EAAG,MAAO,GACF,CAAA,EAAA,EAAA,CAAA,AAAkB,EAAC,EAAI,OAAO,CAAC,OAAO,CAAE,cA4B1C,EA3BJ,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,SAAW,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,cAAe,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,2CAA4C,GACpM,IAAM,EAAO,EAAI,IAAI,CACf,MAAE,CAAI,OAAE,CAAK,UAAE,CAAQ,OAAE,CAAK,aAAE,CAAW,YAAE,CAAU,CAAE,GAAG,EAAM,CAAG,EAC3E,GAAI,CAAC,EAAA,KAAO,GAAG,SAAS,CAAC,GAAO,OAAO,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAa,AAAC,GACrH,IAAM,EAAoB,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CACvE,GAAI,EAAS,MAAM,CAAG,EAErB,MADA,EAAI,OAAO,CAAC,CAD4B,KACtB,CAAC,KAAK,CAAC,yBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,GAElF,IAAM,EAAoB,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CACvE,GAAI,EAAS,MAAM,CAAG,EAErB,MADA,EAAI,OAAO,CAAC,CAD4B,KACtB,CAAC,KAAK,CAAC,wBACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,iBAAiB,AAAC,GAEjF,IAAI,AAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,EAAA,CAAM,EAAG,KAE/D,CAFqE,KACrE,EAAI,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,oCAAoC,EAAE,EAAA,CAAO,EAChE,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAA,CAAgB,CAAC,qCAAqC,AAAC,GAU9G,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAE7C,GAAI,CACH,IAAM,EAAO,EAAe,EAAI,OAAO,CAAC,OAAO,CAAE,EAAM,UAQvD,GAAI,CAAC,CAPL,EAAc,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,CAC1D,MAAO,EAAM,WAAW,QACxB,QACA,EACA,GAAG,CAAI,CACP,eAAe,CAChB,EAAA,EACkB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,qBAAsB,AAAD,EACtG,CAAE,MAAO,EAAG,CAEX,GADI,CAAA,EAAA,EAAA,CAAA,AAAa,KAAI,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAyB,GACnE,aAAa,EAAA,QAAQ,CAAE,MAAM,CAEjC,OADA,EAAI,OAAO,CAAC,MAAM,EAAE,MAAM,wBAAyB,GAC7C,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAC1C,QAAS,GAAA,CAAgB,CAAC,qBAAqB,CAC/C,QAAS,CACV,EACD,CACA,GAAI,CAAC,EAAa,MAAM,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAA,CAAgB,CAAC,qBAAqB,AAAC,GAO/G,GANA,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,CAC7C,OAAQ,EAAY,EAAE,CACtB,WAAY,aACZ,UAAW,EAAY,EAAE,CACzB,SAAU,CACX,GACI,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,cAAgB,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,wBAAwB,CAAE,CACzH,IAAM,EAAQ,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAY,KAAK,CAAE,KAAK,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WACjI,EAAgB,EAAK,WAAW,CAAG,mBAAmB,EAAK,WAAW,EAAI,mBAAmB,KAC7F,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAM,aAAa,EAAE,EAAA,CAAe,CACvF,EAAO,EAAI,OAAO,CAAG,CAAC,CAC3B,KAAM,MACN,QACA,CACD,EAAG,EAAI,OAAO,CAAC,CAAG,CAAC,CAClB,KAAM,MACN,QACA,CACD,EAAE,AACF,OAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,2BAA2B,EACzE,CACA,IAAwD,IAApD,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,UAAU,EAAc,EAAI,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,wBAAwB,CAAE,OAAO,EAAI,IAAI,CAAC,CAC/I,MAAO,KACP,KAAM,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,EAC5C,GACA,IAAM,EAAU,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAY,EAAE,EAAiB,IAAf,GAChF,GAAI,CAAC,EAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,wBAAwB,AAAC,GAKrG,OAJA,MAAM,GAAiB,EAAK,SAC3B,EACA,KAAM,CACP,GAAkB,IAAf,GACI,EAAI,IAAI,CAAC,CACf,MAAO,EAAQ,KAAK,CACpB,KAAM,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,EAC5C,EACD,IAquBE,YA7jCuB,CA6jCV,EA7jC6B,iBAAkB,CAC9D,OAAQ,OACR,YAAa,cACb,KAAM,EAAA,MAAQ,CAAC,CACd,MAAO,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,mBAAoB,GAC1D,SAAU,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,sBAAuB,GAChE,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0DAA2D,GAAG,QAAQ,GAClH,WAAY,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,0EAA2E,GAAG,OAAO,EAAC,GAAM,QAAQ,EACjJ,GACA,SAAU,CACT,OAAQ,CACP,KAAM,CAAC,EACP,SAAU,CAAC,CACZ,EACA,QAAS,CACR,YAAa,cACb,YAAa,kCACb,UAAW,CAAE,IAAO,CACnB,YAAa,2DACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,YAAa,4CACb,WAAY,CACX,SAAU,CACT,KAAM,UACN,KAAM,EAAC,EACR,AADc,EAEd,MAAO,CACN,KAAM,SACN,YAAa,eACd,EACA,IAAK,CACJ,KAAM,SACN,UAAU,CACX,EACA,KAAM,CACL,KAAM,SACN,KAAM,2BACP,CACD,EACA,SAAU,CACT,WACA,QACA,OACA,AACF,CAAE,CAAE,CACL,CAAE,CACH,CACD,CACD,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,EAAE,kBAAkB,QAE3C,CAFoD,KACpD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,gLACnB,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,mCAAoC,GAElF,GAAM,CAAE,OAAK,UAAE,CAAQ,CAAE,CAAG,EAAI,IAAI,CACpC,GAAI,CAAC,EAAA,KAAO,GAAG,SAAS,CAAC,GAAO,OAAO,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,aAAc,AAAD,GACpH,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,eAAe,CAAC,EAAO,CAAE,iBAAiB,CAAK,GAC9F,GAAI,CAAC,EAGJ,IAHU,EACV,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAChC,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,iBAAkB,OAAE,CAAM,GAC7C,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,yBAAyB,AAAC,GAE1F,IAAM,EAAoB,EAAK,QAAQ,CAAC,IAAI,CAAC,AAAC,GAAuB,eAAjB,EAAE,UAAU,EAChE,GAAI,CAAC,EAGJ,MAFA,MAAM,EAAI,GADa,IACN,CAAC,QAAQ,CAAC,IAAI,CAAC,GAChC,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,+BAAgC,OAAE,CAAM,GAC3D,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,yBAAyB,AAAC,GAE1F,IAAM,EAAkB,GAAmB,SAC3C,GAAI,CAAC,EAGJ,MAFA,MAAM,EAAI,CADW,MACJ,CAAC,QAAQ,CAAC,IAAI,CAAC,GAChC,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,qBAAsB,OAAE,CAAM,GACjD,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,yBAAyB,AAAC,GAE1F,GAAI,CAAC,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CACtC,KAAM,WACN,CACD,GAEC,CAFG,KACH,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,oBACnB,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,yBAAyB,AAAC,GAE1F,GAAI,EAAI,OAAO,CAAC,OAAO,EAAE,kBAAkB,0BAA4B,CAAC,EAAK,IAAI,CAAC,aAAa,CAAE,CAChG,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,EAAE,mBAAmB,sBAAuB,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,GACnJ,GAAI,EAAI,OAAO,CAAC,OAAO,EAAE,mBAAmB,aAAc,CACzD,IAAM,EAAQ,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAK,IAAI,CAAC,KAAK,CAAE,KAAK,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WAC/H,EAAc,EAAI,IAAI,CAAC,WAAW,CAAG,mBAAmB,EAAI,IAAI,CAAC,WAAW,EAAI,mBAAmB,KACnG,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAM,aAAa,EAAE,EAAA,CAAa,AAC3F,OAAM,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,CACjE,KAAM,EAAK,IAAI,KACf,QACA,CACD,EAAG,EAAI,OAAO,CACf,CACA,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAA,CAAgB,CAAC,kBAAkB,AAAC,EAChF,CACA,IAAM,EAAU,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAK,IAAI,CAAC,EAAE,CAAE,CAAwB,MAApB,IAAI,CAAC,UAAU,EACjG,GAAI,CAAC,EAEJ,MADA,CADa,CACT,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,4BACnB,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAA,CAAgB,CAAC,wBAAwB,AAAC,GAMzF,OAJA,MAAM,GAAiB,EAAK,SAC3B,EACA,KAAM,EAAK,IACZ,AADgB,EACW,KAAxB,EAAI,IAAI,CAAC,UAAU,EACf,EAAI,IAAI,CAAC,CACf,SAAU,CAAC,CAAC,EAAI,IAAI,CAAC,WAAW,CAChC,MAAO,EAAQ,KAAK,CACpB,IAAK,EAAI,IAAI,CAAC,WAAW,CACzB,KAAM,EAAgB,EAAI,OAAO,CAAC,OAAO,CAAE,EAAK,IAAI,CACrD,EACD,GAg9BG,6BACA,yBACA,GACA,8BACA,eACA,GACA,WAvuBsB,CAuuBV,EAvuB6B,eAAgB,CAC3D,OAAQ,OACR,YAAa,aACb,KAAM,EAAA,MAAQ,CAAC,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,6BAA8B,GAAI,EAAA,GAAK,IACrF,IAAK,CAAC,GAAkB,CACxB,SAAU,CACT,OAAQ,CAAE,KAAM,CAAC,CAAE,EACnB,QAAS,CACR,YAAa,aACb,YAAa,0BACb,YAAa,CAAE,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACvD,KAAM,SACN,WAAY,CACX,KAAM,CACL,KAAM,SACN,YAAa,sBACd,EACA,MAAO,CACN,KAAM,SACN,YAAa,wBACb,UAAU,CACX,CACD,CACD,CAAE,CAAE,CAAE,EACN,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,KAAM,CACnB,KAAM,SACN,KAAM,2BACP,CAAE,CACH,CAAE,CAAE,CACL,CAAE,CACH,CACD,CACD,EAAG,MAAO,IACT,IAAM,EAAO,EAAI,IAAI,CACrB,GAAI,EAAK,KAAK,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAA,CAAgB,CAAC,wBAAwB,AAAC,GACvG,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,GAAG,EAAM,CAAG,EAC3B,EAAU,EAAI,OAAO,CAAC,OAAO,CAC7B,EAAmB,EAAe,EAAI,OAAO,CAAC,OAAO,CAAE,EAAM,UACnE,GAAc,KAAK,IAAf,GAA6B,KAAK,IAAd,GAA4D,IAAzC,OAAO,IAAI,CAAC,GAAkB,MAAM,CAAQ,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,qBAAsB,GAC1J,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,EAAQ,IAAI,CAAC,EAAE,CAAE,MAC1E,QACA,EACA,GAAG,CAAgB,AACpB,GAQA,OAJA,MAAM,GAAiB,EAAK,CAC3B,QAAS,EAAQ,OAAO,CACxB,MACD,GACO,EAAI,IAAI,CAAC,CAAE,QAAQ,CAAK,EAChC,cAgrBG,GACA,qDACA,GACA,aHn0FwB,CGm0FV,EHn0F6B,iBAAkB,CAC/D,OAAQ,MACR,YAAa,mBACb,IAAK,CAAC,GAAkB,CACxB,gBAAgB,EAChB,SAAU,CAAE,QAAS,CACpB,YAAa,mBACb,YAAa,wCACb,UAAW,CAAE,IAAO,CACnB,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,QACN,MAAO,CAAE,KAAM,8BAA+B,CAC/C,CAAE,CAAE,CACL,CAAE,CACH,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CACH,IAAM,EAAiB,CAAC,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,EAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAE,CAAC,CAAE,MAAM,CAAC,AAAC,GACrG,EAAQ,SAAS,CAAmB,EAAhB,EAAoB,MAEhD,KAFyC,EAElC,EAAI,IAAI,CAAC,EACjB,CAAE,MAAO,EAAG,CAEX,MADA,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GACnB,EAAI,KAAK,CAAC,wBACjB,CACD,GG0yFG,cAAA,GACA,eAAA,GACA,oBAAA,qBACA,oBACA,sBACA,iBACA,gBACA,kBACA,GACA,eACA,GAAG,CAAe,IAClB,SACA,EACD,EAAG,eACH,CACD,CACD,CvCxmGA,eAAe,GAAc,CAAM,CAAE,CAAC,EACrC,IAAM,GAAqB,MAAM,EAAE,OAAO,CAAC,CAAjB,cAAgC,CAAC,YAAY,CAAC,EAAA,CAAO,EAAG,KAAK,AAAC,GAAmC,eAAvB,EAAQ,UAAU,EAChH,EAAkB,GAAmB,SAC3C,GAAI,CAAC,GAAqB,CAAC,GAAmB,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAE,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,8BAA+B,GAC5I,GAAI,CAAC,MAAM,EAAE,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CACpC,KAAM,EACN,SAAU,EAAE,IAAI,CAAC,QAAQ,AAC1B,GAAI,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,kBAAmB,GACpE,OAAO,CACR,2DSlBA,GAAA,EAAA,CAAA,CAAA,OACA,GAAA,EAAA,CAAA,CAAA,OAiMA,eAAe,KACd,GAAI,EAAkB,OAAO,EAC7B,GAAI,CACH,IAAM,EAAM,AAAmB,oBAAZ,SAAkD,YAAvB,OAAO,QAAQ,GAAG,CAAkB,QAAQ,GAAG,GAAK,GAClG,GAAI,CAAC,EAAK,OAAO,AAEjB,GAAM,CAAC,CAFe,AAEb,QAAS,CAAE,CAAE,CAAE,CAAE,QAAS,CAAI,CAAE,CAAC,CAAG,MAAM,QAAQ,GAAG,CAAC,eADjB,qBACkC,AADb,eAApC,SAAS,0BACwE,QAAQ,EAClH,EAAM,MAAM,EAAG,QAAQ,CAAC,EAAK,IAAI,CAAC,EAAK,gBAAiB,SAE9D,OADA,AACO,EADY,KAAK,KAAK,CAAC,EAE/B,CAAE,KAAM,CAAC,CACV,CACA,eAAe,GAAkB,CAAG,EACnC,GAAI,EAAkB,OAAO,EAAiB,YAAY,EAAE,CAAC,EAAI,EAAI,EAAiB,eAAe,EAAE,CAAC,EAAI,EAAI,EAAiB,gBAAgB,EAAE,CAAC,EAAI,CACxJ,GAAI,CACH,IAAM,EAAyB,aAAnB,OAAO,SAAkD,YAAvB,OAAO,QAAQ,GAAG,CAAkB,QAAQ,GAAG,GAAK,GAClG,GAAI,CAAC,EAAK,MAAU,AAAJ,MAAU,UAE1B,GAAM,CAAC,CAAE,QAAS,CAAE,CAAE,CAAE,CAAE,QAAS,CAAI,CAAE,CAAC,CAAG,MAAM,QAAQ,GAAG,CAAC,oCAAiB,eADjD,SAAS,KAAM,qBAAqB,AAC6C,QAAQ,EAClH,EAAc,EAAK,IAAI,CAAC,EAAK,eAAgB,EAAK,gBAClD,EAAM,MAAM,EAAG,QAAQ,CAAC,EAAa,SAC3C,OAAO,KAAK,KAAK,CAAC,GAAK,OAAO,EAAI,MAAM,GAA+B,IAAQ,KAAK,CACrF,CAAE,KAAM,CAAC,CACT,OAAO,MAAM,GAA+B,EAC7C,CACA,eAAe,GAA+B,CAAG,EAChD,IAAM,EAAO,MAAM,KACnB,GAAK,CAAD,CACJ,IADW,EACJ,CAAA,CACN,GAFiB,AAEd,EAAK,GAFc,SAEF,CACpB,GAAG,EAAK,eAAe,CACvB,GAAG,EAAK,gBAAgB,AACzB,CAAA,CAAC,CAAC,EAAI,AACP,CACA,eAAe,KACd,OAAO,AAAC,MAAM,IAAA,CAAqB,EAAG,IACvC,CAIA,IAAM,GAAY,CACjB,GAAI,aACJ,MAAO,QACP,QAAS,UACT,QAAS,SACT,iBAAkB,SAClB,iBAAkB,SAClB,SAAU,UACV,QAAS,UACT,cAAe,SAChB,EACA,eAAe,KACd,IAAK,GAAM,CAAC,EAAK,EAAK,GAAI,OAAO,OAAO,CAAC,IAAY,CACpD,IAAM,EAAU,MAAM,GAAkB,GACxC,GAAI,EAAS,MAAO,MACnB,UACA,CACD,CACD,CACD,CAIA,IAAM,GAAa,CAClB,KAAM,OACN,KAAM,OACN,4BAA6B,QAC7B,MAAO,QACP,gBAAiB,YACjB,cAAe,cACf,iBAAkB,iBAClB,KAAM,OACN,QAAS,UACT,OAAQ,SACR,KAAM,MACP,EACA,eAAe,KACd,IAAK,GAAM,CAAC,EAAK,EAAK,GAAI,OAAO,OAAO,CAAC,IAAa,CACrD,IAAM,EAAU,MAAM,GAAkB,GACxC,GAAI,EAAS,MAAO,MACnB,UACA,CACD,CACD,CACD,CAwBA,SAAS,KACR,IAAM,EAAS,CAAC,GAAG,IAAS,EAAK,IAAI,CAAC,AAAC,IAAM,CAAQ,GAAA,CAAG,CAAC,EAAE,SAC3D,AAAI,EAAO,WAAY,eAAgB,kBAAyC,aAArB,OAAO,WAAqD,sBAAsB,CAA9C,UAAU,SAAS,CAAkC,aAChJ,EAAO,SAAU,aAAc,cAAsB,CAAP,QAC9C,EAAO,UAAW,eAAuB,CAAP,SAClC,EAAO,SAAU,aAAc,2BAA4B,qBAA6B,CAAP,QACjF,EAAO,2BAA4B,oBAAqB,oBAA4B,CAAP,KAC7E,EAAO,6BAA8B,uBAAwB,cAAe,aAAqB,CAAP,KAC1F,EAAO,sBAAuB,2BAA4B,sBAAuB,qBAA6B,CAAP,OACvG,EAAO,qBAAsB,eAAuB,CAAP,aAC7C,EAAO,eAAgB,aAAc,gBAAwB,CAAP,QACtD,EAAO,qBAAsB,4BAAoC,CAAP,SAC1D,EAAO,OAAQ,mBAA2B,CAAP,QACnC,EAAO,mBAAoB,cAAe,gBAAwB,CAAP,cAC3D,EAAO,QAAS,sBAAuB,kBAA0B,CAAP,OACvD,IACR,CACA,eAAe,KACd,GAAI,CACH,GAAoB,eAAhB,KAA8B,MAAO,aACzC,IAAM,EAAK,MAAM,AAzBX,SAAS,KAAM,qBAyBU,AAzBW,MA0BpC,EAAO,EAAG,IAAI,GACpB,MAAO,CACN,iBAAkB,KAClB,eAAgB,EAAG,QAAQ,GAC3B,cAAe,EAAG,OAAO,GACzB,mBAAoB,EAAG,IAAI,GAC3B,SAAU,EAAK,MAAM,CACrB,SAAU,EAAK,MAAM,CAAG,CAAI,CAAC,EAAE,CAAC,KAAK,CAAG,KACxC,SAAU,EAAK,MAAM,CAAG,CAAI,CAAC,EAAE,CAAC,KAAK,CAAG,KACxC,OAAQ,EAAG,QAAQ,GACnB,MAAO,MAAM,KACb,SAAU,MAAM,KAChB,MAA0B,aAAnB,OAAO,SAA2B,QAAQ,MAAM,CAAG,QAAQ,MAAM,CAAC,KAAK,CAAG,IAClF,CACD,CAAE,MAAO,EAAG,CACX,MAAO,CACN,eAAgB,KAChB,cAAe,KACf,mBAAoB,KACpB,SAAU,KACV,SAAU,KACV,SAAU,KACV,OAAQ,KACR,MAAO,KACP,SAAU,KACV,MAAO,IACR,CACD,CACD,CAEA,eAAe,KACd,GAAI,AAAgB,oBAAc,MAAO,GACzC,GAAI,CAEH,MADA,CAAC,MAAM,mCAAc,KAAA,CAAK,CAAE,QAAQ,CAAC,gBAC9B,CACR,CAAE,KAAM,CACP,OAAO,CACR,CACD,CACA,eAAe,KACd,GAAI,AAAgB,oBAAc,OAAO,EACzC,GAAI,CACH,MAAO,CAAC,MAAM,mCAAc,KAAA,CAAK,CAAE,YAAY,CAAC,oBAAqB,QAAQ,QAAQ,CAAC,SACvF,CAAE,KAAM,CACP,OAAO,CACR,CACD,CACA,eAAe,WACd,AAAoB,cAAc,CAA9B,MAAqC,CAClB,KAAK,IAAxB,IAA2B,EAAiB,MAAM,MAAkB,MAAM,IAAA,EACvE,EACR,CACA,eAAe,KACd,GAAI,CACH,GAAoB,eAAhB,MACA,AAAmB,oBAAZ,SAA2B,SAAS,WAAa,QAD1B,CACmC,KAD5B,EACmC,CAC5E,IAAM,EAAK,MAAM,mCAAc,MAC/B,GAAI,CAAC,MAAM,mCAAc,KAAA,CAAK,CAAE,OAAO,GAAG,WAAW,GAAG,QAAQ,CAAC,aAAc,CAC9E,GAAI,MAAM,KAAqB,OAAO,EACtC,OAAO,CACR,CACA,QAAO,EAAG,YAAY,CAAC,gBAAiB,QAAQ,WAAW,GAAG,QAAQ,CAAC,cAAe,CAAC,MAAM,IAC9F,CAAE,KAAM,CACP,MAAO,EACR,CACD,CAEA,CANqH,GAM/G,GAAkB,UACvB,GAAoB,eAAhB,KAA8B,OAAO,EACzC,GAAI,CAEH,MADC,AAAD,MAAO,oCAAc,KAAA,CAAK,CAAE,QAAQ,CAAC,uBAC9B,CACR,CAAE,KAAM,CACP,OAAO,CACR,CACD,EACA,eAAe,KAEd,OADgC,KAAK,IAAjC,IAAoC,EAA0B,MAAM,MAAqB,MAAM,IAAA,EAC5F,CACR,CA+BA,eAAe,GAAa,CAAI,EAC/B,IAAM,EAAS,MAAM,CAAA,EAAA,GAAA,UAAA,AAAU,EAAC,WAAW,MAAM,CAAC,GAClD,OAAO,GAAA,MAAM,CAAC,MAAM,CAAC,EACtB,CAUA,IAAI,GAAkB,KACtB,eAAe,GAAa,CAAO,EAClC,GAAI,GAAiB,OAAO,GAC5B,IAAM,EAAc,MAAM,YAC1B,AAAI,EACH,GAAkB,MAAM,EADR,CACqB,EAAU,EAAU,EAAc,GAGpE,EACH,GAAkB,IADN,EACY,GAAa,GAGtC,GAjBO,CAAA,EAAA,GAAA,SAiBW,kBAjBX,AAA2B,EAAC,MAAO,MAAO,OAAO,AAiB3B,GAE9B,CAIA,IAvBiE,WAuBlD,GAAgB,CAAO,CAAE,CAAO,EAC9C,IAeI,EAfE,EAAe,EAAQ,SAAS,EAAE,OAAS,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,+BAA+B,GAC3F,EAAqB,GAAA,CAAG,CAAC,8BAA8B,CACvD,EAAQ,MAAO,IAChB,GAAS,YAAa,MAAM,EAAQ,WAAW,CAAC,GAAO,KAAK,CAAC,GAAA,MAAM,CAAC,KAAK,EACpE,EAAc,GAAA,MAAM,CAAC,IAAI,CAAC,kBAAmB,KAAK,SAAS,CAAC,EAAO,KAAM,IAC7E,MAAM,GAAY,EAAoB,CAC1C,OAAQ,OACR,KAAM,CACP,GAAG,KAAK,CAAC,GAAA,MAAM,CAAC,KAAK,CACtB,EACM,EAAY,UACjB,IAAM,EAAmB,EAAQ,SAAS,EAAE,UAAY,KAAK,GAAI,EAAQ,SAAS,CAAC,OAAO,CAC1F,EAD6F,IACtF,CAAC,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,yBAAyB,IAAU,CAAA,CAAgB,GAAM,EAAD,CAAU,eAAiB,CAAC,CAAA,EAAA,EAAA,CAAA,AAAM,GAAA,CAAE,AACtH,EACM,EAAU,MAAM,IAElB,IACH,EAAc,GADF,GACQ,GAAa,EAAQ,OAAO,EAChD,EAAM,CACL,KAAM,OACN,QAAS,CACR,OAjeI,CACN,AAgeU,UAheA,EAAS,SACnB,QA+d0C,CA/djC,EAAS,QAClB,kBAAmB,CAClB,sBAAuB,CAAC,CAAC,EAAQ,iBAAiB,EAAE,sBACpD,aAAc,CAAC,CAAC,EAAQ,iBAAiB,EAAE,aAC3C,aAAc,CAAC,CAAC,EAAQ,iBAAiB,EAAE,aAC3C,4BAA6B,CAAC,CAAC,EAAQ,iBAAiB,EAAE,4BAC1D,UAAW,EAAQ,iBAAiB,EAAE,UACtC,oBAAqB,CAAC,CAAC,EAAQ,iBAAiB,EAAE,oBAClD,uBAAwB,CAAC,CAAC,EAAQ,iBAAiB,EAAE,sBACtD,EACA,iBAAkB,CACjB,QAAS,CAAC,CAAC,EAAQ,gBAAgB,EAAE,QACrC,cAAe,CAAC,CAAC,EAAQ,gBAAgB,EAAE,cAC3C,yBAA0B,CAAC,CAAC,EAAQ,gBAAgB,EAAE,yBACtD,kBAAmB,EAAQ,gBAAgB,EAAE,kBAC7C,kBAAmB,EAAQ,gBAAgB,EAAE,kBAC7C,kBAAmB,CAAC,CAAC,EAAQ,gBAAgB,EAAE,kBAC/C,4BAA6B,EAAQ,gBAAgB,EAAE,4BACvD,gBAAiB,CAAC,CAAC,EAAQ,gBAAgB,EAAE,gBAC7C,SAAU,CACT,KAAM,CAAC,CAAC,EAAQ,gBAAgB,EAAE,UAAU,KAC5C,OAAQ,CAAC,CAAC,EAAQ,gBAAgB,EAAE,UAAU,MAC/C,EACA,WAAY,CAAC,CAAC,EAAQ,gBAAgB,EAAE,WACxC,8BAA+B,CAAC,CAAC,EAAQ,gBAAgB,EAAE,6BAC5D,EACA,gBAAiB,OAAO,IAAI,CAAC,EAAQ,eAAe,EAAI,CAAC,GAAG,GAAG,CAAC,AAAC,IAChE,IAAM,EAAW,EAAQ,eAAe,EAAE,CAAC,EAAE,QAC7C,AAAK,EACE,CACN,CAFG,EAEC,EACJ,EAHc,eAGI,CAAC,CAAC,EAAS,gBAAgB,CAC7C,oBAAqB,CAAC,CAAC,EAAS,mBAAmB,CACnD,qBAAsB,CAAC,CAAC,EAAS,oBAAoB,CACrD,sBAAuB,EAAS,qBAAqB,CACrD,cAAe,EAAS,aAAa,CACrC,YAAa,CAAC,CAAC,EAAS,WAAW,CACnC,yBAA0B,CAAC,CAAC,EAAS,wBAAwB,CAC7D,OAAQ,EAAS,MAAM,CACvB,cAAe,CAAC,CAAC,EAAS,aAAa,CACvC,MAAO,EAAS,KAAK,CACrB,mBAAoB,CAAC,CAAC,EAAS,kBAChC,AADkD,EAb5B,CAAC,CAexB,GACA,QAAS,EAAQ,OAAO,EAAE,IAAI,AAAC,GAAM,EAAE,EAAE,CAAC,QAAQ,IAClD,KAAM,CACL,UAAW,EAAQ,IAAI,EAAE,UACzB,OAAQ,EAAQ,IAAI,EAAE,OACtB,iBAAkB,EAAQ,IAAI,EAAE,iBAChC,YAAa,CACZ,QAAS,EAAQ,IAAI,EAAE,aAAa,QACpC,4BAA6B,CAAC,CAAC,EAAQ,IAAI,EAAE,aAAa,2BAC3D,CACD,EACA,aAAc,CACb,UAAW,EAAQ,YAAY,EAAE,UACjC,eAAgB,EAAQ,YAAY,EAAE,eACtC,OAAQ,EAAQ,YAAY,EAAE,MAC/B,EACA,QAAS,CACR,UAAW,AAmaqB,EAnab,OAAO,EAAE,UAC5B,iBAAkB,EAAQ,OAAO,EAAE,iBACnC,YAAa,CACZ,QAAS,EAAQ,OAAO,EAAE,aAAa,QACvC,OAAQ,EAAQ,OAAO,EAAE,aAAa,OACtC,SAAU,EAAQ,OAAO,EAAE,aAAa,QACzC,EACA,sBAAuB,EAAQ,OAAO,EAAE,sBACxC,UAAW,EAAQ,OAAO,EAAE,UAC5B,OAAQ,EAAQ,OAAO,EAAE,OACzB,SAAU,EAAQ,OAAO,EAAE,SAC3B,0BAA2B,EAAQ,OAAO,EAAE,0BAC5C,uBAAwB,EAAQ,OAAO,EAAE,uBACzC,UAAW,EAAQ,OAAO,EAAE,SAC7B,EACA,QAAS,CACR,UAAW,EAAQ,OAAO,EAAE,UAC5B,OAAQ,EAAQ,OAAO,EAAE,OACzB,mBAAoB,EAAQ,OAAO,EAAE,mBACrC,sBAAuB,EAAQ,OAAO,EAAE,sBACxC,eAAgB,CACf,QAAS,EAAQ,OAAO,EAAE,gBAAgB,QAC1C,iBAAkB,EAAQ,OAAO,EAAE,gBAAgB,iBACnD,qBAAsB,EAAQ,OAAO,EAAE,gBAAgB,qBACvD,kBAAmB,EAAQ,OAAO,EAAE,gBAAgB,iBACrD,CACD,EACA,MAAO,CACN,MAAO,CAAC,CAAC,EAAQ,KAAK,EAAE,MACxB,OAAQ,CAAC,CAAC,EAAQ,KAAK,EAAE,MAC1B,EACA,iBAAkB,CAAC,CAAC,EAAQ,gBAAgB,CAC5C,SAAU,CACT,aAAc,CAAC,CAAC,EAAQ,QAAQ,EAAE,aAClC,QAAS,CAAC,CAAC,EAAQ,QAAQ,EAAE,QAC7B,sBAAuB,CACtB,OAAQ,CAAC,CAAC,EAAQ,QAAQ,EAAE,uBAAuB,OACnD,QAAS,EAAQ,QAAQ,EAAE,uBAAuB,QAClD,kBAAmB,EAAQ,QAAQ,EAAE,uBAAuB,iBAC7D,EACA,SAAU,CACT,YAAa,CAAC,CAAC,EAAQ,QAAQ,EAAE,UAAU,aAAe,EAAQ,QAAQ,EAAE,UAAU,aAAe,SACrG,WAAY,EAAQ,QAAQ,EAAE,UAAU,WACxC,qBAAsB,EAAQ,QAAQ,EAAE,UAAU,oBACnD,EACA,iBAAkB,EAAQ,QAAQ,EAAE,iBACpC,UAAW,CACV,kBAAmB,EAAQ,QAAQ,EAAE,WAAW,kBAChD,iBAAkB,EAAQ,QAAQ,EAAE,WAAW,gBAChD,EACA,iBAAkB,EAAQ,QAAQ,EAAE,iBACpC,iBAAkB,CACjB,QAAS,EAAQ,QAAQ,EAAE,yBAAyB,QACpD,OAAQ,EAAQ,QAAQ,EAAE,yBAAyB,OACnD,SAAU,EAAQ,QAAQ,EAAE,yBAAyB,SACrD,OAAQ,CAAC,CAAC,EAAQ,QAAQ,EAAE,yBAAyB,OACrD,KAAM,EAAQ,QAAQ,EAAE,yBAAyB,KACjD,SAAU,EAAQ,QAAQ,EAAE,yBAAyB,QACtD,CACD,EACA,eAAgB,EAAQ,cAAc,EAAE,OACxC,UAAW,CACV,QAAS,EAAQ,SAAS,EAAE,QAC5B,UAAW,EAAQ,SAAS,EAAE,UAC9B,OAAQ,EAAQ,SAAS,EAAE,OAC3B,cAAe,CAAC,CAAC,EAAQ,SAAS,EAAE,cACpC,QAAS,EAAQ,SAAS,EAAE,QAC5B,IAAK,EAAQ,SAAS,EAAE,GACzB,EACA,WAAY,CACX,SAAU,EAAQ,UAAU,EAAE,SAC9B,QAAS,CAAC,CAAC,EAAQ,UAAU,EAAE,QAC/B,MAAO,EAAQ,UAAU,EAAE,KAC5B,EACA,OAAQ,CACP,SAAU,EAAQ,MAAM,EAAE,SAC1B,MAAO,EAAQ,MAAM,EAAE,MACvB,IAAK,CAAC,CAAC,EAAQ,MAAM,EAAE,GACxB,EACA,cAAe,CACd,KAAM,CACL,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,MAAM,QAAQ,MAC9C,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,MAAM,QAAQ,MAChD,EACA,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,MAAM,QAAQ,MAC9C,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,MAAM,QAAQ,MAChD,CACD,EACA,QAAS,CACR,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACjD,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACnD,EACA,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACjD,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACnD,CACD,EACA,QAAS,CACR,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACjD,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACnD,EACA,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACjD,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,SAAS,QAAQ,MACnD,CACD,EACA,aAAc,CACb,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,cAAc,QAAQ,MACtD,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,cAAc,QAAQ,MACxD,EACA,OAAQ,CACP,MAAO,CAAC,CAAC,EAAQ,aAAa,EAAE,cAAc,QAAQ,MACtD,OAAQ,CAAC,CAAC,EAAQ,aAAa,EAAE,cAAc,QAAQ,MACxD,CACD,CACD,CACD,EA2SG,QA7EH,AAAoB,CA6ER,YA7ER,AAA6B,OAAtB,KAA6B,CACvC,KAAM,OACN,QAAS,MAAM,SAAS,MAAQ,IACjC,EACmB,aAAf,AAA4B,OAArB,IAA4B,CACtC,KAAM,MACN,QAAS,KAAK,SAAW,IAC1B,EACuB,aAAnB,OAAO,SAA2B,SAAS,UAAU,KAAa,CAAP,AAC9D,KAAM,OACN,QAAS,QAAQ,QAAQ,CAAC,IAAI,EAAI,IACnC,EACO,CACN,KAAM,OACN,QAAS,IACV,EA+DG,SAAU,MAAM,KAChB,UAAW,MAAM,KACjB,YA9D8B,CA8DjB,cA9DT,CAAA,EAAA,GAAA,CAAA,AAAS,EAAC,YAA+B,aAxB9B,AAwB6C,UAxBxD,CAAsB,EAAtB,CAAG,CAAC,EAAE,GAAiB,aAAc,GAAA,CAAG,EAAI,iBAAkB,GAAA,CAAG,EAAI,OAAQ,GAAA,CAAG,EAAI,cAAe,GAAA,CAAG,EAAI,gBAAiB,GAAA,CAAG,EAAI,oBAAqB,GAAA,CAAG,EAAI,YAAa,GAAA,CAAG,EAAI,2BAA4B,GAAA,CAAG,EAAI,WAAY,GAAA,CAAA,AAAG,EAwBnK,KAAO,CAAA,EAAA,EAAA,CAAA,AAAM,IAAK,OAAS,cA+DhG,WAAY,MAAM,KAClB,eAAgB,AAlNpB,SAAS,EACR,IAAM,EAAY,GAAA,CAAG,CAAC,qBAAqB,CAC3C,GAAI,CAAC,EAAW,OAChB,IAAM,EAAS,EAAU,KAAK,CAAC,IAAI,CAAC,EAAE,CAChC,EAAe,EAAO,WAAW,CAAC,KAClC,EAAO,EAAO,SAAS,CAAC,EAAG,GACjC,MAAO,CACN,KAAe,eAAT,EAAwB,OAAS,EACvC,QAAS,EAAO,SAAS,CAAC,EAAe,EAC1C,CACD,GAyMG,cACA,CACD,IAED,MAAO,CAAE,QAAS,MAAO,IACnB,IACD,AAAC,GAAa,EADJ,CACkB,MAAM,GAAa,EAAQ,QAAO,EAClE,MAAM,EAAM,CACX,KAAM,EAAM,IAAI,CAChB,QAAS,EAAM,OAAO,aACtB,CACD,GACD,CAAE,CACH,CgC7eA,IAAM,GAAiB,0CAIvB,SAAS,GAAU,CAAG,EACrB,MAAO,CAAC,CAAC,IAAuB,GAAhB,OAAC,OAAO,GAAmC,YAAf,OAAO,CAAQ,CAAU,EAAyB,YAApB,OAAO,EAAI,IAAI,AAC1F,CAIA,eAAe,GAAc,CAAG,EAC/B,IAAI,EAAU,EAAI,OAAO,CACnB,EAAU,EAAQ,OAAO,EAAI,EAAE,CACjC,EAAU,EACR,EAAU,EAAE,CAClB,IAAK,IAAM,KAAU,EAAS,GAAI,EAAO,IAAI,CAAE,CAC9C,IACI,EADA,EAAc,EAAO,IAAI,CAAC,GAI9B,GAAsB,UAAlB,OAFwB,AAEjB,EAFP,GAAU,GAAuB,MAAM,EAC7B,GACkB,CAC/B,GAAI,EAAO,OAAO,CAAE,CACnB,GAAM,eAAE,CAAa,CAAE,GAAG,EAAU,CAAG,EAAO,OAAO,CACjD,GAAe,EAAQ,IAAI,CAAC,GAChC,EAAU,GAAK,EAAS,EACzB,CACI,EAAO,OAAO,GAAE,EAAU,CAC7B,GAAG,CAAO,CACV,GAAG,EAAO,OAAO,CAClB,CACD,CACD,CASA,OARA,EAAQ,IAAI,CAAC,EAAQ,aAAa,EAClC,EAAQ,eAAe,CAAG,GAAsB,EAAQ,OAAO,CAAE,SAChE,EACA,OAAQ,EAAQ,MAAM,CACtB,MAAO,EAAQ,MAAM,CAAC,AAAC,GAAY,KAAK,IAAX,GAC7B,WAAY,EAAQ,UAAU,AAC/B,GACA,EAAQ,OAAO,CAAG,EACX,SAAE,CAAQ,CAClB,CA0CA,eAAe,GAAkB,CAAO,CAAE,CAAO,CAAE,CAAe,cAyH7D,Md8EE,IAEA,EctIG,EACA,CAnEL,CAAC,EAAQ,QAAQ,GAAE,EAAU,GAAO,EAAS,CAChD,QAAS,CAAE,YAAa,CACvB,SAAS,EACT,SAAU,MACV,cAAc,CACf,CAAE,EACF,QAAS,CACR,mBAAoB,SACpB,oBAAoB,CACrB,CACD,EAAA,EACA,IAAM,EAAU,EAAQ,OAAO,EAAI,EAAE,CAC/B,GAtDqB,EAsDgB,EApDvC,EAAQ,CAFsB,OAEd,CAoDI,CApDF,uBAAuB,QAD7B,CACsC,CAAC,AADrC,EAsDZ,EAAW,CAAA,EAAA,GAAA,CAAA,AAAY,EAAC,EAAQ,MAAM,EACtC,EAAU,GAAW,EAAQ,OAAO,CAAE,EAAQ,QAAQ,EACtD,EAAS,EAAQ,MAAM,EAAI,GAAA,CAAG,CAAC,kBAAkB,EAAI,GAAA,CAAG,CAAC,WAAW,EAAI,GAvBxE,EAAkB,IAAW,GACnC,IAAI,CAAA,EAAA,EAAA,CAAA,AAAM,KAAI,MACd,GAAI,GAAmB,GAAA,CAAY,CAAE,MAAM,IAAI,GAAA,eAAe,CAAC,yIAC/D,GAAI,CAAC,EAAQ,MAAM,IAAI,GAAA,eAAe,CAAC,yGACvC,GAAI,AAoBW,EApBJ,MAAM,CAAG,GAAI,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,sKAC/C,CAA0B,CAD6L,CAAC,GAdxN,AAAW,GAAG,EADZ,EAAS,GAgBK,CAhBD,IAAI,GAAK,IAAI,EACP,EAClB,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAQ,EAAI,MAAM,KAcT,AAmBZ,EAnBqB,IAAI,CAAC,wHFi6FlD,AEt4FC,SFs4FQ,AAAuB,CAAO,CAAE,CAAQ,EAChD,IAAM,EAAmC,GEv4FlB,CFu4FsB,IAC7C,EAAQ,OADiB,AACV,EAAE,QAAQ,AAAC,GADY,CAErC,GAAI,EAAO,SAAS,EAAE,AACrB,IAAK,GAAM,CAAC,EAAK,EAAS,GAAI,OAAO,OAAO,CAAC,EAAO,SAAS,EAAG,GAAI,GAAY,SAAU,EAAU,CACnG,IAAM,EAAO,EAAS,IAAI,CACtB,EAAU,EAAE,CACZ,EAAS,OAAO,EAAI,WAAY,EAAS,OAAO,EAAE,CACjD,MAAM,OAAO,CAAC,EAAS,OAAO,CAAC,MAAM,EAAG,EAAU,EAAS,OAAO,CAAC,MAAM,CACjC,UAAnC,OAAO,EAAS,OAAO,CAAC,MAAM,GAAe,EAAU,CAAC,EAAS,OAAO,CAAC,MAAM,CAAC,GAEnE,IAAnB,EAAQ,MAAM,GAAQ,EAAU,CAAC,IAAI,EACrC,AAAC,EAAiB,GAAG,CAAC,IAAO,EAAiB,GAAG,CAAC,EAAM,EAAE,EAC9D,EAAiB,GAAG,CAAC,GAAM,IAAI,CAAC,CAC/B,SAAU,EAAO,EAAE,CACnB,YAAa,UACb,CACD,GACD,CAEF,GACA,IAAM,EAAY,EAAE,CACpB,IAAK,GAAM,CAAC,EAAM,EAAQ,GAAI,EAAiB,OAAO,GAAI,GAAI,EAAQ,MAAM,CAAG,EAAG,CACjF,IAAM,EAA4B,IAAI,IAClC,EADc,CACA,EAClB,IAAK,IAAM,EAFoB,GAEX,EAAS,IAAK,IAAM,KAAU,EAAM,OAAO,CAAE,AAC5D,AAAC,EAAU,GAAG,CAAC,IAAS,EAAU,GAAG,CAAC,EAAQ,EAAE,EACpD,EAAU,GAAG,CAAC,GAAQ,IAAI,CAAC,EAAM,QAAQ,EACrC,EAAU,GAAG,CAAC,GAAQ,MAAM,CAAG,IAAG,GAAc,CAAA,EAChD,AAAW,SAAO,EAAQ,MAAM,CAAG,EAAG,GAAc,EACpC,MAAX,GAAkB,EAAU,GAAG,CAAC,OAAM,GAAc,CAAA,EAE9D,GAAI,EAAa,CAChB,IAAM,EAAgB,IAAI,IAAI,IAAI,EAAQ,GAAG,CAAC,AAAC,GAAM,EAAE,QAAQ,GAAG,CAC5D,EAAqB,EAAE,CAC7B,IAAK,GAAM,CAAC,EAAQ,EAAQ,GAAI,EAAU,OAAO,GAAI,CAAI,EAAQ,MAAM,CAAG,GAAgB,MAAX,GAAkB,EAAQ,MAAM,CAAG,GAAgB,MAAX,GAAkB,EAAU,GAAG,CAAC,IAAA,GAAM,EAAmB,IAAI,CAAC,GACrL,EAAU,IAAI,CAAC,MACd,EACA,QAAS,qBACT,CACD,EACD,CACD,CACA,GAAI,EAAU,MAAM,CAAG,EAAG,CACzB,IAAM,EAAmB,EAAU,GAAG,CAAC,AAAC,GAAa,CAAC,KAAK,EAAE,EAAS,IAAI,CAAC,GAAG,EAAE,EAAS,kBAAkB,CAAC,IAAI,CAAC,MAAM,mBAAmB,EAAE,EAAS,OAAO,CAAC,IAAI,CAAC,MAAA,CAAO,EAAE,IAAI,CAAC,MAChL,EAAS,KAAK,CAAC,CAAC;AAClB,EAAE,iBAAiB;;;;;;AAMnB,CAAC,CACA,CACD,EEn8FC,EAAU,CACT,GAAG,CAAO,QACV,EACA,QAAS,EAAU,IAAI,IAAI,GAAS,MAAM,CAAG,GAC7C,SAAU,EAAQ,QAAQ,EAAI,YAC9B,QAAS,EAAQ,MAAM,CAAC,EACzB,EACgC,GAChC,IAAM,Gd4KA,EAAe,CADf,EAAe,Ec3KL,Cd0KG,Ec1KQ,Id4KO,CAFR,SACc,MACW,CAAE,OAAQ,EAAQ,OAAO,EAAE,WAAa,GAAG,MAAQ,GAAI,KACtF,EAAa,eAAgB,CAAE,OAAQ,EAAQ,OAAO,EAAE,aAAa,QAAU,GAAI,GACjG,EAAc,EAAa,eAAgB,CAAE,OAAQ,EAAQ,OAAO,EAAE,aAAa,QAAU,GAAI,KAC7E,EAAa,iBAChC,CACN,aAAc,CACb,KAAM,EAAa,IAAI,CACvB,QAAS,EAAa,UACvB,AADiC,EAEjC,YAAa,CACZ,KAAM,EAAY,IAAI,CACtB,QAAS,EAAY,UAAU,AAChC,EACA,kBAAmB,CAClB,KAAM,EAAkB,IAAI,CAC5B,QAAS,EAAkB,UAAU,AACtC,EACA,YAAa,CACZ,KAAM,EAAY,IAAI,CACtB,QAAS,EAAY,UAAU,AAChC,CACD,GchMM,EAAS,CAAA,EAAA,EAAA,CAAa,AAAb,EAAc,GACvB,EAAY,OAAO,OAAO,CAAC,EAAQ,eAAe,EAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,EAAK,EAAO,IACjF,GAAc,MAAV,IACmB,IAAnB,EAAO,CAAmB,MAAZ,CADE,AACiB,OADV,IAEvB,CAAC,EAAO,QAAQ,EAAE,EAAS,IAAI,CAAC,CAAC,gBAAgB,EAAE,EAAI,oCAAoC,CAAC,EAChG,IAAM,EAAW,EAAe,CAAC,EAAI,CAAC,GAEtC,OADA,EAAS,qBAAqB,CAAG,EAAO,qBAAqB,CACtD,CACR,GAAG,MAAM,CAAC,AAAC,GAAY,OAAN,GACX,EAAiB,CAAC,CAAE,OAAK,MAAE,CAAI,CAAE,GACtC,AAA4C,YAAxC,AAAoD,OAA7C,EAAQ,QAAQ,EAAE,WAAkC,EAAQ,QAAQ,CAAC,UAAU,CAAC,OAC1F,OACA,CACD,GACuD,YAAnD,AAA+D,OAAxD,GAAS,UAAU,UAAU,WAAkC,EAAQ,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,OAC9G,OACA,CACD,GACO,CAAA,EAAA,EAAA,CAAA,AAAU,EAAC,GAEb,SAAE,CAAO,CAAE,CAAG,MAAM,GAAgB,EAAS,CAClD,QAAS,EAAQ,EAAE,CACnB,SAAsC,YAA5B,OAAO,EAAQ,QAAQ,CAAkB,UAAY,EAAgB,EAAQ,QAAQ,CAChG,GACM,EAAgB,GAAc,CACnC,QAAS,EAAQ,OAAO,EAAI,cAC5B,gBAAiB,UACjB,EACA,YAAa,CACZ,mBAAoB,EAAQ,OAAO,EAAE,oBAAsB,WAC3D,qBAAsB,CAAC,CAAC,EAAQ,OAAO,EAAE,oBAC1C,SACA,EACA,eAAgB,AAhGlB,SAAS,AAAkB,CAAO,EACjC,IAAM,EAAU,GAAW,EAAQ,OAAO,CAAE,EAAQ,QAAQ,EAC5D,GAAI,CAAC,EAAS,MAAO,EAAE,CACvB,IAAM,EAAiB,CAAC,IAAI,IAAI,GAAS,MAAM,CAAC,AAC5C,GAAQ,cAAc,EAAI,MAAM,OAAO,CAAC,EAAQ,cAAc,GAAG,EAAe,IAAI,IAAI,EAAQ,cAAc,EAClH,IAAM,EAAoB,GAAA,CAAG,CAAC,2BAA2B,CAEzD,GADI,GAAmB,EAAe,IAAI,IAAI,EAAkB,KAAK,CAAC,MAClE,EAAe,MAAM,CAAE,AAAD,GAAO,CAAC,GAAG,MAAM,CAAE,MAAM,IAAI,GAAA,eAAe,CAAC,kGACvE,OAAO,CACR,EAuFoC,GAClC,QAAS,GAAW,GACpB,cAAe,CACd,UAAW,EAAQ,OAAO,EAAE,YAAc,KAAK,EAAI,EAAQ,OAAO,CAAC,SAAS,CAAG,MAC/E,CADsF,SAC3E,EAAQ,OAAO,EAAE,WAAa,OAAO,AAChD,KADqD,IAC3C,EAAQ,OAAO,EAAE,WAAa,KAAK,EAAI,MAAY,CAAL,CAAa,OAAO,CAAC,QAAQ,CACrF,kBAAA,EAAoB,CAAC,CACC,EAAQ,OAAO,EAAE,aAAa,eACpC,EAAQ,OAAO,EAAE,aAAa,QAAU,IACvD,CAAqB,IAAjB,GAA2C,KAAK,GAAG,CAAzB,KACT,CADyC,GAC1D,EAAuB,AAAO,CACjC,SAAS,EACT,UAAW,KAAK,KAAK,CAAU,GAAT,EACvB,EACO,CACN,QAAS,GACT,UAAsC,KAAK,IAAhC,EAAa,SAAS,CAAc,EAAa,SAAS,CAAG,KAAK,KAAK,CAAU,GAAT,EACpF,GAEF,SACA,EACA,UAAW,CACV,GAAG,EAAQ,SAAS,CACpB,QAAS,EAAQ,SAAS,EAAE,SAAW,GAAA,CAAY,CACnD,OAAQ,EAAQ,SAAS,EAAE,QAAU,GACrC,IAAK,EAAQ,SAAS,EAAE,KAAO,IAC/B,QAAS,EAAQ,SAAS,EAAE,UAAY,CAAD,CAAS,gBAAgB,CAAG,oBAAsB,QAAA,CAAQ,AAClG,EACA,YAAa,EACb,OAAQ,EACR,WAAY,EACZ,QAAS,KACT,iBAAkB,EAAQ,gBAAgB,CAC1C,SAAU,CACT,KAAM,EAAQ,gBAAgB,EAAE,UAAU,MAAQ,GAAA,CAAY,CAC9D,OAAQ,EAAQ,gBAAgB,EAAE,UAAU,QAAU,GAAA,CAAc,CACpE,OAAQ,CACP,kBAAmB,EAAQ,gBAAgB,EAAE,mBAAqB,EAClE,kBAAmB,EAAQ,gBAAgB,EAAE,mBAAqB,GACnE,EACA,cAAA,EACD,EACA,cAAc,CAAO,EACpB,IAAI,CAAC,UAAU,CAAG,CACnB,EACA,WAAY,aACZ,EACA,gBAAiB,GAAsB,EAAS,SAC/C,EACA,OAAQ,EACR,MAAO,EAAQ,aAAa,CAAG,CAAC,EAAQ,aAAa,CAAC,CAAG,EAAE,CAC3D,WAAY,CACb,GACA,iBAAkB,GAAmB,GACrC,MAAM,gBACL,MAAM,IAAI,GAAA,eAAe,CAAC,gEAC3B,EACA,iBAAkB,EAClB,cAAe,CAAC,CAAC,EAAQ,QAAQ,EAAE,iBACnC,gBAAiB,EAAQ,QAAQ,EAAE,qBAAuB,KAAK,EAAI,EAAQ,QAAQ,CAAC,kBAAkB,GAAG,CAAA,EAAA,EAAA,CAAA,AAAM,GAChH,GADqH,AAKrH,OAL4H,AAGxH,GAAU,GAAiB,SAAC,CAAO,CAAC,CAAG,CAAb,KAAmB,EAC3C,SAAC,CAAO,CADgD,AAC/C,CAAG,EACX,CACR,CrB1NA,IAAM,GAAO,EqBwNmB,IrBxNZ,IACnB,IAAM,EAAU,MAAM,GAAW,GAE3B,EAAM,MAAM,GAAkB,EAAS,EADrB,AAAC,GAAa,CAAA,EAAA,CACgB,CADhB,CAAA,AAAqB,EAAC,IAAa,WAOzE,OALA,EAAI,aAAa,CAAG,iBACnB,GAAI,CAAC,EAAQ,QAAQ,EAAI,eAAgB,EAAQ,QAAQ,CAAE,MAAM,IAAI,GAAA,eAAe,CAAC,wGACrF,GAAM,eAAE,CAAa,CAAE,CAAG,MAAM,GAAc,EAC9C,OAAM,GACP,EACO,CACR,UnBbA,IAAM,GAAa,EAAA,MAAQ,CAAC,CAC3B,GAAI,EAAA,MAAQ,GACZ,UAAW,EAAA,IAAM,GAAG,OAAO,CAAC,IAAM,AAAgB,IAAI,MACtD,GAD+C,OACpC,EAAA,IAAM,GAAG,OAAO,CAAC,IAAsB,AAAhB,IAAoB,KACvD,GAIsB,CAL0B,EAKf,MAAM,CAAC,CACvC,WAAY,EAAA,MAAQ,GACpB,UAAW,EAAA,MAAQ,GACnB,OAAQ,GAAA,MAAQ,CAAC,MAAM,GACvB,YAAa,EAAA,MAAQ,GAAG,OAAO,GAC/B,aAAc,EAAA,MAAQ,GAAG,OAAO,GAChC,QAAS,EAAA,MAAQ,GAAG,OAAO,GAC3B,qBAAsB,EAAA,IAAM,GAAG,OAAO,GACtC,sBAAuB,EAAA,IAAM,GAAG,OAAO,GACvC,MAAO,EAAA,MAAQ,GAAG,OAAO,GACzB,SAAU,EAAA,MAAQ,GAAG,OAAO,EAC7B,GAIwB,EAAA,MAAQ,CAAC,CAChC,IAAK,EAAA,MAAQ,GACb,MAAO,EAAA,MAAQ,GACf,YAAa,EAAA,MAAQ,EACtB,GAIsB,GAAW,MAAM,CAAC,CACvC,OAAQ,GAAA,MAAQ,CAAC,MAAM,GACvB,UAAW,EAAA,IAAM,GACjB,MAAO,EAAA,MAAQ,GACf,UAAW,EAAA,MAAQ,GAAG,OAAO,GAC7B,UAAW,EAAA,MAAQ,GAAG,OAAO,EAC9B,GAImB,GAAW,MAAM,CAAC,CACpC,MAAO,EAAA,MAAQ,GAAG,SAAS,CAAC,AAAC,GAAQ,EAAI,WAAW,IACpD,cAAe,EAAA,OAAS,GAAG,OAAO,EAAC,GACnC,KAAM,EAAA,MAAQ,GACd,MAAO,EAAA,MAAQ,GAAG,OAAO,EAC1B,GAI2B,GAAW,MAAM,CAAC,CAC5C,MAAO,EAAA,MAAQ,GACf,UAAW,EAAA,IAAM,GACjB,WAAY,EAAA,MAAQ,EACrB,GkBpDA,IAAA,GAAA,EAAA,CAAA,CAAA,OAGA,GAAA,EAAA,CAAA,CAAA,OAAA,GAAA,EAAA,CAAA,CAAA,O3BRA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OACA,IAAA,GAAA,EAAA,CAAA,CAAA,OUgCA,SAAS,GAAoB,CAAC,EAC7B,MAAO,CACN,QAAQ,UAAU,MAhCZ,CACN,UAAU,CAAO,CAAE,EAAY,KAAK,EACnC,IAAI,GAAU,EACd,IAAK,GAAM,CAAC,EAAmB,EAAiB,GAAI,OAAO,OAAO,CAAC,GAAU,CAC5E,IAAM,EAAiB,CAAU,CAAC,EAAkB,CACpD,GAAI,CAAC,EAAgB,MAAO,CAC3B,SAAS,EACT,MAAO,CAAC,wCAAwC,EAAE,EAAA,CAAmB,AACtE,EACA,GAAI,MAAM,OAAO,CAAC,GAAmB,EAAU,EAAiB,KAAK,CAAC,AAAC,GAAoB,EAAe,QAAQ,CAAC,SAC9G,GAAgC,UAA5B,AAAsC,OAA/B,EAEiB,EAAN,OAAtB,EAAQ,SAAS,CAAqB,EAAQ,OAAO,CAAC,IAAI,CAAC,AAAC,GAAoB,EAAe,QAAQ,CAAC,IAC7F,AAFC,EAEO,OAAO,CAAC,KAAK,CAAC,AAAC,GAAoB,EAAe,QAAQ,CAAC,SAC5E,MAAM,IAAI,GAAA,eAAe,CAAC,kCACjC,GAAI,GAAyB,OAAd,EAAoB,MAAO,SAAE,CAAQ,EACpD,GAAI,CAAC,GAAyB,QAAd,EAAqB,MAAO,CAC3C,SAAS,EACT,MAAO,CAAC,iCAAiC,EAAE,EAAkB,CAAC,CAAC,AAChE,CACD,QACI,AAAJ,EAAoB,OAAP,EAAS,CAAQ,EACvB,CACN,QAAS,GACT,MAAO,gBACR,CACD,EACA,UAAA,CA5BY,EAkCC,CALd,GAOC,IApCsB,OAoCV,CACb,CACD,CEpBA,IAAM,GAAY,GAlBQ,CACzB,KAAM,CACL,SACA,CAeoC,MAdpC,WACA,MACA,cACA,SACA,eACA,MACA,SACA,CACD,QAAS,CACR,OACA,SACA,SACA,AACF,GAEgB,GAAU,OAAO,CAAC,CACjC,KAAM,CACL,SACA,OACA,WACA,MACA,cACA,SACA,eACA,MACA,SACA,CACD,QAAS,CACR,OACA,SACA,SACA,AACF,GACe,GAAU,OAAO,CAAC,CAChC,KAAM,EAAE,CACR,QAAS,EAAE,AACZ,GEpBA,IAAM,GAAY,GApBQ,CACzB,aAAc,CAAC,EAmBsB,OAnBZ,SAAS,CAClC,OAAQ,CACP,SACA,SACA,SACA,CACD,WAAY,CAAC,SAAU,SAAS,CAChC,KAAM,CACL,SACA,SACA,SACA,CACD,GAAI,CACH,SACA,OACA,SACA,SACA,AACF,GAEgB,GAAU,OAAO,CAAC,CACjC,aAAc,CAAC,SAAS,CACxB,WAAY,CAAC,SAAU,SAAS,CAChC,OAAQ,CACP,SACA,SACA,SACA,CACD,KAAM,CACL,SACA,SACA,SACA,CACD,GAAI,CACH,SACA,OACA,SACA,SACA,AACF,GACgB,GAAU,OAAO,CAAC,CACjC,aAAc,CAAC,SAAU,SAAS,CAClC,OAAQ,CACP,SACA,SACA,SACA,CACD,WAAY,CAAC,SAAU,SAAS,CAChC,KAAM,CACL,SACA,SACA,SACA,CACD,GAAI,CACH,SACA,OACA,SACA,SACA,AACF,GACiB,GAAU,OAAO,CAAC,CAClC,aAAc,EAAE,CAChB,OAAQ,EAAE,CACV,WAAY,EAAE,CACd,KAAM,EAAE,CACR,GAAI,CAAC,OACN,AADa,mB6BzDa,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAC1C,sBAAuB,wBACvB,oBAAqB,uBACrB,sCAAuC,0CACvC,wBAAyB,0BACzB,yCAA0C,2CAC1C,oCAAqC,sCACrC,kCAAmC,oCACnC,2CAA4C,6CAC5C,iCAAkC,mCAClC,yCAA0C,2CAC1C,6CAA8C,+CAC9C,oCAAqC,sCACrC,0CAA2C,4CAC3C,YAAa,6CACb,gCAAiC,kCACjC,kBAAmB,oBACnB,oCAAqC,sCACrC,2BAA4B,6BAC5B,8CAA+C,sDAChD,aJtB8B,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAC9C,qBAAsB,4CACtB,sBAAuB,wBACvB,yBAA0B,2BAC1B,iDAAkD,kDACnD,WLRA,EAAA,CAAA,CAAA,OAAA,EAAA,CAAA,CAAA,ccQsC,GAAA,QAAQ,CAoNf,EAAA,MAAQ,CAAC,CACvC,SAAU,EAAA,MAAQ,GAClB,aAAc,EAAA,MAAQ,GAAG,QAAQ,GACjC,KAAM,EAAA,IAAM,CAAC,CACZ,MACA,SACA,mBACA,SACA,EACD,KAAM,EAAA,MAAQ,GACd,KAAM,EAAA,MAAQ,GAAG,QAAQ,GACzB,SAAU,EAAA,MAAQ,GAAG,QAAQ,GAC7B,SAAU,EAAA,OAAS,GAAG,QAAQ,GAAG,OAAO,EAAC,GACzC,aAAc,EAAA,MAAQ,GACtB,OAAQ,EAAA,MAAQ,GAAG,QAAQ,GAC3B,UAAW,EAAA,IAAM,GACjB,UAAW,EAAA,IAAM,EAClB,kBK42CoB,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CACpC,sBAAuB,0CACvB,oCAAqC,2DACrC,oCAAqC,2DACrC,YAAa,iBACb,qBAAsB,kCACtB,cAAe,oBACf,aAAc,sBACd,YAAa,sBACb,eAAgB,sCAChB,oBAAqB,6BACrB,wBAAyB,8DACzB,wBAAyB,6DACzB,kBAAmB,wDACnB,sBAAuB,sDACvB,oBAAqB,oDACrB,kBAAmB,wBACnB,oBAAqB,uBACrB,oBAAqB,uBACrB,wBAAyB,6CACzB,gBAAiB,mBACjB,6BAA8B,2CAC9B,mCAAoC,gEACpC,qBAAsB,wFACtB,yBAA0B,2BAC1B,cAAe,2BAChB,a/B7lD6B,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAC7C,oBAAqB,8BACrB,iBAAkB,2BAClB,cAAe,sBAChB,GAC6B,CAAA,EAAA,GAAA,CAAgB,AAAhB,EAAiB,CAC7C,mBAAoB,qBACpB,oBAAqB,6BACtB,GE/B8B,EAAA,QAAU,CAAC,EAAA,MAAQ,CAAC,CACjD,mBAAoB,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,sDAAuD,GAAG,EAAE,CAAC,EAAA,MAAQ,GAAG,SAAS,CAAC,AAAC,GAAY,SAAN,IAAe,QAAQ,GACpK,eAAgB,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,2FAA4F,GAAG,QAAQ,EACxJ,ccCyC,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CACzD,oBAAqB,sBACrB,oBAAqB,0BACrB,kBAAmB,wBACnB,sBAAuB,wBACvB,cAAe,gBACf,kBAAmB,oBACnB,8BAA+B,gCAC/B,uBAAwB,yBACxB,eAAgB,iBAChB,yBAA0B,2BAC1B,2BAA4B,6BAC5B,wBAAyB,yBAC1B,GA0CmB,EAAA,MAAQ,CAAC,CAC3B,GAAI,EAAA,MAAQ,GACZ,WAAY,EAAA,MAAQ,GACpB,SAAU,EAAA,MAAQ,GAClB,OAAQ,EAAA,MAAQ,GAAG,QAAQ,GAC3B,UAAW,EAAA,IAAM,GACjB,OAAQ,EAAA,MAAQ,GAChB,aAAc,EAAA,IAAM,GAAG,QAAQ,GAC/B,gBAAiB,EAAA,MAAQ,GAAG,QAAQ,GACpC,SAAU,EAAA,MAAQ,GAAG,QAAQ,GAC7B,MAAO,EAAA,MAAQ,GAAG,QAAQ,EAC3B,GAIA,IAAM,GAAsB,EAAA,MAAQ,CAAE,AAAD,IACpC,GAAI,CACH,GAAG,EACJ,CAAE,MAAO,EAAG,CACX,OAAO,CACR,CACA,OAAO,CACR,EAAG,CAAE,QAAS,sEAAuE,GAC5C,EAAA,MAAQ,CAAC,CACjD,UAAW,GAAoB,OAAO,CAAC,OAAO,QAAQ,CAAC,2FACvD,SAAU,GAAoB,OAAO,CAAC,MAAM,QAAQ,CAAC,sFACrD,iBAAkB,EAAA,MAAQ,GAAG,GAAG,GAAG,QAAQ,GAAG,OAAO,CAAC,IAAI,QAAQ,CAAC,wEACnE,eAAgB,EAAA,MAAQ,GAAG,GAAG,GAAG,QAAQ,GAAG,OAAO,CAAC,GAAG,QAAQ,CAAC,qEAChE,mBAAoB,EAAA,MAAQ,CAAC,AAAC,GAAQ,AAAe,mBAAR,EAAoB,CAAE,QAAS,qGAAsG,GAAG,QAAQ,GAAG,QAAQ,CAAC,wGACzM,iBAAkB,EAAA,MAAQ,CAAC,AAAC,GAAuB,YAAf,OAAO,EAAoB,CAAE,QAAS,mGAAoG,GAAG,QAAQ,GAAG,QAAQ,CAAC,sGACrM,eAAgB,EAAA,MAAQ,CAAC,AAAC,GAAuB,YAAf,OAAO,EAAoB,CAAE,QAAS,mGAAoG,GAAG,QAAQ,GAAG,QAAQ,CAAC,yFACnM,oBAAqB,EAAA,MAAQ,CAAC,AAAC,GAAuB,YAAf,OAAO,EAAoB,CAAE,QAAS,8FAA+F,GAAG,QAAQ,GAAG,QAAQ,CAAC,2GACnM,gBAAiB,EAAA,MAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,mPAChD,OAAQ,EAAA,MAAQ,CAAC,KAAM,EACxB,mBOnEoB,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CACpC,YAAa,cACb,YAAa,cACb,kBAAmB,mBACpB,mBCtBkC,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAClD,4BAA6B,8BAC7B,oBAAqB,oDACrB,0BAA2B,+BAC3B,qBAAsB,0BACtB,qBAAsB,+BACtB,iBAAkB,qBACnB,iBjBdoB,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAAE,qBAAsB,oFAAqF,aGC9H,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAAE,sBAAuB,uBAAwB,4BkB0nBhE,GAAqB,UACnC,EAAC,GAMoB,GAAqB,CAAE,IAAK,CAAC,GAAkB,AAAC,EAAG,MAAO,IAC/E,CAAE,QAAS,EAAI,OAAO,CAAC,OAAO,CAAC,GAKN,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CACjD,iDAAkD,mDAClD,qDAAsD,uDACtD,4BAA6B,8BAC7B,gCAAiC,kCACjC,uBAAwB,yBACxB,yCAA0C,2CAC1C,gDAAiD,kDACjD,gDAAiD,kDACjD,uBAAwB,yBACxB,8CAA+C,gDAC/C,iBAAkB,mBAClB,eAAgB,iBAChB,yCAA0C,2CAC1C,oBAAqB,sBACrB,eAAgB,iBAChB,oDAAqD,sDACrD,mDAAoD,qDACpD,0CAA2C,4CAC3C,yDAA0D,2DAC1D,6CAA8C,+CAC9C,qBAAsB,uBACtB,4CAA6C,8CAC7C,qEAAsE,uEACtE,8CAA+C,gDAC/C,kDAAmD,oDACnD,kDAAmD,sDACnD,8BAA+B,gCAC/B,6CAA8C,+CAC9C,2BAA4B,6BAC5B,0CAA2C,4CAC3C,sCAAuC,wCACvC,yDAA0D,2DAC1D,yDAA0D,2DAC1D,wCAAyC,0CACzC,wCAAyC,0CACzC,yBAA0B,2BAC1B,0BAA2B,4BAC3B,iCAAkC,mCAClC,4CAA6C,uDAC7C,+BAAgC,iCAChC,gDAAiD,6CACjD,4CAA6C,8CAC7C,gDAAiD,8DACjD,0CAA2C,4CAC3C,oBAAqB,6HACrB,gDAAiD,kDACjD,qCAAsC,uCACtC,qCAAsC,uCACtC,qCAAsC,uCACtC,mCAAoC,qCACpC,mCAAoC,qCACpC,kCAAmC,oCACnC,eAAgB,uCAChB,iBAAkB,uDAClB,2BAA4B,kCAC5B,iCAAkC,kCACnC,GAw+DA,IAAM,GAAa,EAAA,MAAQ,GACrB,GAAmB,EAAA,IAAM,CAAC,CAC/B,UACA,WACA,WACA,WACA,EAAE,OAAO,CAAC,WACgB,EAAA,MAAQ,CAAC,CACnC,GAAI,EAAA,MAAQ,GAAG,OAAO,CAAC,EAAA,CAAU,EACjC,KAAM,EAAA,MAAQ,GACd,KAAM,EAAA,MAAQ,GACd,KAAM,EAAA,MAAQ,GAAG,OAAO,GAAG,QAAQ,GACnC,SAAU,EAAA,MAAQ,CAAC,EAAA,MAAQ,GAAI,EAAA,OAAS,IAAI,EAAE,CAAC,EAAA,MAAQ,GAAG,SAAS,CAAC,AAAC,GAAM,KAAK,KAAK,CAAC,KAAK,QAAQ,GACnG,UAAW,EAAA,IAAM,EAClB,GACqB,EAAA,MAAQ,CAAC,CAC7B,GAAI,EAAA,MAAQ,GAAG,OAAO,CAAC,EAAA,CAAU,EACjC,eAAgB,EAAA,MAAQ,GACxB,OAAQ,GAAA,MAAQ,CAAC,MAAM,GACvB,KAAM,GACN,UAAW,EAAA,IAAM,GAAG,OAAO,CAAC,IAAM,AAAgB,IAAI,KACvD,GACyB,CAFuB,CAEvB,MAAQ,CAAC,CACjC,GAAI,EAAA,MAAQ,GAAG,OAAO,CAAC,EAAA,CAAU,EACjC,eAAgB,EAAA,MAAQ,GACxB,MAAO,EAAA,MAAQ,GACf,KAAM,GACN,OAAQ,GACR,OAAQ,EAAA,MAAQ,GAAG,OAAO,GAC1B,UAAW,EAAA,MAAQ,GACnB,UAAW,EAAA,IAAM,GACjB,UAAW,EAAA,IAAM,GAAG,OAAO,CAAC,IAAsB,AAAhB,IAAoB,KACvD,GACmB,CAF6B,CAE7B,MAAQ,CAAC,CAC3B,GAAI,EAAA,MAAQ,GAAG,OAAO,CAAC,EAAA,CAAU,EACjC,KAAM,EAAA,MAAQ,GAAG,GAAG,CAAC,GACrB,eAAgB,EAAA,MAAQ,GACxB,UAAW,EAAA,IAAM,GACjB,UAAW,EAAA,IAAM,GAAG,QAAQ,EAC7B,GACyB,EAAA,MAAQ,CAAC,CACjC,GAAI,EAAA,MAAQ,GAAG,OAAO,CAAC,EAAA,CAAU,EACjC,OAAQ,EAAA,MAAQ,GAChB,OAAQ,EAAA,MAAQ,GAChB,UAAW,EAAA,IAAM,GAAG,OAAO,CAAC,IAAM,AAAgB,IAAI,KACvD,GAC+B,CAFiB,CAEjB,MAAQ,CAAC,CACvC,GAAI,EAAA,MAAQ,GAAG,OAAO,CAAC,EAAA,CAAU,EACjC,eAAgB,EAAA,MAAQ,GACxB,KAAM,EAAA,MAAQ,GACd,WAAY,EAAA,MAAQ,CAAC,EAAA,MAAQ,GAAI,EAAA,KAAO,CAAC,EAAA,MAAQ,KACjD,UAAW,EAAA,IAAM,GAAG,OAAO,CAAC,IAAM,AAAgB,IAAI,MACtD,GAD+C,OACpC,EAAA,IAAM,GAAG,QAAQ,EAC7B,GACA,IAAM,GAAiB,CACtB,QACA,SACA,QACA,CAC0B,EAAA,KAAO,CAAC,CAAC,EAAA,IAAM,CAAC,IAAiB,EAAA,KAAO,CAAC,EAAA,IAAM,CAAC,KAAiB,kBRhuF3D,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CACjD,qBAAsB,uBACtB,mBAAoB,8BACpB,uBAAwB,gCACxB,iCAAkC,mCAClC,iBAAkB,mBAClB,cAAe,gBACf,YAAa,cACb,YAAa,cACb,0BAA2B,4BAC3B,+BAAgC,iCAChC,yBAA0B,0BAC1B,kBAAmB,mBACpB,GhBnBA,IAAA,GAAA,EAAA,CAAA,CAAA,sC0BwBM,GAAA,OAAA,gBAEA,GAAA,OAAa,MACL,OAAA,iEAKqC,GAAI,IAAS,CAAC,OADS,KAGtD,EAAA,EAAA,CAAA,EAAA,EAAe,QACrB,CAAA,GAAM,CAAD,CAAC,GAAQ,CAAC,UAEV,CAAA,EAAA,CAAA,EAAA,CAAA,EAAuB,CAAC,EAAK,CAAC,CAAC,4CAI1B,GAAA,EAAA,EAAY,EAAA,EAAW,EAAA,eAChB,IAAA,OAAc,EAAA,CAAE,CAAA,EAAA,sDAMtB,CAAC,EAAA,iBDpCK,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAC/C,gBAAiB,kBACjB,gBAAiB,kBACjB,iBAAkB,mBAClB,uBAAwB,2BACxB,yBAA0B,8BAC1B,oBAAqB,sBACrB,aAAc,eACd,mCAAoC,gDACpC,0BAA2B,2BAC5B,mBVjBA,IAAM,GAAuB,CAAA,EAAA,GAAA,CAAA,AAAgB,EAAC,CAC7C,6BAA8B,+BAC9B,mBAAoB,qBACpB,iBAAkB,mBAClB,0BAA2B,iDAC3B,mBAAoB,wBACpB,kBAAmB,uBACnB,iBAAkB,sBAClB,yBAA0B,6BAC3B,GA4BA,SAAS,GAAyB,CAAU,EAC3C,MAAO,mBAAmB,IAAI,CAAC,EAChC,CzB9CA,IAAA,GAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAAA,IAAA,GAAA,EAAA,CAAA,CAAA,OAEO,IAAM,GYoBL,CqB0MiB,CAAC,EjC9NN,AiC8Ne,KAClC,IAAM,EAAc,ErB3MI,AqB2MG,GACrB,CAAE,KAAG,CAAE,CAAG,GAAa,EAAa,GAC1C,MAAO,CACN,QAAS,MAAO,IACf,IAAM,EAAM,MAAM,EACZ,EAAW,EAAI,OAAO,CAAC,QAAQ,EAAI,YACzC,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,CAAE,CACzB,IAAM,EAAU,GAAW,KAAK,EAAG,EAAU,EAAS,KAAK,EAAG,EAAI,OAAO,CAAC,QAAQ,EAAE,qBACpF,GAAI,EACH,EAAI,KADQ,EACD,CAAG,EACd,EAAI,OAAO,CAAC,OAAO,CAAG,GAAU,EAAI,OAAO,GAAK,KAAK,OAC/C,MAAM,IAAI,GAAA,eAAe,CAAC,wEAClC,CACA,EAAI,cAAc,CAAG,IAAI,EAAQ,cAAc,CAAG,MAAM,OAAO,CAAC,EAAQ,cAAc,EAAI,EAAQ,cAAc,CAAG,MAAM,EAAQ,cAAc,CAAC,GAAW,EAAE,CAAE,EAAI,OAAO,CAAC,OAAO,CAAC,CACnL,GAAM,SAAE,CAAO,CAAE,CAAG,CFk4FR,CAAC,EAAK,KACpB,GAAM,KAAE,CAAG,CAAE,aAAW,CAAE,CAAG,GAAa,EAAK,GACzC,EAAW,IAAI,IAAI,EAAI,OAAO,EAAE,QAAQ,CAC9C,MAAO,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAK,CACxB,cAAe,EACf,QAAS,CAAE,UAAU,CAAK,WAC1B,EACA,iBAAkB,CAAC,CAClB,KAAM,MACN,WAAY,EACb,KAAM,EAAY,CAClB,kBAAmB,CAAC,mBAAmB,CACvC,MAAM,UAAU,CAAG,EAClB,IAAM,EAAgB,EAAI,OAAO,CAAC,aAAa,EAAI,EAAE,CAC/C,EAAO,IAAI,IAAI,EAAI,GAAG,EAAE,QAAQ,CAAC,OAAO,CAAC,EAAU,IACzD,GAAI,EAAc,QAAQ,CAAC,GAAO,OAAO,IAAI,SAAS,YAAa,CAAE,OAAQ,GAAI,GACjF,IAAK,IAAM,KAAU,EAAI,OAAO,CAAC,OAAO,EAAI,EAAE,CAAE,GAAI,EAAO,SAAS,CAAE,CACrE,IAAM,EAAW,MAAM,EAAO,SAAS,CAAC,EAAK,GAC7C,GAAI,GAAY,aAAc,EAAU,OAAO,EAAS,QAAQ,CAChE,GAAI,GAAY,YAAa,EAAU,CACtC,IAAM,EAAsB,MAAM,GAAmB,EAAS,OAAO,CAAE,GACvE,GAAI,EAAqB,OAAO,EAChC,OAAO,EAAS,OACjB,AADwB,CAEzB,CACA,OAAO,GAAmB,EAAK,EAChC,EACA,MAAM,WAAW,CAAG,EACnB,IAAK,IAAM,KAAU,EAAI,OAAO,CAAC,OAAO,EAAI,EAAE,CAAE,GAAI,EAAO,UAAU,CAAE,CACtE,IAAM,EAAW,MAAM,EAAO,UAAU,CAAC,EAAK,GAC9C,GAAI,EAAU,OAAO,EAAS,QAC/B,AADuC,CAEvC,OAAO,CACR,EACA,QAAQ,CAAC,EACR,GAAI,aAAa,EAAA,QAAQ,EAAiB,UAAb,EAAE,MAAM,CAAc,OACnD,GAAI,EAAQ,UAAU,EAAE,MAAO,MAAM,EACrC,GAAI,EAAQ,UAAU,EAAE,QAAS,YAChC,EAAQ,UAAU,CAAC,OAAO,CAAC,EAAG,GAG/B,IAAM,EAAc,EAAQ,MAAM,EAAE,MAC9B,EAAsB,UAAhB,GAA2C,SAAhB,GAA0C,UAAhB,EAA0B,GAAA,MAAM,CAAG,KAAK,EACzG,GAAI,EAAQ,MAAM,EAAE,YAAa,EAAM,CACtC,GAAI,GAAkB,UAAb,OAAO,GAAkB,YAAa,GAA0B,UAArB,AAA+B,OAAxB,EAAE,OAAO,GAC/D,EAAE,OAAO,CAAC,QAAQ,CAAC,cAAgB,EAAE,OAAO,CAAC,QAAQ,CAAC,WAAa,EAAE,OAAO,CAAC,QAAQ,CAAC,aAAe,EAAE,OAAO,CAAC,QAAQ,CAAC,UAAY,EAAE,OAAO,CAAC,QAAQ,CAAC,iBAAA,EAAmB,YAC7K,EAAI,MAAM,EAAE,MAAM,EAAE,OAAO,EAIzB,aAAa,EAAA,QAAQ,EAAE,AACT,0BAAb,EAAE,MAAM,EAA8B,EAAI,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAE,GACrE,GAAK,MAAM,EAAE,OAAO,GACd,EAAI,MAAM,EAAE,MAAM,GAAkB,UAAb,OAAO,GAAkB,SAAU,EAAI,EAAE,IAAI,CAAG,GAAI,EACnF,CACD,CACD,EACD,GE37F8B,EAAK,GAChC,MAAO,CAAA,EAAA,GAAA,CAAA,AAAc,EAAC,EAAI,OAAO,CAAE,IAAM,EAAQ,GAClD,MACA,UACA,EACA,SAAU,EACV,aAAc,CACb,GAAG,EAAQ,OAAO,EAAE,OAAO,CAAC,EAAK,IAChC,AAAI,EAAO,YAAY,CAAS,CAC/B,AADwB,GACrB,CAAG,CACN,GAAG,EAAO,YAAY,AACvB,EACO,EACL,CAAC,EAAE,CACN,GAAG,GAAA,CACJ,AADoB,CAErB,CACD,GjC9P+B,CAC7B,QAAA,EAAU,EAAe,GAAA,EAAE,GAAE,CAC3B,SAAU,KACV,WAAW,EACX,OAAQ,CACN,GAAG,EAAM,CACT,KAAM,GAAO,KAAK,CAClB,QAAS,GAAO,QAAQ,CACxB,QAAS,GAAO,QAAQ,CACxB,aAAc,GAAO,aAAa,AACpC,CACF,EWLG,EAAc,KACZ,EAAsB,AAAC,GAAS,CAAC,cAAE,CAAY,SAAE,CAAO,CAAE,IAC/D,SAAS,EAAU,CAAK,EACvB,IAAM,EAAS,EAAO,MAAM,EAAI,EAAK,CAAC,CAAC,UAAU,CACjD,GAAI,CAAC,EAAQ,MAAM,IAAI,GAAA,eAAe,CAAC,yHACvC,IAAM,EAAc,CAAM,CAAC,EAAM,CACjC,GAAI,CAAC,EAAa,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,gCAAgC,EAAE,EAAM,6FAA6F,CAAC,EACnL,OAAO,CACR,CACA,IAAM,EAAgB,MAAO,EAAO,EAAS,EAAM,KAClD,GAAwB,UAApB,EAAO,QAAQ,CAAc,MAAO,CAAC,MAAM,EAAQ,SAAS,EAAA,CAAE,AAAC,CAAC,EAAE,AACtE,OAAM,EAAQ,OAAO,GACrB,IAAM,EAAc,EAAU,GACxB,EAAa,EAAQ,MAAM,EAAE,OACnC,GAAI,GAAO,OAAQ,CAClB,IAAM,EAAS,EAAmB,EAAM,GAAG,CAAC,AAAC,GACtB,AAAtB,KAA2B,GAAG,CAA1B,CAAI,CAAC,EAAE,KAAK,CAAC,CAAoB,CACpC,GAAG,CAAC,CACJ,MAAO,CAAI,CAAC,EAAE,KAAK,CAAC,AACrB,EACO,GACJ,GACJ,MAAO,CAAC,MAAM,EAAK,MAAM,GAAG,IAAI,CAAC,GAAa,KAAK,IAAI,EAAA,CAAO,AAAC,CAAC,EAAE,AACnE,CAAO,GAAI,GAAc,CAAU,CAAC,EAAE,EAAE,IAAI,MAAO,CAClD,IAAI,EAAM,CAAU,CAAC,EAAE,EAAE,IAAI,MAE7B,OADI,AAAC,IAAK,EAAM,CAAC,MAAM,EAAK,MAAM,CAAC,CAAE,GAAI,GAAA,GAAG,CAAC,gBAAgB,CAAE,AAAD,GAAI,IAAI,CAAC,GAAa,OAAO,CAAC,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,EAAY,EAAE,GAAG,KAAK,CAAC,EAAA,CAAE,AAAC,CAAC,EAAE,CAAC,EAAA,AAAE,EAC1H,CAAC,MAAM,EAAK,MAAM,GAAG,IAAI,CAAC,GAAa,KAAK,CAAC,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,EAAY,EAAE,CAAE,IAAM,KAAK,CAAC,GAAG,OAAO,EAAA,CAAE,AAAC,CAAC,EAAE,AACpG,CAAO,GAAI,EAAK,EAAE,CAAE,MAAO,CAAC,MAAM,EAAK,MAAM,GAAG,IAAI,CAAC,GAAa,KAAK,CAAC,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,EAAY,EAAE,CAAE,EAAK,EAAE,GAAG,KAAK,CAAC,GAAG,OAAO,EAAA,CAAE,AAAC,CAAC,EAAE,CAE1H,GAAI,CAAC,CAAC,OAAQ,CAAA,CAAW,CAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,WAAW,EAAE,EAAM,6EAA6E,CAAC,EACxJ,MAAO,CAAC,MAAM,EAAK,MAAM,GAAG,IAAI,CAAC,GAAa,OAAO,CAAC,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,EAAY,EAAE,GAAG,KAAK,CAAC,GAAG,OAAO,EAAA,CAAE,AAAC,CAAC,EAAE,AAEpG,EACA,SAAS,EAAmB,CAAK,CAAE,CAAK,EACvC,IAAM,EAAc,EAAU,GAC9B,GAAI,CAAC,EAAO,MAAO,EAAE,CACrB,GAAqB,IAAjB,EAAM,MAAM,CAAQ,CACvB,IAAM,EAAI,CAAK,CAAC,EAAE,CAClB,GAAI,CAAC,EAAG,MAAO,EAAE,CACjB,IAAM,EAAQ,EAAa,OAC1B,EACA,MAAO,EAAE,KAAK,AACf,GACA,GAAI,CAAC,CAAW,CAAC,EAAM,CAAE,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,8CAA8C,EAAE,EAAM,6BAA6B,CAAC,EAC7J,GAAI,AAAe,SAAb,QAAQ,CAAW,CACxB,GAAI,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,yBAAyB,EAAE,EAAE,KAAK,CAAC,gDAAgD,CAAC,EAC5I,MAAO,CAAC,CAAA,EAAA,GAAA,OAAA,AAAO,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,AAC9C,CACA,GAAmB,WAAf,EAAE,QAAQ,CAAe,CAC5B,GAAI,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,yBAAyB,EAAE,EAAE,KAAK,CAAC,oDAAoD,CAAC,EAChJ,MAAO,CAAC,CAAA,EAAA,GAAA,UAAA,AAAU,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,AACjD,OACA,AAAmB,YAAY,CAA3B,EAAE,QAAQ,CAAwB,CAAC,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAC,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAC7D,eAAe,CAA9B,EAAE,QAAQ,CAA2B,CAAC,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAA,EAAG,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAC/D,aAAa,CAA5B,EAAE,QAAQ,CAAyB,CAAC,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAC,CAAC,EAAE,EAAE,KAAK,CAAA,CAAE,EAAE,CAC7D,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAC,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,CAC9C,OAAO,CAAtB,EAAE,QAAQ,CAAmB,CAAC,CAAA,EAAA,GAAA,GAAA,AAAG,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,CAChD,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAC,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,CAC9C,AAAf,MAAqB,GAAnB,QAAQ,CAAkB,CAAC,CAAA,EAAA,GAAA,EAAE,AAAF,EAAG,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,CAC9C,OAAO,CAAtB,EAAE,QAAQ,CAAmB,CAAC,CAAA,EAAA,GAAA,GAAA,AAAG,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,CAC5D,CAAC,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAAE,AACzC,CACA,IAAM,EAAW,EAAM,MAAM,CAAC,AAAC,GAAsB,QAAhB,EAAE,SAAS,EAAc,CAAC,EAAE,SAAS,EACpE,EAAU,EAAM,MAAM,CAAC,AAAC,GAAsB,OAAhB,EAAE,SAAS,EACzC,EAAY,CAAA,EAAA,GAAA,GAAG,AAAH,KAAO,EAAS,GAAG,CAAC,AAAC,IACtC,IAAM,EAAQ,EAAa,OAC1B,EACA,MAAO,EAAE,KAAK,AACf,GACA,GAAmB,OAAf,EAAE,QAAQ,CAAW,CACxB,GAAI,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,yBAAyB,EAAE,EAAE,KAAK,CAAC,gDAAgD,CAAC,EAC5I,MAAO,CAAA,EAAA,GAAA,OAAA,AAAO,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,CAC3C,CACA,GAAmB,AAAf,aAAE,QAAQ,CAAe,CAC5B,GAAI,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,yBAAyB,EAAE,EAAE,KAAK,CAAC,oDAAoD,CAAC,EAChJ,MAAO,CAAA,EAAA,GAAA,UAAA,AAAU,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,CAC9C,OACA,AAAmB,YAAY,CAA3B,EAAE,QAAQ,CAAwB,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAC,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EACzE,AAAe,eAAe,GAA5B,QAAQ,CAA2B,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAA,EAAG,EAAE,KAAK,CAAC,CAAC,CAAC,EAC5D,aAAa,CAA5B,EAAE,QAAQ,CAAyB,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAC,CAAC,EAAE,EAAE,KAAK,CAAA,CAAE,EACzE,AAAe,MAAM,GAAnB,QAAQ,CAAkB,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC3C,OAAO,CAAtB,EAAE,QAAQ,CAAmB,CAAA,EAAA,GAAA,GAAA,AAAG,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC7C,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC3C,OAAO,CAAtB,EAAE,QAAQ,CAAmB,CAAA,EAAA,GAAA,GAAA,AAAG,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC7C,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAA,EAAA,GAAA,EAAE,AAAF,EAAG,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EACvD,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,CACtC,IACM,EAAW,CAAA,EAAA,GAAA,EAAA,AAAE,KAAI,EAAQ,GAAG,CAAC,AAAC,IACnC,IAAM,EAAQ,EAAa,OAC1B,EACA,MAAO,EAAE,KAAK,AACf,GACA,GAAmB,OAAf,EAAE,QAAQ,CAAW,CACxB,GAAI,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,yBAAyB,EAAE,EAAE,KAAK,CAAC,gDAAgD,CAAC,EAC5I,MAAO,CAAA,EAAA,GAAA,OAAA,AAAO,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,CAC3C,CACA,GAAmB,WAAf,EAAE,QAAQ,CAAe,CAC5B,GAAI,CAAC,MAAM,OAAO,CAAC,EAAE,KAAK,EAAG,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,yBAAyB,EAAE,EAAE,KAAK,CAAC,oDAAoD,CAAC,EAChJ,MAAO,CAAA,EAAA,GAAA,UAAA,AAAU,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,CAC9C,OACA,AAAmB,YAAY,CAA3B,EAAE,QAAQ,CAAwB,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAC,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAC1D,eAAe,CAA9B,EAAE,QAAQ,CAA2B,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAA,EAAG,EAAE,KAAK,CAAC,CAAC,CAAC,EAC5D,aAAa,CAA5B,EAAE,QAAQ,CAAyB,CAAA,EAAA,GAAA,IAAA,AAAI,EAAC,CAAW,CAAC,EAAM,CAAE,CAAC,CAAC,EAAE,EAAE,KAAK,CAAA,CAAE,EAC1D,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC3C,OAAO,CAAtB,EAAE,QAAQ,CAAmB,CAAA,EAAA,GAAA,GAAA,AAAG,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC7C,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC3C,OAAO,CAAtB,EAAE,QAAQ,CAAmB,CAAA,EAAA,GAAA,GAAA,AAAG,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EAC7C,MAAM,CAArB,EAAE,QAAQ,CAAkB,CAAA,EAAA,GAAA,EAAA,AAAE,EAAC,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,EACvD,CAAA,EAAA,GAAA,EAAE,AAAF,EAAG,CAAW,CAAC,EAAM,CAAE,EAAE,KAAK,CACtC,IACM,EAAS,EAAE,CAGjB,OAFI,EAAS,MAAM,EAAE,EAAO,IAAI,CAAC,GAC7B,EAAQ,MAAM,EAAE,EAAO,IAAI,CAAC,GACzB,CACR,CAKA,MAAO,CACN,MAAM,OAAO,OAAE,CAAK,CAAE,KAAM,CAAM,CAAE,EACnC,IAAM,EAAc,EAAU,GAL/B,GAAI,CAAC,AAMe,EANP,MAAM,IAAI,GAAA,eAAe,CAAC,iIACvC,IAAK,IAAM,KAK6B,EALtB,AAAQ,GAAI,CAAC,CAAM,CAAC,EAAI,CAAE,MAAM,IAAI,GAAA,eAAe,CAAC,CAAC,WAAW,EAAE,EAAI,yBAAyB,EAAE,AAKlF,EALwF,gHAAgH,CAAC,EAMzO,OAAO,MAAM,EAAc,EAAO,EAAK,MAAM,CAAC,GAAa,MAAM,CAAC,GAAS,EAC5E,EACA,MAAM,QAAQ,OAAE,CAAK,OAAE,CAAK,MAAE,CAAI,CAAE,EACnC,IAAM,EAAc,EAAU,GACxB,EAAS,EAAmB,EAAO,GACzC,GAAI,EAAQ,YAAY,EAAE,MAAO,GAAI,AAAC,EAAK,KAAK,EAAK,EAAD,AAAM,KAAK,CAAC,EAAM,CAG/D,CAHiE,AAKvE,IADI,EACE,EAAoB,EAAE,CAC5B,GAAI,EAGH,IAHS,AAGJ,GAAM,CAAC,EAAS,EAAS,GAF9B,CAEkC,CAFvB,CAAC,EACQ,OAAO,OAAO,CAAC,IACY,CAC9C,IAAM,EAAQ,EAAS,KAAK,EAAI,EAAQ,QAAQ,EAAE,UAAU,sBAAwB,IAC9E,EAAiC,eAAtB,EAAS,QAAQ,CAC5B,EAAe,GAAY,EAAO,SAAS,CAAG,GAAK,IACzD,CAAQ,CAAC,CAAA,EAAG,EAAA,EAAU,EAAA,CAAc,CAAC,GAAG,GAAkB,OAAE,CAAT,AAAe,EAC9D,AAAC,GAAU,EAAkB,IAAI,CAAC,CAAA,EAAG,EAAA,EAAU,EAAA,CAAc,CAClE,CAED,IAAM,EAAQ,MAAM,EAAK,KAAK,CAAC,EAAM,CAAC,SAAS,CAAC,CAC/C,MAAO,CAAM,CAAC,EAAE,CAChB,KAAM,CACP,GACA,GAAI,EAAO,IAAK,IAAM,KAAoB,EAAmB,CAC5D,IAAI,EAAe,AAAD,EAAQ,SAAS,CAAmC,EAAhC,EAAiB,KAAK,CAAC,EAAG,CAAC,GACjE,CAAK,CAAC,EAAY,CAAG,CAAK,CAAC,EAAiB,CACxC,IAAqB,GAAa,OAAO,CAAK,CAAC,EAAiB,AACrE,CACA,OAAO,CACR,MA1BC,GAAA,MAAM,CAAC,KAAK,CAAC,CAAC,gCAAgC,EAAE,EAAM,wJAAwJ,CAAC,EAC/M,GAAA,MAAM,CAAC,IAAI,CAAC,iCA0Bb,IAAM,EAAM,MAAM,EAAK,MAAM,GAAG,IAAI,CAAC,GAAa,KAAK,IAAI,UAC3D,AAAK,EAAI,EAAL,IAAW,CACR,CADU,AACP,CAAC,EAAE,CADW,IAEzB,EACA,MAAM,SAAS,OAAE,CAAK,OAAE,CAAK,QAAE,CAAM,OAAE,CAAK,QAAE,CAAM,MAAE,CAAI,CAAE,EAC3D,IAAM,EAAc,EAAU,GACxB,EAAS,EAAQ,EAAmB,EAAO,GAAS,EAAE,CACtD,EAAS,GAAQ,YAAc,OAAS,GAAA,IAAI,CAAG,GAAA,GAAG,CACxD,GAAI,EAAQ,YAAY,EAAE,MAAO,GAAK,CAAD,CAAM,KAAK,CAAC,EAAM,CAGhD,CAEN,AALwD,IAIpD,EAaA,EAZE,EAAoB,EAAE,CAC5B,GAWc,AAXV,EAGH,GAQkB,CAXT,AAGJ,GAAM,CAAC,EAAS,EAAS,GAF9B,CAEkC,CAFvB,CAAC,EACQ,OAAO,OAAO,CAAC,IACY,CAC9C,IAAM,EAAiC,eAAtB,EAAS,QAAQ,CAC5B,EAAU,EAAS,KAAK,EAAI,EAAQ,QAAQ,EAAE,UAAU,sBAAwB,IAClF,EAAe,GAAY,EAAO,SAAS,CAAG,GAAK,GACvD,EAAQ,CAAC,CAAA,EAAG,EAAA,EAAU,EAAA,CAAc,CAAC,GAAG,GAAkB,CAAE,MAAO,CAAhB,AAAwB,EACtE,AAAD,GAAW,EAAkB,IAAI,CAAC,CAAA,EAAG,EAAA,EAAU,EAAA,CAAc,CAClE,CAGG,GAAQ,QAAO,EAAU,CAAC,EAAO,CAAW,CAAC,EAAa,OAC7D,EACA,MAAO,GAAQ,KAChB,GAAG,EAAE,EACL,IAAI,EAAM,MAAM,EAAK,KAAK,CAAC,EAAM,CAAC,QAAQ,CAAC,CAC1C,MAAO,CAAM,CAAC,EAAE,CAChB,KAAM,EACN,MAAO,GAAS,IAChB,OAAQ,GAAU,UAClB,CACD,GACA,GAAI,EAAK,IAAK,IAAM,KAAQ,EAAK,IAAK,IAAM,KAAoB,EAAmB,CAClF,IAAM,EAAc,AAAC,EAAO,SAAS,CAAmC,EAAhC,EAAiB,KAAK,CAAC,EAAG,CAAC,GAC/D,IAAgB,IACpB,CAAI,CAAC,EAAY,CAAG,CAAI,CAAC,EAAiB,CAC1C,IAFsC,GAE/B,CAAI,CAAC,EAAiB,CAC9B,CACA,OAAO,CACR,MAnCC,GAAA,MAAM,CAAC,KAAK,CAAC,CAAC,gCAAgC,EAAE,EAAM,wJAAwJ,CAAC,EAC/M,GAAA,MAAM,CAAC,IAAI,CAAC,iCAmCb,IAAI,EAAU,EAAK,MAAM,GAAG,IAAI,CAAC,GASjC,OANI,KAA0B,EAAnB,MAAgC,EAAU,EAAQ,KAAK,CAF3C,AAE4C,EAAA,EAC/D,KAA2B,EAApB,KAAiC,GAAU,EAAQ,MAAM,CAAC,AAF7C,EAE6C,EACjE,GAAQ,QAAO,EAAU,EAAQ,OAAO,CAAC,EAAO,CAAW,CAAC,EAAa,OAC5E,EACA,MAAO,GAAQ,KAChB,GAAG,EAAA,EACI,MAAM,EAAQ,KAAK,IAAI,EAC/B,EACA,MAAM,MAAM,OAAE,CAAK,OAAE,CAAK,CAAE,EAC3B,IAAM,EAAc,EAAU,GACxB,EAAS,EAAQ,EAAmB,EAAO,GAAS,EAAE,CAC5D,MAAO,CAAC,MAAM,EAAK,MAAM,CAAC,CAAE,M3B/NvB,C2B+N8B,E3B/N9B,GAAG,CAAC,MAAM,EAAE,AAAc,GAAA,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,O2B+NZ,GAAG,IAAI,CAAC,GAAa,KAAK,IAAI,EAAA,CAAO,AAAC,CAAC,EAAE,CAAC,KAAK,AAC3F,EACA,MAAM,OAAO,OAAE,CAAK,OAAE,CAAK,CAAE,OAAQ,CAAM,CAAE,EAC5C,IAAM,EAAc,EAAU,GACxB,EAAS,EAAmB,EAAO,GACzC,OAAO,MAAM,EAAc,EAAO,EAAK,MAAM,CAAC,GAAa,GAAG,CAAC,GAAQ,KAAK,IAAI,GAAS,EAAQ,EAClG,EACA,MAAM,WAAW,OAAE,CAAK,OAAE,CAAK,CAAE,OAAQ,CAAM,CAAE,EAChD,IAAM,EAAc,EAAU,GACxB,EAAS,EAAmB,EAAO,GACzC,OAAO,MAAM,EAAK,MAAM,CAAC,GAAa,GAAG,CAAC,GAAQ,KAAK,IAAI,EAC5D,EACA,MAAM,OAAO,OAAE,CAAK,OAAE,CAAK,CAAE,EAC5B,IAAM,EAAc,EAAU,GACxB,EAAS,EAAmB,EAAO,GACzC,OAAO,MAAM,EAAK,MAAM,CAAC,GAAa,KAAK,IAAI,EAChD,EACA,MAAM,WAAW,OAAE,CAAK,OAAE,CAAK,CAAE,EAChC,IAAM,EAAc,EAAU,GACxB,EAAS,EAAmB,EAAO,GACnC,EAAM,MAAM,EAAK,MAAM,CAAC,GAAa,KAAK,IAAI,GAChD,EAAU,EASd,OARI,GAAO,aAAc,EAAK,EAAU,EAAI,QAAQ,CAC3C,MAAM,OAAO,CAAC,GAAM,EAAU,EAAI,MAAM,CACxC,IAAQ,GAAD,cAAmB,GAAO,iBAAkB,GAAO,YAAa,CAAA,CAAG,GAAG,EAAU,EAAI,YAAY,EAAI,EAAI,YAAY,EAAI,EAAI,OAAO,AAAP,EACrH,UAAnB,OAAO,GAAsB,GAAA,MAAM,CAAC,KAAK,CAAC,mKAAoK,KACjN,QACA,QACA,CACD,GACO,CACR,EACA,QAAS,CACV,CACD,IACqB,KACrB,EAAiB,CAChB,OAAQ,CACP,UAAW,UACX,YAAa,kBACb,UAAW,EAAO,SAAS,GAAI,EAC/B,UAAW,EAAO,SAAS,GAAI,EAC/B,cAAmC,OAApB,AAA2B,EAApB,KAA2B,GAAnB,CAC9B,cAAa,EAAO,WAAW,GAAY,AAAC,CAAT,EAAgB,EAAG,WAAW,CAAC,AAAC,GAC3D,EAAG,CAAA,EAAA,GAAA,CAAoB,AAApB,EAAqB,CAC9B,OAAQ,EAAe,MAAM,CAC7B,QAAS,EAAoB,EAC9B,GAAG,IACJ,CACD,EACA,CAFM,OAEG,EAAoB,EAC9B,EACM,EAAU,CAAA,EAAA,GAAA,CAAoB,AAApB,EAAqB,GAC7B,AAAD,IACN,EAAc,EACP,EAAQ,KXvQf,iBAAkB,CAChB,SAAS,EACT,yBAA0B,EAC5B,EAEA,QAAS,EyB0BO,EzBzBL,CACP,kBAAmB,EACnB,kBAAmB,EACrB,EyBuBG,EAAc,AAAD,GACd,AAAJ,GAAa,yBAA0B,EAAc,EACjD,GAAS,AADiC,sBACH,CAAP,CAAe,qBAAqB,CAAC,GAClE,EAAW,WAAW,KAEK,AAAD,GAC1B,GAAS,6BAA+B,EAAQ,4BAA4B,CAAC,GAAmB,EAEjG,CACN,GAAI,gBACC,AAAL,GAAQ,AACA,EAAE,QAAS,CAAE,cAAe,CAAE,KAAM,CAC1C,OAAQ,CAAE,MAAM,OAAO,CAAI,CAAE,CAAO,EACnC,IAAM,EAAa,aAAc,EAAO,EAAK,QAAQ,CAAG,KAClD,EAAkB,oBAAqB,EAAO,EAAK,eAAe,CAAG,KAC3E,MAAO,CAAE,KAAM,CACd,GAAG,CAAI,CACP,GAAG,EAAa,CAAE,SAAU,EAAW,EAAY,EAAI,CAAC,CAAC,CACzD,GAAG,EAAkB,CAAE,gBAAiB,EAA0B,EAAiB,EAAI,CAAC,CAAC,AAC1F,CAAE,CACH,CAAE,EACF,OAAQ,CAAE,MAAM,OAAO,CAAI,CAAE,CAAO,EACnC,IAAM,EAAa,aAAc,EAAO,EAAK,QAAQ,CAAG,KAClD,EAAkB,oBAAqB,EAAO,EAAK,eAAe,CAAG,KAC3E,MAAO,CAAE,KAAM,CACd,GAAG,CAAI,CACP,GAAG,EAAa,CAAE,SAAU,EAAW,EAAY,EAAI,CAAC,CAAC,CACzD,GAAG,EAAkB,CAAE,gBAAiB,EAA0B,EAAiB,EAAI,CAAC,CACzF,AAD0F,CACxF,CACH,CAAE,CACH,CAAE,CAAE,EAAE,EAEP,UAAW,CACV,eAAgB,GAAmB,oBAAqB,CACvD,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CACd,SAAU,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0BAA2B,GACpE,SAAU,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,0BAA2B,GACpE,WAAY,EAAA,OAAS,GAAG,IAAI,CAAC,CAAE,YAAa,2BAA4B,GAAG,QAAQ,GACnF,YAAa,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,iDAAkD,GAAG,QAAQ,EAC1G,GACA,SAAU,CAAE,QAAS,CACpB,QAAS,wBACT,YAAa,wBACb,UAAW,CACV,IAAK,CACJ,YAAa,UACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CACX,MAAO,CACN,KAAM,SACN,YAAa,6CACd,EACA,KAAM,CAAE,KAAM,2BAA4B,CAC3C,EACA,SAAU,CAAC,QAAS,OAAO,AAC5B,CAAE,CAAE,CACL,EACA,IAAK,CACJ,YAAa,yCACb,QAAS,CAAE,mBAAoB,CAAE,OAAQ,CACxC,KAAM,SACN,WAAY,CAAE,QAAS,CAAE,KAAM,QAAS,CAAE,CAC3C,CAAE,CAAE,CACL,CACD,CACD,CAAE,CACH,EAAG,MAAO,IACT,GAAI,CAAC,EAAI,IAAI,CAAC,QAAQ,EAAI,CAAC,EAAI,IAAI,CAAC,QAAQ,CAE3C,CAF6C,KAC7C,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,kCACnB,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAqB,4BAA4B,AAAC,GAEjG,IAAM,EAAa,GAAS,iBAAiB,WAAa,oBAAsB,EAAW,EAAI,IAAI,CAAC,QAAQ,EAAI,EAAI,IAAI,CAAC,QAAQ,CAC3H,EAAoB,GAAS,mBAAqB,EAClD,EAAoB,GAAS,mBAAqB,GACxD,GAAI,EAAW,MAAM,CAAG,EAEvB,MADA,EAAI,OAAO,CAAC,CAD8B,KACxB,CAAC,KAAK,CAAC,qBAAsB,CAAE,SAAU,CAAW,GAChE,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAC1C,KAAM,qBACN,QAAS,GAAqB,kBAAkB,AACjD,GAED,GAAI,EAAW,MAAM,CAAG,EAEvB,MADA,EAAI,OAAO,CAAC,CAD8B,KACxB,CAAC,KAAK,CAAC,oBAAqB,CAAE,SAAU,CAAW,GAC/D,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAqB,iBAAiB,AAAC,GAE9F,GAAI,CAAC,CAAC,GAAS,mBAAqB,EAAA,CAAwB,CAAE,GAAa,MAAM,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAqB,gBAAgB,AAAC,GACvK,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAC9C,MAAO,OACP,MAAO,CAAC,CACP,MAAO,WACP,MAAO,EAAW,EACnB,EACD,AADG,GAEH,GAAI,CAAC,EAGJ,IAHU,EACV,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAI,IAAI,CAAC,QAAQ,EACjD,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,iBAAkB,CAAE,SAAU,CAAW,GAC5D,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAqB,4BAA4B,AAAC,GAEjG,IAAM,EAAU,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CACjD,MAAO,UACP,MAAO,CAAC,CACP,MAAO,SACP,MAAO,EAAK,EACb,AADe,EACZ,CACF,MAAO,aACP,MAAO,YACR,EAAE,AACH,GACA,GAAI,CAAC,EAAS,MAAM,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAqB,4BAA4B,AAAC,GAC9G,IAAM,EAAkB,GAAS,SACjC,GAAI,CAAC,EAEJ,MADA,EAAI,OAAO,AADU,CACT,MAAM,CAAC,KAAK,CAAC,qBAAsB,CAAE,SAAU,CAAW,GAChE,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAqB,4BAA4B,AAAC,GAEjG,GAAI,CAAC,MAAM,EAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CACtC,KAAM,EACN,SAAU,EAAI,IAAI,CAAC,QAAQ,AAC5B,GAEC,CAFG,KACH,EAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,oBACnB,IAAI,EAAA,QAAQ,CAAC,eAAgB,CAAE,QAAS,GAAqB,4BAA4B,AAAC,GAEjG,GAAI,EAAI,OAAO,CAAC,OAAO,EAAE,kBAAkB,0BAA4B,CAAC,EAAK,aAAa,CAAE,CAC3F,GAAI,CAAC,EAAI,OAAO,CAAC,OAAO,EAAE,mBAAmB,sBAAuB,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAqB,kBAAkB,AAAC,GACvJ,GAAI,EAAI,OAAO,CAAC,OAAO,EAAE,mBAAmB,aAAc,CACzD,IAAM,EAAQ,MAAM,GAA6B,EAAI,OAAO,CAAC,MAAM,CAAE,EAAK,KAAK,CAAE,KAAK,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,WAC1H,EAAM,CAAA,EAAG,EAAI,OAAO,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAM,aAAa,EAAE,EAAI,IAAI,CAAC,WAAW,EAAI,IAAA,CACtG,AAD2G,OACrG,EAAI,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,MACjE,MACA,QACA,CACD,EAAG,EAAI,OAAO,CACf,CACA,MAAM,IAAI,EAAA,QAAQ,CAAC,YAAa,CAAE,QAAS,GAAqB,kBAAkB,AAAC,EACpF,CACA,IAAM,EAAU,MAAM,EAAI,OAAO,CAAC,eAAe,CAAC,aAAa,CAAC,EAAK,EAAE,EAA0B,IAAxB,EAAI,IAAI,CAAC,UAAU,SAC5F,AAAK,GAIL,CAJI,KAAU,AAIR,GAAiB,EAAK,SAC3B,OACA,CACD,EAAG,AAAwB,OAApB,IAAI,CAAC,UAAU,EACf,EAAI,IAAI,CAAC,CACf,MAAO,EAAQ,KAAK,CACpB,KAAM,CACL,GAAI,EAAK,EAAE,CACX,MAAO,EAAK,KAAK,CACjB,cAAe,EAAK,aAAa,CACjC,SAAU,EAAK,QAAQ,CACvB,gBAAiB,EAAK,eAAe,CACrC,KAAM,EAAK,IAAI,CACf,MAAO,EAAK,KAAK,CACjB,UAAW,EAAK,SAAS,CACzB,UAAW,EAAK,SAAS,AAC1B,CACD,IArBqB,EAAI,IAAI,CAAC,KAAM,CACnC,OAAQ,IACR,KAAM,CAAE,QAAS,GAAA,CAAgB,CAAC,wBAAwB,AAAC,CAC5D,EAmBD,GACA,oBAAqB,GAAmB,yBAA0B,CACjE,OAAQ,OACR,KAAM,EAAA,MAAQ,CAAC,CAAE,SAAU,EAAA,MAAQ,GAAG,IAAI,CAAC,CAAE,YAAa,uBAAwB,EAAG,EACtF,EAAG,MAAO,IACT,IAAM,EAAa,EAAI,IAAI,CAAC,QAAQ,CACpC,GAAI,CAAC,EAAY,MAAM,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAqB,gBAAgB,AAAC,GAC7G,IAAM,EAAoB,GAAS,mBAAqB,EAClD,EAAoB,GAAS,mBAAqB,GACxD,GAAI,EAAW,MAAM,CAAG,EAAmB,MAAM,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CACrF,KAAM,qBACN,QAAS,GAAqB,kBAC/B,AADiD,GAEjD,GAAI,EAAW,MAAM,CAAG,EAAmB,MAAM,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAqB,iBAAiB,AAAC,GACxI,GAAI,CAAC,MAAM,CAAC,GAAS,mBAAqB,EAAA,CAAwB,CAAE,GAAa,MAAM,IAAI,EAAA,QAAQ,CAAC,uBAAwB,CAAE,QAAS,GAAqB,gBAAgB,AAAC,UACzK,AAAJ,MAAU,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CACrC,MAAO,OACP,MAAO,CAAC,CACP,MAAO,WACP,MAAO,EAAW,EACnB,EAAE,AACH,GAAW,CAAP,CAAW,IAAI,CAAC,CAAE,UAAW,EAAM,GAChC,EAAI,IAAI,CAAC,CAAE,WAAW,CAAK,EACnC,EACD,EACA,O7CjIF,A6CiIU,S7CjIW,AAAZ,CAAkB,CAAE,CAAS,A6CiIhB,E7ChIrB,GAAI,CAAC,EAAW,OAAO,EACvB,IAAK,IAAM,KAAS,EAAW,CAC9B,IAAM,EAAe,CAAS,CAAC,EAAM,EAAE,UAEvC,IAAK,IAAM,KADP,IAAc,CAAM,CAAC,EAAM,CAAC,SAAS,CAAG,CAAA,EACxB,CAAM,CAAC,EAAM,CAAC,MAAM,CAAE,CACzC,IAAM,EAAW,CAAS,CAAC,EAAM,EAAE,QAAQ,CAAC,EAAM,CAC7C,IACL,CAAM,CAAC,EAAM,CAAC,CADC,KACK,CAAC,EAAM,CAAC,SAAS,CAAG,CAAA,CACzC,CACD,CACA,OAAO,CACR,G6C/FmB,EAoNa,CAC7B,SAAU,EACV,gBAAiB,CAClB,EAtNM,CAAE,KAAM,CAAE,OAAQ,CACxB,SAAU,CACT,KAAM,SACN,UAAU,EACV,UAAU,EACV,QAAQ,EACR,UAAU,EACV,UAAW,OAAQ,AAAN,GACY,EADD,QAChB,OAAO,EAAqB,EAAQ,EAAW,QAAQ,CAAC,EAC9D,CACH,EACA,gBAAiB,CAChB,KAAM,SACN,UAAU,EACV,UAAW,OAAQ,AAAN,GACY,EADD,QAChB,OAAO,EAAqB,EAAQ,EAAW,eAAe,CAAC,EACrE,CACH,CACD,CAAE,CAAE,GAoMC,GAAS,QACb,MAAO,CAAE,OAAQ,CAAC,SACjB,AAAQ,GACiB,IADV,eACP,EAAQ,IAAI,EAA0C,AAAjB,mBAAQ,IAAI,CAEzD,QAAS,GAAqB,MAAO,IACpC,IAAM,EAA0C,UAA7B,OAAO,EAAI,IAAI,CAAC,QAAQ,EAAiB,GAAS,iBAAiB,WAAa,qBAAuB,EAAW,EAAI,IAAI,CAAC,QAAQ,EAAI,EAAI,IAAI,CAAC,QAAQ,CAC3K,GAAmB,AAAf,KAAoB,OAA2B,UAAtB,OAAO,EAAyB,CAC5D,IAAM,EAAoB,GAAS,mBAAqB,EAClD,EAAoB,GAAS,mBAAqB,GACxD,GAAI,EAAW,MAAM,CAAG,EAAmB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAC5E,KAAM,qBACN,QAAS,GAAqB,kBAAkB,AACjD,GACA,GAAI,EAAW,MAAM,CAAG,EAAmB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAqB,iBAAiB,AAAC,GAC/H,GAAI,CAAC,MAAM,CAAC,GAAS,mBAAqB,EAAA,CAAwB,CAAE,GAAa,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAqB,gBAAgB,AAAC,GACpK,IAAM,EAAO,MAAM,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAC9C,MAAO,OACP,MAAO,CAAC,CACP,MAAO,WACP,MAAO,CACR,EAAE,AACH,GACM,EAAiC,mBAAb,EAAI,IAAI,EAAyB,EACrD,EAAqC,iBAAb,EAAI,IAAI,EAAuB,GAAQ,EAAI,OAAO,CAAC,OAAO,EAAI,EAAK,EAAE,GAAK,EAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAC1I,GAAI,GAAqB,EAAuB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAqB,yBAAyB,AAAC,EAC7I,CACA,IAAM,EAAsD,UAApC,OAAO,EAAI,IAAI,CAAC,eAAe,EAAiB,GAAS,iBAAiB,kBAAoB,qBAAuB,EAA0B,EAAI,IAAI,CAAC,eAAe,EAAI,EAAI,IAAI,CAAC,eAAe,CAC3N,GAAwB,KAAK,IAAzB,GAAyD,UAA3B,AAAqC,OAA9B,GACpC,GAAS,0BAA0B,AAClC,CAAC,MAAM,EAAQ,wBAAwB,CAAC,GAAkB,MAAM,IAAI,EAAA,QAAQ,CAAC,cAAe,CAAE,QAAS,GAAqB,wBAAwB,AAAC,EAG5J,EACD,EAAG,SACF,AAAQ,GACiB,IADV,eACP,EAAQ,IAAI,EAA0C,iBAAjB,EAAQ,IAAI,CAEzD,QAAS,GAAqB,MAAO,IAChC,EAAI,IAAI,CAAC,QAAQ,EAAI,CAAC,EAAI,IAAI,CAAC,eAAe,GAAE,EAAI,IAAI,CAAC,eAAe,CAAG,EAAI,IAAI,CAAC,QAAA,AAAQ,EAC5F,EAAI,IAAI,CAAC,eAAe,EAAI,CAAC,EAAI,IAAI,CAAC,QAAQ,GAAE,EAAI,IAAI,CAAC,QAAQ,CAAG,EAAI,IAAI,CAAC,eAAA,AAAe,CACjG,EACD,EAAE,AAAC,EACH,aAAc,EACf,GzB7PE,CAED,QAAS,CACP,YAAa,CACX,QAAS,GACT,OAAQ,GACV,EACA,AAFe,UAEJ,KAAK,EAChB,GADqB,KAAK,EACf,KAAK,AAClB,EAEA,GAHuB,EAGjB,CACJ,iBAAkB,CAChB,SAAU,CACR,KAAM,SACN,UAAU,CACZ,EACA,KAAM,CACJ,KAAM,SACN,UAAU,EACV,aAAc,SAChB,EACA,UAAW,CACT,KAAM,SACN,UAAU,CACZ,EACA,SAAU,CACR,KAAM,SACN,UAAU,CACZ,EACA,SAAU,CACR,KAAM,UACN,UAAU,EACV,cAAc,CAChB,EACA,YAAa,CACX,KAAM,OACN,UAAU,CACZ,CACF,CACF,EAEA,eAAgB,CACd,QAAQ,GAAG,CAAC,eAAe,EAAI,wBAChC,AACH,EYhDkC,IRvBrB,CAAE,MAAG,MAAE,EAAI,CAAE,CgBSlB,CACN,ChBV2B,EgBU3B,CAJK,CAIA,CAJU,MAAO,GACf,aAAa,EhBPuB,AgBOhB,GAAK,OAAO,CAAC,GAAW,GAAK,GAIxD,KAAM,EACN,MAAO,EACP,IAAK,EACL,OAAQ,CACT,sC5CAD,IAAA,GAAA,EAAA,CAAA,CAAA,OAIA,IAAM,GAAc,IAAI,EAAA,mBAAmB,CAAC,CACxC,WAAY,CACR,KAAM,EAAA,SAAS,CAAC,SAAS,CACzB,KAAM,2BACN,SAAU,qBACV,SAAU,QACV,WAAY,EAChB,EACA,QAAS,CAAA,OACT,IADiD,eACc,CAA3C,EACpB,iBAAkB,+CAClB,iBAZqB,GAarB,SAAA,EACJ,GAIM,kBAAE,EAAgB,sBAAE,EAAoB,aAAE,EAAW,CAAE,CAAG,GAChE,SAAS,KACL,MAAO,CAAA,EAAA,EAAA,UAAA,AAAW,EAAC,kBACf,wBACA,EACJ,EACJ,CAEO,eAAe,GAAQ,CAAG,CAAE,CAAG,CAAE,CAAG,EACnC,GAAY,KAAK,EAAE,AACnB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,+BAAgC,QAAQ,MAAM,CAAC,MAAM,IAE7E,IAAI,EAAU,2BAKV,EAAU,EAAQ,OAAO,CAAC,WAAY,KAAO,IAMjD,IAAM,EAAgB,MAAM,GAAY,OAAO,CAAC,EAAK,EAAK,SACtD,EACA,mBAHE,CAAA,CAIN,GACA,GAAI,CAAC,EAID,OAHA,EAAI,IADY,MACF,CAAG,IACjB,EAAI,GAAG,CAAC,eACS,MAAjB,CAAwB,CAApB,IAAyB,KAAhB,EAAoB,EAAI,SAAS,CAAC,IAAI,CAAC,EAAK,QAAQ,OAAO,IACjE,KAEX,GAAM,SAAE,CAAO,QAAE,CAAM,YAAE,CAAU,WAAE,CAAS,aAAE,CAAW,mBAAE,CAAiB,qBAAE,CAAmB,CAAE,sBAAoB,yBAAE,CAAuB,kBAAE,CAAgB,yBAAE,CAAuB,uBAAE,CAAqB,CAAE,CAAG,EACnN,EAAoB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,GACvC,EAAQ,GAAQ,EAAkB,aAAa,CAAC,EAAkB,EAAI,EAAkB,MAAM,CAAC,EAAA,AAAiB,EAC9G,EAAY,WAEa,MAAvB,EAA8B,KAAK,EAAI,EAAoB,SAAA,AAAS,EAAE,AACtE,MAAM,EAAoB,SAAS,CAAC,EAAK,EAAK,EAAW,IAEzD,EAAI,GAAG,CAAC,gCAEL,MAEX,GAAI,GAAS,CAAC,EAAa,CACvB,IAAM,GAAgB,CAAQ,EAAkB,MAAM,CAAC,EAAiB,CAClE,EAAgB,EAAkB,aAAa,CAAC,EAAkB,CACxE,GAAI,IAC+B,IAA3B,EAAc,KADH,GACW,EAAc,CAAC,EAAe,CACpD,GAAI,EAAW,YAAY,CAAC,WAAW,CACnC,CADqC,MAC9B,MAAM,GAEjB,OAAM,IAAI,EAAA,eAAe,AAC7B,CAER,CACA,IAAI,EAAW,MACX,GAAU,GAAY,GAAb,EAAkB,EAAK,EAAD,CAG/B,GAAW,AAAa,OAHqB,KAC7C,EAAW,CAAA,EAEwB,IAAM,CAAA,EAE7C,IAAM,GACgB,IAAtB,GAAY,CAAkB,IAAb,EAEjB,CAAC,EAKK,EAAqB,GAAS,CAAC,EAIjC,GAAyB,GACzB,CAAA,EAAA,EAAA,iBADkD,aAClD,AAA8B,EAAC,CAC3B,KAAM,GAbqF,uBAc3F,wBACA,EACA,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,uBACnC,CACJ,EACJ,GAEJ,IAAM,EAAS,EAAI,MAAM,EAAI,MACvB,EAAS,CAAA,EAAA,EAAA,SAAA,AAAS,IAClB,EAAa,EAAO,kBAAkB,GACtC,EAAU,QACZ,oBACA,EACA,WAAY,CACR,aAAc,CACV,gBAAgB,CAAQ,EAAW,YAAY,CAAC,cAAc,AAClE,EACA,iBAAiB,CAAQ,EAAW,eAAe,yBACnD,EACA,iBAAkB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,oBACtC,kBAAmB,EAAW,SAAS,CACvC,UAAW,EAAI,SAAS,CACxB,QAAS,AAAC,IACN,EAAI,EAAE,CAAC,QAAS,EACpB,EACA,sBAAkB,EAClB,8BAA+B,CAAC,EAAO,EAAU,IAAe,GAAY,cAAc,CAAC,EAAK,EAAO,EAAc,EACzH,EACA,cAAe,SACX,CACJ,CACJ,EACM,EAAc,IAAI,EAAA,eAAe,CAAC,GAClC,EAAc,IAAI,EAAA,gBAAgB,CAAC,GACnC,EAAU,EAAA,kBAAkB,CAAC,mBAAmB,CAAC,EAAa,CAAA,EAAA,EAAA,sBAAsB,AAAtB,EAAuB,IAC3F,GAAI,CACA,IAAM,EAAoB,MAAO,GACtB,GAAY,MAAM,CAAC,EAAS,GAAS,OAAO,CAAC,KAChD,GAAI,CAAC,EAAM,OACX,EAAK,aAAa,CAAC,CACf,mBAAoB,EAAI,UAAU,CAClC,YAAY,CAChB,GACA,IAAM,EAAqB,EAAO,qBAAqB,GAEvD,GAAI,CAAC,EACD,OAEJ,GAAI,EAAmB,GAAG,CAAC,EAHF,kBAGwB,EAAA,cAAc,CAAC,aAAa,CAAE,YAC3E,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,EAAmB,GAAG,CAAC,kBAAkB,qEAAqE,CAAC,EAG9J,IAAM,EAAQ,EAAmB,GAAG,CAAC,cACrC,GAAI,EAAO,CACP,IAAM,EAAO,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAO,CACjC,EAAK,aAAa,CAAC,CACf,aAAc,EACd,aAAc,EACd,iBAAkB,CACtB,GACA,EAAK,UAAU,CAAC,EACpB,MACI,CADG,CACE,UAAU,CAAC,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAE9C,GAEE,GAAgB,CAAoC,CAAA,EAAA,EAAA,EAA5B,YAA4B,AAAc,EAAC,EAAK,eACxE,EAAiB,MAAO,QACtB,EA2FI,EA1FR,IAAM,EAAoB,MAAO,oBAAE,CAAkB,CAAE,IACnD,GAAI,CACA,GAAI,CAAC,GAAiB,GAAwB,GAA2B,CAAC,EAKtE,OAJA,EAAI,SADsF,CAC5E,CAAG,IAEjB,EAAI,SAAS,CAAC,iBAAkB,eAChC,EAAI,GAAG,CAAC,gCACD,KAEX,IAAM,EAAW,MAAM,EAAkB,GACzC,EAAI,YAAY,CAAG,EAAQ,UAAU,CAAC,YAAY,CAClD,IAAI,EAAmB,EAAQ,UAAU,CAAC,gBAAgB,CAGtD,GACI,EAAI,SAAS,EAAE,CACf,CAFc,CAEV,SAAS,CAAC,GACd,OAAmB,GAG3B,IAAM,EAAY,EAAQ,UAAU,CAAC,aAAa,CAGlD,IAAI,EA6BA,OADA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,EAAU,EAAQ,UAAU,CAAC,gBAAgB,EACnF,IA7BA,EACP,IAAM,EAAO,MAAM,EAAS,IAAI,GAE1B,EAAU,CAAA,EAAA,EAAA,yBAAA,AAAyB,EAAC,EAAS,OAAO,EACtD,GACA,EAAO,CAAC,EAAA,GADG,mBACmB,CAAC,CAAG,CAAA,EAElC,CAAC,CAAO,CAAC,eAAe,EAAI,EAAK,IAAI,EAAE,CACvC,CAAO,CAAC,eAAe,CAAG,EAAK,IAAA,AAAI,EAEvC,IAAM,EAAa,AAAkD,SAA3C,EAAQ,UAAU,CAAC,mBAAmB,IAAoB,EAAQ,UAAU,CAAC,mBAAmB,EAAI,EAAA,cAAA,AAAc,GAAG,AAAQ,EAAQ,UAAU,CAAC,mBAAmB,CACvL,EAAuD,AAA9C,SAAO,EAAQ,UAAU,CAAC,eAAe,EAAoB,EAAQ,UAAU,CAAC,eAAe,EAAI,EAAA,cAAc,MAAG,EAAY,EAAQ,UAAU,CAAC,eAAe,CAcjL,MAZmB,CAYZ,AAXH,MAAO,CACH,KAAM,EAAA,eAAe,CAAC,SAAS,CAC/B,OAAQ,EAAS,MAAM,CACvB,KAAM,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,YACxC,CACJ,EACA,aAAc,CACV,aACA,QACJ,CACJ,CAEJ,CAKJ,CAAE,KALS,CAKF,EAAK,CAcV,MAX0B,MAAtB,EAA6B,KAAK,EAAI,EAAmB,OAAA,AAAO,EAAE,CAClE,MAAM,GAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,oBAClC,uBACA,CACJ,EACJ,EAAG,GAED,CACV,CACJ,EACM,EAAa,MAAM,GAAY,cAAc,CAAC,KAChD,EACA,aACA,WACA,UAAW,EAAA,SAAS,CAAC,SAAS,CAC9B,YAAY,oBACZ,EACA,mBAAmB,uBACnB,0BACA,oBACA,EACA,UAAW,EAAI,SAAS,eACxB,CACJ,GAEA,GAAI,CAAC,EACD,KADQ,EACD,KAEX,GAAI,CAAe,MAAd,CAAqB,EAAS,AAA0C,GAA9C,IAAK,EAAoB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAkB,IAAI,IAAM,EAAA,eAAe,CAAC,SAAS,CAE9I,CAFgJ,KAE1I,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,kDAAkD,EAAgB,MAAd,CAAqB,EAAS,AAA2C,GAA/C,IAAK,EAAqB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAmB,IAAI,CAAA,CAAE,EAAG,oBAAqB,CACjO,MAAO,OACP,WAAY,GACZ,cAAc,CAClB,EAEA,CAAC,GACD,EAAI,SAAS,CADG,AACF,iBAAkB,EAAuB,cAAgB,EAAW,MAAM,CAAG,OAAS,EAAW,OAAO,CAAG,QAAU,OAGnI,GACA,EAAI,QADS,CACA,CAAC,gBAAiB,2DAEnC,IAAM,EAAU,CAAA,EAAA,EAAA,2BAAA,AAA2B,EAAC,EAAW,KAAK,CAAC,OAAO,EAcpE,OAbI,AAAE,CAAD,EAAkB,GACnB,EADwB,AAChB,GADmB,GACb,CAAC,EAAA,sBAAsB,EAIrC,GAAW,YAAY,EAAK,EAAD,AAAK,SAAS,CAAC,kBAAqB,EAAD,AAAS,GAAG,CAAC,kBAAkB,AAC7F,EAAQ,GAAG,CAAC,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,EAAW,YAAY,GAE9E,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAChC,IAAI,SAAS,EAAW,KAAK,CAAC,IAAI,CAAE,SAChC,EACA,OAAQ,EAAW,KAAK,CAAC,MAAM,EAAI,GACvC,IACO,IACX,EAGI,EACA,MAAM,EAAe,EADT,CAGZ,MAAM,EAAO,qBAAqB,CAAC,EAAI,OAAO,CAAE,IAAI,EAAO,KAAK,CAAC,EAAA,cAAc,CAAC,aAAa,CAAE,CACvF,SAAU,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAChC,KAAM,EAAA,QAAQ,CAAC,MAAM,CACrB,WAAY,CACR,cAAe,EACf,cAAe,EAAI,GAAG,AAC1B,CACJ,EAAG,GAEf,CAAE,MAAO,EAAK,CAcV,GAbI,AAAE,CAAD,YAAgB,EAAA,eAAe,EAChC,CADmC,KAC7B,GAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,oBAClC,uBACA,CACJ,EACJ,GAIA,EAAO,MAAM,EAKjB,OAHA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,IAAI,SAAS,KAAM,CAC5D,OAAQ,GACZ,IACO,IACX,CACJ,EAEA,qCAAqC","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67]}