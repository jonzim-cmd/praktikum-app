{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jz/Projekte/Schule/praktikum-app/node_modules/better-auth/dist/adapters/memory-adapter/index.mjs"],"sourcesContent":["import \"../../get-model-name-D4DUV7S2.mjs\";\nimport \"../../utils-db7gNqd-.mjs\";\nimport \"../../crypto-CFUhAR9W.mjs\";\nimport \"../../misc-BwNc0MKr.mjs\";\nimport \"../../json-CnHxKYpj.mjs\";\nimport { t as createAdapterFactory } from \"../../adapter-factory-HF3JB9cT.mjs\";\nimport { logger } from \"@better-auth/core/env\";\n\n//#region src/adapters/memory-adapter/memory-adapter.ts\nconst memoryAdapter = (db, config) => {\n\tlet lazyOptions = null;\n\tlet adapterCreator = createAdapterFactory({\n\t\tconfig: {\n\t\t\tadapterId: \"memory\",\n\t\t\tadapterName: \"Memory Adapter\",\n\t\t\tusePlural: false,\n\t\t\tdebugLogs: config?.debugLogs || false,\n\t\t\tcustomTransformInput(props) {\n\t\t\t\tif ((props.options.advanced?.database?.useNumberId || props.options.advanced?.database?.generateId === \"serial\") && props.field === \"id\" && props.action === \"create\") return db[props.model].length + 1;\n\t\t\t\treturn props.data;\n\t\t\t},\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tlet clone = structuredClone(db);\n\t\t\t\ttry {\n\t\t\t\t\treturn await cb(adapterCreator(lazyOptions));\n\t\t\t\t} catch (error) {\n\t\t\t\t\tObject.keys(db).forEach((key) => {\n\t\t\t\t\t\tdb[key] = clone[key];\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tadapter: ({ getFieldName, options, getModelName }) => {\n\t\t\tconst applySortToRecords = (records, sortBy, model) => {\n\t\t\t\tif (!sortBy) return records;\n\t\t\t\treturn records.sort((a, b) => {\n\t\t\t\t\tconst field = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: sortBy.field\n\t\t\t\t\t});\n\t\t\t\t\tconst aValue = a[field];\n\t\t\t\t\tconst bValue = b[field];\n\t\t\t\t\tlet comparison = 0;\n\t\t\t\t\tif (aValue == null && bValue == null) comparison = 0;\n\t\t\t\t\telse if (aValue == null) comparison = -1;\n\t\t\t\t\telse if (bValue == null) comparison = 1;\n\t\t\t\t\telse if (typeof aValue === \"string\" && typeof bValue === \"string\") comparison = aValue.localeCompare(bValue);\n\t\t\t\t\telse if (aValue instanceof Date && bValue instanceof Date) comparison = aValue.getTime() - bValue.getTime();\n\t\t\t\t\telse if (typeof aValue === \"number\" && typeof bValue === \"number\") comparison = aValue - bValue;\n\t\t\t\t\telse if (typeof aValue === \"boolean\" && typeof bValue === \"boolean\") comparison = aValue === bValue ? 0 : aValue ? 1 : -1;\n\t\t\t\t\telse comparison = String(aValue).localeCompare(String(bValue));\n\t\t\t\t\treturn sortBy.direction === \"asc\" ? comparison : -comparison;\n\t\t\t\t});\n\t\t\t};\n\t\t\tfunction convertWhereClause(where, model, join) {\n\t\t\t\tconst execute = (where$1, model$1) => {\n\t\t\t\t\tconst table = db[model$1];\n\t\t\t\t\tif (!table) {\n\t\t\t\t\t\tlogger.error(`[MemoryAdapter] Model ${model$1} not found in the DB`, Object.keys(db));\n\t\t\t\t\t\tthrow new Error(`Model ${model$1} not found`);\n\t\t\t\t\t}\n\t\t\t\t\tconst evalClause = (record, clause) => {\n\t\t\t\t\t\tconst { field, value, operator } = clause;\n\t\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\t\tcase \"in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) throw new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\treturn value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) throw new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\treturn !value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"contains\": return record[field].includes(value);\n\t\t\t\t\t\t\tcase \"starts_with\": return record[field].startsWith(value);\n\t\t\t\t\t\t\tcase \"ends_with\": return record[field].endsWith(value);\n\t\t\t\t\t\t\tcase \"ne\": return record[field] !== value;\n\t\t\t\t\t\t\tcase \"gt\": return value != null && Boolean(record[field] > value);\n\t\t\t\t\t\t\tcase \"gte\": return value != null && Boolean(record[field] >= value);\n\t\t\t\t\t\t\tcase \"lt\": return value != null && Boolean(record[field] < value);\n\t\t\t\t\t\t\tcase \"lte\": return value != null && Boolean(record[field] <= value);\n\t\t\t\t\t\t\tdefault: return record[field] === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn table.filter((record) => {\n\t\t\t\t\t\tif (!where$1.length || where$1.length === 0) return true;\n\t\t\t\t\t\tlet result = evalClause(record, where$1[0]);\n\t\t\t\t\t\tfor (const clause of where$1) {\n\t\t\t\t\t\t\tconst clauseResult = evalClause(record, clause);\n\t\t\t\t\t\t\tif (clause.connector === \"OR\") result = result || clauseResult;\n\t\t\t\t\t\t\telse result = result && clauseResult;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tif (!join) return execute(where, model);\n\t\t\t\tconst baseRecords = execute(where, model);\n\t\t\t\tconst grouped = /* @__PURE__ */ new Map();\n\t\t\t\tconst seenIds = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const baseRecord of baseRecords) {\n\t\t\t\t\tconst baseId = String(baseRecord.id);\n\t\t\t\t\tif (!grouped.has(baseId)) {\n\t\t\t\t\t\tconst nested = { ...baseRecord };\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") nested[joinModelName] = null;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnested[joinModelName] = [];\n\t\t\t\t\t\t\t\tseenIds.set(`${baseId}-${joinModel}`, /* @__PURE__ */ new Set());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgrouped.set(baseId, nested);\n\t\t\t\t\t}\n\t\t\t\t\tconst nestedEntry = grouped.get(baseId);\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\tconst joinTable = db[joinModelName];\n\t\t\t\t\t\tif (!joinTable) {\n\t\t\t\t\t\t\tlogger.error(`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`, Object.keys(db));\n\t\t\t\t\t\t\tthrow new Error(`JoinOption model ${joinModelName} not found`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst matchingRecords = joinTable.filter((joinRecord) => joinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from]);\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") nestedEntry[joinModelName] = matchingRecords[0] || null;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst seenSet = seenIds.get(`${baseId}-${joinModel}`);\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (const matchingRecord of matchingRecords) {\n\t\t\t\t\t\t\t\tif (count >= limit) break;\n\t\t\t\t\t\t\t\tif (!seenSet.has(matchingRecord.id)) {\n\t\t\t\t\t\t\t\t\tnestedEntry[joinModelName].push(matchingRecord);\n\t\t\t\t\t\t\t\t\tseenSet.add(matchingRecord.id);\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(grouped.values());\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcreate: async ({ model, data }) => {\n\t\t\t\t\tif (options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === \"serial\") data.id = db[getModelName(model)].length + 1;\n\t\t\t\t\tif (!db[model]) db[model] = [];\n\t\t\t\t\tdb[model].push(data);\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tfindOne: async ({ model, where, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst resArray = res;\n\t\t\t\t\t\tif (!resArray.length) return null;\n\t\t\t\t\t\treturn resArray[0];\n\t\t\t\t\t}\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tfindMany: async ({ model, where, sortBy, limit, offset, join }) => {\n\t\t\t\t\tlet res = convertWhereClause(where || [], model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst resArray = res;\n\t\t\t\t\t\tif (!resArray.length) return [];\n\t\t\t\t\t\tapplySortToRecords(resArray, sortBy, model);\n\t\t\t\t\t\tlet paginatedRecords = resArray;\n\t\t\t\t\t\tif (offset !== void 0) paginatedRecords = paginatedRecords.slice(offset);\n\t\t\t\t\t\tif (limit !== void 0) paginatedRecords = paginatedRecords.slice(0, limit);\n\t\t\t\t\t\treturn paginatedRecords;\n\t\t\t\t\t}\n\t\t\t\t\tlet table = applySortToRecords(res, sortBy, model);\n\t\t\t\t\tif (offset !== void 0) table = table.slice(offset);\n\t\t\t\t\tif (limit !== void 0) table = table.slice(0, limit);\n\t\t\t\t\treturn table || [];\n\t\t\t\t},\n\t\t\t\tcount: async ({ model, where }) => {\n\t\t\t\t\tif (where) return convertWhereClause(where, model).length;\n\t\t\t\t\treturn db[model].length;\n\t\t\t\t},\n\t\t\t\tupdate: async ({ model, where, update }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tdelete: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tdb[model] = table.filter((record) => !res.includes(record));\n\t\t\t\t},\n\t\t\t\tdeleteMany: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tdb[model] = table.filter((record) => {\n\t\t\t\t\t\tif (res.includes(record)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !res.includes(record);\n\t\t\t\t\t});\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\tupdateMany({ model, where, update }) {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\treturn (options) => {\n\t\tlazyOptions = options;\n\t\treturn adapterCreator(options);\n\t};\n};\n\n//#endregion\nexport { memoryAdapter };"],"names":[],"mappings":"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","ignoreList":[0]}}]
}